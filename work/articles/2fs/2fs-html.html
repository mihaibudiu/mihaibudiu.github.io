<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Funcþionarea sistemului de fiºiere din Unix</TITLE>
<META NAME="description" CONTENT="Funcþionarea sistemului de fiºiere din Unix">
<META NAME="keywords" CONTENT="2fs-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>
<body>

<P>

<P>
<H1 ALIGN="CENTER">Funcþionarea sistemului de fiºiere din Unix</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+, at cs.cmu.edu</TT> 
<BR><TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>18 octombrie 1997</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Funcþiuni speciale ale sistemului de fiºiere în
sistemul de operare Unix
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>oarecare familiaritate cu sistemul de
operare Unix
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>atribute, protecþie, interfaþã, periferic,
apel de sistem
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html26"
  HREF="2fs-html.html">Funcþiunile sistemului de fiºiere</A>
<LI><A NAME="tex2html27"
  HREF="#SECTION00030000000000000000">Fiºiere</A>
<LI><A NAME="tex2html28"
  HREF="#SECTION00040000000000000000">Operaþiile cu conþinutul fiºierelor</A>
<LI><A NAME="tex2html29"
  HREF="#SECTION00050000000000000000">Directoare</A>
<LI><A NAME="tex2html30"
  HREF="#SECTION00060000000000000000">Operaþiile cu atribute</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION00070000000000000000">Protecþie</A>
<LI><A NAME="tex2html32"
  HREF="#SECTION00080000000000000000">Abstracþia de fiºier; operaþiile pe fiºiere</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION00090000000000000000">Þevile cu nume</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION000100000000000000000">Perifericele în Unix: fiºierele ``speciale''</A>
<LI><A NAME="tex2html35"
  HREF="#SECTION000110000000000000000">Pseudo-perifericele (pseudo-devices)</A>
<LI><A NAME="tex2html36"
  HREF="#SECTION000120000000000000000">Sistemul de fiºiere <TT>/proc</TT></A>
<LI><A NAME="tex2html37"
  HREF="#SECTION000130000000000000000">Concluzie: programarea orientatã pe obiecte</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Sistemul de operare Unix s-a impus în lumea calculatoarelor datoritã
multor calitãþi remarcabile.  Acest articol va încerca sã
ilustreze una dintre ele, ºi anume <I>uniformitatea</I> remarcabilã
a operaþiilor.  Vom ilustra cum o singurã parte a sistemului de
operare, ºi anume sistemul de fiºiere integreazã într-un mod
uniform o multitudine de funcþii independente cum ar fi: stocarea
informaþiei, numirea ei, protejarea informaþiei prin controlul
accesului, numirea perifericelor ºi controlul accesului la
periferice, iar în sistemele moderne Unix chiar ºi numirea
proceselor, operaþiile cu procese ºi controlul accesului la procese.
Partea frumoasã este cã toate aceste lucruri diferite se fac
folosind un numãr mic de mecanisme: protecþia fiºierelor,
perifericelor ºi proceselor se face de cãtre nucleu în exact
acelaºi fel.  Aceastã uniformitate face sistemul mai uºor de
folosit ºi de implementat ºi mai flexibil.

<P>
Într-un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#sistem-f">articol</a>
anterior am prezentat structurile de date pe care le foloseºte
sistemul de operare Unix pentru a implementa operaþiile cu fiºiere
(structuri a cãror totalitate poartã denumirea de ``sistem de
fiºiere'').  O oarecare familiaritate cu conþinutul acelui articol se
poate dovedi utilã, dar (sper cã) nu este absolut necesarã.  Articolul
acela este disponibil din pagina de web a autorului în postscript.
Articolul de faþã este o continuare independentã a celuilalt.  Sperãm
ca peste cîtãva vreme sã augumentãm aceastã suitã cu un al treilea
articol despre implementarea sistemului de fiºiere din Unix, care este
extrem de interesantã.

<P>
Am folosit acest articol ºi ca un pretext pentru a trece în revistã
<I>totalitatea</I> apelurilor de sistem din Unix care opereazã cu
fiºiere.  E un lucru foarte instructiv sã înþelegem cum orice
operaþie ne putem imagina se poate sintetiza numai din aceste
operaþii primitive puse la dispoziþie de nucleu.

<P>

<H1><A NAME="SECTION00020000000000000000">
Funcþiunile sistemului de fiºiere</A>
</H1>

<P>
Un rãspuns superficial la întrebarea ``la ce foloseºte un sistem de
fiºiere (în Unix -- dar ºi în alte multe sisteme de operare)?''
ar fi ``la stocarea informaþiei.''  Rãspunsul este cu siguranþã
corect, dar incomplet.  Sistemul de fiºiere mai are ºi multe alte
funcþionalitãþi esenþiale, cîteodatã foarte departe de misiunea
aceasta.  Le vom enumera pe scurt, le vom discuta fugar, ºi vom vedea
apoi cum unele dintre aceste funcþiuni se manifestã în sistemul de
operare Unix.

<P>
Funcþiuni ale sistemelor de fiºiere:

<UL>
<LI>Stocarea persistentã a informaþiei;
</LI>
<LI>Numirea informaþiei (servicii de directoare);
</LI>
<LI>Protecþia informaþiei;
</LI>
<LI>Mecanism de comunicaþie inter-proces (folosirea în comun a
informaþiei);
</LI>
<LI>Interfaþã spre structurile de date ale nucleului (ex:
periferice (devices) în Unix; sistemul de fiºiere <TT>/proc</TT>);
</LI>
<LI>Interfaþã universalã la resurse ale reþelei (ex: URL-uri);
</LI>
<LI>Aparat de mãsurã a propriei sale performanþe.
</LI>
</UL>

<P>
Ultimele douã aspecte nu vor fi discutate în acest articol.

<P>
Celorlalte le vom consacra grosso modo cîte o secþiune.

<P>
Sã aruncãm o scurtã privire pe lista de apeluri de sistem care
opereazã cu fiºiere (un apel de sistem este o funcþiune oferitã de
sistemul de operare).  Dãm în tabela&nbsp;<A HREF="2fs-html.html#apeluri">1</A> o listã
completã (sortatã alfabetic) a apelurilor de sistem care opereazã
cu fiºiere, din sistemul de operare SunOS 4.1.3, o versiune de Unix
extrem de popularã de la firma Sun Microsystems.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"> Apel</TD>
<TD ALIGN="LEFT">Funcþiune</TD>
<TD ALIGN="CENTER">Categorie</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>access </TT></TD>
<TD ALIGN="LEFT">verificã dreptul de acces</TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>chdir </TT></TD>
<TD ALIGN="LEFT">schimbã directorul curent</TD>
<TD ALIGN="CENTER">D</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>chmod </TT></TD>
<TD ALIGN="LEFT">schimbã drepturile de acces</TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>chown </TT></TD>
<TD ALIGN="LEFT">schimbã posesorul</TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>chroot </TT></TD>
<TD ALIGN="LEFT">schimbã directorul rãdãcinã</TD>
<TD ALIGN="CENTER">D</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>close </TT></TD>
<TD ALIGN="LEFT">închide un fiºier</TD>
<TD ALIGN="CENTER">F</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>creat </TT></TD>
<TD ALIGN="LEFT">creazã un fiºier</TD>
<TD ALIGN="CENTER">FD</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>execve </TT></TD>
<TD ALIGN="LEFT">executã un fiºier</TD>
<TD ALIGN="CENTER">--</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>fchmod </TT></TD>
<TD ALIGN="LEFT">ca ºi <TT>chmod</TT></TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>fchown </TT></TD>
<TD ALIGN="LEFT">ca ºi <TT>chown</TT></TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>fcntl </TT></TD>
<TD ALIGN="LEFT">operaþii speciale</TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>flock </TT></TD>
<TD ALIGN="LEFT">``încuie'' fiºier</TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>fstat </TT></TD>
<TD ALIGN="LEFT">ca ºi <TT>stat</TT></TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>fsync </TT></TD>
<TD ALIGN="LEFT">salveazã conþinutul  din cache al fiºierului</TD>
<TD ALIGN="CENTER">F</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ftruncate </TT></TD>
<TD ALIGN="LEFT">ca ºi <TT>truncate</TT></TD>
<TD ALIGN="CENTER">F</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>getdents </TT></TD>
<TD ALIGN="LEFT">citeºte conþinutul directorului</TD>
<TD ALIGN="CENTER">D</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ioctl </TT></TD>
<TD ALIGN="LEFT">operaþii speciale cu fiºiere speciale</TD>
<TD ALIGN="CENTER">S</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>link </TT></TD>
<TD ALIGN="LEFT">dã încã un nume unui fiºier</TD>
<TD ALIGN="CENTER">D</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>lseek </TT></TD>
<TD ALIGN="LEFT">mutã cursorul la o nouã adresã în fiºier</TD>
<TD ALIGN="CENTER">F</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>lstat </TT></TD>
<TD ALIGN="LEFT">ca ºi <TT>stat</TT></TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>mkdir </TT></TD>
<TD ALIGN="LEFT">face un nou director</TD>
<TD ALIGN="CENTER">D</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>mkfifo </TT></TD>
<TD ALIGN="LEFT">face un fiºier special ``þeavã''</TD>
<TD ALIGN="CENTER">S</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>mknod </TT></TD>
<TD ALIGN="LEFT">face un fiºier special</TD>
<TD ALIGN="CENTER">S</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>mmap </TT></TD>
<TD ALIGN="LEFT">transformã acest fiºier într-o zonã de memorie</TD>
<TD ALIGN="CENTER">F</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>open </TT></TD>
<TD ALIGN="LEFT">deschide un fiºier pentru acces</TD>
<TD ALIGN="CENTER">F</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>read </TT></TD>
<TD ALIGN="LEFT">citeºte din fiºier date</TD>
<TD ALIGN="CENTER">F</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>readlink </TT></TD>
<TD ALIGN="LEFT">citeºte o legãturã simbolicã</TD>
<TD ALIGN="CENTER">D</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>rename </TT></TD>
<TD ALIGN="LEFT">schimbã numele unui fiºier</TD>
<TD ALIGN="CENTER">D</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>rmdir </TT></TD>
<TD ALIGN="LEFT">ºterge un director</TD>
<TD ALIGN="CENTER">D</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>stat </TT></TD>
<TD ALIGN="LEFT">citeºte atributele unui fiºier</TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>symlink </TT></TD>
<TD ALIGN="LEFT">creazã un nou nume pentru un fiºier</TD>
<TD ALIGN="CENTER">D</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>sync </TT></TD>
<TD ALIGN="LEFT">salveazã cache-ul pe disc</TD>
<TD ALIGN="CENTER">--</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>tell </TT></TD>
<TD ALIGN="LEFT">unde e cursorul în fiºier?</TD>
<TD ALIGN="CENTER">F</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>truncate </TT></TD>
<TD ALIGN="LEFT">reduce lungimea fiºierului</TD>
<TD ALIGN="CENTER">F</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>umask </TT></TD>
<TD ALIGN="LEFT">schimbã drepturile cu care se creazã fiºiere</TD>
<TD ALIGN="CENTER">A</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>unlink </TT></TD>
<TD ALIGN="LEFT">ºterge un nume al unui fiºier</TD>
<TD ALIGN="CENTER">D</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>write </TT></TD>
<TD ALIGN="LEFT">scrie date în fiºier</TD>
<TD ALIGN="CENTER">F</TD>
</TR>
</TABLE>
</DIV>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="apeluri"></A><A NAME="326"></A>
<TABLE>
<CAPTION><STRONG>Table 1:</STRONG>
Apelurile de sistem pentru fiºiere din SunOS.</CAPTION>
<TR><TD></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Am clasificat apelurile de sistem dupã tipul operaþiei în
categoriile descrise în tabela&nbsp;<A HREF="#categ">2</A>.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="327"></A>
<TABLE>
<CAPTION><STRONG>Table 2:</STRONG>
Tipuri de apeluri de sistem pentru fiºiere</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="CENTER">Categorie</TD>
<TD ALIGN="LEFT">Semnificaþie</TD>
<TD ALIGN="CENTER">Apeluri</TD>
<TD ALIGN="CENTER">Operaþii distincte</TD>
</TR>
<TR><TD ALIGN="CENTER">A</TD>
<TD ALIGN="LEFT">operaþii cu atribute</TD>
<TD ALIGN="CENTER">11</TD>
<TD ALIGN="CENTER">7</TD>
</TR>
<TR><TD ALIGN="CENTER">F</TD>
<TD ALIGN="LEFT">operaþii cu conþinutul fiºierelor</TD>
<TD ALIGN="CENTER">10</TD>
<TD ALIGN="CENTER">9</TD>
</TR>
<TR><TD ALIGN="CENTER">D</TD>
<TD ALIGN="LEFT">operaþii cu directoare</TD>
<TD ALIGN="CENTER">11</TD>
<TD ALIGN="CENTER">11</TD>
</TR>
<TR><TD ALIGN="CENTER">S</TD>
<TD ALIGN="LEFT">operaþii cu fiºiere ``speciale''</TD>
<TD ALIGN="CENTER">3</TD>
<TD ALIGN="CENTER">3</TD>
</TR>
<TR><TD ALIGN="CENTER">--</TD>
<TD ALIGN="LEFT">nu e o operaþie propriu-zisã pe fiºiere</TD>
<TD ALIGN="CENTER">2</TD>
<TD ALIGN="CENTER">2</TD>
</TR>
<TR><TD ALIGN="CENTER" COLSPAN=2>Total</TD>
<TD ALIGN="CENTER">37</TD>
<TD ALIGN="CENTER">32</TD>
</TR>
</TABLE>
</DIV>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>

<H1><A NAME="SECTION00030000000000000000">
Fiºiere</A>
</H1>

<P>
Funcþiunea cea mai evidentã a unui sistem de fiºiere este de a
organiza datele în fiºiere.  Acestea pot avea proprietãþi felurite
în diferite sisteme de operare.  În Unix fiºierele propriu-zise
(adicã nu directoarele sau alte varietãþi ciudate pe care le
discutãm mai jos) sunt simple array-uri de octeþi din punct de
vedere al sistemului de operare; utilizatorul îºi organizeazã în
aceste array-uri datele cum doreºte.  Acest model este valabil ºi
în MS-DOS ºi Windows.  În plus fiºierele mai sunt caracterizate de
niºte <I>atribute</I> a cãror semnificaþie este importantã pentru
sistemul de operare.  Atribute tipice sunt: numele fiºierelor, de
care utilizatorul se foloseºte pentru a indica fiºierele asupra
cãrora vrea sã facã operaþiile, posesorul fiºierului, data la
care fiºierul a fost creat, drepturile de acces la fiºier, etc.
Atributele unui fiºier sunt memorate de Unix într-o structurã de
date numitã <I>inod</I>, de la ``information-node''.

<P>
Atributele sunt oarecum secundare funcþiei principale a fiºierelor,
cea de a memora date; fiºierele puteau fi folosite pentru a memora
date chiar ºi fãrã a avea la-ndemînã atribute.  Sistemul de
operare însã menþine atributele pentru cã s-a observat cã
funcþionalitatea pe care acestea o oferã este foarte utilã.
Vom vedea cã atributele sunt unul dintre mecanismele prin care
sistemul de fiºiere poate fi folosit ºi pentru alte scopuri.

<P>

<H1><A NAME="SECTION00040000000000000000">
Operaþiile cu conþinutul fiºierelor</A>
</H1>

<P>
Sã trecem în revistã rapid operaþiile care se ocupã doar de
manipularea datelor; operaþiile cu atribute vor fi explorate într-o
secþiune ulterioarã.

<P>
În tabelul&nbsp;<A HREF="#continut">3</A> sunt extrase din tabelul&nbsp;<A HREF="2fs-html.html#apeluri">1</A>
operaþiile de categoria ``F'', care lucreazã direct cu conþinutul
fiºierelor.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="329"></A>
<TABLE>
<CAPTION><STRONG>Table 3:</STRONG>
Apeluri de sistem pentru conþinutul fiºierelor.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"> Apel</TD>
<TD ALIGN="LEFT"> Sintaxa</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>Descriere</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>open  </TT></TD>
<TD ALIGN="LEFT"><TT>fd = open(path, mod) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>deschide un fiºier specificat prin
                           nume (path) pentru acces în modul indicat;
                           întoarce un numãr întreg (descriptor) pentru a
                           manipula ulterior fiºierul</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>close </TT></TD>
<TD ALIGN="LEFT"><TT>close(fd) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>închide un fiºier deschis cu <TT>open</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>creat </TT></TD>
<TD ALIGN="LEFT"><TT>creat(path, drepturi) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>creazã un fiºier cu un nume specificat</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>truncate </TT></TD>
<TD ALIGN="LEFT"><TT>truncate(path, lungime) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>redu lungimea fiºierului dat
                                        prin nume la cea indicatã</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ftruncate </TT></TD>
<TD ALIGN="LEFT"><TT>ftruncate(fd, lungime) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>ca ºi <TT>truncate</TT>, doar
                                     cã fiºierul e indicat prin descriptor</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>lseek </TT></TD>
<TD ALIGN="LEFT"><TT>lseek(fd, deplasare, relativ) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>mutã cursorul de scriere/citire la o
                                        nouã adresã în fiºier</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>tell </TT></TD>
<TD ALIGN="LEFT"><TT>tell(fd) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>aflã unde e cursorul în fiºier</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>read </TT></TD>
<TD ALIGN="LEFT"><TT>read(fd, memorie, lungime) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>citeºte din fiºier date în memorie 
                                (de la poziþia unde e cursorul curent)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>write </TT></TD>
<TD ALIGN="LEFT"><TT>write(fd, memorie, lungime) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>scrie date din memorie în fiºier (la 
                                poziþia datã de cursorul curent)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>fsync </TT></TD>
<TD ALIGN="LEFT"><TT>fsync(fd) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>salveazã conþinutul fiºierului 
                        care era pãstrat în cache</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>mmap </TT></TD>
<TD ALIGN="LEFT"><TT>... </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>transformã acest fiºier într-o zonã de memorie; scrierile în
                aceastã zonã de memorie se vor reflecta în fiºier, iar citirile
                din memorie se vor face din acel fiºier.  Argumentele sunt prea
                complicate ca sã le discutãm acum.</TD>
</TR>
</TABLE>
</DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Dupã cum vedeþi operaþiile sunt relativ clare, poate mai puþin
<TT>mmap()</TT>, de care ne vom ocupa altã datã, într-un articol
referitor la sistemul de memorie virtualã (aceastã funcþie, de
altfel foarte importantã, este o aplicaþie imediatã a sistemului de
memorie virtualã).

<P>
Putem face mai multe lucruri cu un fiºier: îl putem crea, îl putem
scurta, ne putem plimba prin el ºi putem citi/scrie în el
``petice''.  Funcþia <TT>fsync()</TT> ne asigurã cã fiºierul
ajunge pe disc; sistemele de operare încearcã sã þinã cît mai
mult timp informaþiile în memorie pentru cã discul este foarte lent
comparativ cu memoria ºi orice acces la el este foarte costisitor.
Este demn de observat cã doar <TT>open()</TT>, <TT>creat()</TT> ºi
<TT>truncate()</TT> lucreazã cu fiºiere date prin <I>nume</I>;
celelalte funcþii lucreazã cu fiºiere deja deschise cu
<TT>open()</TT> anterior, ºi care sunt indicate cu rezultatul dat de
funcþia <TT>open()</TT>.  Cînd <TT>open()</TT> deschide un fiºier
returneazã un numãr întreg care se numeºte <I>descriptor de
fiºier</I>: ``file descriptor'', sau ``file handle'' (în traducere
``mîner de fiºier''), folosit de alte funcþii pentru a indica
fiºierul.  Verificarea dreptului de acces se face o singurã datã,
la deschiderea fiºierului.  Toate celelalte operaþii sunt apoi mult
mai rapide.<A NAME="tex2html4"
  HREF="#foot114"><SUP>1</SUP></A>
<P>
Funcþia <TT>open()</TT> poate crea noi fiºiere, ca ºi <TT>creat()</TT>.

<P>

<H1><A NAME="SECTION00050000000000000000">
Directoare</A>
</H1>

<P>
Sistemul de directoare are ca misiune de a ordona fiºierele într-o
ierarhie ºi de a le da nume care sã fie convenabile utilizatorilor.
Un director este un obiect al cãrui ``conþinut'' este format din
nume de fiºiere ºi din nume de alte directoare.  Directoarele mai
conþin pentru fiecare nume ºi numãrul inodului care-i corespunde
(articolul citat în introducere vorbeºte mai mult despre asta).
Presupunem cã cititorului îi este cunoscutã noþiunea de
``cãrare'' (path) care descrie un lanþ de directoare care duce la un
fiºier (de exemplu <TT>/usr/home/mihaib/data/articles/2fs.tex</TT>
este cãrarea care duce la fiºierul în care tocmai scriu acest
articol în aceastã clipã.

<P>
Sã trecem rapid în revistã în tabelul&nbsp;<A HREF="#directoare">4</A> operaþiile
(luate din tabelul&nbsp;<A HREF="2fs-html.html#apeluri">1</A>) care lucreazã cu directoare.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="331"></A>
<TABLE>
<CAPTION><STRONG>Table 4:</STRONG>
Apeluri de sistem pentru directoare</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"> Apel</TD>
<TD ALIGN="LEFT"> Sintaxa</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>Descriere</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>chdir   </TT></TD>
<TD ALIGN="LEFT"><TT>chdir(path) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>schimbã directorul curent pentru acest proces</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>chroot  </TT></TD>
<TD ALIGN="LEFT"><TT>chroot(path) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>schimbã directorul rãdãcinã pentru acest proces</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>getdents </TT></TD>
<TD ALIGN="LEFT"><TT>getdents(fd, memorie, lungime) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>citeºte conþinutul
                                            directorului în memorie</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>creat   </TT></TD>
<TD ALIGN="LEFT"><TT>creat(path, drepturi) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>creazã un fiºier cu numele indicat</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>mkdir   </TT></TD>
<TD ALIGN="LEFT"><TT>mkdir(path, drepturi) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>fã un nou director cu numele indicat</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>rmdir   </TT></TD>
<TD ALIGN="LEFT"><TT>rmdir(path) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>ºterge un director care nu conþine fiºiere</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>link    </TT></TD>
<TD ALIGN="LEFT"><TT>link(path1, path2) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>dã încã un nume (path2) fiºierului cu numele path1</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>unlink  </TT></TD>
<TD ALIGN="LEFT"><TT>unlink(path) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>ºterge un nume al unui fiºier</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>rename  </TT></TD>
<TD ALIGN="LEFT"><TT>rename(path1, path2) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>schimbã numele unui fiºier din path1 în path2</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>symlink </TT></TD>
<TD ALIGN="LEFT"><TT>symlink(path1, path2) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>creazã un nou nume pentru un fiºier</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>readlink </TT></TD>
<TD ALIGN="LEFT"><TT>readlink(path, memorie, lungime) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>citeºte la cine merge o legãturã simbolicã</TD>
</TR>
</TABLE>
</DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Funcþia <TT>creat()</TT> apare din nou, pentru cã schimbã
conþinutul unui director atunci cînd creazã un fiºier.
<TT>mkdir()</TT> este echivalentul lui <TT>creat()</TT>, doar cã face
un nou director.

<P>
Un fiºier în Unix poate avea mai multe nume.  Primul nume apare
cînd fiºierul este creat, urmãtoarele se pot adãuga cu funcþia
<TT>link()</TT>.  Un nume al unui fiºier poate fi schimbat cu
<TT>rename()</TT>, sau poate fi ºters cu <TT>unlink()</TT>.
<TT>rmdir()</TT> este echivalentul lui <TT>unlink()</TT> pentru
directoare.

<P>
În fine, în Unix existã o clasã specialã de fiºiere numite
<I>legãturi simbolice</I> (symbolic links), al cãror conþinut este
numele altui fiºier (o cãrare).  Aceste fiºiere se creazã cu apelul
<TT>symlink()</TT>.

<P>
Dacã fiºierul A este o legãturã simbolicã la B, atunci orice
acces la A este transformat de nucleu într-un acces la B.  Pentru cã
un <TT>read()</TT> din fiºierul A ne aratã automat conþinutul
fiºierului B, avem la dispoziþie funcþia specialã,
<TT>readlink()</TT>, cu care putem vedea la ce fiºier puncteazã o
legãturã simbolicã.

<P>
Legãturile simbolice sunt foarte asemãnãtoare cu numele
fiºierelor, dar existã o serie de diferenþe subtile pe care le vom
discuta altã datã.  Ele au fost create pentru cã, deºi un fiºier
poate avea mai multe nume create cu <TT>link()</TT>, ele toate trebuie
sã se afle pe acelaºi disc.  Pentru a putea avea nume alternative
pentru un fiºier pe alte discuri decît cel pe care se aflã
fiºierul, se folosesc legãturile simbolice.

<P>
URL-urile (Universal Resource Locators), cu care în Internet se indicã
paginile de web, sunt o extensie a noþiunii de legãturã simbolicã: pe
lîngã numele unui fiºier ele indicã ºi numele unui calculator plus
eventual numele unui protocol, astfel:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="RIGHT"><TT>http://</TT></TD>
<TD ALIGN="CENTER"><TT>www.cs.cmu.edu</TT></TD>
<TD ALIGN="LEFT"><TT>/afs/cs/user/mihaib/</TT></TD>
</TR>
<TR><TD ALIGN="RIGHT">protocolul de comunicaþii</TD>
<TD ALIGN="CENTER">calculatorul</TD>
<TD ALIGN="LEFT">cãrarea</TD>
</TR>
</TABLE>
</DIV>

<P>
Facem acum o observaþie banalã, dar <I>crucialã</I>: <B>pentru a
putea face orice operaþie cu un fiºier trebuie sã cunoaºtem o
cãrare la el</B> (pot exista mai multe, pentru cã un fiºier poate avea
mai multe nume); <B>singura metodã pentru a specifica un fiºier
este printr-o cãrare!</B>

<P>
De aici rezultã imediat o serie de consecinþe foarte importante.
Una dintre ele este cã un fiºier care nu are nume nu este accesibil
nicicum.  Din cauza asta în Unix fiºierele nu pot fi ºterse (nu
existã nici un apel de sistem pentru asta! verificaþi); ele dispar
atunci cînd ultimul lor nume este ºters cu <TT>unlink()</TT>.

<P>
Dar cele mai importante consecinþe vor apãrea abia atunci cînd vom
vorbi despre protecþie.  Înainte de asta trebuie însã sã vedem
cum se manipuleazã atributele.

<P>

<H1><A NAME="SECTION00060000000000000000">
Operaþiile cu atribute</A>
</H1>

<P>
Toate atributele unui fiºier (mai puþin numele) sunt þinute de Unix
în inod.  (Numele sunt þinute în directoare.)  În
tabela&nbsp;<A HREF="#atribute">5</A> sunt trecute operaþiile puse la dispoziþie de
cãtre nucleu pentru a opera cu atribute.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="333"></A>
<TABLE>
<CAPTION><STRONG>Table 5:</STRONG>
Apeluri de sistem pentru manipularea atributelor.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"> Apel</TD>
<TD ALIGN="LEFT"> Sintaxa</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>Descriere</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>access  </TT></TD>
<TD ALIGN="LEFT"><TT>access(path, drepturi) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>verificã dacã fiºierul path poate fi
                                accesat în modul indicat (de cãtre
                                procesul curent)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>umask   </TT></TD>
<TD ALIGN="LEFT"><TT>umask(masca) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>indicã drepturile de acces pe care le vor
                        avea fiºierele create de acum încolo
                        (cu <TT>open</TT>, <TT>creat</TT>, <TT>mkdir</TT>)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>chmod   </TT></TD>
<TD ALIGN="LEFT"><TT>chmod(path, drepturi) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>schimbã drepturile de acces la
                                fiºierul indicat</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>fchmod  </TT></TD>
<TD ALIGN="LEFT"><TT>fchmod(fd, drepturi) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>ca ºi <TT>chmod</TT>, pe un fiºier deschis</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>chown   </TT></TD>
<TD ALIGN="LEFT"><TT>chown(path, utilizator, grup) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>schimbã posesorul unui fiºier</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>fchown  </TT></TD>
<TD ALIGN="LEFT"><TT>fchown(fd, utilizator, grup) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>ca ºi <TT>chown</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>stat    </TT></TD>
<TD ALIGN="LEFT"><TT>stat(path, memorie) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>citeºte toate atributele unui fiºier</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>fstat   </TT></TD>
<TD ALIGN="LEFT"><TT>fstat(fd, memorie) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>ca ºi <TT>stat</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>lstat   </TT></TD>
<TD ALIGN="LEFT"><TT>lstat(path, memorie) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>ca ºi <TT>stat</TT>, doar cã citeºte
                                atributele unei legãturi simbolice</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>flock   </TT></TD>
<TD ALIGN="LEFT"><TT>flock(fd, permisiuni) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>``încuie'' sau descuie un fiºier
                                (interzice -- pentru sincronizare --
                                accesele  altor procese)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>fcntl   </TT></TD>
<TD ALIGN="LEFT"><TT>fcntl(fd, comanda, argumente) </TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>operaþii speciale...</TD>
</TR>
</TABLE>
</DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Funcþia <TT>fcntl()</TT> (file control: controlul fiºierelor) face o
sumedenie de lucruri diferite în funcþie de valoarea celui de-al
doilea argument: aflã dacã fiºierul e încuiat, modificã modul de
lucru cu fiºierul (de exemplu poate aranja ca fiecare octet scris sã
meargã imediat spre disc, fãrã sã stea în cache), poate pune alte
încuietori, etc.  O funcþie complicatã care deocamdatã nu ne
intereseazã prea tare.

<P>
<TT>stat()</TT> citeºte într-o structurã de date atributele
fiºierului.

<P>
Pentru secþiunea urmãtoare ne intereseazã mai ales sã ºtim cã
urmãtoarele sunt atribute ale unui fiºier:

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="181"></A>
<TABLE>
<CAPTION><STRONG>Table 6:</STRONG>
Atribute importante ale fiºierelor.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Posesorul</TD>
</TR>
<TR><TD ALIGN="LEFT">Drepturi de acces</TD>
</TR>
<TR><TD ALIGN="LEFT">Tipul (director, etc.)</TD>
</TR>
</TABLE>
</DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Funcþiile <TT>access()</TT>, <TT>umask()</TT>, <TT>[f]chmod()</TT>
opereazã cu drepturile, funcþiile <TT>[f]chown()</TT> cu posesorul.

<P>

<H1><A NAME="SECTION00070000000000000000">
Protecþie</A>
</H1>

<P>
Cum implementeazã sistemul de operare Unix protecþia accesului la
fiºiere?

<P>
În primul rînd trebuie sã ne fie clar <I>cine</I> poate accesa
fiºierele.  Fiºierele sunt accesate numai de procese (programele
care sunt în curs de execuþie).  Nu utilizatorii lucreazã cu
fiºiere<A NAME="tex2html8"
  HREF="#foot189"><SUP>2</SUP></A>, ci programele lor.  Fiecare program are o identitate
moºtenitã de la programul care a identificat utilizatorul cînd
acesta a tastat parola.  Pe toate programele care s-au nãscut din
programul cãruia i-am tastat parola mea, scrie undeva ``ãsta e al
lui mihaib'' (numele meu de utilizator).

<P>
Atributul ``posesor'' al unui fiºier este de aceeaºi naturã.  Cînd
un proces ºtampilat ``mihaib'' creazã un fiºier (cu <TT>open(),
mknod(), mkdir()</TT> sau <TT>creat()</TT>), acel fiºier capãtã
aceeaºi ºtampilã, care devine atributul ``posesor''.  Comanda
<TT>chown()</TT> poate fi folositã pentru a schimba posesorul unui
fiºier.

<P>
În cele ce urmeazã simplificãm puþin discuþia restrîngînd
atenþia la drepturile ``utilizatorilor''.  Dupã cum ºtiþi Unix
poate agrega utilizatori în grupuri, dar funcþionarea sistemului de
protecþie este asemãnãtoare pentru grupuri ca pentru indivizi.

<P>
Cum observam mai sus, orice comandã care opereazã asupra unui
fiºier trebuie sã manipuleze întîi o cãrare la acel fiºier
(pentru a putea scrie într-un fiºier, el trebuie întîi deschis,
ºi atunci se indicã prin cãrare).  Unix-ul clasic distinge doar
trei tipuri de operaþii pe fiºiere: citire, scriere ºi executare.

<P>
Regula de protecþie pentru accesul la un fiºier în Unix este atunci
foarte simplã:

<P>
<BLOCKQUOTE>
<EM>Un proces poate opera asupra unui fiºier indicat printr-o cãrare
dacã are drept de inspecþie în toate directoarele din cãrare, ºi
dacã are dreptul de a face operaþia doritã asupra ultimei
componente din cãrare.

</EM></BLOCKQUOTE>

<P>
Observaþi un lucru foarte interesant: decizia dacã un proces are
dreptul sã facã ceva cu un fiºier depinde numai de drepturile
procesului pe fiecare componentã a cãrãrii.  Decizia nu depinde
nicidecum de conþinutul fiºierului, de pildã.  Decizia nu depinde
(aproape) nicidecum de <I>tipul</I> fiºierului.

<P>
Chiar dacã fiºierul este un director, un fiºier de date, un fiºier
special (vom vedea ce sunt astea mai jos), sau o legãturã
simbolicã, dreptul de acces se verificã în acelaºi fel (pentru
toate fiºierele care compun cãrarea):

<P>

<UL>
<LI>Se comparã posesorul din inod cu posesorul procesului care vrea
sã facã operaþia;
</LI>
<LI>Se comparã drepturile din inod-ul fiºierului cu tipul
operaþiei cerute.
</LI>
</UL>

<P>
Observaþi cã datoritã faptului cã un fiºier poate avea mai multe
cãrãri, accesul pe diferite cãrãri poate avea restricþii diferite
pentru un acelaºi proces!

<P>
Lãsãm ca exerciþiu cititorului ilustrarea aplicaþiilor acestui
mecanism de protecþie.  Exemplele abundã: directoarele fiecãrui
utilizator au drepturi mai mari pentru posesor, fiºierele executabile
de cãtre toþi utilizatorii nu pot fi modificate (decît de
administrator), (deci viruºii nu se pot propaga!), se pot folosi
directoare publice pentru fiºiere temporare (<TT>/tmp</TT>), poºta
electronicã poate fi stocatã în fiºiere ordinare fãrã fricã de
violare a secretului corespondenþei, serverele de comunicaþie în
reþea (ex.: ftp, www) lucreazã pe o ierarhie de directoare izolatã
de cea principalã a sistemului (cu <TT>chroot()</TT><A NAME="tex2html9"
  HREF="#foot200"><SUP>3</SUP></A>), etc.

<P>

<H1><A NAME="SECTION00080000000000000000">
Abstracþia de fiºier; operaþiile pe fiºiere</A>
</H1>

<P>
Sa ne uitãm încã odatã la tabelul&nbsp;<A HREF="#continut">3</A>.

<P>
Observaþi cã ceea ce un proces ºtie despre conþinutul unui fiºier
este accesibil numai prin funcþiile acestea: <TT>open(), close(),
read(), write(), lseek()</TT> (celelalte funcþii sunt mai puþin
importante ºi nu neapãrat necesare; operaþiile lor principale ar
putea fi sintetizate din cele înºirate aici).

<P>
Aceastã interfaþã este foarte generalã, pentru cã nu presupune
nimic despre organizarea internã a fiºierelor.  La o adicã ne putem
imagina aceste operaþii mergînd pe orice ``container'' cu date.
<I>Aceste operaþii sunt o interfaþã abstractã pentru un depozit
de date.</I>

<P>
Aceastã putere de expresie a interfeþei a fost sesizatã de
proiectanþii Unix-ului, la începutul anilor '70, ºi este
premeditatã.  În Unix o mulþime de alte obiecte pe lîngã fiºiere
sunt accesate folosind aceste operaþii!

<P>

<H1><A NAME="SECTION00090000000000000000">
Þevile cu nume</A>
</H1>

<P>
Unix oferã noþiunea de ``pipe'': o þeavã între douã procese.
Existã douã feluri de þevi, dar acum ne vom ocupa doar de una
dintre ele, de ``þeava numitã'' (named pipe).  Aceasta are un nume
ca un fiºier, dar se comportã oarecum diferit: datele pot fi citite
o singurã datã; citirea ``consumã'' datele.  Partea frumoasã este
cã o astfel de þeavã poate fi manipulatã tot cu apelurile indicate
mai sus... nimic din interfaþã nu obligã un fiºier sã
pãstreze datele scrise!

<P>
O astfel de þeavã se poate crea cu apelul de sistem
<TT>mkfifo(path, drepturi);</TT>.  Dacã am creat un astfel de
``fiºier'', toate celelalte operaþii pe el se efectueazã cu
aceleaºi funcþii: <TT>open()</TT> deschide þeava ºi verificã
drepturile de acces, <TT>close()</TT> o închide, <TT>write()</TT>
scrie în þeavã (ºi blocheazã scriitorul pînã apare un cititor),
iar <TT>read()</TT> citeºte din þeavã (sau blocheazã cititorul
pînã apare un scriitor).  Apelul de sistem <TT>lseek()</TT> nu se
poate folosi cu astfel de fiºiere.

<P>
<I>Natura diferitã a þevii nu este vizibilã pentru procese,
pentru cã interfaþa este aceeaºi.</I>  Aceastã interfaþã este
extrem de puternicã.  

<P>
Ca un divertisment, care nu are prea mare legãturã cu subiectul
articolului, vom arãta cum se poate folosi o ``þeavã numitã''
pentru a depista pe un calculator legat în Internet cine face
<TT>finger</TT> ca sã afle informaþii despre noi.

<P>
Ideea este cã atunci cînd cineva face <TT>finger
adresa_mea@cs.cmu.edu</TT> demonul local de finger citeºte din
directorul meu fiºierul cu numele <TT>.plan</TT>.  Dacã fac acest
fiºier o þeavã numitã ºi pun un proces sã scrie în þeavã, acest proces
va fi blocat pînã cînd cineva face un <TT>finger</TT> spre mine.
Acest proces va fi deblocat de demonul de <TT>finger</TT>.  Un script
shell ca cel urmãtor face acest lucru:

<P>
<PRE>
cd
rm -f .plan
mknod .plan p       # creaza teava
while /bin/true; do
        echo "No plan" &gt; .plan
        netstat | grep finger &gt;&gt;ma-cauta
done
</PRE>

<P>
Comanda <TT>echo</TT> va fi blocatã pînã apare un cititor.  Dupã
ce apare un cititor (demonul <TT>fingerd</TT>), se va executa imediat
comanda <TT>netstat</TT>, care va arãta toate conexiunile de reþea
deschise în clipa aceea, inclusiv cea a demonului <TT>fingerd</TT> de
pe maºina localã cu programul <TT>finger</TT> de pe maºina de la
distanþã.  În fiºierul <TT>ma-cauta</TT> se va depune adresa
maºinii de unde se face <TT>finger</TT>.  (Mai mult de atît este
ceva mai greu de aflat.)

<P>

<H1><A NAME="SECTION000100000000000000000">
Perifericele în Unix: fiºierele ``speciale''</A>
</H1>

<P>
Dar sã ne întoarcem la drepturile noastre.

<P>
Am vãzut cã abstracþia de fiºier poate îmbrãca mai multe
obiecte: nu numai fiºiere, ci ºi þevi.  Oare nu existã ºi alte
creaturi care sã poatã fi manipulate prin aceastã interfaþã?

<P>
Ba da, ba da.  O mulþime.  De exemplu: toate perifericele.

<P>
În Unix toate perifericele conectate la calculator au un nume de
fiºier ºi sunt operate ca fiºiere!  Aceste fiºiere sunt numite
``fiºiere speciale'', ºi existã douã mari categorii: fiºiere
speciale de tip ``caracter'' ºi fiºiere de tip ``bloc''.  Diferenþa
între ele nu ne intereseazã aici<A NAME="tex2html10"
  HREF="#foot228"><SUP>4</SUP></A>.

<P>
Tot ceea ce e periferic în Unix: mouse-ul, tastatura ºi ecranul
(numite împreunã ``consolã''), terminalele conectate ºi
modemurile, memoria video, discurile ºi unitãþile de bandã,
cdrom-ul ºi placa audio, toate acestea sunt ascunse de Unix sub
aceeaºi abstracþie, asupra cãreia se opereazã cu <TT>open(),
close(), read(), write(), lseek()</TT> ºi <TT>ioctl()</TT>.

<P>
Singura funcþie nou-venitã este <TT>ioctl()</TT>, care seamãnã cu
<TT>fcntl()</TT>, pe care am prezentat-o mai sus.  Diferenþa este cã
<TT>ioctl()</TT>, de la ``I/O control'' (controlul intrãrii ºi
ieºirii) se foloseºte numai pentru fiºiere speciale, iar
<TT>fcntl()</TT> pentru fiºiere ordinare.  Funcþia aceasta este o
ºmecherie care permite utilizatorilor sã facã toate operaþiile pe
care nu le pot face cu celelalte funcþii.  Cu alte cuvinte, nu toate
perifericele se ``ascund'' bine sub abstracþia prezentatã, ºi
atunci avem nevoie de o funcþie specialã.

<P>
Deocamdatã sã lãsãm pe <TT>ioctl()</TT> la o parte ºi sã vedem
mai multe despre fiºierele speciale.

<P>
În sistemele Unix tradiþionale toate fiºierele speciale sunt
strînse în directorul <TT>/dev</TT>, de la ``devices'' (aparate).
În sistemele moderne existã o întreagã ierarhie de directoare în
directorul acesta: directoare pentru discuri, directoare pentru benzi,
etc.

<P>
Iatã o porþiune din directorul <TT>/dev</TT> de pe o staþie de
lucru Sun cu SunOS 4.1.3 (fac o selecþie; sunt peste 550 de
fiºiere!):

<P>
<PRE>
    crw-rw-rw-  1 root      69,   0 May  6 17:55 audio
    crw-rw-rw-  1 root      26,   0 May  6 17:55 bwone0
    crw--w--w-  1 mihaib     0,   0 Oct 19 14:06 console
    lrwxrwxrwx  1 root            9 May  6 17:37 modem -&gt; /dev/ttya
    crw-rw-rw-  1 root      11,   0 May  6 17:55 des
    brw-rw-rw-  1 root      16,   0 May  6 17:51 fd0a
    crw-rw-rw-  1 root     104,   0 May  6 17:55 lightpen
    crw-rw-rw-  1 root      13,   0 May  6 17:51 mouse
    crw-------  1 root      37,  40 May  6 17:51 nit
    crw-rw-rw-  1 root      30,   0 May  6 17:55 rmt0
    crw-rw-rw-  1 root      30,   1 May  6 17:55 rmt1
    crw-r-----  1 root      17,   0 May  6 17:51 rsd0a
    crw-r-----  1 root      17,   1 May  6 17:51 rsd0b
    crw-rw-rw-  1 root       2,   0 Sep 25 11:25 tty
    crw-rw-rw-  1 root      12,   0 Oct 19 14:44 ttya
    crw-rw-rw-  1 root      12,   1 May  6 17:51 ttyb
    ^                       ^^    ^
tipul                    major    minor
</PRE>

<P>
Numele fiºierelor speciale nu sunt prea bine standardizate; fiecare
sistem va numi un anumit periferic în alt fel.  Tipul mai sus este
``c'' pentru fiºiere de tip ``caracter'' ºi ``b'' pentru fiºiere de
tip ``bloc''.  Pe sistemul meu fiºierele de mai sus corespund la
(tabela&nbsp;<A HREF="#speciale">7</A>):

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="334"></A>
<TABLE>
<CAPTION><STRONG>Table 7:</STRONG>
Fiºiere speciale.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">audio</TD>
<TD ALIGN="LEFT">placa de sunet</TD>
</TR>
<TR><TD ALIGN="LEFT">bwone0</TD>
<TD ALIGN="LEFT">placa graficã alb-negru (Black-and-White ONE)</TD>
</TR>
<TR><TD ALIGN="LEFT">console</TD>
<TD ALIGN="LEFT">consola (tastaturã, ecran)</TD>
</TR>
<TR><TD ALIGN="LEFT">des</TD>
<TD ALIGN="LEFT">integratul care cripteazã DES (Data Encription Standard)</TD>
</TR>
<TR><TD ALIGN="LEFT">fd0a</TD>
<TD ALIGN="LEFT">primul floppy disk</TD>
</TR>
<TR><TD ALIGN="LEFT">lightpen</TD>
<TD ALIGN="LEFT">creionul optic</TD>
</TR>
<TR><TD ALIGN="LEFT">mouse</TD>
<TD ALIGN="LEFT">ºoarecul</TD>
</TR>
<TR><TD ALIGN="LEFT">nit</TD>
<TD ALIGN="LEFT">placa de reþea (Network Interface Tap)</TD>
</TR>
<TR><TD ALIGN="LEFT">rmt0</TD>
<TD ALIGN="LEFT">banda nr. 0 (Remote Mag Tape)</TD>
</TR>
<TR><TD ALIGN="LEFT">rsd0a</TD>
<TD ALIGN="LEFT">primul disc SCSI, partiþia A (Raw Scsi Disc 0)</TD>
</TR>
<TR><TD ALIGN="LEFT">ttya</TD>
<TD ALIGN="LEFT">primul terminal (mai precis portul serial; TeleTYpe)</TD>
</TR>
</TABLE>
</DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Faptul cã fiecare periferic oferã o interfaþã de fiºier are
urmãtoarele consecinþe:

<P>

<UL>
<LI>Programele lucreazã cu perifericele exact ca ºi cu fiºierele
(aceleaºi operaþii); anumite programe nici nu trebuie sã ºtie cu
ce anume lucreazã;
</LI>
<LI>Protecþia accesului la periferice se face prin aceleaºi
mecanisme (drepturi, posesor).
</LI>
</UL>

<P>
Fireºte, ca ºi þevile, fiºierele speciale <I>nu existã fizic
pe disc</I>; pe disc existã doar <I>numele acestor fiºiere precum
ºi atributele</I>.  ``Conþinutul'' acestor fiºiere este ``calculat''
de nucleu.  Vom reveni la acest lucru.

<P>
Sã vedem în acþiune abstracþia de fiºier în cazul perifericelor.

<P>
Dacã vã uitaþi cu atenþie mai sus veþi observa cã ``fiºierul''
<TT>console</TT> îi aparþine utilizatorului <TT>mihaib</TT> (eu),
ºi nu lui <TT>root</TT>, ca toate celelalte.  Asta pentru cã atunci
cînd eu am fãcut ``login'' la consolã, fiºierul special care este
consola mi-a fost trecut în posesie mie de programul ``login''.  În
felul acesta, toate procesele lansate de mine, care au ``ºtampila''
<TT>mihaib</TT> pe ele pot scrie ºi citi de la consolã (un lucru
foarte util)!

<P>
De asemenea veþi observa cã drepturile pentru alþi utilizatori
permit scrierea la consolã!  Acest lucru permite altor utilizatori
sã-mi trimitã mesaje folosind comanda <TT>write</TT> a shell-ului, a
cãrei implementare nu face altceva decît sã deschidã fiºierul
<TT>/dev/console</TT> ºi sã scrie mesajele.

<P>
Adesea se fac bancuri proaste pe un sistem pe care lucreazã mai
mulþi utilizatori: unul gãseºte un astfel de terminal al unui coleg
permisiv ºi aruncã o tonã de date spre el: <TT>cat
/usr/include/*.h &gt;/dev/console</TT>.  Pentru a nu permite aºa ceva, pot
face <TT>chmod 600 /dev/console</TT>.  (Pot face acelaºi lucru cu
comanda <TT>mesg n</TT>.)

<P>
Iatã deci cum sistemul de fiºiere constrînge accesul la periferice
ºi comunicaþia între procese.  Iar acest lucru este ``pe gratis'':
acelaºi mecanism care era folosit pentru fiºiere ordinare merge ºi
aici.

<P>
În general accesul la periferice este restrîns, pentru cã altfel
utilizatori rãutãcioºi ar putea cauza stricãciuni.  Dacã aveþi
drepturi de administrator pe o maºinã puteþi citi toate discurile
direct, bloc cu bloc, direct ``din'' fiºierele speciale.  Pe maºina
asta aº putea cu <TT>od /dev/sd0a</TT>.  Dacã aveþi un Linux ºi
vreþi sã încercaþi, discurile se numesc de obicei
<TT>/dev/hd0_</TT>.

<P>
ªi aºa mai departe.  Programele care arhiveazã pe bandã pur ºi
simplu deschid fiºierul <TT>/dev/rmt0</TT> ºi scriu apoi ce au de
scris acolo.  Serverul de ferestre X Windows deschide (cu
<TT>open()</TT>) fiºierele speciale <TT>/dev/bwone0</TT> ºi
<TT>/dev/mouse</TT> ºi scrie, respectiv citeºte de acolo.  Aceste
programe nu au nici o instrucþiune magicã pentru a opera cu benzi
sau cu ecranul: ºtiu doar sã scrie ºi sã citeascã din
``fiºiere'', ºi în plus ºtiu ce semnificaþie are ``conþinutul''
fiºierelor (adicã valorile scrise) pentru hardware.

<P>
Cum funcþioneazã aceste ``fiºiere''?  Pentru implementarea
fiecãruia din ele nucleul conþine o cantitate impresionantã de
``soft'', numitã ``driver'' (ºofer?).  Pe un sistem Unix driverele
pot lua mai mult de jumãtate din codul întregului sistem de operare!

<P>
Fiecare fiºier special are printre atribute douã valori, numite
``major device number'' ºi ``minor device number''.  Acestea sunt
cele douã coloane de numere care apar în listingul de mai sus.

<P>
Cînd nucleul este compilat, înauntru are un array mare de structuri
care corespund fiecãrui driver.  De exemplu cãsuþa 0 din array
corespunde driver-ului de consolã, cãsuþa 17 discurilor iar
cãsuþa 13 mouse-ului.  (Am citit numãrul ``major'' din listing).

<P>
Aceasta este ºi asocierea dintre numele de fiºier ºi programele
care implementeazã abstracþia de fiºier: cînd un proces deschide
fiºierul <TT>/dev/console</TT>, nucleul observã din atributele
fiºierului stocate în inod, cã este vorba de un fiºier special cu
major-ul 0, deci roagã driver-ul 0 sã manipuleze toate operaþiile
pe acel fiºier.  Acel driver va face anumite acþiuni cînd se va
scrie în fiºier, care acþiuni vor duce la afiºarea de informaþii
pe ecran.  Cum se face acest lucru, depinde foarte tare de hardware-ul
în chestiune.

<P>
La ce foloseºte numãrul minor?  De exemplu sistemul de mai sus are
douã benzi: <TT>rmt0</TT> ºi <TT>rmt1</TT>.  Atunci, pentru cã în
hardware sunt identice, pentru ele existã un singur driver.
Driver-ul va opera însã cu una sau alta din unitãþile de bandã,
în funcþie de numãrul minor al fiºierului: scrierile la
<TT>rmt0</TT> vor merge pe o banda, iar cele la <TT>rmt1</TT> la
cealaltã.

<P>
<PRE>
                 /-------------------------&gt;banda 1
    /dev/rmt1    |
     inod        |     | driver  |         | driver    |      | Array
  |---------|    |     | consola |         | banda     |      | de
  | posesor |    |     |_________|__....___|___^_______|_...__| drivere
  | drepturi|    |      0         1         17/         18
  | .....   |    |                           /
  | major 17|----|--------------------------/
  | minor  1|----/
  |         |
  | tip=c   |   
  |---------|   |
                |       
   In sistemul  |  In nucleu
   de fisiere   |
        &lt;-------|------&gt;
</PRE>

<P>
Pentru ca schema sã funcþioneze trebuie ca atributele (major-minor)
ale fiºierelor speciale sã fie corect alocate pentru a corespunde
ordinii în care sunt driverele compilate în nucleu.  Administratorul
de sistem este cel care creazã noi fiºiere speciale, cu comanda
<TT>mknod</TT>, ºi trebuie sã fie grijuliu sã menþinã o asociere
corectã cînd creazã noi fiºiere speciale (ºi adaugã noi drivere
în nucleu).

<P>

<H1><A NAME="SECTION000110000000000000000">
Pseudo-perifericele (pseudo-devices)</A>
</H1>

<P>
Observaþi cã deja un periferic ``seamãnã'' foarte puþin cu un
fiºier: nu poþi depune date pe care apoi sã le extragi în mouse,
de pildã.  Totuºi perifericul este un dispozitiv care manipuleazã
informaþie, deci interfaþa genericã este potrivitã.

<P>
Se poate merge ºi mai departe cu ideile.  La ce altceva se poate
``aplica'' aceastã interfaþã?  Ce fel de funcþionalitate îmi mai
poate da sistemul fãrã a introduce abstracþii noi?

<P>
Foarte multe alte obiecte cu aceeaºi interfaþã pot fi construite.
Pe lîngã fiºierele speciale care corespund unor periferice
concrete, în directorul <TT>/dev</TT> mai existã o mulþime de alte
fiºiere speciale care corespund unor <I>periferice virtuale</I>, sau
unor ``pseudo-periferice''.  Acestea sunt niºte aparate imaginare,
sintetizate în întregime în software.

<P>
Iatã cîteva:

<P>
<PRE>
crw-------  1 root      16,   0 May  6 17:51 klog
crw-r--r--  1 root       3,   1 May  6 17:51 kmem
crw-r--r--  1 root       3,   0 May  6 17:51 mem
crw-rw-rw-  1 root       3,   2 Oct 19 20:50 null
crw-rw-rw-  1 root      21,   0 Oct 19 20:51 ptyp0
crw-rw-rw-  1 root      21,   1 Oct 19 20:36 ptyp1
crw-rw-rw-  1 root      20,   0 Oct 19 20:51 ttyp0
crw-rw-rw-  1 root      20,   1 Oct 19 20:36 ttyp1
crw-rw-rw-  1 root      15,   0 Apr  7  1997 win0
crw-rw-rw-  1 root      15,   1 Apr  7  1997 win1
crw-rw-rw-  1 root       3,  12 May  6 17:51 zero
</PRE>

<P>
Ele corespund urmãtoarelor funcþiuni:

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="283"></A>
<TABLE>
<CAPTION><STRONG>Table 8:</STRONG>
Fiºiere speciale.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">klog</TD>
<TD ALIGN="LEFT">depozit pentru mesajele de eroare ale nucleului</TD>
</TR>
<TR><TD ALIGN="LEFT">kmem</TD>
<TD ALIGN="LEFT">memoria virtualã vizibilã nucleului</TD>
</TR>
<TR><TD ALIGN="LEFT">mem</TD>
<TD ALIGN="LEFT">memoria fizicã a calculatorului</TD>
</TR>
<TR><TD ALIGN="LEFT">null</TD>
<TD ALIGN="LEFT">``canalul fãrã fund'' (sink)</TD>
</TR>
<TR><TD ALIGN="LEFT">ttyp0</TD>
<TD ALIGN="LEFT">terminal virtual 0; master</TD>
</TR>
<TR><TD ALIGN="LEFT">ptyp0</TD>
<TD ALIGN="LEFT">terminal virtual 0; sclav</TD>
</TR>
<TR><TD ALIGN="LEFT">win0</TD>
<TD ALIGN="LEFT">fereastra 0</TD>
</TR>
<TR><TD ALIGN="LEFT">zero</TD>
<TD ALIGN="LEFT">ºirul infinit de zerouri</TD>
</TR>
</TABLE>
</DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
De exemplu <TT>win0</TT> reprezintã o fereastrã de pe ecran; aceasta
se comportã ca un terminal în miniaturã, dar nu existã fizic; este
o noþiune emulatã software.  Un pseudo-periferic, deci.

<P>
<TT>/dev/mem</TT> este chiar o imagine directã a memoriei
calculatorului.  Citind astfel octetul 1000 din <TT>/dev/mem</TT>:

<P>
<PRE>
{
   char c;
   int i = open("/dev/mem", O_RDONLY); 
   lseek(i, 1000);
   read(i, &amp;c, 1);
   close(i);
}
</PRE>

<P>
vom afla ce se aflã în memoria fizicã a maºinii la
adresa 1000!  (Fireºte, presupunînd cã drepturile de acces ne
permit acest lucru.)

<P>
Alte fiºiere bizare: <TT>/dev/null</TT> este un fiºier de lungime 0,
în care orice se scrie se pierde (nu are nici un efect).  Este extrem
de util într-o sumedenie de circumstanþe.  De pildã dacã nu vrem
sã vedem erorile care pot fi generate de o comandã, putem sã rugãm
comanda sã scrie aceste erori ``în'' fiºierul <TT>/dev/null</TT>:
<TT>ls -R /var/spool/ 2&gt;/dev/null</TT>.

<P>
Încã odatã: protecþia accesului la pseudo-periferice se face în
acelaºi fel, de cãtre codul din sistemul de fiºiere care cautã în
directoare.

<P>

<H1><A NAME="SECTION000120000000000000000">
Sistemul de fiºiere <TT>/proc</TT></A>
</H1>

<P>
Prezentãm aici o altã spectaculoasã extensie a noþiunii de fiºier
(sau mai precis o altã construcþie care foloseºte interfaþa cu
care se acceseazã fiºierele): un sistem de fiºiere în care se
aflã... procese!

<P>
Aceastã interfaþã a fost propusã în 1991 pentru sistemul Unix de
la AT&amp;T, System V, iniþial pentru a facilita depanarea, dar a
evoluat într-o metodã generalã de interacþiune cu procesele care
se executã pe un calculator.

<P>
Existã o oarecare variabilitate în implementarea acestei
construcþii, aºa cã exemplul pe care îl prezentãm ar putea diferi
oarecum pe sisteme specifice.

<P>
Lucrurile stau cam aºa: existã un director <TT>/proc</TT>, iar în
acest director existã cîte un sub-director pentru fiecare proces
care se executã pe sistem, numit ca identificatorul numeric al
procesului (adicã procesul ``1'' are un director numit ``1'').  În
directorul fiecãrui proces se aflã mai multe ``fiºiere'' care
descriu procesul respectiv.  Pentru un proces putem avea urmãtoarele
fiºiere:

<P>
<DL>
<DT><STRONG><TT>status</TT></STRONG></DT>
<DD>informaþie despre starea procesului (posesori,
memorie alocatã, etc);
</DD>
<DT><STRONG><TT>psinfo</TT></STRONG></DT>
<DD>informaþie folositã de comanda <TT>ps</TT>,
pentru a descrie acest proces;
</DD>
<DT><STRONG><TT>ctl</TT></STRONG></DT>
<DD>scriind în acest fiºier anumite valori se poate
influenþa comportarea procesului;
</DD>
<DT><STRONG><TT>map</TT></STRONG></DT>
<DD>descrie harta memoriei virtuale a procesului; cum
se traduce fiecare adresã virtualã într-una fizicã;
</DD>
<DT><STRONG><TT>as</TT></STRONG></DT>
<DD>memoria virtualã alocatã procesului.
</DD>
<DT><STRONG>etc.</STRONG></DT>
<DD>
</DD>
</DL>

<P>
Acest sistem de fiºiere este folosit de debuggere: un debugger care
vrea sã depaneze procesul 100 va deschide fiºierul
<TT>/proc/100/as</TT> ºi va scrie la adresa doritã (cu
<TT>lseek(), write()</TT>) codul unui breakpoint!

<P>
Multe alte operaþii pot fi fãcute pe fiºiere în acest fel.  Linux
are în plus în <TT>/proc</TT> pentru fiecare proces o listã a
tuturor fiºierelor pe care procesul le are deschise.

<P>
Protecþiile pe directoarele ºi fiºierele din <TT>/proc</TT> sunt
puse în aºa fel încît interacþiunile între procese independente
sunt strict controlate.  De exemplu directorul care corespunde
fiecãrui proces aparþine utilizatorului care a lansat procesul.

<P>

<H1><A NAME="SECTION000130000000000000000">
Concluzie: programarea orientatã pe obiecte</A>
</H1>

<P>
Faptul cã putem folosi interfaþa read-write-open-close-lseek-ioctl
pentru creaturi atît de variate în constituþie, de la fiºiere
pînã la pseudo-periferice ne face sã ne gîndim dacã nu poate fi
folositã ca un mijloc universal de acces la informaþie.

<P>
Aceastã interfaþã derivã simultan o fenomenalã putere din
generalitatea ei, pentru cã orice tip de date poate fi vãzut pînã
la urmã ca o succesiune de octeþi, dar ºi o fenomenalã
slãbiciune, pentru cã semnificaþia acestor octeþi trebuie
stabilitã prin alte mijloace decît cele ale interfeþei.  Ce
înseamnã sã scriu un <I>x</I> ``în'' fiºierul
<TT>/dev/bwone0</TT>, asta numai cel care a scris driver-ul pentru
placa graficã poate ºti (ºi cel care a citit documentaþia,
desigur).

<P>
Funcþia <TT>ioctl()</TT>, despre care n-am spus mare lucru în acest
articol, este folositã pentru a simula toate funcþiunile care nu se
pot obþine cu uºurinþã doar cu funcþiile citate.  Un exemplu de
acþiune care se obþine cu un <TT>ioctl()</TT> ºi care este greu de
implementat doar cu celelalte funcþii: pentru un driver al unitãþii
de bandã existã o comandã <TT>ioctl()</TT> care îi spune sã
deruleze banda înapoi.

<P>
Varianta diametral opusã de proiectare este prezentã în interfaþa
driver-elor de ``terminal'' din sistemele de operare Windows: o
sumedenie de apeluri de sistem diferite pentru fiecare operaþie
graficã, de la desenatul unui cerc, la ºters fereastra.  Este greu
de arbitrat între cele douã alternative.  Lãsãm cititorul sã
gîndeascã la meritele fiecãrei scheme.

<P>
Revenind la interfaþa uniformã din Unix: în tehnologia orientatã
pe obiecte aceastã situaþie se rezumã astfel: avem o clasã de
bazã abstractã, care are ca metode virtuale <TT>open()</TT>,
<TT>close()</TT>, <TT>read()</TT>, <TT>write()</TT>, <TT>ioctl()</TT>
ºi <TT>lseek()</TT>.  Fiºierele, perifericele, pseudo-perifericele
ºi descrierile proceselor sunt toate clase derivate din aceastã
clasã de bazã.

<P>
Deºi sistemul de operare Unix tradiþional (ºi chiar ºi variantele
moderne) este scris în C, astfel de ``reminiscenþe'' ale
programãrii orientate pe obiecte abundã.  Sperãm sã putem vorbi
în alte articole despre: variatele tipuri de sisteme de fiºiere pe
care Unix le poate folosi (în Linux existã cel puþin 10!), despre
sistemul de memorie virtualã ºi despre STREAMS.  Toate aceste
construcþii folosesc aceeaºi tehnologie, de a manipula a mulþime de
obiecte diferite ca naturã dar folosind o unicã interfaþã.

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot114">... rapide.</A><A NAME="foot114"
 HREF="2fs-html.html#tex2html4"><SUP>1</SUP></A>
<DD>Dezavantajul este cã o schimbare a drepturilor
de acces nu are nici un efect pentru procesele care au deschis
anterior fiºierul!

<DT><A NAME="foot189">... siere</A><A NAME="foot189"
 HREF="2fs-html.html#tex2html8"><SUP>2</SUP></A>
<DD>Un utilizator poate ``accesa'' discul doar cu un
ciocan.

<DT><A NAME="foot200">...chroot()</A><A NAME="foot200"
 HREF="2fs-html.html#tex2html9"><SUP>3</SUP></A>
<DD>În
Unix nu numai noþiunea de ``director curent'' este alta pentru
fiecare proces, dar fiecare proces are propriul lui ``director
rãdãcinã''.

<DT><A NAME="foot228">... aici</A><A NAME="foot228"
 HREF="2fs-html.html#tex2html10"><SUP>4</SUP></A>
<DD>Diferenþa este cã cele
bloc se pot accesa fizic numai în blocuri de informaþie de mãrime
fixã, iar cu cele caracter se pot transfera cantitãþi arbitrare de
informaþie.  Altã diferenþã este cã se pot plasa sisteme de
fiºiere decît pe periferice de tip bloc.

</DL>
<BR><HR>

</BODY>
</HTML>
