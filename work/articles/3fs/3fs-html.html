<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Sistemul Virtual de Fiºiere</TITLE>
<META NAME="description" CONTENT="Sistemul Virtual de Fiºiere">
<META NAME="keywords" CONTENT="3fs-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>
<body>

<P>

<P>
<H1 ALIGN="CENTER">Sistemul Virtual de Fiºiere</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- mihaib+ at cs.cmu.edu 
<BR><TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>ianuarie 1998</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>VFS: Virtual File System
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe generale despre sistemele
de fiºiere; familiaritate cu arhitectura unui sistem de fiºiere;
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>vnod, sistem de fiºiere virtual, montare,
modularitate
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html25"
  HREF="3fs-html.html">Interfaþã ºi implementare</A>
<LI><A NAME="tex2html26"
  HREF="#SECTION00030000000000000000">Fiºierul ca abstracþiune</A>
<UL>
<LI><A NAME="tex2html27"
  HREF="#SECTION00031000000000000000">Vnodul: un i-nod virtual</A>
<LI><A NAME="tex2html28"
  HREF="#SECTION00032000000000000000">Vnoduri speciale</A>
</UL>
<BR>
<LI><A NAME="tex2html29"
  HREF="#SECTION00040000000000000000">Sistemul de fiºiere ca abstracþiune</A>
<LI><A NAME="tex2html30"
  HREF="#SECTION00050000000000000000">Montarea</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION00060000000000000000">Sistemul de fiºiere în acþiune</A>
<UL>
<LI><A NAME="tex2html32"
  HREF="#SECTION00061000000000000000">Compilarea nucleului</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION00062000000000000000">Boot-area</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION00063000000000000000">Montarea</A>
<LI><A NAME="tex2html35"
  HREF="#SECTION00064000000000000000">Deschiderea unui fiºier</A>
<LI><A NAME="tex2html36"
  HREF="#SECTION00065000000000000000">O operaþie pe un fiºier</A>
</UL>
<BR>
<LI><A NAME="tex2html37"
  HREF="#SECTION00070000000000000000">Concluzie</A>
</UL>
<!--End of Table of Contents-->
<BR>
<BR>

<P>

<H1><A NAME="SECTION00020000000000000000">
Interfaþã ºi implementare</A>
</H1>

<P>
Ingineria programãrii ne învaþã cã putem ascunde un acelaºi
obiect sub o sumedenie de operaþii diferite, ºi alternativ, cã
putem inventa seturi de operaþii distincte pentru a opera asupra unei
aceleiaºi entitãþi.

<P>
Avem deci o oarecare <I>independenþã</I> între <I>implementarea</I>
unui obiect (de pildã o stivã poate fi implementatã ca o listã sau
ca un vector) ºi <I>interfaþa</I> unui obiect, care este setul de
operaþii pe care le efectuãm asupra lui (de exemplu o stivã va
oferi operaþii de genul ``pune element (push)'', ``extrage element
(pop)'', ``verificã dacã sunt elemente (empty?)'').

<P>
Aparent paradoxal, tradiþia ne învaþã cã mai importantã decît
implementarea unei creaturi informatice este interfaþa ei.  De ce?
Din motive de <I>compatibilitate</I>.  Atîta vreme cît un obiect are
aceeaºi interfaþã (ºi un acelaºi comportament), toþi cei care
care îl folosesc pot rãmîne neschimbaþi, chiar dacã implementarea
obiectului se schimbã.  De aceea este <I>extrem</I> de important sã
proiectãm interfeþele cum trebuie de la început.

<P>
Putem vedea importanþa acestui precept la scarã industrialã
într-un exemplu izbitor.  Proiectanþii procesorului 8086 de la Intel
nu au putut rezista tentaþiei de a introduce în setul de
instrucþiuni al procesorului o mulþime de operaþii exotice (de
exemplu operaþii pe ºiruri de numere zecimale cu cifre pe cîte 4
biþi), pentru cã aveau destui tranzistori nefolosiþi pe circuitul
integrat.  ªi-au zis: ``în definitiv ce ne costã?''.  Eroare
fatalã.  Setul de instrucþiuni este interfaþa unui procesor, ºi ca
atare trebuie sã rãmînã neschimbat chiar atunci cînd arhitectura
internã (implementarea) procesorului se schimbã.  Aºa cã aceste
instrucþiuni pe care nu le foloseºte (practic) nimeni existã ºi
în setul de instrucþiuni din 80486, Pentium, Pentium Pro ºi Pentium
II.  ªi ºtiþi de ce nu existã procesoare Pentium la mai mult de
300Mhz, dar existã procesoare Alpha la 600Mhz?  Din cauza setului de
instrucþiuni: anumite instrucþiuni Pentium pur ºi simplu nu pot fi
implementate foarte rapid (una din ele fiind cea de mai sus).

<P>
Asta este drama: interfaþa unui produs longeviv tinde sã
supravieþuiascã implementãrii.  Din cauza aceasta cel care
proiecteazã o interfaþã trebuie sã fie extrem de grijuliu, pentru
cã are de luptat cu un adversar colosal: timpul.  El trebuie sã
anticipeze evoluþia unei interfeþe ºi a utilizãrii ei.

<P>
Vom vedea în acest articol o interfaþã excelent proiectatã cu
peste un sfert de secol în urmã, care a evoluat ºi supravieþuit
tuturor încercãrilor la care a fost supusã.  Este vorba de
interfaþa (setul de operaþii) cu fiºiere în sistemul de operare
Unix<A NAME="tex2html1"
  HREF="#foot56"><SUP>1</SUP></A>.

<P>

<H1><A NAME="SECTION00030000000000000000">
Fiºierul ca abstracþiune</A>
</H1>

<P>
Un fiºier în Unix este un simplu container de date; un fel de array
de octeþi de o lungime (teoretic) arbitrarã.  Independent de modul
în care este implementat un fiºier operaþiile pe el se fac cu un
set extrem de redus de operaþii esenþiale (<TT>open(), close(),
read(), write(), lseek()</TT>) la care se adaugã o sumedenie de operaþii
secundare ca importanþã sau care sunt folosite pentru a manipula
<I>directoare</I>.  Sã ne reamintim pe scurt cum se folosesc aceste
operaþii:

<P>

<UL>
<LI><TT>open()</TT> ``deschide'' un fiºier ºi are ca rezultat un
``mîner'' (file handle) cu care fiºierul este apoi manipulat (un
numãr mic întreg);

<P>
</LI>
<LI><TT>close()</TT> este folositã pentru a închide un fiºier
care nu mai este necesar;

<P>
</LI>
<LI><TT>lseek()</TT> este folositã pentru a fixa locul în fiºier
unde se va face urmãtoare operaþie de scriere/citire; scrierea ºi
citirea vor avansa acest ``cursor'' cu cantitatea de date pe care o
transferã.  Astfel este favorizat în mod implicit accesul
<I>secvenþial</I> la fiºiere;

<P>
</LI>
<LI><TT>read()</TT>, respectiv <TT>write()</TT> citesc ºi scriu
date dintr-un buffer din memorie în fiºier.

<P>
</LI>
</UL>

<P>
Avem un exemplu de folosire a funcþiilor de acces la fiºiere în
programul de mai jos, care copiazã fiºierul ``sursa'' în fiºierul
``destinatie''.

<P>
<PRE>
#include &lt;unistd.h&gt;     /* pentru open(), exit() */
#include &lt;fcntl.h&gt;      /*        O_RDWR */
#include &lt;errno.h&gt;      /*        perror() */

void fatal(char * mesaj_eroare)
{
        perror(mesaj_eroare);
        exit(1);
}       

int main(void)
{
        int miner_sursa, miner_destinatie;
        int copiat;
        char buf[1024];

        miner_sursa = open("sursa", O_RDONLY);
        miner_destinatie = open("destinatie", O_WRONLY | O_CREAT, 0644);
        if (miner_sursa &lt; 0 ||
            miner_destinatie &lt; 0)
                fatal("Nu pot deschide un fisier");
        lseek(miner_sursa, 0, SEEK_SET);
        lseek(miner_destinatie, 0, SEEK_SET);
        while ((copiat = read(miner_sursa, buf, sizeof(buf)))) {
                if (copiat &lt; 0)
                        fatal("Eroare la citire");
                copiat = write(miner_destinatie, buf, copiat);
                if (copiat &lt; 0)
                        fatal("Eroare la scriere");
        }
        close(miner_sursa);
        close(miner_destinatie);
        return 0;
}
</PRE>

<P>

<H2><A NAME="SECTION00031000000000000000">
Vnodul: un i-nod virtual</A>
</H2>

<P>
Un sistem de operare de tip Unix poate opera simultan cu mai multe
tipuri de sisteme de fiºiere.  De pildã toate sistemele suportã pe
lîngã un sistem de fiºiere pe un disc local un sistem de fiºiere
la distanþã numit NFS: network file system, creat de firma SUN.  Tot
firma Sun Microsystems a construit mecanismele necesare suportãrii
unei varietãþi de fiºiere implementate complet diferit simultan de
cãtre un singur nucleu (de fapt nu cei de la Sun au inventat
noþiunea, însã implementarea lor, descrisã în cele ce urmeazã, a
devenit practic un standard).  Terminologia folositã in acest articol
este deci cea propusã de Sun, deºi exemplele de cod C vor fi din
sistemul de operare Linux.

<P>
Cheia constã în urmãtorul fapt: toate sistemele de fiºiere
prezintã <I>aceeaºi interfaþã</I>.  Cu alte cuvinte, utilizatorul
(ºi vom vedea cã ºi nucleul în interiorul sãu) acþioneazã cu
exact aceleaºi funcþii asupra tuturor fiºierelor, indiferent cã se
aflã pe un disc local sau pe unul la distanþã sau pe un floppy DOS,
etc.; programul de mai sus va fi scris în exact acelaºi fel pentru
toate aceste cazuri.

<P>
În interiorul nucleului fiecare fiºier este reprezentat printr-o
structurã de date numitã <I>vnod</I>: un nod de informaþii virtual.
În <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#sistem-f">articolul</a>
anterior, despre structura sistemului de fiºiere din Unix, din PC
Report din decembrie 1996, am vãzut cã sistemul de fiºiere tradiþional
din Unix folosea pe disc o structurã de date numitã <I>inod</I> pentru
a descrie atributele fiºierelor.  Vnodul este o generalizare a
inodului, care este însã rezidentã în memoria calculatorului, ºi nu pe
un disc, ºi cu care nucleul reprezintã fiecare fiºier deschis.

<P>
Vnodul conþine douã feluri de cîmpuri în interiorul sãu:

<P>

<UL>
<LI>O serie de cîmpuri comune tuturor sistemelor de fiºiere; din
aceastã cauzã aceste cîmpuri se mai numesc ``independente de
sistemul de fiºiere'';

<P>
</LI>
<LI>Cîmpuri specifice fiecãrui sistem de fiºiere în parte.
</LI>
</UL>

<P>
Structura ar arãta deci (în principiu) cam aºa:

<P>
<PRE>
struct vnode {
    cimpuri_independente;
    union {
        struct msdos_inode_info msdos_i;
        struct nfs_inode_info   nfs_i;
        struct sysv_inode_info  sysv_i;
        ....
    } u;
};
</PRE>

<P>
Fiecare structurã din uniunea <TT>u</TT> conþine atribute specifice
fiecãrui sistem de fiºiere în parte.  Dacã aveþi un sistem Linux
(o variantã de Unix ale cãrei surse sunt disponibile gratuit oricui)
puteþi vedea definiþia vnodului în fiºierul de surse al nucleului
<TT>/usr/src/linux/include/linux/fs.h</TT> (din pãcate Linux
foloseºte pentru aceste structuri de date -- cel puþin versiunile
pînã la 2.0.30 -- alte nume decît restul lumii; numele structurii
este <TT>struct inode</TT> în loc de vnode, dar nu o sã lãsãm asta
sã ne descurajeze).

<P>
Cel mai important cîmp independent de structurã este o structurã cu
pointeri spre funcþii.  Ca sã fim concreþi vom folosi tot sursa
Linux, unde numele structurii este <TT>struct inode_operations</TT>
(numele ei corect ar fi <TT>struct vnode_operations</TT>).

<P>
Definiþia acestei structuri se gãseºte în acelaºi fiºier ºi
este extrem de interesantã; schematic aratã aºa (am simplificat un
pic pentru motive pedagogice):

<P>
<PRE>
struct inode_operations {
        int (*lseek) (struct inode *, struct file *, off_t, int);
        int (*read) (struct inode *, struct file *, char *, int);
        int (*write) (struct inode *, struct file *, char *, int);
        int (*open) (struct inode *, struct file *);
        void (*release) (struct inode *, struct file *);
        int (*fsync) (struct inode *, struct file *);
        int (*create) (struct inode *,const char *,int,int,struct inode **);
        int (*lookup) (struct inode *,const char *,int,struct inode **);
        int (*link) (struct inode *,struct inode *,const char *,int);
        int (*unlink) (struct inode *,const char *,int);
        ....
}
</PRE>

<P>
Vnodul conþine deci ºi un pointer spre o structurã care conþine
pointeri cãtre funcþiile care trebuie sã opereze cu inodul
însuºi!

<P>
Vom reveni mai jos asupra folosirii vnodurilor.

<P>

<H3><A NAME="SECTION00031100000000000000">
Partea independentã de arhitecturã</A>
</H3>

<P>
Ce fel de atribute sunt prezente în orice vnod?  Putem sã ne facem o
idee în Linux privind în fiºierul <TT>fs.h</TT> indicat mai sus;
printre altele: discul (perifericul) pe care se aflã acest fiºier,
numãrul acestui inod pe acel periferic, drepturile ºi posesorul
fiºierului, data modificãrii, etc.  Mai sunt prezente structuri de
date necesare nucleului pentru operaþii pe vnod: semafoare pentru
sincronizarea accesului proceselor la vnod, liste înlãnþuite de
hash pentru cãutarea rapidã a vnodurilor în memorie, structura cu
funcþiile care opereazã asupra vnodului, descrisã mai sus.

<P>

<H3><A NAME="SECTION00031200000000000000">
Partea dependentã de arhitecturã</A>
</H3>

<P>
Desigur, fiecare sistem de fiºiere þine informaþiile de care are
nevoie în vnod în partea care-i este rezervatã.  De exemplu, pentru
un sistem de fiºiere Unix clasic (descris într-un articol mai
vechi), vnodul va conþine lista blocurilor de pe disc care aparþin
fiºierului.

<P>
Aceastã listã de blocuri nu va fi prezentã în cazul vnodurilor
pentru fiºiere de tip NFS, pentru cã acestea nu sunt prezente pe un
disc pe calculatorul local, ci pe unul la distanþã.  Dimpotrivã, un
vnod pentru un fiºier NFS va conþine informaþii suficiente pentru a
comunica cu serverul care deþine fiºierul.

<P>
Pentru cazul sistemului de operare Linux, existã pentru fiecare tip
de sistem de fiºiere care poate fi prezent în nucleu cîte un
fiºier header cu numele de tipul <TT>include/linux/*_fs_i.h</TT>
care conþine structura de date privatã respectivului sistem de
fiºiere; aruncaþi o privire prin ele.

<P>
Sã facem în figura&nbsp;<A HREF="3fs-html.html#vnod">1</A> un desen ca sã rezumãm situaþia
aºa cum este ea acum.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="vnod"></A><A NAME="234"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Vnodul</CAPTION>
<TR><TD><IMG
 WIDTH="452" HEIGHT="327" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{vnod.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
În limbajul programãrii orientate pe obiecte situaþia se descrie
foarte sumar astfel: în nucleu existã o clasã de bazã virtualã
numitã vnod prin care nucleul reprezintã orice fiºier; toate
metodele acestei clase sunt pur virtuale (metodele sunt funcþiile din
structura <TT>inode_operations</TT>).  Fiecare tip de fiºier
particular suportat de un nucleu este o <I>clasã derivatã</I> din
aceastã clasã de bazã.

<P>

<H2><A NAME="SECTION00032000000000000000">
Vnoduri speciale</A>
</H2>

<P>
În articolul din decembrie 1997 am explicat faptul cã în Unix sub
abstracþia de fiºier se ascund multe alte creaturi: þevile (pipes),
perifericele (fiºierele speciale), pseudo-perifericele ºi chiar
procesele!  Cu alte cuvinte toate aceste obiecte sunt accesate prin
aceeaºi interfaþã, care include funcþiile descrise mai sus,
<TT>read(), close()</TT>, etc.

<P>
<I>În interior nucleul reprezintã toate aceste obiecte în acelaºi
fel, ºi anume prin vnoduri.</I>  În consecinþã, pentru nucleu fiecare
periferic ``deschis'' este un vnod; în particular o partiþie de disc
este reprezentatã intern în nucleu tot ca un vnod.

<P>

<H1><A NAME="SECTION00040000000000000000">
Sistemul de fiºiere ca abstracþiune</A>
</H1>

<P>
Toatã povestea anterioarã se repetã aproape identic pe un alt
nivel: nucleul Unix se bazeazã pe lîngã abstracþia de fiºier pe
cea de <I>sistem de fiºiere</I>.  Structura prin care se reprezintã
în nucleu un sistem de fiºiere se numeºte Sistem de Fiºiere
Virtual (Virtual File System, VFS).  Putem citi definiþia structurii
pentru Linux în acelaºi fiºier: <TT>include/linux/fs.h</TT>, unde
(în terminologie specificã Linux) structura de date se cheamã
<TT>struct super_block</TT>.

<P>
Dacã un vnod reprezintã un fiºier individual care a fost deschis,
un VFS reprezintã o întreagã partiþie care a fost montatã în
sistemul de fiºiere (secþiunea urmãtoare este consacratã acestei
operaþii).

<P>
Tot aºa cum vnodul are o serie de metode (funcþii) care opereazã
asupra lui, VFS conþine un pointer spre o serie de funcþii globale
ale unui sistem de fiºiere.  Pentru Linux acestea sunt declarate în
acelaºi fiºier, în structura <TT>struct super_operations</TT>;
cele mai importante operaþii sunt cele care citesc/scriu de pe o
partiþie un inod.  Iatã un fragment din aceastã structurã:

<P>
<PRE>
struct super_operations {
        void (*read_inode) (struct inode *);
        void (*write_inode) (struct inode *);
        void (*put_inode) (struct inode *);
        void (*put_super) (struct super_block *);
        void (*write_super) (struct super_block *);
        void (*statfs) (struct super_block *, struct statfs *);
        .....
};
</PRE>

<P>

<H1><A NAME="SECTION00050000000000000000">
Montarea</A>
</H1>

<P>
Cum ajung mai multe sisteme de fiºiere (nu neapãrat diferite
arhitectural) sã fie folosite simultan de un sistem Unix?  În DOS
sau Windows cînd se indicã un fiºier se indicã (poate implicit)
ºi partiþia de disc unde fiºierul se aflã (ex.: cu <TT>C:</TT>).

<P>
În Unix lucrurile stau puþin altfel: toate sistemele de fiºiere
disponibile utilizatorilor sunt <I>montate</I> (cu comanda
<TT>mount</TT>) de cãtre administratorul de sistem, de obicei cînd
calculatorul boot-eazã.  Comanda aceasta (care se foloseºte de un
apel de sistem cu acelaºi nume) are douã argumente importante: un
nume de partiþie, ºi un nume de director<A NAME="tex2html3"
  HREF="#foot226"><SUP>2</SUP></A>.

<P>
De exemplu, presupunînd cã am un hard disc numit <TT>/dev/hda2</TT>,
pot sã montez (dacã am drepturi de administrator) sistemul de
fiºiere aflat pe el peste directorul <TT>/mnt</TT> cu comanda:

<P>
<PRE>
mount /dev/hda2 /mnt
</PRE>

<P>
Sã observãm în trecere cã faptul cã numai administratorul are
dreptul de a monta sisteme de fiºiere restrînge mult posibilitatea
de propagare a viruºilor: un utilizator neprivilegiat nu poate accesa
dischete sau discuri strãine.

<P>
Ce înseamnã montarea?  Poate fi montatã numai o partiþie
formatatã ºi pe care se aflã un sistem de fiºiere.  Prin montare
directorul rãdãcinã al acelei partiþii este identificat cu
directorul indicat la comanda <TT>mount</TT>, în cazul nostru
<TT>/mnt</TT>.  Dupã execuþia comenzii, de la directorul
<TT>/mnt</TT> în jos se va afla întregul arbore de directoare de pe
partiþia <TT>/dev/hda2</TT>.

<P>
Am vãzut cîteva lucruri foarte simple; am putea spune aproape
banale.  Uluitor este de pildã faptul cã în interior nucleul
foloseºte o singurã structurã de date, vnodul, pentru a reprezenta
zeci de creaturi diferite:

<P>

<UL>
<LI>Fiºiere de naturi diferite de pe un acelaºi tip de sistem de
fiºiere (ex. directoare, fiºiere);
</LI>
<LI>Fiºiere de pe orice fel de tip de sistem de fiºiere (ex. NFS,
DOS, Unix);
</LI>
<LI>Fiºiere speciale care reprezintã periferice (ex. partiþii de
disc, consola, ecranul, benzi, mouse, etc);
</LI>
<LI>Pseudo-periferice (ex. ferestre din sistemul grafic, memoria
virtualã a maºinii <TT>/dev/mem</TT>, gaura fãrã fund
<TT>/dev/null</TT>, etc.);
</LI>
<LI>Procesele în curs de execuþie ºi informaþiile despre ele
(ex. <TT>/proc/*</TT>);
</LI>
<LI>Mecanisme de comunicare inter-proces (ex. þevi (pipes, sockets,
etc.)).
</LI>
</UL>

<P>
<I>Toate aceste obiecte sunt reprezentate în acelaºi fel
pentru cã oferã fiecare (un subset) al aceleiaºi interfeþe,
bazatã pe <TT>read(), write(), open(), close(), ioctl()</TT>.</I>

<P>
Acum vom încerca sã vedem cum funcþioneazã aceste abstracþii.
Sã urmãrim deci o serie de operaþii în sistemul de fiºiere.

<P>

<H1><A NAME="SECTION00060000000000000000">
Sistemul de fiºiere în acþiune</A>
</H1>

<P>
Vom parcurge mai multe etape:

<P>

<OL>
<LI>Vom vedea de unde ºtie nucleul sã manipuleze atîtea feluri de
sisteme de fiºiere ºi obiecte diferite;
</LI>
<LI>Vom vedea cum apare prima partiþie montatã;
</LI>
<LI>Vom vedea cum celelalte partiþii sunt montate;
</LI>
<LI>Vom vedea cum se executã o operaþie asupra unui fiºier care
trebuie sã traverseze o cãrare pe mai multe partiþii.
</LI>
</OL>

<P>
Partea spectaculoasã este cã, datoritã interfeþei identice a
tuturor fiºierelor din sistem, codul care opereazã cu fiºiere poate
fi scris în mare mãsurã <I>complet independent de natura
fiºierelor</I>, fie ele DOS, Unix sau NFS sau altceva.  Vom vedea cã
cea mai mare parte a operaþiilor se petrec într-un nivel software
care se comportã ca un comutator gigantic, care pe mãsurã ce
acþioneazã asupra unor fiºiere aflate pe partiþii diferite comutã
între codul feluritelor sisteme de fiºiere.  Acest comutator se
numeºte Virtual File System Switch, ºi se abreviazã cîteodatã cu 
<TT>vfssw</TT>.

<P>
Plasamentul acestui cod în interiorul nucleului este simbolizat în
figura&nbsp;<A HREF="3fs-html.html#vfs">2</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="vfs"></A><A NAME="240"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Sistemul de fiºiere în nucleu</CAPTION>
<TR><TD><IMG
 WIDTH="451" HEIGHT="359" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{vfs.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00061000000000000000">
Compilarea nucleului</A>
</H2>

<P>
Fiecare sistem de fiºiere îºi aranjeazã altfel datele pe disc;
anumite sisteme ca NFS cer colaborarea unui client ºi a unui server
pentru a oferi servicii de fiºiere.  Fiecare este implementat prin
alte proceduri, chiar dacã oferã acelaºi set de operaþii.
Administratorul de sistem hotãrãºte la compilarea nucleului care
din sistemele de fiºiere disponibile vor face parte din nucleu.
Fiecare pune la dispoziþie un set de funcþii pentru manipularea
structurii vfs (cele din structura <TT>struct super_operations</TT> de
mai sus) ºi pentru manipularea fiºierelor însele (vnoduri).

<P>
În cazul sistemului de operare Linux fiecare sistem de fiºiere are
sursele în propriul lui arbore de directoare plecînd din
<TT>/usr/src/linux/fs/</TT>.

<P>

<H2><A NAME="SECTION00062000000000000000">
Boot-area</A>
</H2>

<P>
Cînd sistemul de operare booteazã, înainte de lansarea proceselor,
se executã o secþiune de iniþializãri în care
sunt chemate procedurile de iniþializare ale tuturor subsistemelor
nucleului; fiecare driver se iniþializeazã ºi apoi sistem de
fiºiere are ocazia sã se iniþializeze.

<P>
Înainte de a lansa orice proces nucleul monteazã prima partiþie,
partiþia rãdãcinã.  Aceastã partiþie a fost configuratã de
administratorul de sistem la construirea sistemului.  Pe aceastã
partiþie se gãsesc cele mai importante directoare ale sistemului,
fãrã de care acesta nu poate funcþiona.  Acestea sunt:

<P>
<DL>
<DT><STRONG><TT>/dev/</TT></STRONG></DT>
<DD>care conþine toate numele fiºierelor speciale ºi
inodurile lor; aici fiecare hard-disc are un nume ºi un numãr major
ºi minor<A NAME="tex2html5"
  HREF="#foot140"><SUP>3</SUP></A> care indicã nucleului ce partiþie fizicã
corespunde fiecãrui nume;

<P>
</DD>
<DT><STRONG><TT>/etc/</TT></STRONG></DT>
<DD>care conþine toate fiºierele de configurare ale
sistemului ºi scripturile care se executã la iniþializare;

<P>
</DD>
<DT><STRONG><TT>/bin/</TT></STRONG></DT>
<DD>care conþine toate fiºierele executabile
esenþiale, printre care shell-ul, comanda <TT>mount</TT>, utilitare
de reparat discul, etc.
</DD>
</DL>

<P>
Dupã montarea partiþiei nucleul deschide directorul rãdãcinã care
va rãmîne deschis pînã la oprirea sistemului.  Asta înseamnã cã
îi alocã un vnod pe care îl iniþializeazã corespunzãtor ºi pe
care îl pãstreazã în memorie; o variabilã globalã puncteazã la
acest vnod.  (Aceste operaþii sunt executate de nucleul Linux în
funcþia <TT>mount_super()</TT> pe care o puteþi gãsi prin surse
într-un loc depinzînd de versiunea nucleului pe care o aveþi.)

<P>
Din clipa asta sistemul este funcþional.

<P>
Sã vedem mai departe cum procedeazã nucleul pentru a monta o nouã
partiþie în arborele de directoare ºi cum nucleul procedeazã
pentru a deschide un fiºier.

<P>

<H2><A NAME="SECTION00063000000000000000">
Montarea</A>
</H2>

<P>
Sã presupunem cã avem doar o partiþie montatã, cea rãdãcinã.
Sã vedem ce face nucleul la executarea comenzii:

<P>
<PRE>
mount -t msdos /dev/hda1 /mnt
</PRE>

<P>
care îi cere sã monteze o partiþie cu sistem de fiºiere
de tip MS-DOS peste directorul <TT>/mnt</TT>.

<P>
Nucleul face urmãtoarele operaþii:

<P>

<OL>
<LI>Descifreazã tipul sistemului de fiºiere pentru a ºti care
porþiune de cod (dintre multiplele sisteme de fiºiere ale nucleului)
o sã manipuleze structurile de date de pe aceastã partiþie;

<P>
</LI>
<LI>Deschide directorul indicat (<TT>/mnt</TT>); asta înseamnã
citirea de pe disc a inodului acelui director într-un vnod din
memorie; acest vnod va rãmîne deschis atîta vreme cît sistemul de
fiºiere va fi montat deasupra lui;

<P>
</LI>
<LI>Cheamã funcþia de iniþializare corespunzãtoare acestui
sistem de fiºiere (msdos), care funcþie construieºte structura VFS
(numitã în Linux <TT>super_block</TT>) ºi îi iniþializeazã
cîmpurile, de obicei citind primele sectoare de pe hard-disc din
partiþia indicatã (<TT>/dev/hda1</TT>);

<P>
</LI>
<LI>Deschide fiºierul <TT>/dev/hda1</TT>, care este un fiºier
special de tip bloc corespunzînd unei partiþii de disc;

<P>
</LI>
<LI>Deschide directorul rãdãcinã al partiþiei montate
(<TT>/dev/hda1</TT>) într-un vnod în memorie;

<P>
</LI>
<LI>Marcheazã faptul cã cele douã vnoduri (ale directorului
<TT>/mnt</TT> ºi al rãdãcinii partiþiei noi) practic ``coincid'':
asta va permite traversarea unor cãrãri de genul <TT>/mnt/tmp</TT>,
care încep pe o partiþie ºi se terminã pe alta.
</LI>
</OL>

<P>
Puteþi citi codul apelului de sistem <TT>mount(2)</TT> pentru Linux
în fiºierul <TT>/usr/src/linux/fs/super.c</TT>; pe lîngã cele
spuse codul mai face o sumedenie de verificãri pe care le-am sãrit.

<P>

<H2><A NAME="SECTION00064000000000000000">
Deschiderea unui fiºier</A>
</H2>

<P>
Existã douã mari categorii de apeluri de sistem care opereazã cu
fiºiere: apeluri care primesc cãrãri (path) cãtre un fiºier, ºi
care primesc un descriptor de fiºier (mîner, handle).  Descriptorii
am vãzut cã se obþin deschizînd un fiºier cu <TT>open()</TT>,
cãreia i se dã o cãrare.

<P>
Pe scurt, pentru a opera asupra unui fiºier trebuie întîi parcursã
o cãrare pînã la el.  Dupã cum ºtim existã douã feluri de
cãrãri: relative la directorul curent al procesului sau absolute,
care pornesc de la rãdãcina sistemelor de fiºiere (cele din urmã
se scriu începînd cu semnul /).  Diferenþa constã doar în vnodul
de la care porneºte operaþia de traversare a cãrãrii: într-un caz
este vnodul directorului curent al procesului, care este permanent
menþinut de nucleu într-o variabilã asociatã procesului, iar în
celãlalt caz directorul rãdãcinã, care este menþinut într-o
altã variabilã asociatã procesului (în Unix un proces poate
sã-ºi schimbe ceea ce crede cã este rãdãcina întregului arbore
de directoare cu apelul de sistem <TT>chroot(2)</TT>).

<P>
Pentru nucleu deschiderea unui fiºier înseamnã:

<P>

<UL>
<LI>Alocarea unui vnod liber în memorie;
</LI>
<LI>Citirea informaþiilor dependente ºi independente de pe disc
(sau de unde-or fi) în vnod.
</LI>
</UL>

<P>

<H3><A NAME="SECTION00064100000000000000">
Starea iniþialã</A>
</H3>

<P>
Sã revizuim însã structurile de date ale nucleului aºa cum se
prezintã ele în aceastã clipã; ele sunt înfãþiºate în
figura&nbsp;<A HREF="3fs-html.html#structuri">3</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="structuri"></A><A NAME="246"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
Structurile de date în nucleu</CAPTION>
<TR><TD><IMG
 WIDTH="438" HEIGHT="328" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{structuri.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H3><A NAME="SECTION00064200000000000000">
Funcþia <TT>namei</TT></A>
</H3>

<P>
Funcþia din nucleu care traduce o cãrare într-un vnod în acest fel
se numeºte în mod tradiþional în sistemele derivate din Berkeley
Unix (ºi în Linux) <TT>namei()</TT>, datoritã faptului cã traduce
un nume de fiºier într-un i(v)nod.  (Numele funcþiei în sisteme
descendente din System V de la AT&amp;T este <TT>lookuppn()</TT>, de la
lookup path name.)  Într-un pseudo-cod funcþia <TT>namei()</TT>
aratã cam aºa (cu detalii e mult mai complicatã):

<P>
<PRE>
vnode * namei(char * carare, vnode * start)
{
        char * componenta;
        vnode * curent = start;

        while (carare) {
                if (carare &amp;&amp; !DIRECTOR(curent)) 
                        return NULL;
                componenta = extrage_prima_componenta(carare);
                carare = elimina_prima_componenta(carare);
                if (!strcmp(componenta, "..") &amp;&amp;
                    curent-&gt;montat_pe) {
                        if (curent != ROOT_VNODE)
                                curent = curent-&gt;montat_pe;
                        continue;
                }
                if (curent-&gt;montat_sub) {
                        curent = curent-&gt;montat_sub;
                        continue;
                }
                curent = curent-&gt;operatii-&gt;lookup(curent, componenta);
                if (!curent) 
                        return NULL;
        }
        return curent;
}
</PRE>

<P>
Sã vedem pas cu pas cum opereazã nucleul pentru a deschide fiºierul
<TT>/mnt/tmp/a</TT>.

<P>

<OL>
<LI>Este invocatã funcþia <TT>namei("mnt/tmp/a", ROOT_VNODE)</TT>;

<P>
</LI>
<LI>Pentru cã mai avem componenente în cãrare trebuie ca
<TT>curent</TT> sã fie un vnod de director; se verificã acest lucru;

<P>
</LI>
<LI>Este extrasã prima componentã din cãrare (<TT>mnt</TT>);
cãrarea rãmîne <TT>tmp/a</TT>;

<P>
</LI>
<LI><TT>curent = ROOT_VNODE</TT>; peste <TT>curent</TT> nu e montat
nimic;

<P>
</LI>
<LI>Se cheamã indirect funcþia
<TT>curent-&gt;operatii-&gt;lookup(curent, "mnt")</TT>, care cautã în
directorul dat de vnodul <TT>curent</TT> un fiºier cu numele
<TT>mnt</TT> ºi returneazã vnodul sãu de pe aceeaºi partiþie
(partiþia rãdãcinã în cazul nostru); aceasta este noua valoare a
lui <TT>curent</TT>; dacã vnodul cãutat nu se afla anterior
cãutãrii în memorie, funcþia <TT>lookup()</TT> îl alocã ºi îl
citeºte de pe disc; funcþia <TT>lookup()</TT> construieºte ºi
structura de <TT>-&gt;operatii</TT> din cadrul vnodului, pãstrînd
operaþiile de la directorul în care se cautã (dacã douã vnoduri
sunt pe aceeaºi partiþie sunt deci din acelaºi sistem de fiºiere
ºi deci au aceleaºi funcþii de acces!);

<P>
</LI>
<LI>Se reia bucla <TT>while</TT>;

<P>
</LI>
<LI>Pentru cã pe directorul <TT>/mnt</TT> este montatã partiþia
<TT>/dev/hda1</TT>, valoarea lui <TT>curent-&gt;montat_sub</TT> este
chiar vnodul care este rãdãcina acestei partiþii (care este în
memorie); <TT>curent</TT> ia aceastã valoare iar bucla se reia prin
execuþia lui <TT>continue</TT>;

<P>
</LI>
<LI>În clipa asta <TT>curent</TT> puncteazã la un vnod dintr-un
sistem de fiºiere complet diferit (de tip MS-DOS); pe nucleu însã
acest lucru nu-l intereseazã, pentru cã vnodul are <I>aceleaºi
operaþii</I>, inclusiv <TT>lookup</TT> (chiar dacã ele sunt
implementate într-un mod complet diferit);

<P>
</LI>
<LI>Într-un mod perfect similar se extrage prima componentã a
cãrãrii, <TT>tmp</TT> care este cãutatã (cu apelul funcþiei
<TT>curent-&gt;operatii-&gt;lookup(curent, "tmp")</TT> în directorul al
cãrui vnod este <TT>curent</TT>; se schimbã valoarea lui
<TT>curent</TT>;

<P>
</LI>
<LI>O ultimã trecere prin buclã va gãsi la fel vnodul fiºierului
<TT>a</TT> ºi-l va încãrca în memorie; acesta este rezultatul
funcþiei <TT>namei()</TT>.
</LI>
</OL>

<P>

<H2><A NAME="SECTION00065000000000000000">
O operaþie pe un fiºier</A>
</H2>

<P>
Cheia în implementarea funcþiei <TT>namei</TT> este apelul indirect
de funcþie <TT>curent-&gt;operatii-&gt;lookup()</TT>.  Vom înþelege la ce
foloseºte acest apel privind modul în care nucleul executã o
operaþie pe un fiºier deja deschis; sã vedem un posibil cod al
apelului de sistem <TT>write()</TT>:

<P>
<PRE>
int write(int miner, char * buffer, unsigned cantitate)
{
        struct vnode * v;
        struct file * f;

        f = proces_curent-&gt;fisiere_deschise[miner];
        v = f-&gt;vnode;
        return v-&gt;operatii-&gt;write(v, buffer, cantitate);
}
</PRE>

<P>
(Am eliminat toate testele de corectitudine a argumentelor.)  Nucleul
întîi indexeazã într-un array al procesului curent pentru a gãsi
vnodul <TT>v</TT> al fiºierului deschis anterior al cãrui ``mîner''
a fost returnat utilizatorului (rolul structurii <TT>struct file</TT>
nu ne intereseazã deocamdatã; vom reveni asupra ei într-un alt
articol).  Apoi nucleul cheamã din nou indirect funcþia
<TT>write</TT>, aºa cum apare ea între operaþiile asociate vnodului
gãsit.

<P>
Frumuseþea acestei scheme este urmãtoarea: fiecare sistem de
fiºiere îºi organizeazã altfel datele pe disc; Unix foloseºte o
schemã complicatã în care fiºierele sunt descrise prin inoduri,
MS-DOS descrie blocurile fiºierelor printr-o structurã numita FAT
(file access table), etc.  Dar atîta vreme cît ambele sisteme de
fiºiere pun la dispoziþie o funcþie care scrie într-un fiºier
date, nu conteazã prea tare cã aceastã funcþie este complet
diferit implementatã pentru cele douã sisteme.  Important este cã
are <I>aceeaºi interfaþã</I>!

<P>
Fiecare vnod poartã cu el din momentul în care este adus în memorie
propriul lui vector de operaþii.  Vnodurile pentru sisteme Unix ºi
vnodurile pentru sisteme de fiºiere MS-DOS au ambele o operaþie
<TT>write()</TT>, care primeºte aceleaºi argumente ºi returneazã
aceleaºi rezultate, chiar dacã intern se comportã complet diferit.

<P>
Din aceastã cauzã utilizatorii pot trata în Unix fiºiere de naturi
foarte diferite (ºi nu numai fiºiere) ca pe obiecte de acelaºi tip.

<P>

<H1><A NAME="SECTION00070000000000000000">
Concluzie</A>
</H1>

<P>
Existã o oarecare independenþã între operaþiile pe care le putem
face asupra unui obiect (interfaþa sa) ºi modul în care acele
operaþii sunt realizate (implementarea).  O interfaþã bine
proiectatã poate avea consecinþe dramatice.

<P>
Cu siguranþã flexibilitatea acestei interfeþe este unul dintre
ingredientele care a asigurat succesul sistemului de operare Unix ºi
a paradigmelor sale.  Avem aici un exemplu splendid de
<I>modularitate</I>: pãrþi complet diferite constitutiv au aceeaºi
interfaþã încît pot fi practic substituite una alteia, ca niºte
bucãþi de Lego.

<P>
Mai mult de jumãtate din sursele C ale unui nucleu sunt drivere
(pentru Linux 2.0.30 asta înseamnã aproape o jumãtate de milion de
linii de cod!).  Nici un om nu poate înþelege atît de mult cod.
Dar datoritã modularitãþii nimeni nu trebuie sã înþeleagã toate
piesele: trebuie doar sã cunoºti interfeþele; implementarea poate
fi oricare.  Înþelegînd interfeþele înþelegi ºi cum
funcþioneazã întregul.

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot56">...  Unix</A><A NAME="foot56"
HREF="3fs-html.html#tex2html1"><SUP>1</SUP></A> <DD>Am prezentat
într-un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#2fs">articol</a>
din PC Report din decembrie 1997 aceastã interfaþã pe larg; o copie a
articolului este disponibilã din pagina de web a autorului.  Vom relua
însã aici ideile esenþiale.

<DT><A NAME="foot226">... director</A><A NAME="foot226"
 HREF="3fs-html.html#tex2html3"><SUP>2</SUP></A>
<DD>Articolul citat
mai sus despre funcþionarea sistemelor de fiºiere din Unix, din PC
Report din decembrie 1997 explicã cum se poate numi o partiþie
folosind un nume ca al unui fiºier, ºi cum nucleul opereazã cu
partiþiile.  Vom vedea mai jos cã nucleul trebuie sã aibã de la
bootare montatã cel puþin o partiþie, numitã <I>partiþia
rãdãcinã</I> (root filesystem) ca sã poatã continua cu celelalte.

<DT><A NAME="foot140">... minor</A><A NAME="foot140"
 HREF="3fs-html.html#tex2html5"><SUP>3</SUP></A>
<DD>Despre numerele majore ºi minore vedeþi articolul
citat anterior.

</DL>
<BR><HR>

</BODY>
</HTML>
