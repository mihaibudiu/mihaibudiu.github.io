<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Proiectul ``Ballista'' pentru testarea programelor</TITLE>
<META NAME="description" CONTENT="Proiectul ``Ballista'' pentru testarea programelor">
<META NAME="keywords" CONTENT="ballista-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>
<body>

<P>

<P>
<H1 ALIGN="CENTER">Proiectul ``Ballista'' pentru testarea programelor</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>octombrie 2000</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>o metodologie pentru testarea automatã a robusteþii
software-ului în prezenþa condiþiilor excepþionale
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare de programare
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>software engineering, excepþii, robusteþe,
testare, Ballista, POSIX, Win32
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html33"
  HREF="ballista-html.html">Robusteþea programelor</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION00030000000000000000">Interfeþe, modularitate ºi paranoia</A>
<LI><A NAME="tex2html35"
  HREF="#SECTION00040000000000000000">Metodologia de testare Ballista</A>
<UL>
<LI><A NAME="tex2html36"
  HREF="#SECTION00041000000000000000">Tipuri de eºecuri</A>
<LI><A NAME="tex2html37"
  HREF="#SECTION00042000000000000000">Cazuri de test derivate din tipuri de date</A>
<LI><A NAME="tex2html38"
  HREF="#SECTION00043000000000000000">Detecþia erorilor prin votare</A>
</UL>
<BR>
<LI><A NAME="tex2html39"
  HREF="#SECTION00050000000000000000">Rezultate</A>
<UL>
<LI><A NAME="tex2html40"
  HREF="#SECTION00051000000000000000">POSIX</A>
<LI><A NAME="tex2html41"
  HREF="#SECTION00052000000000000000">Win32</A>
</UL>
<BR>
<LI><A NAME="tex2html42"
  HREF="#SECTION00060000000000000000">Creºterea robusteþii prin împachetare</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION00070000000000000000">Limitãri ale metodologiei Ballista</A>
<LI><A NAME="tex2html44"
  HREF="#SECTION00080000000000000000">Concluzii</A>
<LI><A NAME="tex2html45"
  HREF="#SECTION00090000000000000000">Alte surse de informaþie</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>

<H1><A NAME="SECTION00020000000000000000">
Robusteþea programelor</A>
</H1>

<P>
Anul 2000 a fost aºteptat cu înfricoºare de o mulþime de oameni;
de data asta însã spaimele milenariste au avut o aromã
tehnologicã: mai ales societatea industrializatã era foarte
temãtoare în faþa ravagiilor pe care bug-ul Y2K le va aduce.
Miezul nopþii a trecut însã fãrã mare tamtam, ºi toate temerile
de dinainte ni se par acum ridicole.

<P>
Adevãrul este însã cã, din ce în ce mai mult, viaþa noastrã de
zi cu zi depinde de calculatoare.  Chiar dacã nu vor fi toate
vulnerabile dintr-o datã unui virus, malfuncþia multora dintre ele
poate afecta în mod dramatic existenþa multora dintre noi, în
moduri nebãnuite.  Reþeaua telefonicã digitalã, reþelele de
televiziune digitalã, Internet-ul sunt reþele de calculatoare;
reþeaua de distribuþie a energiei electrice, controlul de trafic
aerian, armata, ºi cine ºtie cîte alte pãrþi ale infrastructurii
unei þãri depind din ce în ce mai mult de calculatoare
interconectate.

<P>
Oricare dintre dumneavoastrã care a scris un program de dimensiuni
chiar modeste apreciazã dificultatea de a face un program sã
funcþioneze corect în orice circumstanþe.  Nici experienþa, nici
sculele, nici managementul nu pot produce la ora actualã programe
fãrã defecte; singurul lucru la care putem spera este sã avem cît
mai puþine defecte, care sã fie cît mai insignifiante ºi care sã
se manifeste cît mai rar.  De fapt calitatea unui program este direct
proporþionalã cu vechimea sa ºi cu frecvenþa de execuþie: cu cît
a fost executat de mai multe ori cu date de intrare diferite, cu atît
ºansele ca eventualele bug-uri sã se fi manifestat sunt mai mari.
Cele mai insidioase defecte rãmîn deci în fragmentele de program
rar executate, cum ar fi pe bucãþile de cod care se executã numai
în mod excepþional.

<P>
Acest articol va prezenta o metodologie de testare automatã a unor
programe, încercînd sã le supunã unor torturi care sã le oblige
sã execute cazuri excepþionale.  Ideile folosite sunt foarte simple
ºi naturale; aproape cã fiecare din noi ar putea zice: ``ºi eu
puteam face aºa ceva''.  Dar cu toatã simplitatea metodei,
rezultatele aplicãrii ei sunt deosebit de interesante ºi totodatã
îngrijorãtoare: practic nici unul dintre sistemele testate,
provenind de la mai mult de 10 fabricanþi diferiþi, nu a exhibat o
robusteþe foarte bunã.  Ca sã vã þin treaz interesul, voi amîna
discuþia rezultatelor calitative pentru o secþiune ulterioarã.

<P>
Grupul de cercetare care a dezvoltat aceastã metodologie este condus
de profesorul Philip Koopman în cadrul Grupului de sisteme software
complexe din Departamentului de inginerie electricã ºi calculatoare
al Universitãþii Carnegie Mellon.  Numele proiectului este
``Ballista'', care înseamnã în englezã acelaºi lucru ca ºi în
românã (mai puþin litera L dublatã): catapultã.  Numele vine din
faptul cã sistemul de testat este ``bombardat'' cu ``proiectile'' în
intenþia de a-i gãsi defecþiuni.  Acest gen de testare se mai
numeºte ``injecþie de defecte'' (fault injection).  Proiectul
Ballista (îl voi scrie în continuare cu numele englezesc) încearcã
sã cuantifice <EM>robusteþea</EM> unui sistem într-un mod concret,
pentru a face posibilã compararea unor sisteme diferite care oferã
aceeaºi funcþionalitate.  ``Robusteþea'' este definitã ca fiind
``gradul în care un sistem (software) funcþioneazã corect în
prezenþa unor date excepþionale sau a unui mediu stresant''.

<P>

<H1><A NAME="SECTION00030000000000000000">
Interfeþe, modularitate ºi paranoia</A>
</H1>

<P>
Vom vedea spre final cã proiectul Ballista are foarte multe
limitãri, dar cu toate acestea utilitatea lui este de necontestat.
Ballista poate fi utilizat pentru a testa implementarea <EM>modulelor</EM> software.  Modulele software sunt programe (sau biblioteci
de funcþii) care oferã servicii altor programe prin interfeþe bine
definite.

<P>
Ballista a fost aplicat cu succes pentru a testa urmãtoarele
componente software: sisteme de operare din familia Unix, sisteme de
operare din familia Windows, componente ORB din arhitecturi CORBA,
ºi biblioteca C standard.  În total au fost examinate 15 versiuni
majore de Unix, 6 versiuni de Windows ºi 9 implementãri ale
componentei ORB (Object Request Broker) din CORBA.

<P>
Toate aceste componente au cîteva trãsãturi comune: toate oferã
funcþionalitate altor programe.  Toate vor fi folosite de programe
dezvoltate de alte persoane decît cele care au scris modulele.  Toate
aceste module trebuie sã ofere servicii mai multor programe diferite
simultan (mai puþin biblioteca C standard, care de obicei este
copiatã într-un exemplar diferit pentru fiecare program care-i
foloseºte funcþiile).  Aceste module nu au ``încredere'' în
programul care le cere serviciile; mai ales sistemele de operare ºi
ORB-ul, pentru cã oferã servicii mai multor programe-clienþi
simultan, nu trebuie sã permitã nici unuia dintre ei sã fure
resurse sau sã compromitã funcþionarea întregului sistem în
detrimentul altor clienþi.

<P>
Neîncrederea nucleului sistemului de operare (SO) în cererile
programelor care se executã (procesele) trebuie sã fie apropiatã de
paranoia: SO este un program care se executã cu foarte multe
privilegii, ºi care poate scrie oriunde pe disc, trimite orice
pachete în reþea, ºi poate face alte astfel acþiuni cu potenþial
distructiv.  Dacã un proces încearcã sã pãcãleascã SO pentru a
face acþiuni la care nu are dreptul, SO trebuie sã refuze execuþia
cererii.  SO este singurul care gestioneazã resursele partajate
între toate procesele în execuþie; acestea trebuie sã cearã orice
acces la resurse prin intermediul unor <EM>apeluri de
sistem</EM><A NAME="tex2html3"
  HREF="#foot59"><SUP>1</SUP></A>.

<P>
De exemplu, pentru a deschide un fiºier, un proces în Unix trebuie
sã cheme urmãtorul apel de sistem: <TT>open(const char*
nume_fisier, int mod)</TT>.  <TT>open</TT> are douã argumente: numele unui
fiºier ºi modul în care fiºierul va fi accesat (citire, scriere,
etc.).  Dacã procesul trimite în loc de nume o adresã oarecare din
memorie (de exemplu un numãr negativ), ºi dacã nucleul nu verificã
faptul cã aceastã adresã este ilegalã, nucleul ar putea citi zone
de memorie care nu existã, ceea ce ar putea duce la cãderea
nucleului ºi deci a întregii maºini.

<P>
Codul fiecãrui apel de sistem începe deci prin a face teste
amãnunþite asupra argumentelor, verificînd dacã valorile lor sunt
corecte ºi au sens.  Dupã aceea, SO copiazã unele din argumente în
interiorul nucleului pentru procesare, dupã care verificã
privilegiile procesului (adicã dacã procesul are dreptul de a face
operaþia cerutã), ºi abia la sfîrºit, dacã toate preliminariile
au mers bine, executã operaþia cerutã ºi returneazã rezultatele.
Dacã argumentele sunt ilegale, SO trebuie sã semnaleze cumva acest
lucru procesului.  În sistemele de operare gen Unix de obicei apelul
de sistem returneazã un rezultat special (un numãr negativ), un cod
de eroare.  În sistemele de tip Windows, nucleul genereazã o
excepþie.

<P>

<H1><A NAME="SECTION00040000000000000000">
Metodologia de testare Ballista</A>
</H1>

<P>
Ballista foloseºte modulele pe care le testeazã ca pe niºte ``cutii
negre'' (black-box testing), adicã nu este interesatã de cum sunt
construite, ci doar de reacþia vizibilã dinafarã cînd primesc
felurite intrãri.  Ballista face un lucru foarte simplu: cere
serviciile modulului care este testat folosind la intrare valori care
nu au sens.  Ballista monitorizeazã apoi comportarea modulului ºi
rãspunsurile pe care acesta le dã.

<P>
Modulele bine scrise vor trebui sa raporteze erori (fie prin coduri de
eroare ca rezultat, fie prin excepþii).  Ballista verificã codul de
eroare ºi capteazã toate excepþiile.  Problemele mari însã apar
cînd modulele <EM>nu</EM> fac ceea ce ar trebui.

<P>
Pentru fiecare serviciu care este testat, Ballista genereazã cîteva
sute sau mii de combinaþii de parametri ilegali.  Balllista apoi
creazã un proces separat, care executã comanda pentru a cere
serviciul, folosind parametrii ilegali.  Dacã procesul care executã
testul se terminã, returneazã codul primit; dacã nu, dupã o vreme
procesul master trage concluzia cã cel de testare a murit.
Rezultatele fiecãrui test sunt înregistrate pe disc, pentru a
preveni pierderea lor în cazul unei catastrofe.

<P>
Ballista este folositã pentru a compara între ele sisteme care
implementeazã aceleaºi interfeþe.  De exemplu, toate sistemele de
tip Unix trebuie sã implementeze funcþiile descrise de standardul
POSIX<A NAME="tex2html4"
  HREF="#foot64"><SUP>2</SUP></A>.
Toate sistemele din familia Windows implementeazã interfaþa Win32.
Astfel putem compara erorile diferitelor sisteme cînd sunt folosite
pentru a executa aceleaºi funcþii.

<P>

<H2><A NAME="SECTION00041000000000000000">
Tipuri de eºecuri</A>
</H2>

<P>
Ballista foloseºte o clasificare a defecþiunilor într-una din cinci
categorii diferite; iniþialele acestor categorii în limba englezã
formeazã acronimul CRASH.

<P>
<DL>
<DT><STRONG>Catastrophic</STRONG></DT>
<DD>(catastrofe): sunt erorile care corup modulul
testat sau cauzeazã întregul sistem sã se blocheze complet sau sã
se reseteze.  Astfel de erori sunt foarte greu de detectat de un
program, mai ales dacã se executã pe chiar sistemul afectat.
Prezenþa unei astfel de erori este o eroare severã de proiectare a
sistemului.

<P>
</DD>
<DT><STRONG>Restart</STRONG></DT>
<DD>(repornire): aceste erori se petrec cînd serviciul
chemat nu returneazã vreodatã o valoare.  Calculatorul continuã sã
funcþioneze însã; doar serviciul cerut nu se terminã.  Astfel de
erori sunt detectate folosind un ceas de alarmã care dupã o vreme de
la cererea serviciului opreºte Ballista din aºteptare.

<P>
</DD>
<DT><STRONG>Abort</STRONG></DT>
<DD>(moarte): o astfel de eroare cauzeazã moartea procesului
care cere serviciul, în sisteme Unix de obicei cu un semnal SIGSEGV
sau SIGBUS iar în Windows cu o excepþie de gen Application Error.

<P>
</DD>
<DT><STRONG>Silent</STRONG></DT>
<DD>(silenþioase): astfel de erori constau în lipsa
raportãrii unei erori.  Deºi sistemul ar trebui sã raporteze o
eroare, el spune de fapt cã cererea a fost executatã cu succes.

<P>
</DD>
<DT><STRONG>Hindering</STRONG></DT>
<DD>(iritante): sunt cele în care sistemul raporteazã o
eroare, dar nu este cea ``realã''.  Aceste probleme sunt neplãcute,
pentru cã dacã cel care a cerut serviciul încearcã sã remedieze
eroarea, informaþia primitã de la modul nu-i va fi utilã pentru a
ghici cauza realã a problemei.  Proiectul Ballista <EM>nu</EM>
încearcã sã mãsoare astfel de eºecuri.

<P>
</DD>
<DT><STRONG>Corect</STRONG></DT>
<DD>adaug la scara anterioarã (CRASH) ºi comportarea
corectã: sistemul ar trebui sã returneze un cod de eroare sau o
excepþie care sã indice exact de ce serviciul cerut nu se poate
executa.
</DD>
</DL>

<P>

<H2><A NAME="SECTION00042000000000000000">
Cazuri de test derivate din tipuri de date</A>
</H2>

<P>
Dar cum ºtim care valori ale argumentelor unei funcþii sunt legale
ºi care ilegale?  Fiecare funcþie are tot felul de parametri
diferiþi, care codificã obiecte felurite.  De exemplu, unele
funcþii primesc pointeri spre buffere unde datele trebuie depozitate,
numere întregi care codificã dimensiunile datelor, numere întregi
care codificã descriptori de fiºiere deschise, numere ale proceselor
pentru a le livra semnale, ºi cîte ºi mai cîte.

<P>
Cea mai elegantã idee din Ballista este folositã pentru a rezolva
aceastã problemã: toate tipurile posibile sunt catalogate în
cîteva clase (20 de tipuri de date sunt suficiente pentru a testa
toate serviciile UNIX pe toate platformele folosite, ºi doar unul în
plus pentru a testa sistemele din familia Windows).

<P>
De exemplu, pentru a testa apelul de sistem Unix, care scrie într-un
fiºier, trebuie sã oferim trei argumente: <TT>write(int fisier,
const void* date, size_t marime_date)</TT>.

<P>
Deºi primul argument este un numãr întreg, de fapt acest numãr
codificã un descriptor de fiºier.  Ballista are o listã cu valori
excepþionale pentru un descriptor de fiºier; iatã un fragment
tipic:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Argument</TD>
<TD ALIGN="LEFT">Semnificaþie</TD>
</TR>
<TR><TD ALIGN="LEFT">FD_CLOSED</TD>
<TD ALIGN="LEFT">Fiºier care a fost închis</TD>
</TR>
<TR><TD ALIGN="LEFT">FD_OPEN_READ</TD>
<TD ALIGN="LEFT">Fiºier deschis doar pentru citire</TD>
</TR>
<TR><TD ALIGN="LEFT">FD_DELETED</TD>
<TD ALIGN="LEFT">Fiºier care a fost ºters între timp</TD>
</TR>
<TR><TD ALIGN="LEFT">FD_NOEXIST</TD>
<TD ALIGN="LEFT">Un fiºier inexistent</TD>
</TR>
<TR><TD ALIGN="LEFT">FD_EMPTY</TD>
<TD ALIGN="LEFT">Fiºier gol</TD>
</TR>
<TR><TD ALIGN="LEFT">FD_PAST_END</TD>
<TD ALIGN="LEFT">Fiºier la care cursorul poziþiei curente este dupã sfîrºit</TD>
</TR>
<TR><TD ALIGN="LEFT">FD_TERM</TD>
<TD ALIGN="LEFT">Fiºier care este un terminal</TD>
</TR>
<TR><TD ALIGN="LEFT">FD_MAXINT</TD>
<TD ALIGN="LEFT">Cel mai mare numãr întreg</TD>
</TR>
<TR><TD ALIGN="LEFT">FD_NEG_ONE</TD>
<TD ALIGN="LEFT">Minus unu</TD>
</TR>
<TR><TD ALIGN="LEFT">etc.</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
</TABLE>
</DIV>

<P>
Pentru a testa funcþia <TT>write</TT>, Ballista genereazã cele trei
argumente luînd o valoare pentru fiecare din tabela corespunzãtoare.
Dacã numãrul total de combinaþii este relativ mic, toate cele
posibile sunt încercate.  Altfel, 5000 de combinaþii posibile sunt
generate aleator.

<P>
În Windows cele mai multe apeluri de sistem au mai mult de patru
argumente, deci numãrul de combinaþii este aproape întotdeauna prea
mare.

<P>
Pentru testarea CORBA, tipurile de argumente sunt organizate într-o
ierarhie de tipuri.  De exemplu, tipul ``numãr întreg'' este un
subtip al lui ``caracter''.  Astfel tipul ``numãr întreg''
moºteneºte automat toate testele aplicate tipul caracter.

<P>
Aceste tabele sunt construite manual de cãtre cei care au implementat
sistemul, folosind valori-limitã ºi experienþa personalã.

<P>
Dar cum generãm o valoare ca <TT>FD_CLOSED</TT>, care codificã un
fiºier închis?  Fiecare valoare are asociate douã proceduri: o
procedurã care construieºte valoarea ºi una care o distruge.
Structura unui test Ballista este deci urmãtoarea:

<P>

<P>
<PRE>
test()
{
        initializari();
        valori = alege_valori_parametri();
        parametri = genereaza_parametri(valori);
        eroare = creaza_subproces(executa_test, parametri);
        exceptie = capteaza_exceptii();
        analizeaza_eroare(eroare, exceptie);
        curata(valori);
}
</PRE>

<P>
De exemplu, pentru a genera un parametru cu valoarea <TT>FD_CLOSED</TT>,
care reprezintã un fiºier închis, se va invoca o procedurã care va
crea un fiºier, îl va deschide, îl va închide ºi va da ca
rezultat identificatorul obþinut la deschiderea fiºierului.

<P>
Dupã ce testul este terminat trebuie fãcutã ``curãþenie'': de
exemplu trebuie sã ºtergem fiºierul care a fost creat pentru a
genera <TT>FD_CLOSED</TT>.

<P>

<H2><A NAME="SECTION00043000000000000000">
Detecþia erorilor prin votare</A>
</H2>

<P>
Dacã luãm toate combinaþiile de valori posibile pentru argumente,
atunci unele dintre ele vor fi plauzibile (adicã nu vor genera o
eroare); combinaþiile astea nu ne intereseazã, pentru cã nu
streseazã de fapt sistemul testat.  Dar de unde ºtim care
combinaþii sunt legale ºi care ilegale?  E imposibil sã anotãm de
mînã fiecare combinaþie, pentru a le identifica pe cele legale.

<P>
Pentru a rezolva aceastã dilemã ne folosim de faptul cã supunem
testului mai multe sisteme ``echivalente'', care oferã aceeaºi
funcþionalitate.  Dacã nici unul dintre diferitele sisteme pe care
le testãm nu genereazã vreo eroare pentru o anumitã combinaþie,
declarãm acea combinaþie ca fiind corectã.

<P>
O altã problemã este: cum putem detecta erorile ``silenþioase'',
care raporteazã OK cînd de fapt a apãrut o problemã?  O altã
euristicã este folositã aici: presupunem cã dacã cel puþin unul
dintre sisteme raporteazã o eroare, atunci combinaþia de argumente
este ilegalã, ºi celelalte sisteme eºueazã în mod silenþios.

<P>
Din pãcate aceastã din urmã metodã s-a dovedit incorectã atunci
cînd unele din aceste cazuri au fost examinate manual.  Cam 20% din
erorile clasificate ca ``silenþioase'' erau cauzate de malfuncþia
unuia dintre sisteme la o combinaþie corectã!  De exemplu, sistemul
de operare QNX nu permite fiºiere al cãror nume conþine spaþii,
deci toate funcþiile care încercau sã opereze cu astfel de fiºiere
eºuau, deºi standardul POSIX afirmã cã acestea sunt perfect
legale.  O asfel de situaþie duce la clasificarea (în mod eronat) a
acestei combinaþii ca fiind o eroare silenþioasã la toate celelalte
sisteme, care nu vor raporta o eroare pentru cã funcþioneazã
corect.

<P>
Erorile ``iritante'' (hindering) sunt foarte greu de clasificat, mai
ales pentru cã standardele nu specificã clar ce eroare trebuie
returnatã în fiecare caz.  De exemplu, dacã douã argumente sunt
eronate, care din erori trebuie raportatã?  Un alt exemplu este cînd
încercãm sã scriem 0 octeþi într-un fiºier inexistent: dacã
testul de lungime este fãcut întîi, funcþia va returna succes,
pentru cã a scris într-adevãr 0 octeþi.  Dar dacã întîi se
descoperã cã fiºierul este inexistent, funcþia ar putea returna o
eroare.  Standardul nu specificã comportarea corectã pentru astfel
de cazuri.

<P>

<H1><A NAME="SECTION00050000000000000000">
Rezultate</A>
</H1>

<P>
În fine, ajungem la secþiunea cea mai suculentã: cît de bune sunt
feluritele sisteme de operare?  Care e mai rezilient?  Sunt sistemele
folosite în aplicaþii importante mai robuste?

<P>
Rãspunsurile sunt extrem de surprinzãtoare: deºi robusteþea
variazã de la sistem la sistem, nu existã nici unul foarte bun, ºi
cam toate sunt la fel de vulnerabile.  Iatã rezultatele concrete
pentru fiecare familie de sisteme testate.

<P>

<H2><A NAME="SECTION00051000000000000000">
POSIX</A>
</H2>

<P>
Testul sistemelor Unix verificã 233 de funcþii specificate de
standardul POSIX (Portable Operating System unIX).  Au fost testate 15
sisteme de operare din familia Unix.  

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="posix"></A><A NAME="180"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
Robusteþea sistemelor POSIX: rata de eroare
normalizatã pentru 233 de apeluri de sistem.  Numai erorile
catastrofale, abort ºi restart sunt contabilizate.</CAPTION>
<TR><TD><IMG
 WIDTH="537" HEIGHT="330" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{posix.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Figura&nbsp;<A HREF="ballista-html.html#posix">1</A> ilustreazã <EM>rata de eroare normalizatã</EM>
pentru 15 sisteme de operare comerciale din familia Unix, unele fiind
versiuni diferite ale aceluiaºi sistem.  Fiecare valoare este
calculatã în felul urmãtor: se numãrã toate apelurile executate
cu cel puþin un parametru ilegal.  Apoi se numãrã cîte din acestea
au dus la: distrugerea sistemului (catastrofã), blocarea procesului
(restart) ºi la moartea procesului (abort).  Se face apoi raportul
dintre al doilea ºi primul numãr.  Rezultatul îl vedeþi în
figura&nbsp;<A HREF="ballista-html.html#posix">1</A>.  Cu cît barele sunt mai scurte, cu atît sistemul
e mai bun, adicã depisteazã mai multe erori în mod civilizat.

<P>
Tabela urmãtoare indicã fabricanþii fiecãruia dintre sisteme;
dupã cum vedeþi o grãmadã de lume bunã: cele mai respectabile
companii de software din lumea Unix sunt toate reprezentate.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"><B>Nume</B> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> </FONT><FONT SIZE="-1"><B>Fabricant</B> </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
AIX	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">	 IBM </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
FreeBSD	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">	 free (bazat pe Berkeley Software Distribution) </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
HP-UX	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">	 Hewlet Packard </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
Irix	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">	 Silicon Graphics </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
Linux	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">	 Linus Torvalds (free) </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
Lynx 	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">     Lynux Works </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
NetBSD	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">	 free (bazat pe Berkeley Software Distribution) </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
OSF/1	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">	 Digital (acum numit Compaq Tru64) </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
QNX	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">	 QNX Software Systems </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
SunOs	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">	 Sun </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
Solaris	   </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">	 Sun </FONT></TD>
</TR>
</TABLE></DIV>

<P>
Putem face imediat o mulþime de observaþii interesante:

<P>

<UL>
<LI>Nici un sistem nu e mai bun de 90%.  Cea mai mic'a bar'a are
10%, pentru AIX; la cel mai robust dintre sisteme, totu'si 10% din
apelurile eronate eºueazã.

<P>
</LI>
<LI>Toate numerele se situeazã între 10 ºi 23 de procente, deci
sunt comparabile ca mãrime.  Nici un sistem nu le dominã pe
celelalte ca fiind foarte bun sau foarte prost.

<P>
</LI>
<LI>Nu întotdeauna versiunea mai nouã a sistemului este mai bunã.
De exemplu versiunea mai nouã de HP-UX introduce o eroare
catastroficã ºi creºte numãrul de erori care cauzeazã moartea
procesului, ca ºi QNX.

<P>
</LI>
<LI>În tabelã avem douã sisteme de operare de timp real, care
sunt folosite pentru sisteme critice, ca controlul automobilelor,
avioanelor, cãilor ferate, etc.: QNX ºi Lynx.  QNX este de departe
cel mai prost dintre sisteme!  Acesta este un rezultat foarte straniu
ºi totodatã îngrijorãtor.  Pe de altã parte existã o explicaþie
pentru robusteþea redusã a acestui gen de sisteme: aplicaþiile care
se executã pe astfel de sisteme tind sã fie mai simple ºi scrise cu
mult mai mare grijã, aºa încît probabil evitã sã streseze
sistemul.  Din cauza asta o mulþime de bug-uri au rãmas
nedescoperite.

<P>
</LI>
<LI>Linux, chiar o versiune destul de veche, este printre cele mai
fiabile sisteme de operare dupã aceastã metricã.

<P>
</LI>
<LI>Sisteme profesionale, de mare calitate, pot fi complet scoase
din funcþiune de programe ale utilizatorilor fãrã nici un fel de
privilegii.  Iatã douã exemple de astfel de programe:

<P>

<UL>
<LI>Aceastã linie distruge Irix 6.2: <TT>munmap(malloc(1 &lt;&lt; 30 +
1), MAXINT);</TT>

<P>
</LI>
<LI>Aceastã linie distruge Digital OSF/1 versiunea 4.0D:
<TT>mprotect(malloc(1 &lt;&lt; 29 + 1), 65537, 0);</TT>
</LI>
</UL>

<P>
</LI>
<LI>Aceastã tabelã <EM>nu</EM> include eºecuri de tip silenþios sau
iritant.  Acest lucru este foarte important, pentru cã avantajeazã
de pildã sisteme ca AIX: cei care au implementat AIX au decis ca
citirea de la adresa 0 din memorie (pointer NULL) sã nu genereze nici
un fel de eroare, pentru a lãsa o ºansã programelor eronate sã
continue execuþia.  Sisteme ca FreeBSD sau Linux acþioneazã
dimpotrivã, anume omoarã procesul care încearcã sã facã astfel
de accese.  Cazul unui pointer 0 va genera o eroare silenþioasã în
cazul AIX ºi probabil o eroare de tip abort pentru FreeBSD.
</LI>
</UL>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="apel"></A><A NAME="188"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
Un apel de sistem trece întîi prin biblioteca
standard, care prelucreazã argumentele ºi abia apoi invocã apelul
de sistem propriu-zis al sistemului de operare.</CAPTION>
<TR><TD><IMG
 WIDTH="303" HEIGHT="109" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=7cm\epsffile{apel.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Dacã sunteþi familiar cu modul în care sunt implementate apelurile
de sistem, ºtiþi cã programele scrise de dumneavoastrã nu fac
direct astfel de apeluri (vedeþi ºi figura&nbsp;<A HREF="ballista-html.html#apel">2</A>).  Ele cheamã
niºte funcþii dintr-o bibliotecã ``standard'', care fac ele însele
tot felul de verificãri, împacheteazã argumentele apelului de
sistem ºi apoi executã apelul real.

<P>
Figura&nbsp;<A HREF="ballista-html.html#biblioteca">3</A> aratã care din erorile din figura&nbsp;<A HREF="ballista-html.html#posix">1</A>
pot fi atribuite bibliotecii standard ºi care sunt adevãrate
slãbiciuni ale sistemului de operare.  Observaþi cã la majoritatea
sistemelor cele mai multe slãbiciuni sunt de fapt în bibliotecã
(deci sistemul de operare este ceva mai robust decît pãrea);
excepþia notabilã este din nou QNX, la care cele douã bare sunt
aproximativ egale.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="biblioteca"></A><A NAME="194"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3:</STRONG>
Erori atribuibile bibliotecii C ºi
apelurilor de sistem (ratã de eroare normalizatã).</CAPTION>
<TR><TD><IMG
 WIDTH="538" HEIGHT="333" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{biblioteca.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
În fine, figura&nbsp;<A HREF="ballista-html.html#posix-functii">4</A> încearcã sã califice erorile
dupã tipul de operaþie executatã.  Rata de eºec este calculatã
separat pentru fiecare categorie de funcþii.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="posix-functii"></A><A NAME="200"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 4:</STRONG>
Erori dupã fiecare tip de apel de
sistem pentru sistemele POSIX.  (Barele care nu se vãd la ``ceasuri''
sunt foarte mici.)</CAPTION>
<TR><TD><IMG
 WIDTH="619" HEIGHT="507" BORDER="0"
 SRC="img4.png"
 ALT="\begin{figure}\centerline{\epsfxsize=14cm\epsffile{posix-functii.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
ªi aceastã figurã ne prilejuieºte niºte observaþii interesante:

<P>

<UL>
<LI>Cam toate sistemele au un procent asemãnãtor (ridicat) de
erori în biblioteca standard.

<P>
</LI>
<LI>QNX are, ca sistem de operare de timp-real, un procent
îngrijorãtor de mare de erori în funcþiile care opereazã cu
ceasuri.

<P>
</LI>
<LI>HP-UX 10 are 100% erori 'in func'tiile legate de managementul
memoriei; e vorba de un subsistem nou, complet reimplementat faþã de
HP-UX 9.05.
</LI>
</UL>

<P>
Figura&nbsp;<A HREF="ballista-html.html#silent">5</A> este construitã folosind metodele de ``votare''
descrise mai sus pentru:

<P>

<UL>
<LI>a elimina cazurile care nu sunt de fapt erori
</LI>
<LI>a clasifica erorile silenþioase
</LI>
</UL>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="silent"></A><A NAME="206"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura:</STRONG>
Folosind tehnica votãrii au fost eliminate
combinaþiile de parametri care nu constituie erori.  Apoi au fost
detectat erorile silenþioase, dupã cum explicãm în secþiunea
despre votare.  Pentru cã sunt mai puþine cazuri de bazã la care ne
raportãm, procentele de eroare sunt mai mari ca în
figura&nbsp;<A HREF="ballista-html.html#posix">1</A>.  În plus aici arãtãm erorile silenþioase, care
se adaugã la cele din acea figurã.</CAPTION>
<TR><TD><IMG
 WIDTH="538" HEIGHT="336" BORDER="0"
 SRC="img5.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{silent.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Acum avem o mºurã mai exactã a robusteþii fiecãrui sistem; vedem
cã AIX era într-adevãr avantajat de faptul cã transforma unele
erori de tip abort în erori silenþioase.  Cele mai bune sistem dupã
acest grafic sunt Solaris ºi Irix 6.2.

<P>

<H2><A NAME="SECTION00052000000000000000">
Win32</A>
</H2>

<P>
Sã trecem acum la datele privitoare la sistemele firmei Microsoft.
Se spune cã Windows este un sistem foarte puþin fiabil, care
``crapã'' regulat, ºi care trebuie rebootat zilnic pentru a rãmîne
``sãnãtos''.  Se mai spune apoi cã Windows NT ºi succesorul lui,
Windows 2000 sunt mult mai robuste.  De asemenea, lumea afirmã cã
Linux este mai fiabil.  În ce mãsurã vor confirma datele aceste
presupuneri?

<P>
În primul rînd, pentru a putea face o comparaþie relativ
echitabilã între Windows ºi Linux, au fost testate din interfaþa
Win32 numai o parte din funcþii, care au echivalente aproximative în
sistemele gen POSIX.  De pildã, nici una dintre funcþiile care
opereazã cu graficã nu face parte din acest test.  Au fost alese 237
de funcþii Win32, care sunt comparate cu 183 de apeluri de sistem
Linux.  Din cauzã cã erorile sunt raportate ca procente, diferenþa
de numãr nu e o problemã.

<P>
Iatã sistemele comparate:

<P>

<UL>
<LI>Windows 95 revizia B
</LI>
<LI>Windows 98 cu service pack 1
</LI>
<LI>Windows 98 ediþia a douã, service pack 1 (98/SE)
</LI>
<LI>Windows NT 4.0 Workstation service pack 5
</LI>
<LI>Windows 2000 Professional Beta 3 (Build 2031)
</LI>
<LI>Windows CE 2.11
</LI>
<LI>RedHat Linux 6.0 (nucleu 2.2.5, altã versiune decît în
testele POSIX).
</LI>
</UL>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="win-crash"></A><A NAME="213"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 6:</STRONG>
Funcþii cu erori catastrofice în Windows
ºi Linux.</CAPTION>
<TR><TD><IMG
 WIDTH="447" HEIGHT="276" BORDER="0"
 SRC="img6.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{win-crash.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
În figura&nbsp;<A HREF="ballista-html.html#win-crash">6</A> vedem numãrul de funcþii care apelate cu
argumente incorecte pot face sistemul sã eºueze în mod catastrofic.
Într-adevãr, Linux, NT ºi Windows 2000 nu pot fi paradite chiar
aºa de uºor, dar celelalte sisteme sunt mult mai vulnerabile.
Windows CE în particular este foarte vulnerabil.

<P>
Figura&nbsp;<A HREF="ballista-html.html#win-rata">7</A> aratã doar apelurile de sistem (excluzînd
biblioteca standard), pentru sistemele Windows ºi referinþa Linux.
Observaþi cã aproape întotdeauna Linux este mai robust decît toate
celelalte sisteme, cu excepþia managementului proceselor.
Surprinzãtor în aceastã figurã este cã NT ºi Windows 2000 au
printre cele mai proaste rezultate (cele mai proaste la 4 categorii).

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="win-rata"></A><A NAME="219"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 7:</STRONG>
Procente de eºecuri în apeluri de sistem
pentru sisteme Windows + Linux.</CAPTION>
<TR><TD><IMG
 WIDTH="543" HEIGHT="316" BORDER="0"
 SRC="img7.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{win-rata.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Dacã ne uitãm însã în figura&nbsp;<A HREF="ballista-html.html#win-biblioteca">8</A> la erorile
datorate doar bibliotecii standard, atunci Linux trece cam pe ultimul
loc.  Nu toate funcþiile de bibliotecã sunt implementate în Windows
CE, aºa cã X-uri în figurã indicã absenþa unei categorii, ºi nu
0 erori.  Nici de data aceasta NT sau Windows 2000 nu se detaºeazã
clar.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="win-biblioteca"></A><A NAME="225"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 8:</STRONG>
Procente de eºecuri generate de
biblioteca C standard.  Un ``x'' înseamnã cã acel sistem nu avea
astfel de funcþii, deci nu a fost testat.</CAPTION>
<TR><TD><IMG
 WIDTH="542" HEIGHT="284" BORDER="0"
 SRC="img8.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{win-biblioteca.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Ce înseamnã aceste numere?  Vom discuta despre limitãrile
mãsurãtorilor Ballista un pic mai jos, dar se cuvine menþionat cã
toate aceste mãsurãtori fac teste foarte simple.  Faptul cã Windows
NT nu are nici o eroare catastrofalã nu înseamnã cã nu se pot
întîlni astfel de erori, ci cã programe de cîteva linii nu au
gãsit niciuna.

<P>

<H4><A NAME="SECTION00052010000000000000">
CORBA:</A>
</H4> Din cauzã cã articolul de faþã este deja cam
dens, voi sãri peste mãsurãtorile sistemelor CORBA.  Demn de spus
este cã sunt comparabile în calitate cu sistemele de operare
prezentate mai sus.

<P>

<H1><A NAME="SECTION00060000000000000000">
Creºterea robusteþii prin împachetare</A>
</H1>

<P>
Defecþiunile gãsite sugereazã ºi o soluþie practicã:
implementarea unor funcþii care împacheteazã pe cele defecte
(wrappers), care sunt scrise cu grijã ºi testeazã toate argumentele
înainte de a chema funcþia realã.

<P>
Pentru sistemele CORBA a fost chiar elaboratã o metodologie
semi-automatã de protecþie împotriva erorilor: înainte de a
trimite o cerere la distanþã, creazã un nou fir de execuþie
(thread) care trimite cererea.  Dacã firul de execuþie moare sau se
blocheazã, programul principal foloseºte o alarmã pentru a continua
execuþia ºi pentru a raporta o eroare.  În felul acesta, erori de
implementare în biblioteci sau în modulul chemat nu afecteazã
clientul, care-ºi poate continua execuþia.

<P>

<H1><A NAME="SECTION00070000000000000000">
Limitãri ale metodologiei Ballista</A>
</H1>

<P>
Am vãzut cã, deºi bazatã pe o idee foarte simplã, Ballista este
surprinzãtor de eficace în a dezgropa o sumedenie de erori în
sisteme care sunt extrem de folosite în viaþa de zi cu zi.  Dacã
reparãm defecþiunile descoperite de Ballista am rezolvat problema
corectitudinii programelor?

<P>
Nu, deloc.  Ballista descoperã numai cele mai simple dintre erori,
care sunt cauzate de programe foarte mici.  Ballista este
neputincioasã în a gãsi de pildã erori cauzate de încãrcarea
mare a sistemului (cînd multã memorie este ocupatã sau cînd o
mulþime de programe aºteaptã o felie de timp a procesorului).

<P>
Ballista nu gãseºte erori care depind de <EM>starea internã</EM> a
sistemului.  De pildã, dacã un program nu dealocã memoria pe care
nu o mai foloseºte, spunem cã are <EM>scurgeri de memorie</EM> (memory
leaks).  Scurgerile de memorie nu influenþeazã corectitudinea
comportãrii programului, dar dacã programul se executã pentru mult
timp, acapareazã prea multã memorie pentru sine, ceea ce împiedicã
execuþia celorlalte programe.  În momentul în care memoria
disponibilã este epuizatã se pot produce accidente.  Astfel de
erori ar fi captate prin repetarea comenzii care cauzeazã scurgeri,
dar Ballista executã fiecare comandã doar o datã cu un set de
parametri.

<P>
De asemenea, Ballista nu gãseºte erori care survin din
interacþiunea a multiple componente: fiecare test evalueazã o
singurã funcþie din interfaþã.  Dacã apelul a mai multe funcþii
într-o anumitã ordine ar putea duce la blocare (deadlock), Ballista
nu va gãsi acest gen de defecþiune.

<P>
În fine, cea mai mare limitare a lui Ballista provine din faptul cã
testeazã sistemele ca pe niºte cutii negre: nu ºtie de fapt care ar
trebui sã fie rãspunsul corect.  Ballista se uitã doar la
condiþiile care trebuie sã genereze erori, dar este complet
neinteresatã de modul în care programul funcþioneazã cînd poate
sã-ºi facã treaba.

<P>

<H1><A NAME="SECTION00080000000000000000">
Concluzii</A>
</H1>

<P>
Chiar dacã am încheiat cu o listã a limitãrilor acestui proiect,
nu trebuie sã-i neglijãm meritele: am vãzut în acest articol o
metodologie foarte simplã de a testa robusteþea sistemelor în faþa
condiþiilor excepþionale.  Atunci cînd testeazã sisteme care
implementeazã funcþionalitãþi asemãnãtoare, Ballista poate fi
folositã pentru a compara cantitativ mai multe sisteme distincte,
folosind rata normalizatã de eºec.

<P>
Pentru cã orice sistem de operare trebuie sã ofere anumite funcþii
elementare, Ballista poate fi folositã chiar pentru a pune faþã-n
faþã sisteme atît de diferite ca Windows ºi Linux.

<P>
Poate cel mai important dintre mesajele acestui text este cã
software-ul este mereu plin de gãuri, ºi cã aparent este foarte
greu sã produci soft de o calitate foarte ridicatã: toate sistemele
testate, de la mai mult de 10 fabricanþi diferiþi, sunt aproximativ
la fel de puþin robuste.

<P>

<H1><A NAME="SECTION00090000000000000000">
Alte surse de informaþie</A>
</H1>

<P>
Pagina de web a proiectului Ballista este foarte bine asortatã:
<TT><A NAME="tex2html13"
  HREF="http://www.ece.cmu.edu/ballista">http://www.ece.cmu.edu/ballista</A></TT>.  Graficele ºi informaþiile au
fost extrase din articole ºi prezentãri din aceastã paginã.

<P>
În jurul lunii decembrie proiectul Ballista va face disponibil pe web
un sistem de test automat, prin care puteþi genera cod pentru testare
de la distanþã; adresa este <TT><A NAME="tex2html14"
  HREF="http://ballista.ece.cmu.edu/test/">http://ballista.ece.cmu.edu/test/</A></TT>.

<P>
Proiectul ``Fuzz'' de la universitatea Wisconsin a aplicat teste
asemãnãtoare unor utilitare Unix.  Douã rapoarte ale lor sunt
disponibile de la
<TT><A NAME="tex2html15"
  HREF="ftp://grilled.cs.wisc.edu/technical_papers/fuzz.ps.Z">ftp://grilled.cs.wisc.edu/technical_papers/fuzz.ps.Z</A></TT> ºi
<TT><A NAME="tex2html16"
  HREF="ftp://grilled.cs.wisc.edu/technical_papers/fuzz-revisited.ps.Z">ftp://grilled.cs.wisc.edu/technical_papers/fuzz-revisited.ps.Z</A></TT>.
Acestea aratã cã programele dezvoltate open-source sunt în general
mai robuste decît cele comerciale.

<P>
Proiectul ``CRASHME'' încearcã sã ``buºeascã'' un sistem de
operare generînd cod la întîmplare (folosind numere aleatoare) ºi
punînd sistemul sã-l execute:
<TT><A NAME="tex2html17"
  HREF="http://people.delphi.com/gjc/crashme.html">http://people.delphi.com/gjc/crashme.html</A></TT>
<P>
<BR><HR><H4>Note</H4>
<DL>
<DT><A NAME="foot59">...  sistem</EM></A><A NAME="foot59"
HREF="ballista-html.html#tex2html3"><SUP>1</SUP></A> <DD>Despre rolul
nucleului unui sistem de operare, modul în care funcþioneazã, ºi ce
sunt apelurile de sistem ºi vedeþi ºi <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#nucleu">articolul</a>
meu din PC Report din decembrie 1996, disponibil din pagina mea de
web.

<DT><A NAME="foot64">...  POSIX</A><A NAME="foot64"
HREF="ballista-html.html#tex2html4"><SUP>2</SUP></A> <DD>Vedeþi ºi <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#unix-2">articolul</a>
meu despre istoria sistemului de operare UNIX din BYTE din august
1996.

</DL>
<BR><HR>

</BODY>
</HTML>
