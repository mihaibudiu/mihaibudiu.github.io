<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Poduri (bridges)</TITLE>
<META NAME="description" CONTENT="Poduri (bridges)">
<META NAME="keywords" CONTENT="bridge-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>
<body>


<P>

<P>
<H1 ALIGN="CENTER">Poduri (bridges)</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><a
href="http://www.cs.cmu.edu/~mihaib">http://www.cs.cmu.edu/~mihaib</a></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>15 ianuarie 1999</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>algoritmii folosiþi de bridge-urile transparente
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare despre
funcþionarea calculatoarelor
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>bridge, adresã, reþea, interfaþã, arbore de
acoperire, algoritm distribuit
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html22"
  HREF="bridge-html.html">Reþele locale</A>
<UL>
<LI><A NAME="tex2html23"
  HREF="#SECTION00021000000000000000">Adrese la nivel de legãturã</A>
</UL>
<BR>
<LI><A NAME="tex2html24"
  HREF="#SECTION00030000000000000000">Interconexiuni: repetoare ºi poduri</A>
<UL>
<LI><A NAME="tex2html25"
  HREF="#SECTION00031000000000000000">Poduri multi-protocol</A>
</UL>
<BR>
<LI><A NAME="tex2html26"
  HREF="#SECTION00040000000000000000">Podurile transparente</A>
<UL>
<LI><A NAME="tex2html27"
  HREF="#SECTION00041000000000000000">Algoritmul de învãþare</A>
</UL>
<BR>
<LI><A NAME="tex2html28"
  HREF="#SECTION00050000000000000000">Buclele în topologie</A>
<LI><A NAME="tex2html29"
  HREF="#SECTION00060000000000000000">Arborele de acoperire</A>
<UL>
<LI><A NAME="tex2html30"
  HREF="#SECTION00061000000000000000">Algoritmul de votare</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION00062000000000000000">Un exemplu numeric</A>
</UL>
<BR>
<LI><A NAME="tex2html32"
  HREF="#SECTION00070000000000000000">Rafinamente</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION00080000000000000000">Concluzii</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Tehnologiile noi se insinueazã încetul cu încetul în existenþa
oamenilor, schimbînd pînã la urmã radical stilul lor de viaþã.
În prima fazã, o tehnologie revoluþionarã nu face decît sã
înlocuiascã tehnologii mai vechi, a cãror funcþiune o poate
îndeplini mai bine.  Dar, cu timpul, îºi asumã tot felul de
sarcini inexistente anterior, transformînd societatea în mod
fundamental.  Aºa s-au petrecut lucrurile, de pildã, cu curentul
electric: la început acesta a preluat funcþiile iluminatului cu gaz,
pentru cã era mai ieftin ºi mai sigur.  Dar încetul cu încetul
i-au fost gãsite mii de aplicaþii; societatea modernã de astãzi nu
mai este de conceput fãrã existenþa sa: electricitatea a devenit o
parte din infrastructurã.

<P>
O revoluþie asemãnãtoare este în curs de desfãºurare:
Internetul, reþeaua mondialã, este noua tehnologie care va schimba
faþa lumii; începuturile sale comerciale sunt cu numai cinci ani în
urmã, ºi evoluþia sa se aflã încã în prima fazã, de
``îmbunãtãþire'' a serviciilor existente.  Maturizarea sa este
rapidã, ºi în viitor ne aºteaptã mutaþii neaºteptate.

<P>
Internetul este, aºa cum aratã ºi numele sãu, ``inter-net'', o
<EM>colecþie de reþele</EM>, o super-reþea, care leagã laolaltã o
sumedenie de reþele mici.  Atenþia articolului de faþã se va
îndrepta spre una din cãrãmizile constitutive ale Internet-ului,
cea mai importantã (din punct de vedere cantitativ): reþeaua
localã.

<P>

<H1><A NAME="SECTION00020000000000000000">
Reþele locale</A>
</H1>

<P>
În 1973 Robert Metcalfe, de la centrul de cercetare PARC (Palo Alto
Research Center) al companiei Xerox, împreunã cu alþi cercetãtori,
punea la punct un tip de reþea extrem de ieftin ºi eficace, numit
Ethernet.  Ethernetul permitea conectarea mai multor calculatoare
printr-un singur cablu coaxial, asemãnãtor cu cele folosite în
televiziunea pe cablu; viteza de transmisiune iniþialã era de pînã
la 4 megabiþi pe secundã (adicã în jur de jumãtate de megaoctet
pe secundã).

<P>
Pentru a comercializa Ethernetul, Xerox a format apoi împreunã cu
Intel ºi Digital o nouã companie, condusã de Metcalfe, care a
devenit apoi independentã sub numele ``3 companii'', sau 3Com.  3Com
este la ora actualã, dupã Cisco, cea mai mare companie de
echipamente de reþele din lume, cu venituri anuale de 6 miliarde de
dolari.

<P>
Tipul de reþea inventat de Xerox a fost standardizat de IEEE sub
sugestivul nume de 802.3; deºi reþeaua 802.3 este oarecum diferitã
de Ethernet, numele încetãþenit pentru aceste reþele este tot
Ethernet.  Ethernet-ul a fost apoi perfecþionat pentru a merge la
viteze de pînã la 10Mbps.  La începutul anilor '90 au apãrut
variantele fast-Ethernet, de 100Mbps, iar acum este în proces de
standardizare varianta Gigabit-Ethernet, care merge la 1000Mbps!
Ethernet-ul este de departe cea mai popularã reþea din lume, ca
numãr de instalãri.  Ethernet-ul este ceea ce se numeºte o ``reþea
localã'' (LAN: Local Area Network).  Motivul principal este cã poate
conecta calculatoare pe o distanþã relativ restrînsã (lungimea
unui cablu este limitatã din motive de duratã a propagãrii
semnalului electromagnetic la 500m).

<P>
La începutul anilor '80, General Motors ºi Boeing erau
nesatisfãcute de anumite proprietãþi ale reþelei Ethernet (ºi
anume de faptul cã Ethernet nu garanteazã cît de mult timp trece
pînã cînd un calculator poate transmite un pachet), aºa cã au
investit pentru dezvoltarea unor tipuri alternative de reþele locale.
Comitetul IEEE 802, care a standardizat Ethernet, s-a ocupat ºi de
aceste noi tipuri de reþele.  Reþelele rezultate sunt 802.4, sau
``token bus'' ºi 802.5, sau ``token ring''<A NAME="tex2html1"
  HREF="#foot53"><SUP>1</SUP></A>.  Token bus foloseºte
tot un cablu coaxial, însã ordinea accesului calculatoarelor
(staþiilor) la cablu este riguros stabilitã; în acest fel fiecare
calculator ºtie cã dupã un anumit timp va avea posibilitatea sã
trimitã ce are de trimis.  Token ring conecteazã calculatoarele
într-un inel fizic, fiecare calculator cu doi vecini; datele curg
apoi de-a lungul inelului într-o singurã direcþie.  Cele trei
tipuri fundamentale de reþele locale sunt ilustrate în
figura&nbsp;<A HREF="bridge-html.html#lan">1</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="lan"></A><A NAME="157"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Cele trei tipuri de reþele locale.  Token bus ºi
Ethernet au acelaºi tip de cablu, dar diferã prin ordinea de
transmisiune, care este precis determinatã pentru un token bus, dar
este ``primul care apucã'' pentru un Ethernet.</CAPTION>
<TR><TD><IMG
 WIDTH="633" HEIGHT="191" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=14cm\epsffile{lan.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
În acest articol ne intereseazã mai puþin natura fizicã a
reþelelor ºi mai mult conceptele care stau la baza utilizãrii lor.
În unele privinþe toate reþelele standardului 802 se aseamãnã, de
aceea anumite pãrþi ale standardului sunt comune tuturor tipurilor;
de pildã 802.1 stabileºte regulile de adresare pe toate aceste
reþele.

<P>

<H2><A NAME="SECTION00021000000000000000">
Adrese la nivel de legãturã</A>
</H2>

<P>
De fiecare datã cînd într-o conversaþie sunt implicate mai mult de
douã persoane, este necesar sã se foloseascã niºte metode pentru a
identifica fiecare participant.  Fiecare participant trebuie sã aibã
un nume<A NAME="tex2html3"
  HREF="#foot60"><SUP>2</SUP></A>.

<P>
În terminologia reþelelor de calculatoare numele unui participant se
numeºte <EM>adresã</EM>.  În reþelele locale 802 adresele sunt numere
de 48 de biþi (6 octeþi).  Metoda standard de scriere a unei adrese
foloseºte ºase numere scrise în hexazecimal, separate de liniuþe.
Aceasta este, de pildã, o adresã validã: 8-0-20-c0-ff-ee.  IEEE are
grijã ca în lume sã nu existe douã calculatoare cu aceeaºi
adresã.  Acest lucru se face atribuind fiecãrui fabricant un anumit
spaþiu de adrese (descris de primii 3 octeþi), fabricanþii apoi
promit ca fiecare ``placã'' fabricatã sã aibã o altã adresã.

<P>
Unicitatea adreselor, ºi faptul cã sunt suficient de multe, face
operarea ºi administrarea reþelelor locale o treabã relativ
simplã; în cele mai multe cazuri instalarea unui calculator într-o
reþea localã este ``plug-and-play'': nimic nu trebuie configurat de
cãtre un administrator uman pentru a-l face sã comunice cu
celelalte<A NAME="tex2html4"
  HREF="#foot62"><SUP>3</SUP></A>.

<P>
Cînd un calculator vrea sã trimitã date altui calculator, atunci
pune pe reþea un pacheþel; în pacheþel se aflã, în afarã de
date, ºi informaþii despre:

<P>

<UL>
<LI>Adresa destinaþie a datelor;
</LI>
<LI>Adresa sursã de unde au plecat datele;
</LI>
<LI>Informaþii despre cine este de aºteptat sã consume datele la
destinaþie (numãrul protocolului).  Asta pentru cã pe un calculator
se pot executa simultan mai multe programe de comunicaþii în reþea;
numãrul protocolului indicã cãruia anume îi sunt destinate datele.
</LI>
</UL>

<P>
Anumite adrese sunt rezervate pentru a indica grupuri de calculatoare
(adrese <EM>multicast</EM>) sau ``toate calculatoarele de pe reþeaua
localã'' (<EM>broadcast</EM>, difuzare).  Un calculator poate fi
instruit sã asculte unele adrese de tip multicast; în acest fel o
informaþie poate fi transmisã cu un singur pachet de la o sursã la
mai multe destinaþii.

<P>
Transmisiunile de tip multicast sunt utile într-o multitudine de
circumstanþe:

<P>

<UL>
<LI>Pentru transmisiuni de tip teleconferinþã în care participã
mai multe calculatoare;

<P>
</LI>
<LI>Pentru a descoperi cine oferã anumite servicii.  De pildã
atunci cînd este pornit un calculator dintr-o reþea Novell, el va
vrea sã vadã cine anume este serverul de disc; atunci el va
``zbiera'' un pachet pentru toatã lumea conþinînd întrebarea
``care eºti server?''.  Pentru cã acest pachet este trimis pe o
adresã de broadcast, toate calculatoarele îl vor primi ºi procesa,
iar cel care este chiar serverul de disc va rãspunde.  Pentru a
trimite rãspunsul va folosi ca destinaþie chiar adresa sursã din
pachetul ``broadcast'';

<P>
</LI>
<LI>Pentru a anunþa servicii interesante pentru toatã lumea (ex.:
server de disc);

<P>
</LI>
<LI>Sunt folosite de ``poduri'' (bridges) pentru a discuta între
ele, dupã cum vom vedea mai jos.
</LI>
</UL>

<P>

<H1><A NAME="SECTION00030000000000000000">
Interconexiuni: repetoare ºi poduri</A>
</H1>

<P>
Dacã avem douã reþele locale pe care vrem sã le conectãm între
ele avem douã posibilitãþi.  Cea mai simplã foloseºte un repetor
(<EM>repeater</EM>).

<P>
Repetorul nu este nimic altceva decît un amplificator electric, care
preia semnale dintr-o parte ºi le pune în cealaltã.  Reþelele de
televiziune pe cablu folosesc astfel de amplificatoare, pentru a mãri
puterea semnalului transmis pe distanþe mari.  Dupã cum este
evident, repetoarele se pot folosi numai între reþele locale de
acelaºi tip (adicã nu putem conecta un token bus cu un token ring).

<P>
Mai mult, deºi sunt eficace în a transforma douã reþele într-una,
în anumite privinþe reþeaua rezultatã este limitatã.  De pildã,
aºa cum am menþionat mai sus, durata de propagare a semnalului
electromagnetic între oricare douã calculatoare nu poate fi prea
mare într-o reþea de tip Ethernet.  O altã limitare provine din
faptul cã toate calculatoarele de pe aceeaºi reþea localã folosesc
în comun acelaºi mediu de transmisie, deci cu cît sunt mai multe,
cu atît rata efectivã de transmisie de care se poate bucura fiecare
din ele scade mai mult.

<P>
Pentru a rezolva acest gen de probleme au fost create podurile
(bridges).    

<P>

<H2><A NAME="SECTION00031000000000000000">
Poduri multi-protocol</A>
</H2>

<P>
Un pod nu este nimic altceva decît un calculator specializat care
este conectat la douã (sau mai multe) reþele locale simultan.  Podul
ºtie sã preia pachete de date dintr-o reþea ºi sã le transmitã
în cealaltã, dacã este nevoie.  Poduri sunt ilustrate în
figurile&nbsp;<A HREF="bridge-html.html#pod">2</A> ºi <A HREF="bridge-html.html#complex">3</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="pod"></A><A NAME="163"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Un pod conectat între douã reþele: un
token-ring ºi un Ethernet.</CAPTION>
<TR><TD><IMG
 WIDTH="361" HEIGHT="171" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{pod.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Aparent funcþiunile unui pod sunt aceleaºi cu ale unui repetor.
Existã însã importante diferenþe:

<P>

<UL>
<LI>Atunci cînd un pod leagã douã reþele locale de tipuri
diferite, el face ºi conversii între cele douã reþele; pachetele
aratã altfel, ºi regulile de transmisiune sunt diferite.  Un astfel
de pod se numeºte pod multi-protocol, pentru cã pe fiecare parte
vorbeºte un protocol diferit;

<P>
</LI>
<LI>Un pod nu copiazã electric informaþii de pe o parte pe alta;
el <EM>citeºte, stocheazã ºi înainteazã</EM> pachetele de date (<EM>store and forward</EM>).  Asta are niºte consecinþe foarte importante:
de exemplu dacã pe reþeaua din stînga se aflã un pachet cînd un
calculator din dreapta transmite, atunci podul poate captura pachetul
din dreapta ºi îl poate stoca pînã reþeaua din stînga devine
liberã;

<P>
</LI>
<LI>Podul nu copiazã orbeºte pachete dintr-o parte într-alta;
dacã un pod determinã cã un pachet are atît sursa cît ºi
destinaþia de aceeaºi parte, atunci nu copiazã pachetul de loc în
cealaltã parte.  Astfel, pe ambele reþele legate de un pod se pot
afla simultan pachete diferite; acest lucru nu este adevãrat despre
un repetor.  Prin aceastã proprietate podul mãreºte capacitatea de
transport a reþelelor pe care le conecteazã (comparat cu o singurã
reþea cu acelaºi numãr de calculatoare).
</LI>
</UL>

<P>

<H1><A NAME="SECTION00040000000000000000">
Podurile transparente</A>
</H1>

<P>
Lucrurile par sã stea ca ºi cum transmisiunea unui pachet între
calculatoarele A ºi B din figura&nbsp;<A HREF="bridge-html.html#pod">2</A> se face în doi paºi: de
la A la bridge, ºi de la bridge la B.  Pentru a lega însã cele
douã reþele într-un mod invizibil, ca ºi cum ar fi una singurã,
existenþa podului trebuie sã fie indiscernabilã; podul trebuie sã
fie <EM>transparent</EM>.

<P>
Din cauza asta, podul captureazã pachetul trimis de A, deºi acesta
specificã adresa B (care nu este tot una cu adresa podului).  Podul
apoi trimite pachetul pe reþeaua Ethernet fãrã a schimba însã
adresa sursã sau destinaþie din pachet!  Pachetul apare pe reþeaua
Ethernet ca ºi cum A ar fi fost cuplat direct la reþea.

<P>
Întrebarea care se pune este: din moment ce podurile nu necesitã
nici un fel de configuraþie manualã, de unde ºtiu ele de fapt cînd
trebuie sã preia un pachet ºi cînd nu, ºi de unde ºtiu pe care
dintre reþele sã-i dea drumul?

<P>

<H2><A NAME="SECTION00041000000000000000">
Algoritmul de învãþare</A>
</H2>

<P>
Rãspunsul este: nici nu ºtiu, cel puþin la început.  Însã
învaþã; din cauza asta se ºi numesc <EM>learning bridges</EM>.  Vom
ilustra algoritmul printr-un exemplu:

<P>

<OL>
<LI>Sã presupunem cã A vrea sã trimitã un pachet calculatorului
B.  Atunci el creazã un pachet cu adresa sursã A, adresa destinaþie
B ºi îl pune pe reþeaua lui localã, token ring.

<P>
</LI>
<LI>Pachetul eventual ajunge la bridge.  Bridge-ul observã adresa
sursã ºi zice: ``aha, iatã un pachet de la A care vine din reþeaua
token-ring; asta înseamnã cã A este de fapt aflat în reþeaua
token-ring!''

<P>
</LI>
<LI>Bridge-ul zice apoi: ``destinaþia este B.  N-am nici cea mai
micã idee unde e B.  Hai sã copiez pachetul în toate reþelele la
care sunt eu conectat; în felul ãsta dacã existã o cale pînã la
B, pachetul va ajunge.''  Zis ºi fãcut; avem acum douã copii ale
pachetului de la A, una în reþeaua token-ring ºi una în Ethernet.

<P>
</LI>
<LI>B primeºte pachetul.  Dupã o vreme probabil B rãspunde cu un
pachet pentru A.  De data asta podul ºtie cã A este în reþeaua
cealaltã, aºa cã face o nouã copie a pachetului.  În plus podul
aflã adevãrata adresã a lui B: în reþeaua Ethernet.

<P>
</LI>
<LI>Dacã mai tîrziu C trimite pentru B un pachet, podul nu mai
face nici o copie, pentru cã ºtie deja cã C ºi B sunt în aceeaºi
reþea.  În plus podul aflã despre poziþia lui C.
</LI>
</OL>

<P>
Podurile ``uitã'' periodic informaþiile învãþate; în acest fel o
staþie poate fi deconectatã dintr-o reþea ºi mutatã în
cealaltã, ºi podurile continuã sã opereze corect.

<P>

<H1><A NAME="SECTION00050000000000000000">
Buclele în topologie</A>
</H1>

<P>
Este uºor de verificat cã algoritmul descris mai sus funcþioneazã
ºi pentru poduri care leagã mai mult de douã reþele, ºi cã
funcþioneazã ºi pentru reþele cu topologii complexe, ca în
figura&nbsp;<A HREF="bridge-html.html#complex">3</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="complex"></A><A NAME="169"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
O topologie complexã pentru care algoritmul
de învãþare al podurilor transparente se comportã totuºi corect.</CAPTION>
<TR><TD><IMG
 WIDTH="542" HEIGHT="312" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{complex.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Din pãcate lucrurile nu stau chiar aºa pentru orice topologie;
figura&nbsp;<A HREF="bridge-html.html#ciclu">4</A> prezintã o topologie de reþele locale pentru care
aplicarea acestui algoritm duce la o catastrofã.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="ciclu"></A><A NAME="175"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4:</STRONG>
O topologie pentru care algoritmul de
învãþare aºa cum este prezentat în text eºueazã datoritã
prezenþei ciclurilor.</CAPTION>
<TR><TD><IMG
 WIDTH="268" HEIGHT="299" BORDER="0"
 SRC="img4.png"
 ALT="\begin{figure}\centerline{\epsfxsize=6cm\epsffile{ciclu.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Sã vedem tot printr-un exemplu ce se întîmplã de fapt:

<P>

<OL>
<LI>A trimite un pachet pentru B;

<P>
</LI>
<LI>Ambele bridge-uri vãd pachetul de la A ºi marcheazã poziþia
curentã a lui A în reþeaua de sus;

<P>
</LI>
<LI>Sã zicem cã bridge-ul 1 copiazã primul pachetul în reþeaua
de jos;

<P>
</LI>
<LI>Bridge-ul 2 vede acest pachet de la A (pentru cã adresa sursã
nu este schimbatã de un pod) ºi presupune cã A s-a mutat în
reþeaua de jos.  Aºa cã marcheazã noua adresã a lui A, dupã care
copiazã ``noul'' pachet în reþeaua de sus (un bridge nu memoreazã
pachetele pe care le-a prelucrat; pentru acest bridge ceea ce a
apãrut este un nou pachet transmis de A);

<P>
</LI>
<LI>ªi tot aºa, povestea se repetã.  Nu numai cã pachetul de la
A este transmis într-una între cele douã reþele, el se ºi
multiplicã.  Cum transmisiunea unui pachet e o chestiune de cîteva
milisecunde, într-o secundã reþeaua este inundatã cu copii ale
aceluiaºi pachet ºi devine complet nefuncþionalã (nu mai poate
transporta nici un fel de trafic util).
</LI>
</OL>

<P>
În general, orice reþea care are cicluri (mai multe drumuri posibile
între douã calculatoare) duce la astfel de probleme, pentru cã
bridge-urile nu se aºteaptã sã vadã pachete de la un calculator
venind de pe douã interfeþe diferite.

<P>

<H1><A NAME="SECTION00060000000000000000">
Arborele de acoperire</A>
</H1>

<P>
Care e soluþia?  Putem cere administratorilor de reþea sã nu
conecteze niciodatã reþele cu cicluri; în acest fel sunt singurii
vinovaþi dacã aºa ceva se întîmplã.

<P>
Însã ideea de a conecta o reþea în mod redundant, în aºa fel
încît între calculatoare sã existe uneori mai mult de un singur
drum, este o idee foarte bunã, pentru cã este <EM>rezilientã la
erori</EM>.  Dacã avem douã conexiuni ºi una dintre ele se stricã,
cealaltã poate prelua traficul fãrã întreruperea conectivitãþii.

<P>
Clar, trebuie oferitã o altã soluþie.  Aceasta constã în
algoritmul prin care bridge-urile reduc orice reþea cu cicluri la una
fãrã cicluri, cãzînd de acord ca anumite legãturi sã nu fie
niciodatã folosite.  În cazul în care topologia reþelei se
schimbã, prin cãderea uneia dintre legãturi, bridge-urile
recalculeazã legãturile folosite, refãcînd conectivitatea
reþelei.  

<P>
Dacã vedem o serie de reþele LAN ca noduri într-un graf, iar
bridge-urile ca arce, algoritmul care rezolvã problema expusã mai
sus calculeazã ceea ce se numeºte <EM>arbore de acoperire</EM> (<EM>spanning tree</EM>) al grafului.  Acesta este un graf care este arbore
(nu are cicluri) ºi cuprinde toate nodurile grafului.  Acest algoritm
a fost inventat de Radia Perlman, ºi este folosit de toate podurile
transparente din lume.  Prezentarea algoritmului se bazeazã pe cea
din cartea ei de la Addison-Wesley ``Interconnections'', pe care am
recomandat-o ºi cu alte ocazii.  Radia Perlman este o personalitate
în lumea reþelelor; are un doctorat în domeniu de la MIT, ºi a
lucrat mai bine de 10 la Digital în proiectare de protocoale.  Multe
din protocoalele de rutare din Internetul de azi sunt bazate pe
prototipurile folosite în DECnet (reþeaua dezvoltatã de Digital);
de pildã protocolul OSPF (Open Shortest-Path First) este în mare
mãsurã creaþia Radiei Perlman.

<P>
Acest gen de algoritmi sunt foarte greu de înþeles, ºi mai greu de
proiectat, extrem de greu de depanat ºi aproape imposibil de
certificat ca fiind corecþi.  Asta pentru cã aceºti algoritmi sunt
<EM>distribuiþi</EM>: fiecare entitate care participã în calcule are
numai informaþii parþiale despre întregul ansamblu, ºi trebuie sã
reconstituie totul doar din informaþiile primite.  Vom vedea mai jos
cã o sumedenie de factori practici (cum ar fi cãderile unor staþii,
erori tranziente, etc.) fac garantarea funcþionãrii unui astfel de
protocol în <EM>toate</EM> circumstanþele o treabã practic
imposibilã.  Dar înainte de asta sã vedem care este algoritmul de
bazã.

<P>

<H2><A NAME="SECTION00061000000000000000">
Algoritmul de votare</A>
</H2>

<P>
Algoritmul se bazeazã pe un set de mesaje de configurare pe care
podurile le trimit între ele, folosind o adresã multicast specialã.
Folosind mesajele de configurare, toate podurile ajung la o aceeaºi
concluzie despre topologia reþelei:

<P>

<UL>
<LI>Toate aleg un ``pod rãdãcinã'', de la care începe calculul
arborelui de acoperire;

<P>
</LI>
<LI>Fiecare pod calculeazã cea mai scurtã ``distanþã'' (într-un
sens care va fi precizat mai tîrziu, care depinde ºi de numele
podurilor prin care trec mesajele, nu numai de distanþa fizicã) de
la sine la podul rãdãcinã;

<P>
</LI>
<LI>Pentru fiecare reþea localã se alege un pod reprezentativ
(<EM>designated bridge</EM>).  Acesta este podul de pe LAN care este
cel mai apropiat de rãdãcinã.  Toate pachetele de pe acest LAN spre
rãdãcinã vor fi transmise numai de podul ales;

<P>
</LI>
<LI>Fiecare pod alege un port (o interfaþã, o conexiune la o
reþea) care este cel mai apropiat de podul rãdãcinã;

<P>
</LI>
<LI>Toate porturile selectate formeazã laolaltã arborele de
acoperire.
</LI>
</UL>

<P>
Fiecare bridge transmite mesaje de configurare ºi calculeazã în
funcþie de mesajele primite cum aratã reþeaua.  Un pod nu
retransmite mesajele primite de la alte poduri (aºa cum face cu
mesajele care conþin date); fiecare mesaj de configurare deci
cãlãtoreºte pe un singur LAN.  Dupã un numãr de runde, fiecare
pod are suficiente informaþii pentru a deduce topologia corectã ºi
algoritmul se terminã.

<P>
Fiecare bridge foloseºte drept nume (identificator, ID) un numãr
unic, de obicei adresa uneia din interfeþele sale (întotdeauna
aceeaºi).  Pod-rãdãcinã va fi ales cel care are cel mai mic ID.

<P>
Fiecare pod transmite un mesaj compus din trei bucãþi:

<P>

<OL>
<LI>Cel mai mic ID de care a auzit vreodatã de la vreun vecin;

<P>
</LI>
<LI>Costul celei mai scurte cãrãri de la sine la podul cu cel mai
mic ID;

<P>
</LI>
<LI>Propriul ID.
</LI>
</OL>

<P>
Iniþial fiecare pod crede despre sine cã este rãdãcina, deci
primul mesaj are forma (ID meu, 0, ID meu).  Cu vremea aceastã opinie
se schimbã pentru fiecare pod.  Un bridge primeºte într-una mesaje
de configurare pe fiecare port, ºi menþine <EM>pentru fiecare port</EM>
``cel mai bun'' mesaj de configurare pe care l-a primit.  ``Cel mai
bun'' mesaj de configurare este obþinut comparînd:

<P>

<OL>
<LI>Mesajele primite pe acel port;

<P>
</LI>
<LI>Mesajele pe care podul se pregãteºte sã le transmitã pe acel
port.
</LI>
</OL>

<P>
Un mesaj e ``mai bun'' decît altul dacã e ``mai mic'' în ordine
lexicograficã.  Cu alte cuvinte: (a, b, c) &lt; (d, e, f) dacã:

<P>

<OL>
<LI>a &lt; d sau</LI>
<LI>a = d ºi b &lt; e sau</LI>
<LI>a = d ºi b = e ºi c &lt; f</LI>
</OL>

<P>
Podurile transmit simultan mesaje de configurare pe toate porturile.
În momentul în care un pod primeºte pe un port un mesaj mai bun
decît ar fi vrut el sã transmitã, atunci înceteazã sã mai
transmitã pe acel port.  Motivul este cã mesajele pot deveni doar
din ce în ce mai bune cu trecerea timpului, deci propriul lui mesaj
nu mai are nici o ºansã sã devinã cel mai bun pe acel LAN.

<P>
Un bridge îºi claseazã apoi porturile în trei categorii:

<P>

<UL>
<LI>Portul dintre rãdãcinã; pe acest port bridge-ul a primit cel
mai bun mesaj.  Acest port va fi activ (folosit) pentru toate
comunicaþiile care merg/vin dinspre rãdãcinã;

<P>
</LI>
<LI>Porturile pe care bridge-ul a trimis el însuºi cel mai bun
mesaj.  Pentru toate LAN-urile legate la aceste porturi acest bridge
este ``designated bridge''.  Aceste porturi sunt ºi ele active.

<P>
</LI>
<LI>Toate celelalte porturi sunt blocate (inactive); pe ele nu vor
fi transmise niciodatã mesaje, atîta vreme cît topologia reþelei
nu se schimbã.
</LI>
</UL>

<P>
În exemplul din figura&nbsp;<A HREF="bridge-html.html#ciclu">4</A>, rezultatul protocolului va fi cã
bridge-ul cu cel mai mic ID devine rãdãcinã, iar celãlalt îºi
dezactiveazã ambele porturi.

<P>
Figura&nbsp;<A HREF="bridge-html.html#designated">5</A> ilustreazã un fragment dintr-o reþea localã
ºi cele trei feluri de porturi pentru un bridge b2.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="designated"></A><A NAME="181"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5:</STRONG>
Fragment dintr-o conexiune de reþele
locale.  b1 este pod desemnat pentru LAN-ul D, iar b2 este pod
desemnat pentru LAN-urile B ºi C.  Legãtura (portul) lui b2 la D
este inactivã.  Portul lui b2 la A este portul lui b2 spre
rãdãcinã.</CAPTION>
<TR><TD><IMG
 WIDTH="536" HEIGHT="229" BORDER="0"
 SRC="img11.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{designated.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00062000000000000000">
Un exemplu numeric</A>
</H2>

<P>
Iatã concret pe un exemplu numeric acþiunile lui b2 din
figura&nbsp;<A HREF="bridge-html.html#designated">5</A> într-o rundã posibilã a protocolului:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=4>Mesajele primite de b2 (ID = 18)</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="CENTER">Rãdãcinã</TD>
<TD ALIGN="CENTER">Cost</TD>
<TD ALIGN="CENTER">Transmiþãtor</TD>
</TR>
<TR><TD ALIGN="LEFT">Port spre A</TD>
<TD ALIGN="CENTER">12</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="CENTER">85</TD>
</TR>
<TR><TD ALIGN="LEFT">Port spre B</TD>
<TD ALIGN="CENTER">20</TD>
<TD ALIGN="CENTER">0</TD>
<TD ALIGN="CENTER">20</TD>
</TR>
<TR><TD ALIGN="LEFT">Port spre C</TD>
<TD ALIGN="CENTER">22</TD>
<TD ALIGN="CENTER">2</TD>
<TD ALIGN="CENTER">44</TD>
</TR>
<TR><TD ALIGN="LEFT">Port spre D</TD>
<TD ALIGN="CENTER">12</TD>
<TD ALIGN="CENTER">5</TD>
<TD ALIGN="CENTER">16</TD>
</TR>
</TABLE>
</DIV>

<P>
Cel ``mai bun'' mesaj primit este (12, 4, 85).  Ca atare b2 decide cã
el se aflã la distanþã 4+1=5 de rãdãcinã; mesajul pe care îl va
transmite în runda urmãtoare va fi deci: (12, 5, 18).  Acest mesaj
este comparat cu toate celelalte 4 mesaje.  Acest mesaje este mai bun
decît cele de la porturile spre B ºi C, deci b2 devine pod desemnat
pentru aceste LAN-uri.  Portul spre A duce spre rãdãcinã (pe acolo
a sosit cel mai bun mesaj), iar portul D este dezactivat, pentru cã
mesajul primit de acolo e mai bun decît cel calculat.  Rezultatul
algoritmului în jurul lui b2 este cel din figura&nbsp;<A HREF="bridge-html.html#designated">5</A>.

<P>

<H1><A NAME="SECTION00070000000000000000">
Rafinamente</A>
</H1>

<P>
Acesta este algoritmul distribuit pentru calculul arborilor de
acoperire.  Analizîndu-l cu oarecare grijã putem sã ne convingem de
corectitudinea lui: algoritmul se terminã pentru cã mesajele trimise
vor fi din ce în ce mai ``bune'', pînã cînd numai bridge-ul
rãdãcinã mai vorbeºte, topologia stabilitã nu va avea cicluri,
pentru cã cel puþin un bridge într-un ciclu va fi forþat sã-ºi
dezactiveze o interfaþã, ºi topologia stabilitã va fi conexã
(adicã va lega toate reþelele), pentru cã fiecare reþea o sã
aibã un ``designated bridge'', ºi pentru cã orice lipsã de
conectivitate între douã pãrþi este remediatã de o rundã de
mesaje.  (Desigur, aceasta este o argumentaþie foarte sumarã.)

<P>
Pe de altã parte aceastã demonstraþie este valabilã în cazul în
care reþeaua este stabilã (<EM>stable, quiescent</EM>); în momentul
cînd se fac schimbãri topologice ce se întîmplã cu algoritmul?
Dacã un bridge sau o reþea cad, sau dacã administratorul adaugã
noi bridge-uri, care încã nu ºtiu de vechea configuraþie, cum de
lucrurile continuã sã funcþioneze?

<P>
Aici lucrurile sunt mult mai problematice, tocmai pentru cã e foarte
greu de imaginat dinainte orice tip de eveniment; pentru unele cazuri
foarte exotice, cum ar fi prezenþa unei defecþiuni care permite
transmisiunea într-un singur sens, nici nu existã soluþii
prestabilite.

<P>
Iatã ilustrate unele dintre posibilele complicaþii ºi soluþiile
adoptate în practicã:

<P>
<DL>
<DT><STRONG>Cãderi:</STRONG></DT>
<DD>fiecare bridge ``învecheºte'' (<EM>ages</EM>)
mesajele primite; cînd acestea ating senectutea, bridge-ul le uitã
complet ºi re-iniþiazã un calcul al topologiei.  În timpul unei
funcþionãri normale, bridge-ul rãdãcinã trimite periodic mesaje de
configurare (numite ``hello''), care cauzeazã fiecare pod sã
reconfigureze.  Dacã anumite mesaje nu mai apar din cauza unei
cãderi, vechea configuraþie se învecheºte ºi atunci cînd la cel
puþin un pod dispare complet, acel pod iniþiazã o nouã execuþie
completã a algoritmului, pentru a descoperi noua topologie.  Chiar
alegerea acestor doi parametri: distanþa dintre hello ºi timpul de
învechire, este o problemã foarte spinoasã: valori mici
supra-încarcã reþeaua cu mesaje inutile în timpul funcþionãrii
normale, dar valori prea mari fac descoperirea erorilor prea
înceatã.  Valorile recomandate sunt de 2, respectiv 20 de secunde.

<P>
</DD>
<DT><STRONG>Evitarea buclelor temporare:</STRONG></DT>
<DD>apariþia unor bucle este o
catastrofã, ºi trebuie evitatã cu orice preþ.  Pentru ca un pod
nou adãugat sã nu creeze o buclã, funcþionarea unui pod este
împãrþitã de standardul 802.1 în douã etape:

<P>

<UL>
<LI>O etapã de învãþare, în care bridge-ul nu retransmite nici
un fel de pachete de date, pentru a nu cauza cicluri.  Singura
funcþiune este de a schimba mesaje de configurare pentru a învãþa
topologia;

<P>
</LI>
<LI>Etapa de funcþionare propriu-zisã, în care datele sunt
transmise conform cu arborele ales.
</LI>
</UL>

<P>
</DD>
<DT><STRONG>Conectivitate unidirecþionalã:</STRONG></DT>
<DD>E posibil ca hardware-ul unui
port sã se strice, ºi ca un bridge sã fie incapabil sã primeascã
pachete de la un anumit LAN, deºi poate transmite perfect.  În acest
caz bridge-ul se va declara ``designated bridge'' pentru acel LAN,
ceea ce ar putea fi o decizie incorectã.  Standardul nu specificã ce
trebuie fãcut în acest caz; singura soluþie este detectarea ºi
repararea erorii de cãtre un operator uman.
</DD>
</DL>

<P>

<H1><A NAME="SECTION00080000000000000000">
Concluzii</A>
</H1>

<P>
Închei aici acest articol despre poduri, deºi problemele care
trebuie considerate în practicã sunt mult mai multe ºi mai
complicate decît am apucat sã ilustrez.  Principiile de bazã ale
funcþionãrii unui bridge sunt însã, sper, cuprinse în acest
text.  Restul sunt detalii.

<P>
Sã recapitulãm învãþãmintele principale: existã mai multe
tipuri de reþele locale, care realizeazã transmisiunea informaþiei
între calculatoare relativ puþine (sute) aflate la distanþe relativ
mici (kilometri) cu viteza relativ mare (sute de megabiþi pe
secundã, în tehnologiile cele mai mature).  Reþelele locale se pot
lega între ele folosind repetoare sau poduri.  Repetoarele sunt doar
o conexiune electricã, pe cînd bridge-urile sunt echipamente
inteligente, care învaþã aºezarea staþiilor, filtreazã traficul
nenecesar între reþelele pe care le leagã, ºi colaboreazã pentru
a construi o reþea completã fãrã cicluri, pentru a preveni
proliferarea nelimitatã a unor pachete.

<P>
Reþelele locale reprezintã cea mai importantã (numeric vorbind)
piesã din Internet, care este o colecþie de reþele legate
laolaltã.  Evoluþia lor este departe de a fi terminatã: cursa spre
distanþe ºi viteze mari continuã.  Fiþi cu ochii, ºi cu datele,
pe ele!

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot53">... ring''</A><A NAME="foot53"
 HREF="bridge-html.html#tex2html1"><SUP>1</SUP></A>
<DD>În ultima vreme
au apãrut ºi standardele 802.6, pentru reþele de întindere medie
(metropolitane), ºi este în lucru standardul 802.11 despre reþele
fãrã fir (wireless), cu transmisiune radio.

<DT><A NAME="foot60">... nume</A><A NAME="foot60"
 HREF="bridge-html.html#tex2html3"><SUP>2</SUP></A>
<DD>De fapt vom vedea mai tîrziu cã un participant poate
sã aibã mai multe nume simultan, cîte unul pentru fiecare reþea la
care este cuplat.

<DT><A NAME="foot62">...  celelalte</A><A NAME="foot62"
HREF="bridge-html.html#tex2html4"><SUP>3</SUP></A> <DD>Cuplarea unui
calculator în Internet necesitã oarecare configurare; configurarea
însã se face pentru protocoalele de nivel superior TCP/IP:
calculatorul funcþioneazã în reþeaua localã de îndatã ce este
conectat.  Despre TCP/IP am scris un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#internet">articol</a>
în PC Report din mai 1998; copia articolului este disponibilã în
pagina mea de web.

</DL>
<BR><HR>

</BODY>
</HTML>
