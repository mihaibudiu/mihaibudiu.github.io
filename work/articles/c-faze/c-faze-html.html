<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Fazele compilatorului de C</TITLE>
<META NAME="description" CONTENT="Fazele compilatorului de C">
<META NAME="keywords" CONTENT="c-faze-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>
<BODY>

<P>

<H1 ALIGN="CENTER">Fazele compilatorului de C</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu</STRONG></P>
<P ALIGN="CENTER"><STRONG>ianuarie 1996</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>fazele compilãrii programelor C 
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>preprocesor, compilator, linkeditor, modul,
                   modul obiect, header, bibliotecã, fiºier executabil 
</DD>
<DT><STRONG>Nivelul tehnic:</STRONG></DT>
<DD>programator cu 1-2 ani de experienþã 
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>limbajul C, bine 
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html13"
  HREF="c-faze-html.html">Precizare</A>
<LI><A NAME="tex2html14"
  HREF="#SECTION00030000000000000000">Introducere</A>
<LI><A NAME="tex2html15"
  HREF="#SECTION00040000000000000000">Premizele scrierii de programe mari</A>
<LI><A NAME="tex2html16"
  HREF="#SECTION00050000000000000000">Soluþia oferitã de C</A>
<UL>
<LI><A NAME="tex2html17"
  HREF="#SECTION00051000000000000000">Un exemplu</A>
</UL>
<BR>
<LI><A NAME="tex2html18"
  HREF="#SECTION00060000000000000000">Compilarea C</A>
<LI><A NAME="tex2html19"
  HREF="#SECTION00070000000000000000">Preprocesarea</A>
<LI><A NAME="tex2html20"
  HREF="#SECTION00080000000000000000">Compilarea propriu-zisã</A>
<LI><A NAME="tex2html21"
  HREF="#SECTION00090000000000000000">Linkeditarea</A>
<LI><A NAME="tex2html22"
  HREF="#SECTION000100000000000000000">Concluzii</A>
<LI><A NAME="tex2html23"
  HREF="#SECTION000110000000000000000">Glosar</A>
</UL>
<!--End of Table of Contents-->
<P>
Acest articol face parte dintr-o serie de articole care îºi
propune sã discute limbajul C standard (ANSI C) supunînd atenþiei
felurite aspecte mai puþin înþelese / folosite / explicate.
Fiecare articol este complet, în sensul cã o cunoaºtere a
limbajului C ar trebui sã fie suficientã pentru înþelegerea lui,
ºi nu se bazeazã fundamental pe altele din aceeaºi serie.
Datoritã însã faptului cã în realitate articolele nu prezintã tehnici
de programare, ci efectiv limbajul ºi semantica (semnificaþia) sa
(deci o construcþie unitarã), referiri incruciºate între articole
apar, atunci cînd aspecte clarificate cu o altã ocazie intervin în
discurs.

<P>

<H1><A NAME="SECTION00020000000000000000">
Precizare</A>
</H1>

<P>
Vom folosi pe alocuri termenul <EM>obiect</EM> pentru a denota
anumite construcþii ale unui limbaj cum ar fi variabile, constante,
funcþii, metode, obiecte (în sensul limbajelor orientate pe
obiecte).  A nu se confunda aceastã noþiune cu cea de obiect din
limbajele orientate pe obiecte, pe care nu o folosim niciodatã
explicit în acest articol, ºi al cãrei sens îl socotim mai
restrîns.

<P>

<H1><A NAME="SECTION00030000000000000000">
Introducere</A>
</H1>

<P>
Încã de la apariþia sa la începutul anilor '70 limbajul C
s-a impus ca lider de necontestat pentru programarea de sistem.
Aceasta din urmã cuprinde o clasã largã de programe care
interacþioneazã foarte strîns cu calculatorul ºi a cãror
performanþã o afecteazã pe a tuturor celorlalte.  Un exemplu tipic de
astfel de program este sistemul de operare.  (El este singurul program
care -- de exemplu -- interacþioneazã cu discul.  Toate celelalte
programe cer serviciile lui pentru acest scop, prin funcþiile de
lucru cu fiºiere.  De aceea el ``interacþioneazã strîns cu
calculatorul''.)

<P>
C are mai multe calitãþi care îl fac atît de apreciat de
cãtre programatorii de sistem (ºi nu numai).  Una dintre ele, de
care ne vom ocupa în parte în acest articol, este suportul pe care
îl oferã pentru dezvoltarea de programe <EM>mari</EM>, eventual lucrate
în echipã.  Vom vedea cã acest suport este oferit prin niºte
mecanisme extrem de simple, dar a cãror existenþã are adesea un
impact foarte important asupra limbajului însuºi.

<P>
Sã vedem acum ce condiþii trebuie sã fie îndeplinite de un
limbaj pentru ne permite scrierea unor programe mari.  Sã numim
aceste condiþii <EM>premize</EM>, ºi sã urmãrim apoi întruparea lor
în cazul C-ului.

<P>

<H1><A NAME="SECTION00040000000000000000">
Premizele scrierii de programe mari</A>
</H1>

<P>
Pentru ca un program sã poatã fi scris de mai mulþi
programatori trebuie ca el sã poatã fi descompus în pãrþi
independente -- cît mai mult -- una de alta, care sã poatã fi
concepute, compilate, testate eventual separat.

<P>
O categorie de astfel de pãrþi sunt <EM>bibliotecile</EM>.
Unele operaþii foarte utile sunt totdeauna aceleaºi (de exemplu
funcþiile matematice (sinus, cosinus, exponenþiale)) ºi pot fi
scrise odatã pentru totdeauna de un programator, fiind apoi folosite
de toþi utilizatorii.  Aceste funcþii sunt livrate adesea de firme 
sub forma unor biblioteci de funcþii.

<P>
Chiar ºi cînd un singur programator este implicat,
împãrþirea unui program în pãrþi puþin dependente una de alta
este de foarte mare ajutor pentru scrierea, dar mai ales depanarea
rezultatului.  Studii experimentale au arãtat cã dificultatea
scrierii unui program creºte exponenþial cu lungimea lui.  Asta
înseamnã ca a scrie un program de 2000 de linii este (mult) mai greu
decît a scrie 2 de cîte 1000.

<P>
Este deci foarte util sã poþi împãrþi un program în mai
multe texte, fiecare -- probabil -- într-un fiºier separat.
Aceastã împãrþire se poate face în foarte multe feluri; de
preferinþã toate funcþiile / variabilele / procedurile etc. care
fac ceva înrudit trebuie sa fie puse în acelaºi fiºier.  Numele
unui astfel de fiºier este <EM>modul</EM>. Putem acum enunþa premiza
întîi necesarã unui limbaj pentru scrierea de programe mari:

<P>
<B>PREMIZA 1 : textul unui program poate fi împãrþit în mai
multe module.</B>

<P>
Pentru a putea testa corectitudinea -- mãcar sintacticã -- a
fiecãrui modul, el trebuie sã se poatã compila separat de
celelalte.  Reamintim cã în cursul compilãrii toate erorile
sintactice sunt depistate (iar cîteodatã ºi posibile erori
conceptuale -- de exemplu variabile neiniþializate).  Compilarea
separatã permite corectarea fiecãrui modul independent.  Avem deci:

<P>
<B>PREMIZA 2 : fiecare modul se poate compila separat.</B>

<P>
Pe de altã parte, modulele fãcînd parte dintr-un tot,
este de aºteptat ca unele obiecte (funcþii, proceduri,
variabile, etc.)  dintr-un modul sã se foloseascã cumva de
altele, dintr-un alt modul.  Pentru cã modulele se pot compila
separat, pentru a face posibilã verificarea corectitudinii
sintactice a fiecãruia în parte, cumva insuºirile
obiectelor dintr-un modul care sunt accesibile ºi din altele
trebuie descrise modulelor utilizator.

<P>
Sã numim un obiect (variabilã, funcþie, etc.) al unui
modul care poate fi folosit de alte module <EM>exportat</EM> de modulul
cãruia îi aparþine.  El este, prin simetrie, <EM>importat</EM>
de modulele care îl folosesc.

<P>
Premiza care urmeazã este necesarã pentru întreþinerea
uºoarã a informaþiilor care trebuie sã fie folosite din mai multe
locuri:

<P>
<B>PREMIZA 3 : Declaraþiile obiectelor exportate de <EM>fiecare</EM>
modul trebuie sã fie centralizate (strînse într-un singur
loc)</B>.  (<EM>Declaraþia</EM> este o instrucþiune care descrie unele
din însuºirile unui obiect; ea va fi tratatã mai pe larg
mai jos, în contextul limbajului C).

<P>
Avem apoi:

<P>
<B>PREMIZA 4 : Trebuie sã existe o metodã prin care declaraþiile
unui modul exportator sunt preluate de modulele importatoare.</B>

<P>
Pentru a încheia ne mai trebuie o premizã.  Cineva
trebuie sã combine rezultatele compilãrilor diferitelor module
separate într-un singur program care se poate executa :

<P>
<B>PREMIZA 5 : Trebuie sã putem pune împreunã mai multe
module compilate (separat) pentru a obþine un executabil.</B>

<P>
În principiu pentru a obþine programul am putea avea o nouã
compilare a tuturor modulelor împreunã.  Însã din moment ce
fiecare modul este probabil deja compilat, ar fi timp cîºtigat dacã
am putea folosi acest lucru.

<P>
Sã observãm cã remarcile din aceastã secþiune
sunt practic independente de limbajul considerat. Ele aratã care
trebuie sã fie calitãþile unui limbaj pentru a uºura
scrierea unor programe multimodul.

<P>

<H1><A NAME="SECTION00050000000000000000">
Soluþia oferitã de C</A>
</H1>

<P>
Compilarea unui program scris în C presupune prezenþa
mai multor module.  Cazul existenþei unuia singur este unul
particular.  (În realitate, dupã cum vom vedea, chiar programele
care par formate dintr-un singur modul sunt adesea formate din mai
multe: cele scrise de programator plus biblioteci!)

<P>
Limbajul C face o distincþie foarte precisã între <EM>declaraþii</EM> ºi <EM>definiþii</EM>.  O declaraþie este o construcþie
care anunþã existenþa unui obiect precum ºi anumite trãsãturi
ale sale.  <EM>Definiþia</EM> unui obiect construieºte efectiv obiectul
(îi alocã un spaþiu).  Orice definiþie este simultan ºi
o declaraþie, dar nu ºi invers.

<P>
Limbajul C permite exportarea variabilelor ºi funcþiilor.  C
mai permite ºi folosirea în comun a macrodefiniþiilor (numite pe
scurt <EM>macro</EM>uri) ºi numelor de tipuri (introduse cu <TT>typedef</TT>) de cãtre mai multe module.  Macrourile ºi tipurile nu dau
naºtere nici unui obiect care sã existe în timpul <EM>execuþiei</EM>
programului, cum este de exemplu o variabilã.  (Cu alte cuvinte
macro-urile ºi tipurile au numai declaraþii ºi niciodatã
definiþii).

<P>

<H2><A NAME="SECTION00051000000000000000">
Un exemplu</A>
</H2>

<P>
Pentru a ilustra terminologia sã considerãm un program
foarte simplu format din douã fiºiere:

<P>
<PRE>
/***********************
 * fisierul : header.h *
 ***********************/

#define YES 1
#define NO 0

#define max(a,b) ((a) &gt; (b) ? (a) : (b))
typedef int NUMAR;

NUMAR abs(NUMAR);   /* valoarea absoluta */
extern NUMAR m;

/*********************
 * fisierul : main.c *
 *********************/

#include "header.h"
#include &lt;stdio.h&gt;

NUMAR m;

NUMAR abs(NUMAR x)
{ if (x &lt; (NUMAR) 0) return -x; else return x; }

static NUMAR n;

int main(void)
{
        int y,z;

        /* sarim ceva din program */
        if (max (y,z) &lt; m) /* mai sarim ceva */
}
</PRE>

<P>
O calitate importantã a obiectelor în C este <EM>vizibilitatea</EM>.  Vizibilitatea unui obiect este totalitatea liniilor
din program în care el poate fi referit.

<P>
Obiectele C care sunt declarate înafara oricãrei
funcþii se numesc <EM>externe</EM>, iar celelalte se numesc <EM>locale</EM>.  În fiºierul <TT>main.c</TT> din exemplul nostru sunt
externe variabilele <TT>m</TT> ºi <TT>n</TT>, precum ºi funcþiile
<TT>main</TT> ºi <TT>abs</TT>.

<P>
Obiectele externe au vizibilitate începînd de la declaraþia
lor ºi pînã la sfîrºitul fiºierului cu excepþia blocurilor care
declarã un alt obiect cu acelaºi nume.  Deci <TT>m</TT> este vizibil
în funcþiile <TT>abs</TT> ºi <TT>main</TT>, dar <TT>n</TT> numai în <TT>main</TT>.

<P>
Obiectele declarate în interiorul unui bloc (delimitat de {
}) se numesc <EM>locale</EM>.  <TT>y</TT> ºi <TT>z</TT> sunt locale lui <TT>main</TT>.  <TT>x</TT> este local lui <TT>abs</TT>.  Un obiect local este
vizibil începînd de la locul declaraþiei ºi pînã la sfîrºitul
blocului în care este declarat (cu excepþia blocurilor interioare
care declarã un obiect cu acelaºi nume).

<P>
Cum aratã definiþia unei variabile / funcþii în C
presupunem cã se ºtie.  Declaraþia unei variabile se face prefixînd
definiþiei ei cuvîntul <TT>extern</TT>.  Declaraþia unei funcþii se
face ne-scriind blocul care formeazã corpul ei.  Astfel în fiºierul
<TT>header.h</TT> avem declaraþii (ºi nu definiþii) ale variabilei
<TT>m</TT> ºi funcþiei <TT>abs</TT>.

<P>
În C implicit toate obiectele externe dintr-un fiºier pot fi
exportate.  Dacã un obiect extern este folosit numai de modulul în
care este definit (adicã nu este exportat) atunci definiþia sa se
poate prefixa cu cuvîntul <TT>static</TT>.  Astfel în fiºierul <TT>main.c m</TT> este exportat iar <TT>n</TT> nu este!  Obiectele care pot fi
exportate se numesc cu <EM>legare externã</EM> (external linkage).  Asta
pentru cã un alt modul le poate folosi fãrã a le defini,
legîndu-se la cel în care sunt definite.  Pentru modulul <TT>main.c
m</TT> este cu legare externã.

<P>
Se obiºnuieºte a se strînge toate declaraþiile
obiectelor exportate de un modul (sau un grup de module) într-un
fiºier numit <EM>header</EM> (sau antet în românã).  Aceste
fiºiere nu conþin niciodatã definiþii.  Numele lor se
terminã prin convenþie cu <TT>.h</TT>.  Un astfel de fiºier este
în exemplul nostru <TT>header.h</TT>.

<P>

<H1><A NAME="SECTION00060000000000000000">
Compilarea C</A>
</H1>

<P>
Compilarea este formatã din trei faze independente, care sunt
realizate de obicei de trei programe distincte, care se executã unul
dupã altul sau în paralel.

<P>
Exemplele pe care le prezentãm sunt pentru douã tipuri de
compilatoare : de sub UNIX (practic orice UNIX, testate pentru Linux)
sau MsDos (testate cu BorlandC 2.0).

<P>
<PRE>
module c si          module             module               program
headere              preprocesate       obiect               executabil
 |  ----------------    ------------------    ---------------   ^
 \-&gt;| preprocesare | -&gt; | compilare      | --&gt;| linkeditare |---/
    |              |    |   propriu-zisa | /-&gt;|  (legare)   |
    ----------------    ------------------ |  ---------------
                                        biblioteci
</PRE>

<P>
Prin anumite opþiuni putem ruga compilatorul sã parcurgã
numai unele dintre aceste faze.  Cînd compilãm mai multe module, noi
dãm o singurã comandã, dar aceastã comandã invocã cele trei faze
pentru noi.  Sã presupunem cã avem un program format din modulul
<TT>main.c</TT> de mai sus ºi modulul <TT>error.c</TT>.  Sub UNIX putem
crea rezultatul cu:

<P>
<PRE>
cc main.c error.c
</PRE>

<P>
Cu BorlandC o facem cu comanda

<P>
<PRE>
bcc main.c error.c
</PRE>

<P>
(Chiar cînd compilarea este lansatã din mediul
integrat BorlandC prin tasta F9, sau prin Compile/Build, în
realitate acelaºi lucru se întîmplã : mediul integrat
invocã pentru noi compilatorul cu o astfel de linie, luînd din
project numele fiºierelor de compilat !).

<P>
Iatã evoluþia fiºierelor pentru MsDos BorlandC

<P>

<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
\left. 
\begin{array}{rclcl}
  \left.
  \begin{array}{l}
  stdio.h  \\
  header.h \\
  main.c   
  \end{array}  
\right\} & \stackrel{preprocesare}{\longrightarrow} & main.i & \stackrel{compilare}{\longrightarrow}  & main.obj \\
error.c  & \stackrel{preprocesare}{\longrightarrow} & error.i & \stackrel{compilare}{\longrightarrow} & error.obj \\
	 & &       &  & \\%% pentru spatiere
         & &       &  & cs.lib   
\end{array}
\right\}
\stackrel{legare}{\longrightarrow} main.exe
\end{displaymath}
 -->

<IMG
 WIDTH="553" HEIGHT="147" BORDER="0"
 SRC="img1.png"
 ALT="\begin{displaymath}
\left.
\begin{array}{rclcl}
\left.
\begin{array}{l}
stdi...
...end{array}\right\}
\stackrel{legare}{\longrightarrow} main.exe
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P> 

<P>
Dupã cum vedeþi premiza 1 (mai multe module) este
îndeplinitã -- un program se poate asambla din mai multe fiºiere
sursã.

<P>
Sã studiem acum fiecare fazã a compilãrii separat,
identificînd ºi celelalte premize:

<P>

<H1><A NAME="SECTION00070000000000000000">
Preprocesarea</A>
</H1>

<P>
Preprocesarea este o fazã deosebit de interesantã, cãreia
intenþionãm sã-i acordãm un articol special cîndva.  Acum o
vom privi din punctul de vedere care ne intereseazã.

<P>
Preprocesorul este de obicei un program separat, care se
numeºte <TT>cpp</TT> (C PreProcessor).  Numele sãu vine de la
faptul cã el realizeazã o procesare înainte (pre) de
compilarea propriu-zisã.

<P>
Preprocesorul este un program care prelucreazã texte.  El
primeºte un text iar rezultatul lui este tot un text.  Comparaþi-l
din acest punct de vedere cu celelalte douã faze.

<P>
În principiu preprocesorul parcurge toate textele care-i sunt
specificate de sus în jos, lucrînd pe linii, cãutînd comenzi
pentru el (numite directive), pe care le executã.  Comenzile pentru
preprocesor încep cu un semn diez (#) în prima coloanã.
Preprocesorul C are trei mari grupe de comenzi:

<P>
<PRE>
        #include
        #define / #undef
        #if / #else / #endif / #ifndef
</PRE>

<P>
Cea mai interesantã pentru noi acum este <TT>#include</TT>,
prezentã ºi în fiºierul <TT>main.c</TT>.  Aceastã directivã este
urmatã de un nume de fîsîer scris între semnele &lt; &gt; sau
<code>" "</code>.  În <TT>main.c</TT> avem

<P>
<PRE>
#include &lt;stdio.h&gt;
#include "header.h"
</PRE>

<P>
Prima formã cautã fiºierul specificat (stdio.h) într-o
serie de directoare care depind de implementarea compilatorului.  De
obicei în UNIX este vorba de <TT>/usr/lib</TT>, iar la BorlandC existã
o opþiune ``Directories'' unde se specificã acest(e) locuri.  A doua
formã cautã fiºierul specificat (<TT>header.h</TT>) întîi relativ la
acelaºi loc în care se gãseºte <TT>main.c</TT> (ex. în directorul
curent), iar apoi, dacã a eºuat în cãutare,
în aceleaºi locuri ca prima formã a lui <TT>include</TT> (cu <code>&lt; &gt;</code>).

<P>
Dupã cum aratã ºi numele fiºierelor (faptul cã se
terminã cu .h), de obicei (dar nu obligatoriu) acestea sunt fiºiere
header, care conþin declaraþiile unor obiecte exportate de alte
module, importate de modulul curent.

<P>
Cînd preprocesorul executã directiva <code>#include</code>
el gãseºte headerul indicat (sau dacã nu, opreºte
compilarea raportînd o eroare) ºi substituie linia
<code>#include</code> cu textul headerului.  Dupã aceea continuã
preprocesarea din acelaºi punct, prelucrînd deci textul tocmai
introdus (care poate include alte headere la rîndul lui).

<P>
Iatã deci cum premiza a 4-a (preluarea într-un modul a
fiºierelor cu declaraþii) este îndeplinitã.  De
asemenea, fiºierele header sunt o consecinþa a premizei a 3-a
(centralizarea declaraþiilor).

<P>
Puteþi vedea rezultatul preprocesãrii rulînd
comandã <TT>cpp</TT> pe fiºierele C.  Aceasta realizeazã numai prima
fazã a compilãrii din cele mai sus indicate.  (<TT>-P-</TT> indicã suprimarea informaþiilor despre numele fiºierelor incluse.
Rezultatul obþinut este fiºierul <TT>main.i</TT>; prin convenþie
extensia .i este pentru fiºiere preprocesate.)

<P>
Borland:

<P>
<PRE>
cpp -P- main.c
</PRE>

<P>
sau UNIX

<P>
<PRE>
cc -E main.c &gt; main.i
</PRE>

<P>
sau UNIX (dacã aveþi <TT>cpp</TT> în directorul <TT>/lib</TT>) :

<P>
<PRE>
/lib/cpp main.c &gt; main.i
</PRE>

<P>

<H1><A NAME="SECTION00080000000000000000">
Compilarea propriu-zisã</A>
</H1>

<P>
Datoritã includerii, fiºierele preprocesate conþin deja
declaraþiile obiectelor importate.  Apoi ele sunt compilate separat
(premiza 2).  Rezultatul acestei compilãri este ceea ce se numeºte
<EM>modul obiect (object file)</EM>.  Borlandc genereazã fiºiere cu
extensia <TT>.obj</TT>, compilatoarele din UNIX cu extensia <TT>.o</TT>.  Se
obþine cîte unul pentru fiecare modul C iniþial.

<P>
Ce este un modul (fiºier) obiect?  Este un amestec de program
compilat (cod maºinã) ºi variate informaþii.  Tot textul C al
modulului a fost compilat în cod maºinã.  Însã referinþele la
simboluri externe din alte module nu au putut fi satisfãcute, pentru cã
aceste module sunt compilate separat.  De
aceea modulul obiect conþine o listã a simbolurilor nesatisfãcute,
indicînd ºi locurile unde sunt folosite.  În plus mai conþine ºi o listã a
simbolurilor exportate de modul.

<P>
De asemenea un modul obiect are o parte cu informaþii
numite <EM>de relocare</EM>.  Acestea sunt necesare pentru cã toate
salturile din codul compilat sar la niºte adrese care se vor
schimba probabil atunci cînd modulul obiect va fi pus cap la cap
cu altele pentru a forma executabilul.

<P>
Adesea modulul obiect mai conþine ºi alte informaþii
care sunt necesare pentru depanarea programului rezultat.  Aceste
informaþii aratã cãror fiºiere sursã ºi cãror
linii (C) le corespund feluritele instrucþiuni din codul maºinã.

<P>
Cîteodatã faza de compilare propriu-zisã este
formatã din douã pãrþi independente ºi fãcute de
programe separate.  O primã fazã genereazã un program în
limbaj de asamblare, iar a doua fazã asambleazã programul pentru
a obþine un fiºier obiect.

<P>
<PRE>
          module      programe in      module
        preprocesate  asamblare         obiect
        ---|  |------------|  |------------|  |----
           |-&gt;| compilare  |-&gt;| asamblare  |-&gt;|
           |  |            |  |            |  |
        ---|  |------------|  |------------|  |-----
                \_________________________/
                  compilare propriu-zisa
</PRE>

<P>
Puteþi opri compilarea la module obiect invocînd
compilatorul cu opþiunea <TT>-c</TT> (compile only); iatã cum
puteþi compila cele douã surse la module obiect :

<P>
UNIX :

<P>
<PRE>
cc -c error.c main.c
</PRE>

<P>
BorlandC

<P>
<PRE>
bcc -c error.c main.c
</PRE>

<P>
Fiºierul obiect nu aratã prea interesant -- pentru
cititorul uman -- dar puteþi încerca sã opriþi
compilarea la limbaj de asamblare:

<P>
UNIX

<P>
<PRE>
cc -S error.c main.c
</PRE>

<P>
BorlandC

<P>
<PRE>
bcc -S error.c main.c
</PRE>

<P>
Rezultatele sunt fiºiere cu extensia <TT>.s</TT> în UNIX
sî <TT>.asm</TT> în DOS.  Citiþi-le!  Aceste fiºier pot
fi asamblate pentru a obþine cod obiect prin

<P>
UNIX

<P>
<PRE>
as -c error.c main.c
</PRE>

<P>
BorlandC

<P>
<PRE>
tasm error.c main.c
</PRE>

<P>

<H1><A NAME="SECTION00090000000000000000">
Linkeditarea</A>
</H1>

<P>
Dupã cum am vãzut fiecare modul sursã este compilat separat
într-un modul obiect.  Modulele obiect au o mulþime de referinþe
nesatisfãcute (la obiectele importate).  Legarea modulelor
(implicînd completarea referinþelor obiectelor globale, relocarea
codului) este fãcutã de ultima fazã a compilãrii, numitã <EM>linkeditare</EM>.  (Link = legãturã în englezã).  Ea este fãcutã de
programul <TT>ld</TT> (în UNIX) sau <TT>tlink</TT> (BorlandC).  Argumentele
ei sunt module obiect.

<P>
Interesant este cã aceste module obiect pot fi obþinute
prin compilarea unor programe scrise în limbaje diferite; este
frecventã combinarea programelor scrise în limbaj de asamblare
cu a celor în C: toate sunt compilate la module obiect, dupã
care sunt legate împreunã.  Lucrurile nu sunt foarte simple,
pentru cã trebuie respectate anumite convenþii (de exemplu
compilatorul C se poate aºtepta ca anumiþi regiºtri sã nu
fie schimbaþi de nici o funcþie).

<P>
Puteþi încerca sã legaþi modulele obiect obþinute mai sus
astfel, deºi n-o sã meargã!

<P>
UNIX :

<P>
<PRE>
ld main.o error.o
</PRE>

<P>
BorlandC :

<P>
<PRE>
tlink main.obj error.obj
</PRE>

<P>
Iatã de ce: în realitate cînd linkerul este invocat de
cãtre compilatorul de C (deci nu separat, cum am fãcut noi mai
sus), mai primeºte ca argumente, pe lîngã modulele obiect
generate prin fazele anterioare ale compilãrii ºi cel puþin
o <EM>bibliotecã</EM>.  Este vorba de biblioteca standard C, numitã
în UNIX <TT>libc.a</TT>, iar în DOS <TT>cs.lib</TT> (în locul
lui s poate fi o altã literã care depinde de modelul de memorie
pe care l-aþi folosit).  Erorile obþinute prin comanda de mai
sus aratã care sunt simbolurile externe importate din bibliotecã
ºi care au lipsit la legare.

<P>
Pentru a lega modulele trebuie specificate ºi bibliotecile.
Sintaxa la BorlandC pentru linker e puþin mai complicatã :

<P>
BorlandC :

<P>
<PRE>
tlink c0s main error, main, ,cs
</PRE>

<P>
pentru cã se specificã separate de virgule fiºierele
<TT>.obj</TT> (incluzînd <TT>c0s</TT>, un fiºier standard), numele
rezultatului, fiºierele map (informaþii generate de compilator),
apoi bibliotecile, ºi apoi resursele (aici map ºi resursele
lipsesc).

<P>
Sub UNIX lucrurile pot fi foarte complicate, pentru cã
bibliotecile se pot afla în multe locuri.  Numele bibliotecilor
este dat linkerului este precedat de opþiunea <TT>-l</TT>; linkerul unui
nume specificat îi prefixeazã <TT>lib</TT>, sufixîndu-i <TT>.a</TT>.  Astfel <TT>-lc</TT> leagã biblioteca <TT>libc.a</TT>.  O linie
minimã de comandã pentru linker ar fi (dar în funcþie de
sistem mai trebuie specificate ºi alte opþiuni, ca <TT>-L</TT> care
indicã locul bibliotecilor) :

<P>
<PRE>
ld /usr/lib/crt0.o main.o error.o -L/usr/lib -lc
</PRE>

<P>
Fiºierele <TT>c0s</TT> (Borland), respectiv <TT>crt0.o</TT>
(UNIX) care apar mai sus sunt niºte module obiect care conþin
codul unei funcþii cu care se începe execuþia programului,
care va cheama funcþia <TT>main()</TT> ºi care dupã executarea
acesteia cheamã funcþia <TT>exit()</TT>, pentru a termina civilizat
programul.

<P>
O bibliotecã (<TT>cs.lib</TT> respectiv <TT>libc.a</TT> sunt
biblioteci) este de fapt o colecþie de module obiect care au fost
compilate mai demult din sursele lor ºi au fost strînse laolaltã
într-un fiºier arhivã.  În <TT>libc.a (cs.lib)</TT> se aflã codul
funcþiilor standard pe care programul dumneavoastrã le poate folosi.
De exemplu <TT>printf, exit, fopen, scanf</TT>.  Prin convenþie
declaraþiile acestor funcþii sunt grupate în fiºiere header puse
într-un anumit loc în sistemul de fiºiere.  Acestea sunt headerele
incluse prin directiva <code>#include &lt;nume_header.h&gt;</code>!  (De aceste
headere este nevoie pentru cã ele conþin declaraþille funcþiilor
exportate de bibliotecã).

<P>
ªi dumneavoastrã puteþi crea biblioteci folosind programul
<TT>ar</TT> (în UNIX) sau <TT>tlib</TT> (în DOS).  Aceste programe
manipuleazã arhive (biblioteci) în multiple feluri.  Bibliotecile
pot fi explorate (pentru a vedea ce conþin) cu <TT>tdump</TT> (în DOS)
sau cu <TT>nm, ranlib, objdump</TT>, etc. sub UNIX.  O discuþie acestor
utilitare este însã în afara acestui articol.

<P>
Rezultatul obþinut de la linker este în fine un program
executabil sub sistemul de operare pentru care lucreazã linkerul.  Un
astfel de fiºier are însã o structurã destul de complicatã,
folositã de sistemul de operare pentru douã scopuri: el conþine
informaþii despre structura însãºi a fiºierului executabil (cît
de lung e codul, cît de lungi sunt datele, sistemul de operare pentru
care merge, dacã foloseºte biblioteci încãrcate dinamic, eventuale
date de relocare, etc.) ºi informaþii de depanare, care sunt
folosite cînd programul este depanat (de ex. cu <TT>td</TT> = Turbo
Debugger în DOS sau cu <TT>dbx</TT> în UNIX).  Aceste informaþii sunt
preluate din fiºierele obiect, dacã existau, ºi în principiu
indicã din ce surse C provin instrucþiunile din executabilul final.
Aceste informaþii pot fi scoase din program, dacã nu mai este nevoie
ca el sã fie depanat, cu <TT>tdstrip</TT> (DOS) sau <TT>strip</TT> (UNIX),
pentru a face un executabil mai mic.

<P>
Douã cuvinte despre <EM>linkeditarea dinamicã</EM>.  Aceasta
este o tehnologie relativ nouã, prezentã în sistemul de operare
Windows sub forma fiºierelor-biblioteci cu extensia <TT>.dll</TT>
(Dinamic Linking Libraries).  Sub UNIX aceste biblioteci se numesc fie
dll-uri fie Shared Libraries (biblioteci comune; numele lor conþine
particula <TT>so</TT>; exemplu: <TT>lib.so.4.1</TT>).  Ideea este destul de
simplã.  Existã o clasã mare de funcþii care tind sã fie prezente
în majoritatea programelor.  Un exemplu tipic este <TT>printf</TT>: cam
toate programele au ceva de scris.  Atunci în loc sã se lege
(linkeze) codul acestor funcþii în fiecare program, funcþiile sunt 
``încãrcate'' în memorie o singurã datã de sistemul de operare,
ºi apoi legate de toate programele care au nevoie de ele.  De aici cele
douã denumiri ale acestor biblioteci: dinamice pentru cã legarea nu
mai e o fazã a compilãrii, ci chiar a executãrii programului
(legarea se face cînd programul este pornit) ºi comune (shared)
pentru cã pot aparþine mai multor programe diferite simultan!

<P>

<H1><A NAME="SECTION000100000000000000000">
Concluzii</A>
</H1>

<P>
Limbajul C pune la dispoziþie niºte mecanisme excelente
pentru scrierea de programe mari.  Aceste mecanisme permit 

<P>

<UL>
<LI>scrierea unui program din mai multe bucãþi, care se pot compila separat.
</LI>
<LI>reutilizarea bucãþilor în programe diferite sub forma
bibliotecilor.  
</LI>
<LI>o gestiune relativ simplã a schimbãrilor
dintr-un modul datoritã headerelor care grupeazã declaraþiile
obiectelor exportate.
</LI>
</UL>

<P>
Cunoaºterea fazelor compilãrii este esenþialã pentru
scrierea unor programe corecte în C.  Dacã un obiect este folosit
fãrã a fi declarat, se obþin erori, sau codul generat este incorect!
(Vom reveni asupra acestui aspect într-un articol despre prototipuri
de funcþii).  Asta poate da naºtere la multe bug-uri misterioase.
Este clar cã un modul nu poate ºti nimic despre obiectele globale
(adicã cu legare externã) definite în alte module pînã în clipa
legãrii.  Ori pînã la legare anumite informaþii se pierd datoritã
compilãrii (de ex.  anumite informaþii de tip).  Linker-ul ar putea
sã nu depisteze anumite erori (de exemplu folosirea unui acelaºi
obiect cu tipuri diferite în module diferite).

<P>
Lecþia se poate rezuma într-o propoziþie : <EM>nu
folosiþi niciodatã în C funcþii sau variabile nedeclarate!</EM>
Puteþi folosi sau nu pentru declaraþii headere.

<P>

<H1><A NAME="SECTION000110000000000000000">
Glosar</A>
</H1>

<P>
Acest articol (ºi toate din aceastã serie) folosesc o
terminologie standard, foarte precisã.  Iatã semnificaþiile
cuvintelor cheie din acest text (ºi numele lor englezesc) :

<P>
<DL>
<DT><STRONG>asamblare:</STRONG></DT>
<DD>compilare din limbaj de asamblare în cod-maºinã;
ASSEMBLY.

<P>
</DD>
<DT><STRONG>ANSI:</STRONG></DT>
<DD>American National Standards Institute; o foarte
prestigioasã instituþie americanã care se ocupã cu crearea
standardelor.  În aceastã serie de articole noi discutãm
limbajul C aºa cum a fost el standardizat de ANSI.

<P>
</DD>
<DT><STRONG>bibliotecã:</STRONG></DT>
<DD>o colecþie de MODULE OBIECT grupate laolaltã.
Conþine codul unor funcþii / variabile foarte utile; în C se
considerã ca biblioteca include ºi HEADERELE cu declaraþile
obiectelor exportate de biblioteca; LIBRARY.

<P>
</DD>
<DT><STRONG>compilare:</STRONG></DT>
<DD>transformarea unui program dintr-un limbaj
într-altul; adesea rezultatul este în cod-maºinã; COMPILATION.

<P>
</DD>
<DT><STRONG>declaraþie:</STRONG></DT>
<DD>o construcþie (de program) care anunþã
existenþa unui obiect fãrã însã a-l construi (aloca
spaþiu) pentru el; DECLARATION.

<P>
</DD>
<DT><STRONG>definiþie:</STRONG></DT>
<DD>o construcþie (de program) care construieºte
(alocã spaþiu) pentru un obiect; DEFINITION.

<P>
</DD>
<DT><STRONG>exportat:</STRONG></DT>
<DD>(de un modul) un obiect care este DEFINIT în acel
modul dar care poate fi folosit ºi în altul; EXPORTED.

<P>
</DD>
<DT><STRONG>extern:</STRONG></DT>
<DD>(în C) orice obiect care nu este LOCAL unei funcþii.
În C variabilele declarate înafara corpului unei funcþii ºi
toate funcþiile sunt externe; EXTERNAL

<P>
</DD>
<DT><STRONG>header:</STRONG></DT>
<DD>un fiºier care grupeazã declaraþiile obiectelor
exportate de unul sau mai multe module (sursã, obiect sau
biblioteci); HEADER FILE.

<P>
</DD>
<DT><STRONG>importat:</STRONG></DT>
<DD>(de un modul) un obiect folosit de acel modul dar
DEFINIT în altul; IMPORTED.

<P>
</DD>
<DT><STRONG>linkeditare:</STRONG></DT>
<DD>combinarea mai multor module obiect într-unul
singur (executabil) prin rezolvarea referinþelor la obiectele
NEDEFINITE pentru fiecare din modulele componente; LINKING.

<P>
</DD>
<DT><STRONG>local:</STRONG></DT>
<DD>un obiect este local unui bloc dacã este vizibil numai
în acel bloc.  Aºa sunt în C argumentele funcþiilor ºi
variabilele declarate în funcþii; LOCAL

<P>
</DD>
<DT><STRONG>modul:</STRONG></DT>
<DD>o parte dintr-un program -- un singur fiºier, grupînd de
obicei obiecte (variabile, funcþii, etc). folosite împreunã;
MODULE; TRANSLATION UNIT

<P>
</DD>
<DT><STRONG>modul obiect:</STRONG></DT>
<DD>un modul compilat dar cu referinþe la obiecte
din alte module încã nerezolvate (referã obiecte cu adrese
necunoscute în acel modul); OBJECT MODULE (OBJECT FILE)

<P>
</DD>
<DT><STRONG>preprocesare:</STRONG></DT>
<DD>o fazã anterioarã compilãrii, care prelucreazã
textul programului sursã C, obþinînd o nouã sursã C;
PREPROCESSING

<P>
</DD>
<DT><STRONG>program executabil:</STRONG></DT>
<DD>un program care poate fi direct executat de
cãtre sistemul de operare; EXECUTABLE (BINARY) FILE.

<P>
</DD>
<DT><STRONG>vizibilitate:</STRONG></DT>
<DD>a unui obiect -- porþiunea din program în
care acel obiect poate fi referit; SCOPE

<P>
</DD>
</DL>

<P>
<BR><HR>

</BODY>
</HTML>
