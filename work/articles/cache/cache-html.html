<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Cache-uri</TITLE>
<META NAME="description" CONTENT="Cache-uri">
<META NAME="keywords" CONTENT="cache-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>
<body>


<P>

<P>
<H1 ALIGN="CENTER">Cache-uri</H1>
<P ALIGN="CENTER"><STRONG>Mihai BUDIU 
<BR>
mihaib@pub.ro, budiu at cs.cornell.edu, 
<BR>
http://www.cs.cornell.edu/Info/People/budiu/budiu.html</STRONG></P>
<P ALIGN="CENTER"><STRONG>ianuarie 1997</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>principiul cache-ului ºi aplicaþii
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>cache, memorie virtualã, memorie asociativã,
politicã de înlocuire, localitate
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>arhitectura elementarã a calculatoarelor
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html24"
  HREF="cache-html.html">Ideea</A>
<LI><A NAME="tex2html25"
  HREF="#SECTION00030000000000000000">Numele</A>
<LI><A NAME="tex2html26"
  HREF="#SECTION00040000000000000000">Eficienþa ºi localitatea</A>
<LI><A NAME="tex2html27"
  HREF="#SECTION00050000000000000000">Variaþiuni</A>
<LI><A NAME="tex2html28"
  HREF="#SECTION00060000000000000000">Algoritmul</A>
<LI><A NAME="tex2html29"
  HREF="#SECTION00070000000000000000">Incarnaþii</A>
<UL>
<LI><A NAME="tex2html30"
  HREF="#SECTION00071000000000000000">Cache-ul de disc</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION00072000000000000000">Cache-ul Microprocesorului</A>
<LI><A NAME="tex2html32"
  HREF="#SECTION00073000000000000000">Cache-ul shell-ului</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION00074000000000000000">Serverele de Nume (``Domain Name Servers'')</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION00075000000000000000">Clienþii de WWW</A>
<LI><A NAME="tex2html35"
  HREF="#SECTION00076000000000000000">Memoria Virtualã</A>
<LI><A NAME="tex2html36"
  HREF="#SECTION00077000000000000000">``Translation Lookaside Buffer'' (TLB)</A>
</UL></UL>
<!--End of Table of Contents-->
<BR>
<BR>
<BR>

<P>
În acest articol îmi propun sã disec unul dintre cele mai simple
dintre ``aparatele'' folosite de calculatoare.  Voi încerca sã arãt
cã existã foarte multe varietãþi de cache, dar cã toate se
bazeazã pe aceeaºi idee foarte simplã: þine la-ndemînã ceea ce
foloseºti des.  Voi încerca de asemenea sã arãt cã fiecare
calculator foloseºte cache-ul într-o mulþime de instanþe, ºi cã
impactul lui asupra eficienþei este extrem de mare.

<P>

<H1><A NAME="SECTION00020000000000000000">
Ideea</A>
</H1>

<P>
Cuvîntul ``cache'' este extrem de familiar celor care lucreazã cu
calculatoare; chiar ºi cînd vrei sã cumperi un calculator þi se
spune: ``120MHz, cache de 256Kb, etc, etc''.  Cuvîntul este
împãmîntenit în forma asta, ºi cum nu cunosc o traducere
rezonabilã, voi continua sã-l folosesc astfel.  Voi desluºi puþin
mai tîrziu sursa numelui (care este un cuvînt franþuzesc, dar
folosit ca atare de întreaga comunitate anglofonã a
calculatoriºtilor, ceea ce e se întîmplã foarte rar).  Pronunþia
la rîndul ei variazã: este sau ``caºe'' (franþuzism), sau
``cheiº'' (citire americanã a cuvîntului).

<P>
<B>Ce este un cache?</B>

<P>
Mai curînd decît un dispozitiv concret putem spune despre cache cã
este un ``principiu''.  Existã foarte multe feluri de cache, unele
construite din hardware special, altele care sunt doar programe.
Toate însã se bazeazã pe aceeaºi idee:

<P>
Noi avem acasã un dulap (nu prea mare, dar la-ndemînã) ºi o debara
(ceva mai mare, dar ce dezordine înauntru!).  Primãvara ºi toamna
se produce o mutare masivã de haine: hainele groase o iau într-o
direcþie, dislocuindu-le pe cele subþiri.  Decizia este naturalã,
chit cã ia o zi sa faci mutarea: dupã aia ai tot ce-þi trebuie
la-ndemînã pentru juma'  de an.  O dificultate se iveºte cînd dai
peste o iarnã extrem de caldã, sau o varã prea rece: trebuie sã
scurmi în debara dupã ceva haine ºi cu alt prilej decît cu
schimbarea sezonului.  

<P>
Acesta este un exemplu tipic de cache.

<P>
În calculatoare lucrurile stau tot aºa: am la dispoziþie douã
memorii, una ieftinã, mare (pentru cã-þi permiþi sã cumperi), dar
cam lentã, una micã ºi scumpã, dar rapidã.  (Cel mai bine e sa
fii ºi bogat ºi sãnãtos, dar nu se poate întotdeauna.)  În plus
mai am ºi o cantitate mare de date de pãstrat, aºa cã trebuie sã
le þin în memoria lentã [debaraua], care e suficient de
încãpãtoare.  Din pãcate dureazã prea mult sã iau ºi sã pun
lucruri acolo: nu e practic sã am numai debara; trebuie ºi un dulap
(memoria rapidã): doar nu o sã pun hainele musafirilor în debara,
nu?  Memoria rapidã [dulapul] este cache-ul.  Din pãcate nu încape
totul în memoria rapidã, aºa cã sunt forþat ca atunci cînd pun
ceva în ea, sã scot altceva în memoria lentã.  Treaba este
avantajoasã atîta vreme cît lucrurile aduse în memoria rapidã
sunt folosite frecvent, deci nu trebuie sã le tot mut.
Figura&nbsp;<A HREF="cache-html.html#principiul">1</A> aratã cum stau lucrurile.

<P>
Observaþi ca scopul meu nu este nici sã am debara, nici sã am
dulap, ci sã pot sã pun undeva hainele, ºi sã le pot manipula
suficient de uºor.  Dulapul ºi debaraua sunt doar <EM>unelte</EM>, nu
scopuri.  Dacã debaraua ar fi suficient de la-ndemînã, n-aº mai
folosi dulapul deloc.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="principiul"></A><A NAME="218"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Principiul cache-ului</CAPTION>
<TR><TD><IMG
 WIDTH="363" HEIGHT="363" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{principiul.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Atenþie la analogie, care nu merge pînã la capãt: în calculatoare
conþinutul memoriei se copiazã foarte uºor, ceea ce nu este
adevãrat despre paltoane.  În calculatoare, cînd ``mut'' ceva, de
fapt fac o copie; acel ceva rãmîne ºi în memoria-sursã (locul de
unde iau).

<P>

<H1><A NAME="SECTION00030000000000000000">
Numele</A>
</H1>

<P>
Abstract vorbind: vreau sã implementez douã operaþii pentru
stocarea de date: <EM>citeºte</EM> ºi <EM>scrie</EM>.  Pot sã citesc ºi
sã scriu din memoria lentã, ºi totul merge cum trebuie, dar prea
lent.  Pentru a spori eficienþa, copiez parte din memoria lentã în
cea rapidã, ºi încerc sã citesc ºi sã scriu acolo.  Cînd nu
gãsesc ce-mi trebuie, operez din nou în memoria lentã.

<P>
``Caché'', (cu accent ascuþit pe ultimul e), înseamnã în limba
francezã ``ascuns''.  Aºa este ºi memoria rapidã: este un
dispozitiv care poate sã fie, sau poate sã lipseascã; absenþa lui
se va remarca numai printr-o vitezã mai scãzutã, dar nu printr-o
reducere a funcþionalitãþii (adicã toate operaþiile pe care le
pot face cu cache-ul, le pot face ºi fãrã el).

<P>
În limbaj tehnic asta înseamnã cã un cache oferã aceeaºi
interfaþã lumii exterioare ca interfaþa pe care el o foloseºte; nu
oferã nici o funcþie suplimentarã (pentru cã atunci mi-aº da
seama cînd l-aº scoate cã lipseºte ceva), ci doar creºte
eficienþa.

<P>
Figura&nbsp;<A HREF="cache-html.html#principiul">1</A> aratã acest lucru, indicînd interfeþele,
care constau din douã proceduri: una pentru scriere ºi una pentru
citire.

<P>
Cu toate cã nu face mare lucru, vom vedea cã arhitectura internã a
cache-ului nu este banalã, ºi cã pentru a folosi eficient spaþiul
mic pe care-l are, trebuie sã-ºi dea ceva ostenealã.

<P>

<H1><A NAME="SECTION00040000000000000000">
Eficienþa ºi localitatea</A>
</H1>

<P>
În mod evident, un cache nu este util în oriºice situaþie: sã ne
imaginãm o þarã cu o climã foarte capricioasã, în care fiecare
zi este altfel decît cea precedentã.  În cazul ãsta aproape
niciodatã nu am avea în dulap hainele necesare, ºi ar trebui sã le
mutãm din debara ºi înapoi.  Dulapul mai mult ar complica treaba
decît ar ajuta, pentru cã pe lîngã faptul cã nu oferã hainele de
care avem nevoie, mai trebuie sã avem grijã ºi de el.

<P>
La fel este ºi în calculatoare: un cache este util <EM>numai</EM> dacã
anumite informaþii sunt folosite frecvent ºi mult.  Atunci acele
informaþii meritã pãstrate înauntru.  Din fericire, experimental
s-a constatat cã acest lucru este foarte adesea adevãrat.  Aceastã
observaþie poate fi formulat în felurite moduri; unul dintre ele
este ``principiilor localitãþii (locality principles)''.  Avem douã
feluri de localitate:

<P>

<UL>
<LI>localitate <EM>spaþialã</EM>: dacã ai nevoie de niºte date,
în curînd vei avea nevoie probabil de date aflate în apropierea lor
în memorie;

<P>
</LI>
<LI>localitatea <EM>temporalã</EM>: cînd ai pus mîna pe niºte date,
foarte adesea le vei folosi de mai multe ori.
</LI>
</UL>

<P>
Acestea sunt doar <EM>observaþii</EM>, dar se potrivesc destul de bine
la programele de calculator, aºa cum funcþioneazã ele în
calculatoarele moderne (poate în viitor lucrurile se vor schimba).
Validitatea observaþiilor ne permite sã folosim cache-uri.  Asta nu
înseamnã cã nu existã programe care folosesc prost cache-urile;
dimpotrivã, dacã vreþi puteþi scrie destul de uºor un astfel de
program (este o metodã eficientã de a încetini calculatorul de la
locul de muncã).  Programele obiºnuite însã nu se comportã aºa.

<P>
Eficienþa unui cache se mãsoarã în procentajul de ``nimereli'' H
(<EM>hit ratio</EM>): din 100 de accese, cîte gãsesc datele în cache?
Opusul acestei valori este <EM>miss ratio</EM> M (rateuri).
Procentajele astea se mãsoarã rulînd o grãmadã de programe ºi
fãcînd media.  Avem desigur, dacã socotim 33% ca 1/3:

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
H = 1 - M
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
Dacã timpul de citire din cache este Tc (``hit time''), iar timpul pe
care îl pierdem cînd ratãm este Tm (``miss time'') atunci putem
mãsura timpul mediu de acces la memoria cu cache cu urmãtoarea
formulã:

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
T = Tc x H + Tm x M
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
Observaþi cã timpul unei ratãri (Tm) nu este neapãrat egal cu
timpul de citire din memoria lentã (Tl), pentru cã în cazul unei
ratãri, întîi trebuie sã ne dãm seama dacã datele sunt în cache,
iar dacã nu sunt sã accesãm memoria lentã.

<P>
Cache-ul va fi eficient dacã T &lt; Tl.  Altfel mai bine fãrã el.

<P>
H depinde de mãrimea cache-ului: pentru un cache de mãrimea
memoriei lente (caz limitã), toate datele pot fi þinute în memoria
rapidã, ºi vom avea H=1.  Pentru un cache de mãrime 0, H=0,
pentru cã niciodatã datele nu se gãsesc în el.  Relaþia între
mãrimea cache-ului, a memoriei lente ºi H nu este o linie
dreaptã, ci creºte repede la început (figura&nbsp;<A
HREF="cache-html.html#marime">2</A>).  Din cauza asta un cache relativ
mic ca mãrime are o importanþã mare ca eficienþã.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="marime"></A><A NAME="224"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Performanþa cache-ului</CAPTION>
<TR><TD><IMG
 WIDTH="270" HEIGHT="263" BORDER="0"
 SRC="img12.png"
 ALT="\begin{figure}\centerline{\epsfxsize=6cm\epsffile{marime.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Eficienþa depinde ºi de raportul dintre Tc ºi Tm; în anumite
cazuri Tm este de ordinul a 10000 x Tc, deci chiar un H mic
poate sã însemne mare lucru.

<P>

<H1><A NAME="SECTION00050000000000000000">
Variaþiuni</A>
</H1>

<P>
Pe lîngã dimensiuni ºi timpi de acces, existã o sumedenie de
detalii prin care cache-urile diferã între ele, datorate faptului
cã mediile de stocare a informaþiei nu se comportã chiar la fel.
Iatã unele dintre posibilele diferenþe:

<P>
<DL>
<DT><STRONG>1)</STRONG></DT>
<DD>Mãrimea blocului de date: cîteodatã este mai economic sã
transporþi mai multe date deodatã din memoria lentã; cache-urile
aduc atunci mai mult decît li se cere (un calup) ºi pãstreazã
totul, în ideea (sugeratã de principiul de localitate spaþialã)
cã ºi vecinii obiectului accesat vor fi cãutaþi în curînd.
Unitatea de transfer între cache ºi memoria lentã e numitã <EM>bloc</EM>.

<P>
</DD>
<DT><STRONG>2)</STRONG></DT>
<DD>Politica de înlocuire: dupã o vreme cache-ul se va umple
cu date, ºi totuºi altele vor trebui aduse.  Decizia despre care
date trebuie scoase afarã este foarte importantã pentru eficienþã;
ea este <EM>politica de înlocuire</EM> (replacement policy).  Existã o
sumedenie de politici; iatã-le doar numite pe unele; orice carte de
sisteme de operare va descrie cele mai multe dintre ele: politica
aleatoare (random), politica circularã (round robin), politica ``cel
mai rar folosit'' (least frequently used), politica ``primul intrat -
primul ieºit'' (first in, first out), politica ``cel mai demult
folosit'' (least recently used), politica ``setul de lucru'' (working
set), politica ``optimã'' (optimal), politica ceasului, politica
celei de-a doua ºanse (second-chance).

<P>
</DD>
<DT><STRONG>3)</STRONG></DT>
<DD>Politica de scriere: odatã cu prezenþa unui cache, datele
efectiv devin duplicate: existã o copie în cache.  Cînd se fac
scrieri, care dintre copii trebuie modificatã?  Una sau amîndouã?
În funcþie de circumstanþe existã varii rãspunsuri la aceastã
întrebare.

<P>
</DD>
<DT><STRONG>4)</STRONG></DT>
<DD>Metoda de identificare: cînd vreau ceva din memoria lentã
indic <EM>adresa</EM> la care acel obiect se gãseºte.  Principiul
transparenþei (faptul cã interfeþele sunt identice) cere ca in
cache datele sã fie cãutate tot dupã aceastã adresã; dar cum
cache-ul este mic, adresele din memoria externã (=
memoria lentã) nu reprezintã adrese ºi în memoria rapidã.  Cum
gãsesc datele?  Rãspunsul este dat de <EM>metoda de identificare</EM> ºi
strîns legat de politica de înlocuire, pentru cã datele trebuie
cãutate acolo unde puteau fi aduse.

<P>
</DD>
<DT><STRONG>5)</STRONG></DT>
<DD>Timpul de viaþã al informaþiei: dacã dintre copiile pe
care le am (una în cache ºi alta în memorie) una se schimbã?  Care
este cea bunã dupã aceea?  Ce trebuie sã fac cu cealaltã?  Cu ce
ocazie trebuie fãcutã schimbarea?
</DD>
</DL>

<P>

<H1><A NAME="SECTION00060000000000000000">
Algoritmul</A>
</H1>

<P>
Schema generalã de funcþionare a unui cache este descrisã la un
nivel abstract de urmãtorul program în C.  Aceasta este doar schema
generalã; în mod normal codul ar trebui sã mai facã o grãmadã de
teste de eroare.

<P>
Singurul punct mai interesant este calculul adreselor: dacã împart
fiºierul în blocuri de mãrime <TT>MARIME</TT>, octetul cu adresa <TT>a</TT> se va afla în blocul cu numãrul <TT>a / MARIME</TT> în fiºier
(ATENÞIE: nu ºi în cache!) ºi va fi octetul cu numãrul <TT>a %
MARIME</TT> în acel bloc.  Adresa de început a blocului va fi <TT>a - a
% MARIME</TT>.

<P>
De asemenea, împãrþirea în proceduri, constantele globale, nu sunt
întotdeauna perfect alese; am încercat sã pãstrez cît mai clarã
structura esenþialã.

<P>
<PRE>
typedef unsigned char BYTE;

#define DA 1
#define NU 0

#define BLOCURI 20
#define MARIME 1024

struct bloc {
   unsigned int liber:1;      /* e folosit acest bloc? */
   unsigned int modificat:1;  /* e modificat acest bloc? */
   unsigned int adresa;       /* datele din fisier intre adresa si adresa+MARIME-1 */
   BYTE date[MARIME];         /* informatia */
};

typedef int blocnr;

struct cache {
   struct bloc blocuri[BLOCURI];
   int blocuri_libere;
   FILE * fisier;
};

/* Metoda de identificare implementata de `cauta' */
extern blocnr cauta(struct cache *c, unsigned int adresa);

/* Politica de inlocuire implementata de `alege_bloc' */
extern blocnr alege_bloc(struct cache *c, unsigned int adresa);

/* metodele de citire/scriere in fisier */
extern void 
citeste_din_fisier(FILE *f, int pozitie, char * buffer, int cantitate);
extern void
scrie_in_fisier(FILE *f, int pozitie, char * buffer, int cantitate);

static int contine(struct cache * c, blocnr bloc, unsigned int adresa)
/* DA daca blocul indicat contine adresa respectiva */
{
   if (c-&gt;blocuri[bloc].liber) return NU;
   if ((c-&gt;blocuri[bloc].adresa &lt;= adresa) &amp;&amp;
       (c-&gt;blocuri[bloc].adresa + MARIME &gt; adresa)) return DA;
   else return NU;
}

static blocnr aduce(struct cache * c, unsigned int adresa) 
/* gaseste blocul care contine aceasta
   adresa, sau aduce datele cu
   aceasta adresa intr-un bloc */
{
   blocnr bloc;

   bloc = cauta(c, adresa);  /* caut adresa indicata in cache */
   if (! contine(c, bloc, adresa)) {
        if (c-&gt;blocuri_libere &gt; 0) {
           bloc = alege_bloc_liber(c);
           c-&gt;blocuri[bloc].liber = NU;
           c-&gt;blocuri_libere -= 1;
       } else {
           bloc = alege_bloc(c);
           if (c-&gt;blocuri[bloc].modificat) {
               scrie_in_fisier(c-&gt;fisier,           /* fisier */
                          c-&gt;blocuri[bloc].adresa,  /* offset in fis. */
                          c-&gt;blocuri[bloc].date,    /* datele */
                          MARIME);                  /* octeti */
               c-&gt;blocuri[bloc].modificat = NU;
           }
       }

       /* am facut rost de un bloc in cache; 
          trebuie sa aducem blocul cu octetul respectiv
          de pe memoria externa */
       c-&gt;blocuri[bloc].adresa = adresa - adresa % MARIME;
       citeste_din_fisier(c-&gt;fisier,                /* fisier */
                          c-&gt;blocuri[bloc].adresa,  /* offset in fis. */
                          c-&gt;blocuri[bloc].date,    /* datele */
                          MARIME);                  /* octeti */
       c-&gt;blocuri[bloc].modificat = NU;
   }
   return bloc;   /* acesta este blocul cu datele */
}

void scrie(struct cache * c, unsigned int adresa, BYTE valoare)
   /* scrie un octet folosind cache-ul */
{
   blocnr bloc;

   bloc = aduce(c, adresa);
   c-&gt;blocuri[bloc].date[adresa % MARIME] = valoare;
   c-&gt;blocuri[bloc].modificat = DA;
}

BYTE citeste(struct cache * c, unsigned int adresa)
   /* citeste un octet folosind cache-ul */
{
   blocnr bloc;

   bloc = aduce(c, adresa);
   return c-&gt;blocuri[bloc].date[adresa % MARIME];
}
</PRE>

<P>
Codul de mai sus implementeazã douã proceduri: <TT>scrie</TT> ºi <TT>citeste</TT>.  Acestea manipuleazã structura de date pusã la dispoziþie
pentru a memora blocuri.  Procedura centralã este <TT>aduce</TT>.  Ea cautã
blocul în cache, dacã nu e scoate unul afarã pentru a face loc, ºi aduce
blocul în locul disponibil.

<P>
Cei cinci parametri sunt vizibili în cod astfel:

<P>
<DL>
<DT><STRONG>1)</STRONG></DT>
<DD>Mãrimea blocului: constanta <TT>MARIME</TT>

<P>
</DD>
<DT><STRONG>2)</STRONG></DT>
<DD>Politica de înlocuire: este realizatã de funcþia <TT>alege_bloc()</TT>, pe care n-am scris-o.  Aceastã funcþie va arãta
diferit în funcþie de politica doritã.  De exemplu, pentru a
implementa o politicã aleatoare, corpul ei, foarte simplu, este:

<P>
<PRE>
#include &lt;stdlib.h&gt;  /* pentru rand() */

blocnr alege_bloc(struct cache *c, unsigned int adresa)
{
   return rand() % BLOCURI;
}

blocnr alege_bloc_liber(struct cache *c)
  /* chemata numai cind EXISTA blocuri libere; gaseste unul */
{
   blocnr b;

   for (b=0; b &lt; BLOCURI; b++) if (c-&gt;blocuri[b].liber) return b;
}
</PRE>

<P>
</DD>
<DT><STRONG>3)</STRONG></DT>
<DD>Politica de scriere este în implementarea de mai sus cea
numitã <EM>write-back</EM>; scrierile se produc doar în copia din cache
a datelor.  [Opusa ei este <EM>write-through</EM>: cînd am de scris ceva
scriu simultan ºi în memoria lentã.  Cîteodatã aceste douã
politici se suplimenteazã cu regula: <EM>no-load-on-write-miss</EM>:
cînd scrierea <EM>nu</EM> gãseºte datele în cache nu le mai
încarcã, ci doar scrie pe disc.]

<P>
</DD>
<DT><STRONG>4)</STRONG></DT>
<DD>Metoda de identificare este de asemenea neprecizatã; ea este
treaba funcþiei <TT>cauta()</TT>.  Cea mai simplã implementare posibilã
este probabil cãutarea liniarã:

<P>
<PRE>
blocnr cauta(struct cache *c, unsigned int adresa)
  /* gaseste blocul care contine aceasta adresa */
{
   blocnr b;

   for (b=0; b &lt; BLOCURI; b++) 
     if (contine(c, b, adresa)) return b;

   /* daca nu l-am gasit pot da orice rezultat; 
      oricum se verifica din nou */
   return 0;
}
</PRE>

<P>
</DD>
<DT><STRONG>5)</STRONG></DT>
<DD>Datele rãmîn în cache-ul acesta pînã sunt scoase afarã
din lipsã de spaþiu.  De obicei cache-urile conþin ºi o procedurã
care le ``goleºte'', astfel (numele tradiþional este <TT>sync</TT>,
pentru cã procedura ``sincronizeazã'' cache-ul cu memoria lentã):

<P>
<PRE>
void goleste(struct cache *c)
  /* salveaza tot */
{
   blocnr b;

   for (b=0; b &lt; BLOCURI; b++) {
      if (!c-&gt;blocuri[b].modificat) continue;
      scrie_in_fisier(c-&gt;fisier,                /* fisier */
                      c-&gt;blocuri[b].adresa,     /* offset in fis. */
                      c-&gt;blocuri[b].date,       /* datele */
                      MARIME);                  /* octeti */
      c-&gt;blocuri[b].modificat = NU;
   }
}
</PRE>

<P>
Cache-ul este aproape complet; Mai trebuie ºi o procedurã de
iniþializare; ceva de genul:

<P>
<PRE>
void initializeaza(struct cache *c, FILE * fisier)
{
   blocnr b;

   c-&gt;fisier = fisier;
   for (b=0; b &lt; BLOCURI; b++) 
      c-&gt;blocuri[b].liber = DA;
   c-&gt;blocuri_libere = BLOCURI;
}
</PRE>

<P>
Puþine proceduri mai trebuie scrise pentru a putea fi testat; <TT>scrie_in_fisier()</TT> ºi 
<BR><TT>citeste_din_fisier()</TT> se pot scrie
foarte simplu:

<P>
<PRE>
#include &lt;stdio.h&gt;

void citeste_din_fisier(FILE *f, int pozitie, 
                        char * buffer, int cantitate)
{
    fseek(f, (long)pozitie, SEEK_SET);
    fread(buffer, 1/* octet */, cantitate, f);
}

void scrie_in_fisier(FILE *f, int pozitie, 
                     char * buffer, int cantitate)
{
    fseek(f, (long)pozitie, SEEK_SET);
    fwrite(buffer, 1, cantitate, f);
}
</PRE>
</DD>
</DL>

<P>

<H1><A NAME="SECTION00070000000000000000">
Incarnaþii</A>
</H1>

<P>
Încheiem acest articol cu o listã (incompletã) de aplicaþii ale
cache-urilor.

<P>

<H2><A NAME="SECTION00071000000000000000">
Cache-ul de disc</A>
</H2>

<P>
Orice sistem de operare modern (mai puþin MS-DOS) are un cache de
disc.  (Chiar ºi pentru MS-DOS existã <TT>smartdrive</TT> sau <TT>ncache</TT> de la Norton).  Cache-ul de disc este probabil una din cele
mai mari surse de eficienþã într-un sistem de operare.  Acesta se
datoreºte faptului cã diferenþa între timpul de acces la disc ºi
cel la memorie este uriaºã (timpul de acces al unei memorii este de
circa 60-70 de nanosecunde, adicã 60x10<sup>-9</sup>, iar timpul de
acces al unui disc este de ordinul a 10 milisecunde, adicã
10x10<sup>-3</sup>.  Cache-ul de disc este o structurã de date care
conþine un vector de blocuri de mãrime egalã.  Discul este la
rîndul lui împãrþit în blocuri de aceeaºi dimensiune.  Cînd
utilizatorul cere un octet de pe disc, blocul care conþine acel octet
este încãrcat în cache, eventual scoþînd un alt bloc afarã.

<P>
Din cele 5 puncte de vedere indicate anterior, un cache de disc are
urmãtoarele caracteristici:

<P>
<DL>
<DT><STRONG>1)</STRONG></DT>
<DD>Mãrimea blocului: Blocuri mari (512 octeþi - 8 Kb).

<P>
</DD>
<DT><STRONG>2)</STRONG></DT>
<DD>Politica de înlocuire: Politica de înlocuire este de obicei:
dã-l afarã pe cel pe care nu l-am folosit cel mai mult timp (Least
Recently Used).

<P>
</DD>
<DT><STRONG>3)</STRONG></DT>
<DD>Politica de scriere: Cache-urile de disc sunt în general
``write-back''.  Asta înseamnã cã atunci cînd se <EM>scrie</EM> pe
disc, modificãrile sunt fãcute doar în cache.  Ele sunt mutate pe
disc doar cînd blocul respectiv este dat afarã, sau cînd acest
lucru este cerut explicit de utilizator.

<P>
</DD>
<DT><STRONG>4)</STRONG></DT>
<DD>Metoda de identificare: Pentru a gãsi un bloc în cache se
folosesc algoritmi de <EM>hash</EM>, care sunt foarte eficienþi (nu ne
putem permite sã intrãm în detalii; orice carte elementarã de
algoritmi descrie hash-urile).

<P>
</DD>
<DT><STRONG>5)</STRONG></DT>
<DD>Timpul de viaþã al informaþiei din cache: Pentru a preveni
catastrofele, sistemele de operare ``golesc'' (scriu toate blocurile
modificate) din cache pe disc periodic (de ex. la 30 de secunde).
</DD>
</DL>

<P>

<H2><A NAME="SECTION00072000000000000000">
Cache-ul Microprocesorului</A>
</H2>

<P>
Un microprocesor la 200 de Megahertzi (un Pentium pro, de pildã) are
un ciclu de instrucþiune de1/(200x10<sup>6</sup>) = 5 nanosecunde.  O
instrucþiune poate dura un numãr variabil de cicluri, între 1 ºi
cîteva zeci.  Executarea unei instrucþiuni înseamnã: citirea ei
din memorie, decodificarea, executarea, memorarea rezultatelor.  Dacã
accesul la memorie dureazã 60 de nanosecunde atunci la fiecare citire
procesorul trebuie sã piardã 12 cicluri!  Din cauza asta între
microprocesor ºi memoria RAM principalã se pune un cache construit
din memorie rapidã, cu timp de acces de 5-10 nanosecunde.

<P>
Cîteodatã designerii pun chiar mai mult decît atît: douã nivele
de cache între procesor ºi RAM: un nivel ceva mai lent, dar mai mare
(pentru un PC între 64Kb ºi 512Kb de obicei), ºi un cache construit
chiar în microprocesor, de ordinul a 1-10Kb, mult mai rapid.

<P>
Aceste cache-uri se implementeazã folosind hardware specializat.

<P>
<DL>
<DT><STRONG>1)</STRONG></DT>
<DD>Mãrimea blocului: blocurile sunt mici 1 - 16 octeþi.

<P>
</DD>
<DT><STRONG>2)</STRONG></DT>
<DD>Politica de înlocuire si <B>4)</B> Metoda de identificare:

<P>
Existã douã clase mari de cache-uri de microprocesor, ºi una
intermediarã.  Ele diferã prin locurile din cache în care un octet
din memoria externã poate fi plasat.  Cele douã mari varietãþi
sunt: cache-ul cu adresare directã, în care locul fiecãrui octet
este unul ºi precis calculat, ºi cache-ul asociativ, în care un
octet din memoria externã poate fi plasat în orice loc din cache.

<P>
</DD>
</DL>
<H3><A NAME="SECTION00072100000000000000">
Cache-ul cu adresare directã (direct mapped)</A>
</H3>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="direct"></A><A NAME="230"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
Cache-ul cu adresare directã</CAPTION>
<TR><TD><IMG
 WIDTH="587" HEIGHT="403" BORDER="0"
 SRC="img17.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{direct.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
De obicei chiar structura adresei este folositã la cãutare.
Figura&nbsp;<A HREF="cache-html.html#direct">3</A> aratã cum este plasat un anume bloc în cache:
biþii de la sfîrºitul adresei blocului dau ºi posibila poziþie a
blocului în cache.  Biþii din începutul adresei blocului constituie
verificarea dacã blocul este cel aflat în cache (mai multe blocuri
candideazã pentru aceeaºi poziþie; cel care se aflã înauntru este
indicat prin <EM>etichetã</EM> (tag)).

<P>
În fine, ultimii biþi din adresã indicã poziþia octetului în
blocul de date.

<P>
Marele avantaj al schemei directe este cã datã fiind adresa,
poziþia în cache a blocului este unic determinatã, ºi nu trebuie
fãcutã nici o cãutare.  Politica de înlocuire nu existã din
acelaºi motiv: nu poþi alege în ce loc sã aduci un bloc.  Din
cauza asta funcþia de cãutare ºi cea de înlocuire sunt identice.

<P>
În termenii codului anterior un exemplu ar fi:

<P>
<PRE>
#define BITI_BLOC        4   /* 2^4 octeti in bloc */
#define BITI_ADRESA_BLOC 8   /* 2^8 blocuri in cache */
#define MASCA_BLOC    0xff   /* un nr format din BITI_ADRESA_BLOC biti 1 */
#define BITI_ETICHETA    4 

#define MARIME (1 &lt;&lt; BITI_ETICHETA)     /* marimea unui bloc */
#define BLOCURI (1 &lt;&lt; BITI_ADRESA_BLOC) /* nr blocuri */

#define BITI_ADRESA (BITI_BLOC + BITI_ADRESA_BLOC + BITI_ETICHETA)
  /* marimea adresei */

blocnr alege_bloc(struct cache *c, unsigned int adresa)
{
   return (adresa &gt;&gt; BITI_BLOC) &amp; MASCA_BLOC;
}

blocnr cauta(struct cache *c, unsigned int adresa)
{
   return alege_bloc(c, adresa);
}
</PRE>

<P>
(Pentru eficienþã putem rescrie ºi structura blocului, sã
pãstreze numai eticheta în loc de adresã, ºi sa facã toate
calculele numai cu biþi; de exemplu:)

<P>
<PRE>
int contine(struct cache * c, blocnr bloc, unsigned int adresa)
/* DA daca blocul indicat contine adresa respectiva */
{
   unsigned int diferenta;

   if (c-&gt;blocuri[bloc].liber) return NU;
   diferenta = adresa ^ c-&gt;blocuri[bloc].adresa; 
        /* sau exclusiv 'intre adrese */
   diferenta &gt;&gt;= BITI_BLOC; 
        /* arunc adresa octetului */
   if (diferenta == 0)
        /* toti bitii identici (rezultat 0) =&gt; acelasi bloc */
        return DA;
   else return NU;
}
</PRE>

<P>
Acest fel de operaþii se implementeazã foarte repede în hardware.

<P>

<H3><A NAME="SECTION00072200000000000000">
Cache-ul cu adresare asociativã (fully associative)</A>
</H3>

<P>
Cache-ul cu adresare asociativã se bazeazã pe un dispozitiv hardware
foarte simpatic, care se numeºte <EM>memorie asociativã</EM> (din cauza
prezenþei ei îºi capãtã cache-ul numele).

<P>
O memorie obiºnuitã oferã douã operaþii: (a) dîndu-se o adresã,
citeºte conþinutul ºi (b) dindu-se o adresã ºi o valoare scrie
aceastã valoare acolo.

<P>
Pe lîngã aceste operaþii o memorie asociativã mai oferã încã
una: dîndu-se o valoare, poate spune la care adresã se gãseºte ea.  
O memorie asociativã nu este tehnologic greu de construit, însã este un
dispozitiv relativ costisitor.

<P>
Un cache asociativ foloseºte o memorie asociativã pentru a memora
<EM>adresele externe</EM> ale blocurilor care corespund fiecãrui bloc
din cache.

<P>
Un bloc poate acum ocupa orice poziþie în cache; cînd este cãutat
memoria asociativã spune unde se aflã.

<P>
Politica de înlocuire va fi însã ceva mai complicatã, oricare din
schemele înºirate fiind un candidat.

<P>

<H3><A NAME="SECTION00072300000000000000">
Cache-ul parþial asociativ (set-associative)</A>
</H3>

<P>
Putem sã ne imaginãm un cache parþial asociativ ca o colecþie de
mai multe cache-uri directe care lucreazã în paralel.  Fie <TT>k</TT>
numãrul de astfel de cache-uri directe.  (un astfel de cache se
numeºte ``associative on k ways'' -- asociativ pe <TT>k</TT> direcþii).

<P>
Ideea este simplã: cînd caut o adresã folosesc adresare directã
în <EM>toate</EM> cele <TT>k</TT> cache-uri directe simultan.  Dacã blocul se
gãseºte într-unul am rezolvat problema.  Daca nu, aleg unul
dintre ele pentru înlocuire.  Numele este de ``parþial asociativ'', pentru
cã plasamentul în cele <TT>k</TT> blocuri posibile este oricare, 
ca la un cache asociativ.

<P>
Sã revenim la discuþia privind cache-urile microprocesoarelor.

<P>
[3)] Politica de scriere, <B>5)</B> Timpul de viaþã al
informaþiei din cache: Dacã mai multe microprocesoare sunt legate la
aceeaºi memorie, existã riscul ca fiecare sã facã modificãri în
propriul cache, obþinînd astfel rezultate eronate, aºa cum aratã
ºi figura&nbsp;<A HREF="cache-html.html#inconsistenta">4</A>.  Din cauza asta cache-ul se face adesea
``write-through'': toate modificãrile se fac simultan în memorie ºi
în cache.  Cache-urile monitorizeazã modificãrile fãcute în
memorie de celelalte cache-uri ºi invalideazã copiile datelor pe
care le posedã ºi care au fost modificate.  (Un astfel de cache se numeºte
``snooping cache'': cache care trage cu urechea, sã vadã dacã altcineva
nu modificã memoria externã.)

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="inconsistenta"></A><A NAME="236"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4:</STRONG>
Acces prin douã cache-uri</CAPTION>
<TR><TD><IMG
 WIDTH="358" HEIGHT="365" BORDER="0"
 SRC="img18.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{inconsistenta.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00073000000000000000">
Cache-ul shell-ului</A>
</H2>

<P>
În Unix (ºi MS-DOS) o comandã tastatã shell-ului (programului
<TT>command.com</TT>) este adesea numele unui fiºier.  Acest fiºier este
cãutat de shell într-o listã de directoare numitã ``path''
(cãrare).  De pildã, dacã tastez <TT>ls</TT> (<TT>dir</TT> în DOS),
shell-ul cautã un fiºier cu numele <TT>ls</TT> pe rînd (de la dreapta
la stînga) în directoarele indicate de variabila <TT>PATH</TT> (o
posibilã valoare este: 
<BR><TT>/sbin:/usr/sbin:/bin:/usr/bin:/usr/bin/X11:/usr/local/bin:.</TT>)  Cum
gãseºte un fiºier executabil numit <TT>ls</TT>, îl executã.  Shell-ul
va gãsi pe <TT>ls</TT> în directorul <TT>bin</TT> ºi va þine minte
acest lucru.

<P>
Operaþia de cãutare este costisitoare, implicînd multe accese la
disc.  Din cauza asta, de îndatã ce un fiºier a fost reperat,
shell-urile inteligente þin minte unde ºi nu mai fac a doua oarã
cãutarea.  A doua oarã cînd voi tasta <TT>ls</TT>, shell-ul se va duce
direct în <TT>bin</TT>, fãrã sã mai caute.  Acesta este tot un cache:
în loc sã acceseze memoria lentã (discul) shell-ul se uitã în 
structura de date pe care a construit-o.

<P>
(Puteþi verifica acest lucru: dacã mutaþi un fiºier executabil din
locul unde se afla într-un alt director din <TT>path</TT>, shell-ul nu
îl va mai gãsi, pentru cã nu mai cautã lista de directoare o a
doua oarã.  Shell-ul <TT>bash</TT> afiºeazã conþinutului cache-ul
intern la comanda <TT>hash</TT>.)

<P>
<DL>
<DT><STRONG>1)</STRONG></DT>
<DD>Mãrimea blocului: Un shell þine minte de obicei numai fiºierele
care au fost folosite; ``blocul'' este perechea nume-loc.

<P>
</DD>
<DT><STRONG>2)</STRONG></DT>
<DD>Politica de înlocuire: Cel mai puþin frecvent folosite
nume pot fi ºterse.

<P>
</DD>
<DT><STRONG>3)</STRONG></DT>
<DD>Politica de scriere, <B>5)</B> Timpul de viaþã al
informaþiei din cache: Dupã cum am vãzut, de obicei shell-ul nu dã
atenþie modificãrilor; el þine minte locul unui fiºier chiar dacã
acest a fost mutat.  De obicei shell-ul are o comandã prin care i se
spune explicit sã uite tot ce a învãþat despre fiºiere (la
shell-ul <TT>csh</TT> comanda este <TT>rehash</TT>).

<P>
</DD>
<DT><STRONG>4)</STRONG></DT>
<DD>Metoda de identificare: Pentru a gãsi locul unui fiºier
foloseºte funcþii de hash.
</DD>
</DL>

<P>

<H2><A NAME="SECTION00074000000000000000">
Serverele de Nume (``Domain Name Servers'')</A>
</H2>

<P>
Cache-urile sunt extrem de utile în reþelele de calculatoare, în
care memoria lentã este un calculator aflat la distanþã.  Un
exemplu foarte interesant în acest context (dar nu singurul posibil)
este cel al serverelor de nume.

<P>
Ca sã facem dintr-o poveste lungã una scurtã, fiecare calculator
este identificat printr-o adresã numericã (de pildã 141.85.128.1).
Din cauzã cã astfel de adrese sunt greu de þinut minte, fiecãruia
i se atribuie ºi o adresã ``simbolicã'' (de pildã <TT>pub.pub.ro</TT>).  Asta simplificã problema oamenilor, dar nu pe a
calculatoarelor, pentru cã atunci cînd cineva indicã o adresã
simbolicã trebuie gãsitã adresa corespunzãtoare numericã.
Adresele simbolice sunt aranjate (ca ºi numele directoarelor, numai
cã se scriu de la dreapta la stînga) într-o ierarhie: pentru a afla
adresa lui <TT>pub.pub.ro</TT>, trebuie sã aflãm adresa (numericã) a
calculatorului care ºtie totul despre <TT>ro</TT>, sã-l întrebãm pe
acesta cine este cel care ºtie totul despre <TT>pub.ro</TT>, care ne va zice
la rîndul lui cine este despre <TT>pub.pub.ro</TT>.  Treaba asta cere timp
(secunde preþioase).

<P>
Din cauza asta, de îndatã ce a aflat o pereche de adrese
simbolicã-numericã, un calculator o pãstreazã într-un cache
local, în ideea cã o va mai folosi.  Trucul merge pentru cã
adresele se schimbã foarte rar.

<P>
<DL>
<DT><STRONG>1)</STRONG></DT>
<DD>Mãrimea blocului: Blocul este o pereche (nume
simbolic-adresa).

<P>
</DD>
<DT><STRONG>2)</STRONG></DT>
<DD>Politica de înlocuire: LRU este un candidat bun.

<P>
</DD>
<DT><STRONG>3)</STRONG></DT>
<DD>Politica de scriere: Aceastã informaþie este practic
``read-only'': un utilizator nu poate schimba adresa unui calculator; nu
se pune problema scrierii.  (Cu alte cuvinte memoria lentã este
``read-only'').

<P>
</DD>
<DT><STRONG>4)</STRONG></DT>
<DD>Metoda de identificare: Identificarea se face tot cu
funcþii de hash.

<P>
</DD>
<DT><STRONG>5)</STRONG></DT>
<DD>Timpul de viaþã al informaþiei din cache: Pentru a
permite adaptarea la schimbãri de adrese, fiecare pereche de adrese
are un ``timp de viaþã'', de ordinul sãptãmînilor.  Dupã ce
timpul de viaþã expirã, informaþia este ºtearsã din cache.  În
acest fel, dacã adresa unui calculator se schimbã, celelalte vor
afla acest lucru la un moment dat.
</DD>
</DL>

<P>

<H2><A NAME="SECTION00075000000000000000">
Clienþii de WWW</A>
</H2>

<P>
Dacã aþi folosit Netscape (sau Internet explorer sau Mosaic), aþi
observat cã la apãsarea butonului ``back'', care vã mutã la
documentul pe care l-aþi vizionat înaintea celui curent, afiºarea
se face mult mai repede decît prima oarã cînd l-aþi vãzut.
Explicaþia este simplã: clientul de web (Netscape, etc.) face pe
discul local un cache în care þine minte ultimele documente pe care
le-aþi vãzut (în directorul <TT>.netscape/cache</TT> de obicei.  
Pune acolo în fiºiere toate paginile recente,
figurile aduse ºi ce-o mai fi.  Asta pentru cã (de obicei) e mult
mai rapidã citirea de pe discul local decît transferul din reþea.

<P>
<DL>
<DT><STRONG>1)</STRONG></DT>
<DD>Mãrimea blocului: Unitatea de memorare (blocul) este în
acest caz fiºierul (fie el pagina html, figurã gif sau document
postscript).

<P>
</DD>
<DT><STRONG>2)</STRONG></DT>
<DD>Politica de înlocuire: Probabil LRU.

<P>
</DD>
<DT><STRONG>3)</STRONG></DT>
<DD>Politica de scriere: În principiu clientul de web poate
doar citi datele; din cauza asta politica de scriere nu existã.

<P>
</DD>
<DT><STRONG>4)</STRONG></DT>
<DD>Metoda de identificare: Identificarea prezenþei unui
document în cache se face dupã URL-ul lui (Universal Resource
Locator).  În lume nu pot exista douã documente cu acelaºi URL.
Cãutarea este probabil o simplã cãutare într-un vector ne-ordonat,
care conþine lista URL-urilor prezente în cache, combinatã cu un
hash parþial dupã prima literã (uitaþi-vã la directorul indicat).

<P>
</DD>
<DT><STRONG>5)</STRONG></DT>
<DD>Timpul de viaþã al informaþiei din cache: Dacã
informaþia pe care o citiþi cu clientul de web se schimbã la
sursã, clientul nu-ºi va da seama, ºi vã va arãta tot ce are în
cache.  Puteþi sã-l forþaþi sã reciteascã datele de la sursã
apãsînd pe butonul ``reload''.
</DD>
</DL>

<P>

<H2><A NAME="SECTION00076000000000000000">
Memoria Virtualã</A>
</H2>

<P>
Memoria virtualã este un mecanism prezent în orice sistem modern de
operare.  Prin acest mecanism se pot executa programe mai mari decît
încap în memorie.  Ideea este de a þine programele pe disc, ºi de
a aduce în memoria RAM a calculatorului numai partea de program care
tocmai se executã.  Figura&nbsp;<A HREF="cache-html.html#virtual">5</A> ilustreazã acest lucru.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="virtual"></A><A NAME="242"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5:</STRONG>
Memoria virtualã</CAPTION>
<TR><TD><IMG
 WIDTH="364" HEIGHT="350" BORDER="0"
 SRC="img19.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{virtual.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Sunã familiar, nu?  Este tocmai comportarea unui cache, dacã stãm
sã ne gîndim bine!  Tot ce am discutat despre cache-uri se aplicã
ºi în acest caz.

<P>
<DL>
<DT><STRONG>1)</STRONG></DT>
<DD>Mãrimea blocului: Blocurile sunt numite în acest caz pagini, ºi
au dimensiuni tipice de 1Kb-8Kb (la Pentium 4Kb).

<P>
</DD>
<DT><STRONG>2)</STRONG></DT>
<DD>Politica de înlocuire: Politica cea mai des folositã este
o variantã a politicii ``setului de lucru'' (WS), care pe englezã
are împãmîntenit numele de WSCLOCK.  Pe scurt politica
funcþioneazã astfel:

<P>

<UL>
<LI>la primul ticãit de ceas toate paginile aflate în memorie se
marcheazã ca fiind ne-atinse;

<P>
</LI>
<LI>procesele sunt lãsate sã meargã o vreme; fiecare paginã pe care
o folosesc este marcatã (cu ajutorul unui hardware special);

<P>
</LI>
<LI>la urmãtorul ticãit de ceas toate paginile încã ne-atinse
sunt date afarã; celelalte formeazã ``setul de lucru''.  Paginile
care vor fi necesare în viitor vor fi aduse în locurile eliberate de
cele date afarã.  Apoi se reia algoritmul de la început.
</LI>
</UL>

<P>
</DD>
<DT><STRONG>3)</STRONG></DT>
<DD>Politica de scriere: Write-back.

<P>
</DD>
<DT><STRONG>4)</STRONG></DT>
<DD>Metoda de identificare: Identificarea poziþiei în RAM a unei
adrese virtuale se face folosind hardware specializat (Unitatea de
Management a Memoriei) care þine ``tabele de pagini''.  Tabelele de
pagini descriu pentru fiecare paginã de adrese virtuale pagina
fizicã ce-i corespunde.  (Tabelele aratã cîteodatã ca niºte
arbori, dar deja am aluneca prea departe cu detaliile).

<P>
</DD>
<DT><STRONG>5)</STRONG></DT>
<DD>Timpul de viaþã al informaþiei din cache: Paginile pot fi
modificate numai cînd se aflã în memoria fizicã (RAM).
</DD>
</DL>

<P>

<H2><A NAME="SECTION00077000000000000000">
``Translation Lookaside Buffer'' (TLB)</A>
</H2>

<P>
Din pãcate nu cunosc nici o traducere a termenului, aºa cã îl voi
folosi cu numele englezesc.  TLB este un dispozitiv folosit pentru a
implementa memoria virtualã.

<P>
Memoria virtualã se bazeazã pe <EM>traducerea</EM> fiecãrei adrese pe
care un program o genereazã într-o altã adresã.  (Revedeþi
figura&nbsp;<A HREF="cache-html.html#virtual">5</A>).  Traducerea se face cãutînd într-o tabelã
mare, care þine pentru fiecare adresã virtualã adresa din RAM (sau
de pe disc) corespunzãtoare.  Problema este cã tabela însãºi
trebuie sã fie stocatã în memorie.

<P>
În felul acesta la fiecare acces la memorie se fac douã accese: unul
în care se cautã în tabelã, ºi unul în care se iau datele de la
adresa indicatã de tabelã.  Vedeþi ºi figura&nbsp;<A HREF="cache-html.html#tlb">6</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="tlb"></A><A NAME="248"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 6:</STRONG>
Traducerea adresei</CAPTION>
<TR><TD><IMG
 WIDTH="227" HEIGHT="336" BORDER="0"
 SRC="img20.png"
 ALT="\begin{figure}\centerline{\epsfxsize=5cm\epsffile{tlb.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Pentru cã nu are sens sã faci douã accese pentru unul singur, se
construieºte un cache cu cele mai folosite adrese virtuale ºi
traducerile lor.  Acest cache se numeºte TLB.

<P>
Adresarea se face atunci astfel: întîi se încearcã drumul (1) din
figurã, cãutînd adresa în TLB.  Doar dacã nu e acolo cãutãm ºi
în tabela de pagini, pe varianta (2).

<P>
<DL>
<DT><STRONG>1)</STRONG></DT>
<DD>Mãrimea blocului: Un bloc este o pereche de adrese virtualã-fizicã.

<P>
</DD>
<DT><STRONG>2)</STRONG></DT>
<DD>Politica de înlocuire: LRU probabil.

<P>
</DD>
<DT><STRONG>3)</STRONG></DT>
<DD>Politica de scriere, <B>5)</B> Timpul de viaþã al
informaþiei din cache: Cînd translatarea virtual-fizic se schimbã
(de pildã cînd o paginã este înlocuitã), informaþia din TLB nu
mai este corectã.  Soluþia este de obicei ºtergerea întregului
conþinut al TLB.

<P>
</DD>
<DT><STRONG>4)</STRONG></DT>
<DD>Metoda de identificare: folosind memorii asociative.
</DD>
</DL>

<P>
<BR><HR>

</BODY>
</HTML>
