<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Teoria complexitãþii</TITLE>
<META NAME="description" CONTENT="Teoria complexitãþii">
<META NAME="keywords" CONTENT="complex-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>
<body>

<P>

<P>
<H1 ALIGN="CENTER">Teoria complexitãþii</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>16 noiembrie 1999</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>teoria modernã a complexitãþii: ce se poate ºi nu
se poate calcula
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare de logicã,
complexitatea algoritmilor
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>limbaj, maºinã Turing, complexitate, oracol
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION01000000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html75"
  HREF="complex-html.html">Introducere</A>
<UL>
<LI><A NAME="tex2html76"
  HREF="#SECTION01020000000000000000">Teoria complexitãþii: o ºtiinþã despre limitele
inferioare</A>
<LI><A NAME="tex2html77"
  HREF="#SECTION01030000000000000000">Modele de calcul ºi resurse</A>
<UL>
<LI><A NAME="tex2html78"
  HREF="#SECTION01031000000000000000">Calculatoarele: procesoare de limbaje</A>
<LI><A NAME="tex2html79"
  HREF="#SECTION01032000000000000000">Operaþii cu limbaje</A>
<LI><A NAME="tex2html80"
  HREF="#SECTION01033000000000000000">Decidabilitate</A>
<LI><A NAME="tex2html81"
  HREF="#SECTION01034000000000000000">Maºina Turing</A>
</UL>
<LI><A NAME="tex2html82"
  HREF="#SECTION01040000000000000000">Clase de complexitate robuste</A>
<LI><A NAME="tex2html83"
  HREF="#SECTION01050000000000000000">Simulãri; maºina Turing universalã</A>
</UL>
<BR>
<LI><A NAME="tex2html84"
  HREF="#SECTION02000000000000000000">calculabilitate</A>
<UL>
<LI><A NAME="tex2html85"
  HREF="#SECTION02010000000000000000">Teorema gãurii; diagonalizarea</A>
<LI><A NAME="tex2html86"
  HREF="#SECTION02020000000000000000">Numãrabilitate</A>
<LI><A NAME="tex2html87"
  HREF="#SECTION02030000000000000000">Problema opririi (the halting problem)</A>
<UL>
<LI><A NAME="tex2html88"
  HREF="#SECTION02031000000000000000">Consecinþe ale teoremei opririi</A>
<LI><A NAME="tex2html89"
  HREF="#SECTION02032000000000000000">Semi-decidabilitate</A>
</UL>
<LI><A NAME="tex2html90"
  HREF="#SECTION02040000000000000000">Oracole</A>
<UL>
<LI><A NAME="tex2html91"
  HREF="#SECTION02041000000000000000">Ierarhia aritmeticã</A>
</UL>
<LI><A NAME="tex2html92"
  HREF="#SECTION02050000000000000000">Concluzii</A>
<LI><A NAME="tex2html93"
  HREF="#SECTION02060000000000000000">Alte surse de informaþie</A>
</UL>
<BR>
<LI><A NAME="tex2html94"
  HREF="#SECTION03000000000000000000">Teoria clasicã a complexitãþii</A>
<UL>
<LI><A NAME="tex2html95"
  HREF="#SECTION03010000000000000000">Recapitulare</A>
<LI><A NAME="tex2html96"
  HREF="#SECTION03020000000000000000">Pietre de hotar</A>
<UL>
<LI><A NAME="tex2html97"
  HREF="#SECTION03021000000000000000">Programul formalist al lui Hilbert</A>
<LI><A NAME="tex2html98"
  HREF="#SECTION03022000000000000000">Teorema lui Gödel ºi teorema lui Turing</A>
<LI><A NAME="tex2html99"
  HREF="#SECTION03023000000000000000">Teorema lui Cook ºi NP-completitudinea</A>
<LI><A NAME="tex2html100"
  HREF="#SECTION03024000000000000000">Teorema lui Solovay; relativizare</A>
<LI><A NAME="tex2html101"
  HREF="#SECTION03025000000000000000">Teorema lui Razborov-Rudich; demonstraþii naturale</A>
<LI><A NAME="tex2html102"
  HREF="#SECTION03026000000000000000">Situaþia actualã</A>
</UL>
<LI><A NAME="tex2html103"
  HREF="#SECTION03030000000000000000">Reduceri ºi completitudine</A>
<UL>
<LI><A NAME="tex2html104"
  HREF="#SECTION03031000000000000000">Reduceri</A>
</UL>
<LI><A NAME="tex2html105"
  HREF="#SECTION03040000000000000000">Clase de complexitate importante</A>
<UL>
<LI><A NAME="tex2html106"
  HREF="#SECTION03041000000000000000">Spaþiu constant</A>
<LI><A NAME="tex2html107"
  HREF="#SECTION03042000000000000000">Spaþiu logaritmic</A>
<LI><A NAME="tex2html108"
  HREF="#SECTION03043000000000000000">Timp polinomial</A>
<LI><A NAME="tex2html109"
  HREF="#SECTION03044000000000000000">Spaþiu polinomial</A>
<LI><A NAME="tex2html110"
  HREF="#SECTION03045000000000000000">Timp exponenþial</A>
<LI><A NAME="tex2html111"
  HREF="#SECTION03046000000000000000">Spaþiu exponenþial</A>
<LI><A NAME="tex2html112"
  HREF="#SECTION03047000000000000000">Dincolo de spaþiu exponenþial</A>
</UL>
<LI><A NAME="tex2html113"
  HREF="#SECTION03050000000000000000">Complexitatea nedeterministã; maºini alternante</A>
<UL>
<LI><A NAME="tex2html114"
  HREF="#SECTION03051000000000000000">Maºini nedeterministe</A>
</UL>
<LI><A NAME="tex2html115"
  HREF="#SECTION03060000000000000000">Clase complementare</A>
<LI><A NAME="tex2html116"
  HREF="#SECTION03070000000000000000">Maºini alternante, ierarhia polinomialã</A>
<LI><A NAME="tex2html117"
  HREF="#SECTION03080000000000000000">Concluzii</A>
</UL>
<BR>
<LI><A NAME="tex2html118"
  HREF="#SECTION04000000000000000000">Aleatorism ºi complexitate</A>
<UL>
<LI><A NAME="tex2html119"
  HREF="#SECTION04010000000000000000">Aleatorism (randomness) ºi amplificare (boosting)</A>
<LI><A NAME="tex2html120"
  HREF="#SECTION04020000000000000000">Complexitate probabilisticã; RP, ZPP ºi BPP</A>
<UL>
<LI><A NAME="tex2html121"
  HREF="#SECTION04021000000000000000">Monte Carlo ºi Las Vegas</A>
<LI><A NAME="tex2html122"
  HREF="#SECTION04022000000000000000">BPP ºi RP</A>
</UL>
<LI><A NAME="tex2html123"
  HREF="#SECTION04030000000000000000">Demonstraþii interactive</A>
<LI><A NAME="tex2html124"
  HREF="#SECTION04040000000000000000">Demonstraþii verificabile probabilistic; teorema PCP</A>
<LI><A NAME="tex2html125"
  HREF="#SECTION04050000000000000000">Complexitatea circuitelor</A>
<LI><A NAME="tex2html126"
  HREF="#SECTION04060000000000000000">Secvenþe pseudo-aleatoare</A>
<LI><A NAME="tex2html127"
  HREF="#SECTION04070000000000000000">Funcþii neinversabile</A>
<LI><A NAME="tex2html128"
  HREF="#SECTION04080000000000000000">Criptografie</A>
<LI><A NAME="tex2html129"
  HREF="#SECTION04090000000000000000">Relaþia dintre aleatorism ºi dificultate</A>
<LI><A NAME="tex2html130"
  HREF="#SECTION040100000000000000000">Teorema elasticului</A>
</UL>
<BR>
<LI><A NAME="tex2html131"
  HREF="#SECTION05000000000000000000">Logicã ºi complexitate</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>

<H1><A NAME="SECTION01010000000000000000">
Introducere</A>
</H1>

<P>
Dintre ramurile informaticii, teoria complexitãþii a fost
întotdeauna pentru mine cea mai fascinantã, pentru cã pune cele mai
cutezãtoare întrebãri ºi dã cele mai cuprinzãtoare rãspunsuri.
La un moment dat intenþionam sã îmi dedic chiar activitatea de
cercetare acestui domeniu, dar paºii mei s-au pãstrat pe o cãrare
mult mai practicã.  Am încercat însã sã fiu un amator informat
în ceea ce priveºte acest fascinant domeniu.  Articolul de faþã va
încerca sã vã transmitã cîteva dintre motivele fascinaþiei mele.

<P>
Pentru cã subiectul acesta este foarte generos, mã vãd din nou
obligat în a face un articol cu mai multe episoade; îmi cer scuze
cititorilor care nu vor cumpãra toate numerele revistei.

<P>
Am mai publicat în PC Report despre subiecte înrudite: un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#algoritmi">articol</a>
amplu în 1997 discuta despre direcþii noi de cercetare în algoritmi,
iar cele douã numere din PC Report anterioare celui de faþã au fost
consacrate celei mai importante probleme nerezolvate din teoria
complexitãþii, <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#sat">problema
satisfiabilitãþii</a>.  Cititorii interesaþi pot gãsi aceste texte în
pagina mea de web.

<P>
Din pãcate îndeletnicirea mea este oarecum ingratã: în primul
rînd este dificil sã vorbeºti despre ceva la care nu te pricepi cu
adevãrat; în al doilea rînd, substanþa însãºi a acestui domeniu
este foarte formalã; nu i se poate da dreptate fãrã a folosi o
dozã substanþialã de matematicã, ori acest gen de literaturã nu
este de loc pe potriva revistei PC Report.  

<P>
Ca atare voi recurge la o practicã reprobabilã: voi încerca sã vã
povestesc despre rezultatele cele mai remarcabile obþinute în acest
domeniu, dar fãrã a oferi întotdeauna demonstraþii matematice, ºi
adesea chiar fãrã a exprima foarte precis noþiunile despre care
vorbesc.  Voi consuma cu neruºinare ``crema'' acestui domeniu,
vînturînd în faþa ochilor dumneavoastrã cele mai spectaculoase
rezultate, dar fãrã a vã arãta toatã sudoarea care stã în
spatele lor.  Dacã asta vã va trezi curiozitatea în a aprofunda
domeniul, sau dacã doar veþi privi cu mai mult respect domeniul
informaticii, nu ca pe o simplã meºteºugãrealã, dar ca pe o
ºtiinþã în toatã regula, mã voi putea declara satisfãcut.

<P>
Cititorul cu înclinaþii matematice poate însã sã fie liniºtit:
toate lucrurile despre care pomenesc sunt de fapt foarte precis
formalizate, ºi suportate de demonstraþii în toatã legea.  În
plus, matematica folositã în teoria complexitãþii este relativ
simplã: toate aceste lucruri ar trebui sã fie accesibile unui elev
de liceu care-ºi dã (ceva mai multã) ostenealã; cu certitudine,
matematica studiatã în facultate este mult mai complicatã decît
cea întîlnitã în studiul teoriei complexitãþii.

<P>
În mod interesant, asta nu înseamnã cã teoria complexitãþii este
mai uºoarã; dimpotrivã, minþi briliante au cucerit cu multã
trudã rezultatele acesteia.  Ceea ce e adevãrat este cã matematica
folositã în teoria complexitãþii are mult mai puþinã structurã,
ºi cã obiectele manipulate sunt mult mai simple.  Cel mai adesea
avem de-a face cu obiecte finite, ºi aproape întotdeauna cu obiecte
numãrabile, discrete.  Obiectul fundamental este ºirul de caractere
formate din litere ale unui alfabet finit: o structurã mult mai
simplã decît cele întîlnite de pildã în analiza matematicã.

<P>
Desigur, faptul cã o problemã are un enunþ simplu nu înseamnã de
loc cã are ºi o soluþie simplã; cea mai puternicã mãrturie este
probabil Marea teoremã a lui Fermat, al cãrei enunþ poate fi
explicat ºi unui ºcolar, dar a cãrei rezolvare a cerut trei sute de
ani de eforturi încordate.  De fapt, vom vedea cã în teoria
complexitãþii existã o sumã de probleme fundamentale nerezolvate;
putem chiar spune cã majoritatea problemelor fundamentale sunt încã
nerezolvate.  

<P>
Dar informatica este o ºtiinþã exactã extrem de tînãrã; mult
mai tînãrã decît matematica sau fizica.  Sunt convins cã cele mai
interesante rezultate vor apãrea abia în viitor; ceea ce ne
minuneazã în ziua de astãzi este echivalentul uimirii pitagorenilor
în faþa triunghiului dreptunghic: doar umbra unei colosale
frumuseþi matematice.

<P>

<H1><A NAME="SECTION01020000000000000000">
Teoria complexitãþii: o ºtiinþã despre limitele
inferioare</A>
</H1>

<P>
Teoria complexitãþii (complexity theory) se ocupã cu studiul
lucrurilor care se pot calcula atunci cînd resursele pe care le avem
la dispoziþie sunt limitate.  Resursele fundamentale în teoria
tradiþionalã erau:

<P>
<DL>
<DT><STRONG>Timpul</STRONG></DT>
<DD>disponibil pentru execuþia unui program; 

<P>
</DD>
<DT><STRONG>Spaþiul</STRONG></DT>
<DD>sau cantitatea de memorie disponibilã pentru a stoca
date.
</DD>
</DL>

<P>
dar dezvoltãrile mai recente au arãtat cã alte genuri de
resurse au un impact foarte important asupra lucrurilor care se pot
calcula, cum ar fi:

<P>
<DL>
<DT><STRONG>Aleatorismul,</STRONG></DT>
<DD>sau cantitatea de biþi aleatori pe care-i avem la
dispoziþie;

<P>
</DD>
<DT><STRONG>Paralelismul,</STRONG></DT>
<DD>sau numãrul de elemente de procesare care pot
opera în paralel;

<P>
</DD>
<DT><STRONG>Interacþiunea,</STRONG></DT>
<DD>sau numãrul de mesaje schimbate între douã
entitãþi care calculeazã;

<P>
</DD>
<DT><STRONG>Sfaturi de la un oracol:</STRONG></DT>
<DD>chiar dacã nu ºtim sã rezolvãm o
anumitã problemã, dacã presupunem cã cineva vine ºi ne dã
rãspunsul, existã apoi în continuare probleme grele?
</DD>
</DL>

<P>
Dintr-un anumit punct de vedere, teoria complexitãþii este exact
opusul teoriei algoritmilor, care probabil partea cea mai dezvoltatã
a informaticii teoretice: dacã teoria algoritmilor ia o problemã ºi
oferã o soluþie a problemei în limitele unor resurse, teoria
complexitãþii încearcã sã arate cînd resursele sunt <EM>insuficiente</EM> pentru a rezolva o anumitã problemã.  Teoria
complexitãþii oferã astfel demonstraþii cã anumite lucruri <EM>nu</EM> pot fi fãcute, pe cînd teoria algoritmilor aratã cum lucrurile
pot fi fãcute.

<P>
De exemplu, atunci cînd învãþãm un algoritm de sortare ca
quicksort, demonstrãm cã problema sortãrii a <I>n</I> numere se poate
rezolva în timp proporþional cu <I>n</I> log <I>n</I>.  ªtim deci cã sortarea
se poate face în timp cel mult <I>n</I> log <I>n</I>, sau mai puþin.

<P>
Pe de altã parte, teoria complexitãþii ne aratã cã pentru a sorta
<I>n</I> numere oarecare ne trebuie <EM>cel puþin</EM> timp
<I>n</I> log <I>n</I>, ºi
cã este imposibil sã sortãm mai repede, dacã nu avem informaþii
suplimentare despre valorile de sortat.

<P>
Combinînd aceste douã rezultate, deducem cã problema sortãrii are
complexitatea exact <I>n</I> log <I>n</I>, pentru cã:

<P>

<OL>
<LI>Avem un algoritm de timp <I>n</I> log <I>n</I>;
</LI>
<LI>Am demonstrat cã nu se poate mai bine de atît.
</LI>
</OL>

<P>
Aceastã stare de fapt este una extrem de fericitã, ºi din pãcate
foarte rarã: pentru majoritatea problemelor pe care le cunoaºtem,
existã o distanþã mare între cea mai bunã posibilitate de
rezolvare pe care o cunoaºtem ºi limita inferioarã cea mai
ridicatã pe care o putem demonstra.  Situaþia este ca în
figura&nbsp;<A HREF="complex-html.html#limite">1</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="limite"></A><A NAME="303"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
Existenþa unui algoritm pentru a rezolva o
problemã oferã o limitã superioarã pentru complexitatea problemei:
în regiunea albastrã, din dreapta, putem rezolva problema.  Teoria
complexitãþii gãseºte limite inferioare: dacã ne plasãm în
regiunea roºie, cu certitudine problema este insolvabilã.  Foarte
adesea, între cele douã regiuni existã o zonã (haºuratã cu
negru) despre care nu putem spune nimic.  Din pãcate, aceastã zonã
este adesea foarte mare ca întindere.</CAPTION>
<TR><TD><IMG
 WIDTH="534" HEIGHT="201" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{limite.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Chiar pentru probleme aparent banale, complexitatea minimã este
adesea necunoscutã.  De exemplu, algoritmul cel mai bun cunoscut
pentru a înmulþi douã numere de <I>n</I> cifre are complexitatea 
<I>n</I> log log <I>n</I>, dar limita inferioarã oferitã de teoria
complexitãþii este de <I>n</I>.  Algoritmul învãþat în ºcoala primarã
pentru înmulþire are complexitatea n<sup>2</sup>.  Nimeni nu ºtie cît
de jos poate fi împinsã aceastã limitã, dar teoria complexitãþii ne
garanteazã ca nu mai jos de <I>n</I> (de fapt în cazul de faþã nu e
nevoie de nici o teorie pentru a ne spune asta: în timp mai puþin de
<I>n</I> nu poþi nici mãcar sã citeºti toate cifrele numerelor de
înmulþit).

<P>
Pentru foarte multe probleme importante, distanþa între limitele
inferioarã ºi superioarã cunoscute este enormã: de exemplu pentru
problema satisfiabilitãþii, cãreia i-am consacrat ultimele mele
douã articole, limita superioarã este o funcþie exponenþialã
(2<sup>n</sup>) iar cea inferioarã este una polinomialã
(n<sup>k</sup>), pentru un <I>k</I> constant, independent de
problemã. 

<P>
Într-un anume sens, teoria complexitãþii are o sarcinã mult mai
grea decît cea a algoritmilor: teoria algoritmilor demonstreazã
propoziþii de genul: ``existã un algoritm de complexitate <I>n</I> log <I>n</I>
care înmulþeºte douã numere''.  Acest lucru este de obicei fãcut
chiar construind acel algoritm.  Pe de altã parte, teoria
complexitãþii trebuie sã demonstreze teoreme de genul ``Nu existã
nici un algoritm care rezolvã aceastã problemã în mai puþin de
<I>n</I> log <I>n</I> paºi''.  Ori aºa ceva este nu se poate demonstra
în mod direct: existã un numãr infinit de algoritmi, deci nu putem pur ºi
simplu sã-i verificãm pe toþi.

<P>

<H1><A NAME="SECTION01030000000000000000">
Modele de calcul ºi resurse</A>
</H1>

<P>
Am tot menþionat tot felul de limite (ex. n<sup>2</sup>), dar nu am spus ce
înseamnã acestea.  Atît teoria complexitãþii, cît ºi teoria
algoritmilor, mãsoarã complexitatea în acelaºi fel, ºi anume
<EM>asimptotic</EM>.  Asta înseamnã cã mãsurãm numãrul de operaþii 
fãcute ca o funcþie de cantitatea de date care ne este oferitã spre
prelucrare, ºi cã împingem aceastã cantitate spre infinit.  Atunci
complexitatea este exprimatã ca o funcþie pe mulþimea numerelor
naturale: pentru fiecare mãrime de intrare, avem o complexitate.
Dacã putem avea mai multe date de intrare cu aceeaºi mãrime (de
exemplu, cînd sortãm putem avea mai mulþi vectori de lungime
<I>n</I>), atunci complexitatea pentru intrarea <I>n</I> este luatã ca
fiind maximumul dintre toate valorile: max<sub>(|i|=n)</sub> f(i), unde
<I>f</I> este complexitatea ºi i sunt datele de intrare (simbolul
| | reprezintã <EM>mãrimea</EM> datelor).

<P>

<H2><A NAME="SECTION01031000000000000000">
Calculatoarele: procesoare de limbaje</A>
</H2>

<P>
Cum mãsurãm datele de intrare ºi cum mãsurãm resursele?
Întrebarea este perfect legitimã, ºi meritã o clarificare.

<P>
În primul rînd, toate datele pe care le vom prelucra sunt exprimate
folosind literele unui <EM>alfabet</EM>.  Nu conteazã prea tare care
este alfabetul, atîta vreme cît are cel puþin douã semne
diferite.  

<P>
Dacã fixãm un alfabet, putem vorbi de ºiruri de caractere (strings)
din acel alfabet.  Putem de asemenea vorbi de <EM>limbaje</EM>: un limbaj
este o mulþime de ºiruri.  Definiþia aceasta pare foarte simplã,
dar este foarte utilã: de aici înainte putem enunþa absolut toate
procesãrile fãcute de un calculator în termeni de operaþii pe
limbaje.

<P>
De exemplu, putem considera limbajul format din mulþimea ºirurilor
care încep cu semnul + sau -, urmate de un ºir de cifre, urmate
eventual de o virgulã, de alte cifre, ºi eventual niºte cifre
între paranteze.  Acest limbaj poate descrie numerele raþionale,
inclusiv pe cele periodice, în notaþia pe care am învãþat-o în
ºcoala primarã; de exemplu -312,413(3) este un ºir din aceastã
mulþime.  Putem de asemenea caracteriza alte limbaje foarte
interesante, ca: limbajul tuturor expresiilor aritmetice corecte,
limbajul Pascal, format din toate ºirurile de caractere care sunt
programe Pascal corecte, etc.

<P>
Un calculator va primi deci la intrare un ºir finit de caractere, ºi
va produce la ieºire un altul.  Putem mãsura foarte precis lungimea
unui ºir de caractere prin numãrul de caractere care-l compun.
Aceasta este definiþia ``mãrimii'' datelor de intrare.  

<P>
Un algoritm se va aºtepta ca datele de intrare sã fie dintr-un
anumit limbaj; în acest caz, el va transforma fiecare cuvînt de la
intrare într-un cuvînt dintr-un alt limbaj.  De pildã, un algoritm
care sorteazã un ºir de numere se aºteaptã ca la intrare datele
sã fie un ºir de numere separate de spaþii; pentru fiecare astfel
de ºir de numere, el va produce la ieºire un alt ºir de numere.
Limbajul datelor de intrare este format din ºirurile de numere
separate de spaþii, limbajul de la ieºire este acelaºi, dar toate
numerele dintr-un ºir la ieºire vor fi sortate.  Ce face algoritmul
dacã datele de intrare nu sunt un ºir de numere, ci niºte gunoaie?
Putem spune cã nu ne intereseazã comportarea algoritmului în astfel
de cazuri.

<P>
Vedeþi, aparent desfacem firul în patru: cine are nevoie de niºte
definiþii atît de amãnunþite, încît sunt aproape lipsite de
sens?  Matematicienii au nevoie: dupã ce am clarificat exact
noþiunile cu care operãm, avem foarte multã libertate în a le
manipula în mod precis.

<P>

<H2><A NAME="SECTION01032000000000000000">
Operaþii cu limbaje</A>
</H2>

<P>
Adesea vom specifica limbajele pornind de la limbaje mai simple, cu
ajutorul unor operaþii.  De exemplu, putem construi limbaje
intersectînd douã limbaje, sau luînd reuniunea lor: doar avem de-a
face cu mulþimi de cuvinte.  De exemplu, dacã intersectãm limbajul
tuturor cuvintelor din limba româna -- sã-l notãm cu <I>R</I>, un
limbaj format din toate cuvintele din DEX ºi derivatele lor -- cu
limba latinã vom obþine un nou limbaj, care constã din toate
cuvintele moºtenite din latinã.

<P>
Alte operaþii pe care le putem face sunt: complementarea unui limbaj
(complementul unui limbaj <I>L</I> este cel format din toate cuvintele care
<EM>nu</EM> sunt în <I>L</I>) sau concatenarea a douã limbaje (L1
concatenat cu L2 este un limbaj format din cuvinte pentru care prima
parte e un cuvînt din L1 iar a doua din L2).  De exemplu, limbajul
propoziþiilor româneºti de douã cuvinte este un subset al
limbajului R concatenat cu el însuºi.

<P>

<H2><A NAME="SECTION01033000000000000000">
Decidabilitate</A>
</H2>

<P>
Un loc aparte în studiul complexitãþii îl au maºinile care dau
totdeauna un rãspuns ``da'' sau ``nu''.  Cu alte cuvinte, limbajul de
ieºire are doar douã elemente.  Spunem despre astfel de maºini cã
<EM>decid</EM> un limbaj: limbajul decis este format din cuvintele de la
intrare pentru care maºina rãspunde ``da''.  Toate problemele pentru
care aºteptãm un rãspuns ``da'' sau ``nu'' se numesc ca atare
<EM>probleme de decizie</EM>; problema SAT, a satifiabilitãþii, cãreia
i-am dedicat douã numere în PC Report, este un exemplu de problemã
de decizie.

<P>
Problemele de decizie sunt o subclasã foarte interesantã a tuturor
problemelor, pentru cã adesea putem enunþa <EM>orice</EM> problemã ca
o colecþie de probleme de decizie.  Aceastã noþiune a fost
prezentatã în cãzut problemei SAT ca ``autoreducere''.  Ideea este
însã destul de simplã.

<P>
De exemplu, sã considerãm problema ``care sunt factorii primi ai
numãrului n?''.  Putem reduce aceastã problemã la mai multe
probleme de decizie, care ne dau exact aceeaºi informaþie: ``este 2
un factor prim al lui n'', ``este 3 ...'', etc.  Dacã ºtim
rãspunsurile la toate aceste probleme de decizie, putem obþine
rãspunsul ºi la problema iniþialã.

<P>

<H2><A NAME="SECTION01034000000000000000">
Maºina Turing</A>
</H2>

<P>
Am clarificat cum aratã datele; cum mãsurãm însã resursele
consumate?  Consumate de fapt de cine?

<P>
Aveþi perfectã dreptate: ne trebuie un model precis de calcul.  Cel
mai folosit este un model propus în anii treizeci de marele
matematician englez Alan Turing: maºina Turing.  Maºina Turing este
un calculator redus la esenþe, abstractizat.  Maºina Turing
(figura&nbsp;<A HREF="complex-html.html#turing">2</A>) este compusã din urmãtoarele piese:

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="turing"></A><A NAME="309"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
Maºina Turing este un model de calcul abstract
propus de matematicianul Alan Turing.  Ea constã dintr-o bandã
infinitã, pe care pot fi scrise simboluri, un cap de scriere-citire,
care poate fi plimbat pe suprafaþa benzii, ºi o unitate de control,
care cuprinde un numãr finit de reguli care indicã maºinii ce sã
facã la fiecare miºcare în funcþie de litera curentã de pe bandã
ºi starea în care maºina se aflã.  În pofida simplitãþii ei,
maºina Turing poate calcula orice poate fi calculat cu cele mai
performante supercomputere.</CAPTION>
<TR><TD><IMG
 WIDTH="360" HEIGHT="164" BORDER="0"
 SRC="img19.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{turing.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<OL>
<LI>O bandã infinitã de hîrtie cu pãtrãþele; în fiecare
pãtrãþel se poate scrie exact un caracter din alfabetul nostru;
banda este iniþial plinã cu ``spaþii'', mai puþin partea de la
început, unde este scris ºirul cu datele de intrare;

<P>
</LI>
<LI>Un cap de citire-scriere, care se poate miºca deasupra benzii,
la stînga sau la dreapta;

<P>
</LI>
<LI>O unitate de control, care conþine un numãr finit de reguli.
Unitatea de control este la fiecare moment dat într-o <EM>stare</EM>;
stãrile posibile sunt fixate dinainte, ºi sunt în numãr finit.
Fiecare regulã are forma urmãtoare:

<P>
Dacã 

<UL>
<LI>sunt în starea Q1;
</LI>
<LI>sub capul de citire este litera X;
</LI>
</UL>

<P>
atunci:

<P>

<UL>
<LI>trec în starea Q2;
</LI>
<LI>scriu pe bandã litera Y;
</LI>
<LI>mut capul de citire/scriere în direcþia D.
</LI>
</UL>
</LI>
</OL>

<P>
ªi asta-i tot!  Un algoritm de calcul este descris de o astfel de
maºinã, prin toate stãrile posibile, ºi toate aceste reguli,
numite <EM>reguli de tranziþie</EM>, care indicã cum se trece de la o
stare la alta.

<P>
``Ce e prostia asta?'' aþi putea exclama, ``ce poþi face cu maºina
asta handicapatã?''  Ei bine, poþi face...totul.  Alegeþi
limbajul dumneavoastrã favorit, sã zicem C; ei bine, se poate
descrie o maºinã Turing care sã interpreteze (adicã sã execute)
orice program C care i s-ar da scris pe bandã.  Putem mima intrarea
ºi ieºirea unui calculator cerînd ca datele de intrare sã fie
scrise de la început pe bandã, iar ca datele de ieºire sã aparã
pe bandã cînd maºina terminã de calculat<A NAME="tex2html5"
  HREF="#foot120"><SUP>1</SUP></A>.

<P>
Orice alte modele de calcul care au fost propuse de-a lungul timpului,
au fost dovedite a fi mai puþin expresive, sau tot atît de expresive
cît maºina Turing.  Nimeni nu a fost în stare, pînã acum, sã
zicã: ``eu cred cã de fapt maºina Turing e prea limitatã; iatã
care zic eu cã sunt operaþiile elementare pe care le avem la
dispoziþie, din care ar trebui sã exprimãm orice algoritm'', ºi
sã ofere ceva care sã fie construibil, ºi care sã poatã face
lucruri pe care maºina Turing nu le poate face.

<P>
Din cauza asta logicianul Alonzo Church a emis ipoteza cã maºina
Turing este modelul cel mai general de calcul care poate fi propus;
acest enunþ, care nu este demonstrabil în sens matematic, se
numeºte ``Teza lui Church''.  Acesta este un postulat asupra cãruia
trebuie sã cãdem de acord înainte de a putea conversa orice lucru
privitor la teoria complexitãþii.

<P>
Dacã avem un model de calcul, putem defini foarte precis ce
înþelegem prin complexitate:

<P>
<DL>
<DT><STRONG>Timpul de calcul</STRONG></DT>
<DD>pentru un ºir dat la intrare, este numãrul
de mutãri fãcut de maºina Turing înainte de a intra în starea
``terminat'';

<P>
</DD>
<DT><STRONG>Spaþiul</STRONG></DT>
<DD>consumat pentru un ºir de intrare, este numãrul de
cãsuþe de pe bandã pe care algoritmul le foloseºte în timpul
execuþiei sale.
</DD>
</DL>

<P>

<H1><A NAME="SECTION01040000000000000000">
Clase de complexitate robuste</A>
</H1>

<P>
Cînd spun cã maºina Turing este la fel de puternicã ca orice alt
model de calcul, nu înseamnã cã poate calcula la fel de repede ca
orice alt model de calcul, ci cã poate calcula aceleaºi lucruri.

<P>
Putem sã ne imaginãm tot felul de modificãri minore ale maºinii
Turing, care o vor face sã poatã rezolva anumite probleme mai
repede.  De exemplu, putem sã ne imaginãm cã maºina are dreptul
sã mute capul la orice cãsuþã dintr-o singurã miºcare, fãrã
sã aibã nevoie sã meargã pas-cu-pas; atunci banda s-ar comporta
mai asemãnãtor cu o memorie RAM obiºnuitã.

<P>
Atunci cum de putem discuta despre complexitate, dacã timpul de
rezolvare depinde de modelul de execuþie?

<P>
Aici teoria complexitãþii se desparte de teoria algoritmilor; teoria
algoritmilor foloseºte de regulã modelul RAM pentru a evalua
complexitatea unui algoritm.  Teoria complexitãþii face niºte
diviziuni mai grosolane.  

<P>
ªi anume, existã niºte clase de complexitate care sunt complet
invariante la variatele definiþii ale maºinii Turing: cã are douã
capete de acces la bandã, cã poate sãri oriunde, complexitatea
rãmîne aceeaºi.  O astfel de clasã de complexitate este clasa
tuturor problemelor care se pot rezolva în timp polinomial, o alta
este cea a tuturor problemelor care se pot rezolva în spaþiu
polinomial, etc.  Aceste clase de complexitate sunt numite
``robuste'', pentru cã definiþia lor nu depinde de modelul de
maºinã.  Acest lucru se poate demonstra arãtînd cã o maºinã de
un anumit model poate simula pe cele diferite fãrã a cheltui prea
multe resurse suplimentare.

<P>
Teoria complexitãþii mai decreteazã ºi cã toate problemele care
se pot rezolva în timp polinomial sunt rezolvabile, iar toate cele
care au nevoie de mai mult timp sunt intractabile.  Aceastã
definiþie este în general adevãratã din punct de vedere practic,
dar trebuie luatã cu un grãunte de sare: cîteodatã un algoritm
n<sup>3</sup> este inacceptabil, dacã problema este prea mare, altãdatã
unul de timp chiar exponenþial este tolerabil, dacã maºina cu
care-l rulãm este foarte rapidã.  Din punct de vedere teoretic,
separaþia însã este perfect acceptabilã, pentru cã întotdeauna
ne gîndim la probleme pentru care mãrimea datelor de intrare tinde
spre infinit.

<P>
Aº vrea sã mai fac o observaþie foarte importantã: o problemã
este foarte strîns legatã de limbajul în care o exprimãm.  Iatã
un exemplu: sã considerãm problema înmulþirii a douã numere.
Dacã limbajul în care lucrãm exprimã numerele în baza 2 (sau
orice altã bazã mai mare de 2), atunci se cunosc algoritmi de
complexitate <I>n</I> log <I>n</I> pentru a face înmulþirea.  Pe de altã
parte, dacã insistãm sã scriem numerele în baza 1 (adicã numãrul
5 este reprezentat de cinci ``beþiºoare'', ca la clasa I), atunci,
în mod evident, complexitatea înmulþirii a douã numere de lungime
totalã n este n<sup>2</sup>: chiar rezultatul înmulþirii lui n cu n
este scris cu n<sup>2</sup> beþiºoare, deci nu are cum sã ne ia mai puþin
timp, pentru cã trebuie sã scriem rezultatul!

<P>
ªi mai spectaculoasã este diferenþa pentru algoritmul care
verificã dacã un numãr este prim: dacã limbajul de intrare
exprimã numerele în baza 2, cel mai bun algoritm cunoscut are
complexitatea 2<sup>n</sup>, exponenþialã, dar dacã scriem numerele în
baza 1, complexitatea este n<sup>2</sup>.  Acest lucru se întîmplã pentru
cã un numãr scris în baza 1 este mult mai lung decît scris în
baza 2 <I>n</I> este scris în baza 2 cu log <I>n</I> cifre).

<P>
Deci, cînd enunþaþi o problemã pentru rezolvare cu calculatorul,
trebuie sã specificaþi ºi limbajul în care problema este
descrisã; abia apoi puteþi discuta despre complexitatea rezolvãrii.

<P>

<H1><A NAME="SECTION01050000000000000000">
Simulãri; maºina Turing universalã</A>
</H1>

<P>
Oare cum au reuºit matematicienii sã demonstreze cã maºina Turing
este atît de puternicã încît este echivalentã cu orice alt model
propus de calcul?  De pildã, un model extrem de faimos, care este
folosit încã foarte ades în teoria limbajelor de programare, este
modelul lambda-calculului.  Acest model manipuleazã niºte formule
simple conform unor reguli de re-scriere.

<P>
Ce sens are sã spunem cã maºina Turing este la fel de puternicã
precum lambda-calculul?

<P>
Rãspunsul stã în <EM>simulare</EM>: putem arãta cã, orice am face cu
lambda-calculul, putem efectua ºi cu o maºinã Turing.  Existã deci
o corespondenþã între fiecare transformare efectuatã de regulile
lambda-calculului ºi un set de transformãri pe care maºina Turing
le poate face cu simbolurile de pe bandã.  

<P>
De fapt maºina Turing este atît de puternicã încît putem construi
o maºinã Turing care sã simuleze orice altã maºina Turing
posibilã.

<P>
Pentru a înþelege cum este posibil aºa ceva, trebuie sã realizãm
douã lucruri:

<P>

<UL>
<LI>Descrierea oricãrei maºini Turing este finitã, ºi poate fi
fãcutã cu alfabetul nostru.  Dacã am o maºinã Turing, pot enumera
stãrile ei ºi regulile de tranziþie sub forma unui ºir de
caractere;

<P>
</LI>
<LI>Maºina universalã primeºte douã intrãri pe bandã: una este
descrierea maºinii de simulat, iar a doua este intrarea pentru care
trebuie sã simuleze maºina.  Maºina universalã apoi urmãreºte cu
rãbdare regulile de tranziþie ale maºinii simulate, folosind
propria ei bandã în acest scop.
</LI>
</UL>

<P>
Dacã vã gîndiþi puþin veþi realiza cã de fapt aceste lucruri
nici mãcar nu sunt prea surprinzãtoare: de fapt un interpretor de
BASIC face acelaºi lucru: primeºte descrierea unei maºini
(programul BASIC) ºi apoi simuleazã execuþia acestei maºini pe
niºte date de intrare.

<P>

<H1><A NAME="SECTION02000000000000000000">
calculabilitate</A>
</H1>

<P>

<H1><A NAME="SECTION02010000000000000000">
Teorema gãurii; diagonalizarea</A>
</H1>

<P>
O întrebare pe care un matematician ºi-o pune imediat este: are vreo
importanþã cîte resurse dãm unei maºini Turing?  Nu cumva totul
se poate calcula cu aceeaºi cantitate de resurse?  

<P>
Existã niºte teoreme deosebit de interesante din acest punct de
vedere.  O teoremã aratã cã dacã dãm unei maºini mai mult timp
(sau spaþiu), atunci ea poate efectua lucruri pe care nici una din
maºinile care au mai puþin timp nu le poate efectua.  Aceastã
teoremã se numeºte ``teorema gãurii'' (gap theorem), pentru cã
aratã cã între feluritele clase de complexitate existã diferenþe:
clasa limbajelor care se pot decide în timp n<sup>3</sup> este diferitã de
clasa limbajelor care se pot decide în timp n<sup>4</sup>.

<P>
Enunþul teoremei este de fapt destul de încîlcit, ºi se bazeazã
pe niºte detalii tehnice, pe care o sã le trec sub tãcere.
Demonstraþia este însã relativ simplã, ºi se bazeazã pe o
tehnicã ades folositã în teoria complexitãþii, numitã
<EM>diagonalizare</EM>.  Aceastã tehnicã a fost folositã în
demonstraþia lui Cantor, pentru a arãta cã numerele reale nu sunt
numãrabile. 

<P>
Ideea de bazã este urmãtoarea: maºina cu mai multe resurse îºi
poate permite sã facã orice face maºina cu mai puþine resurse, iar
dupã aceea sã mai ºi prelucreze rezultatul.  Cu alte cuvinte, putem
construi o maºinã cu resurse mai multe, care dã un rezultat diferit
de orice maºinã mai simplã.  Rezultã ca maºina cu mai multe
resurse calculeazã o funcþie diferitã de toate celelalte!

<P>

<H1><A NAME="SECTION02020000000000000000">
Numãrabilitate</A>
</H1>

<P>
Teorema gãurii se bazeazã în mod explicit pe faptul cã nu existã
prea multe maºini Turing!  Din moment ce fiecare maºinã Turing
poate fi descrisã printr-un ºir de caractere finit, înseamnã cã
putem enumera toate maºinile Turing.  Existã astfel un numãr
numãrabil de maºini Turing (deci cu mult mai puþine decît existã
numere reale!).

<P>
O consecinþã interesantã a acestui fapt este cã <EM>calculatoarele nu
pot manipula numerele reale</EM>.  Existã mai multe 
numere reale decît algoritmi posibili!  Limbajele care opereazã cu
numere reale, de fapt manipuleazã niºte aproximãri cu cîteva zeci
sau zecimale ale acestora.  Nu putem face mai bine de atît nici dacã
operãm cu reprezentãri simbolice ale numerelor reale (vom putea
manipula unele numere reale, dar nu pe toate; vor exista întotdeauna
operaþii cu numere reale care nu sunt calculabile).

<P>
Existã ºi alte consecinþe interesante ale acestui fapt.  De
exemplu, pute privi maºinile Turing ca pe niºte aparate care
calculeazã funcþii de la numerele naturale (<B>N</B>) la <B>N</B>.  Ei
bine, existã <!-- MATH
 $2^{|\mbox{\bf N}|}$
 -->
<IMG
 WIDTH="39" HEIGHT="26" ALIGN="BOTTOM" BORDER="0"
 SRC="img23.png"
 ALT="$2^{\vert\mbox{\bf N}\vert}$"> astfel de funcþii, adicã puterea
continuului (adicã tot atîtea cît numere reale).  Dar maºinile
Turing sunt doar în numãr de <!-- MATH
 $|\mbox{\bf N}|$
 -->
<IMG
 WIDTH="31" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$\vert\mbox{\bf N}\vert$">, deci mult mai
puþine.  Asta înseamnã cã <EM>existã o sumedenie de funcþii
<B>N <IMG
 WIDTH="23" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img25.png"
 ALT="$\rightarrow$"> N</B> care nu se pot calcula cu calculatoarele</EM>!

<P>
Ce dacã, veþi spune, poate toate funcþiile care ne intereseazã în
practicã se pot de fapt calcula.  Vom vedea de fapt cã existã
funcþii extrem de importante care <EM>nu</EM> sunt calculabile, oricît
de multe resurse am pune la bãtaie!

<P>

<H1><A NAME="SECTION02030000000000000000">
Problema opririi (the halting problem)</A>
</H1>

<P>
Ramura extremã a teoriei complexitãþii, care se ocupã cu lucrurile
care nu se pot calcula, nici dacã avem o cantitate nelimitatã de
resurse, se numeºte teoria calculabilitãþii. 

<P>
Teoria calculabilitãþii are o sumedenie de rezultate foarte
interesante, ºi implicaþii foarte mari pentru teoria compilatoarelor
(dar nu numai).

<P>
Am vãzut cã putem descrie orice maºinã Turing folosind un ºir de
caractere; putem apoi face prelucrãri asupra acestui ºir de
caractere, pentru a calcula tot felul de proprietãþi ale maºinii
Turing codificate astfel.  De fapt exact asta face ºi un compilator:
primeºte un program într-un limbaj (adicã descrierea unei maºini
Turing), ºi genereazã un alt program ``optimizat'', care face
acelaºi lucru, dar mai eficient.

<P>
Asta e foarte frumos: putem folosi chiar maºinile Turing pentru a
transforma ºi calcula lucruri despre maºini Turing.  Din pãcate
optimismul nostru trebuie temperat: sunt foarte multe lucruri pe care
nu le putem calcula.

<P>
De pildã ne putem pune, poate cea mai naturalã, întrebare: dacã
bag anumite date de intrare într-o maºina Turing, dupã cît timp
îmi dã rezultatul?  Îmi dã rezultatul vreodatã, sau intrã
într-o buclã infinitã?

<P>
La aceastã întrebare putem rãspunde enunþînd cea mai faimoasã
teoremã din teoria calculabilitãþii, ``teorema opririi'': <EM>nu
existã o maºinã Turing, care primind la intrare descrierea unei
alte maºini Turing T ºi un ºir de date de intrare x, sã poatã
spune dacã T se opreºte vreodatã cînd primeºte pe x la
intrare.</EM>  Figura&nbsp;<A HREF="complex-html.html#oprire">3</A>
ilustreazã problema opririi. 

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="oprire"></A><A NAME="315"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3:</STRONG>
Problema opririi: o ipoteticã maºinã care
ar putea rezolva problema opririi ar primi descrierile altei maºini
pe bandã sîa intrãrilor lor, ºi ar oferi un rãspuns ``da'' sau
``nu'', dupã cum maºina evaluatã terminã vreodatã execuþia sau
nu.</CAPTION>
<TR><TD><IMG
 WIDTH="451" HEIGHT="504" BORDER="0"
 SRC="img28.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{oprire.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Teorema asta a fost demonstratã de Alan Turing, în 1936, deci cu
mult înainte sã existe calculatoarele în sensul modern al
cuvîntului.

<P>
Demonstraþia teoremei opririi este extrem de simplã, ºi se face
prin reducere la absurd.  Demonstraþia este extrem de înruditã cu
celebrul paradox al mincinosului, cunoscut de grecii antici, care
spune cã fraza ``Eu mint'' nu poate fi nici adevãratã, nici falsã,
pentru cã în orice caz s-ar auto-contrazice.

<P>
Sã presupunem cã existã o maºinã H, care rezolvã problema
opririi.  Atunci vom construi o nouã maºinã, sã-i spunem H1,
care face urmãtorul lucru:

<P>

<OL>
<LI>Primeºte la intrare o maºinã M ºi un ºir x;

<P>
</LI>
<LI>Simuleazã funcþionarea lui H pe aceastã intrare, pentru a
vedea dacã M se opreºte atunci cînd primeºte pe x;

<P>
</LI>
<LI>Dacã H zice ``da, M se opreºte'', atunci H1 intrã
într-o buclã infinitã;

<P>
</LI>
<LI>Dacã H zice ``nu'', atunci H1 se opreºte imediat.
</LI>
</OL>

<P>
Din moment ce H1 este o maºinã Turing, putem sã o descriem ºi pe
ea însuºi folosind un ºir de caractere.  Ce se întîmplã însã
dacã pornim maºina H1 avînd pe banda de la intrare chiar propria
ei descriere, de douã ori, o datã pe post de M ºi o data pe post
de x?

<P>
Ei bine, dacã H1 se opreºte cu aceastã intrare, atunci înseamnã
cã H1 va executa pasul (3) de mai sus, deci intrã într-o buclã
infinitã, contradicþie!

<P>
Dacã H1 nu se opreºte niciodatã, atunciH1 va executa pasul
(4), deci se va opri imediat, altã contradicþie!

<P>
Aceste comportãri sunt aberante, deci presupunerea noastrã cã H1
existã trebuie sã fie falsã; dar H1 este construitã folosind
H ºi cîteva piese banale, deci H nu existã!

<P>
Acest rezultat este extrem de important pentru practicã.  Aceasta ne
spune cã nu vom putea niciodatã sã verificãm automat
corectitudinea <EM>oricãrui</EM> algoritm, pentru cã în general nu
putem spune dacã un algoritm se va termina vreodatã.

<P>

<H2><A NAME="SECTION02031000000000000000">
Consecinþe ale teoremei opririi</A>
</H2>

<P>
De asemenea, rezultã o serie întreagã de consecinþe foarte
importante.  Iatã unele dintre ele, din perspectiva teoriei
compilatoarelor:

<P>

<OL>
<LI>Este imposibil sã spunem dacã douã programe sunt echivalente
sau nu (adicã dacã produc aceleaºi rezultate cînd primesc
aceleaºi date de intrare);

<P>
</LI>
<LI>Este imposibil sã spunem dacã rezultatul unui program poate fi
vreodatã zero;

<P>
</LI>
<LI>Este imposibil sã spunem dacã toate accesele unui program
într-un vector de elemente sunt în interiorul vectorului, sau
programul poate accesa memorie nealocatã;

<P>
</LI>
<LI>Este imposibil sã spunem dacã un program este cel mai mic
program care implementeazã o anumitã funcþie.
</LI>
</OL>

<P>
Atenþie: nu vreau sã spun cã aceste lucruri sunt nedecidabile
pentru <EM>orice</EM> program: e clar cã douã programe Pascal identice
sunt echivalente.  Ceea ce aceastã teoremã spune, este cã existã
programe pentru care aceste lucruri nu pot fi determinate.

<P>
Dacã restrîngem setul de programe pe care-l putem scrie, atunci
putem desigur demonstra mai multe lucruri despre programele noastre.
De exemplu, în limbajul Java, suntem asiguraþi de faptul cã un
program nu va accesa niciodatã memorie nealocatã, pentru cã
înainte de a verifica orice acces la memorie, maºina virtualã Java
verificã dacã aceasta a fost alocatã sau nu.

<P>
Dar e vorba de limbaje diferite de intrare: programele scrise în Java
sunt un subset al tuturor programelor.

<P>

<H2><A NAME="SECTION02032000000000000000">
Semi-decidabilitate</A>
</H2>

<P>
Dupã cum am vãzut, existã probleme pentru care nu putem niciodatã
calcula rãspunsul.  

<P>
Putem însã identifica printre problemele indecidabile o submulþime,
a problemelor semi-decidabile, acele probleme pentru care putem
calcula ``jumãtate'' de rãspuns: putem rãspunde întotdeauna corect
cînd suntem întrebaþi de o instanþã ``da'', dar cînd suntem
întrebaþi de o instanþã ``nu'' s-ar putea sã dãm rãspunsul
corect, sau s-ar putea sã nu terminãm niciodatã de calculat.

<P>
Problema opririi este de fapt o problema semi-decidabilã: dacã ni se
dã o maºinã M ºi un ºir x pentru care maºina se opreºte,
vom fi capabili sã descoperim acest lucru simulînd funcþionarea
maºinii M cu intrarea x pînã atinge starea finalã.  Dacã M
însã nu se opreºte cînd primeºte pe x, nici simularea nu se va
termina niciodatã.

<P>

<H1><A NAME="SECTION02040000000000000000">
Oracole</A>
</H1>

<P>
O întrebare interesantã este urmãtoarea: sunt tot felul de probleme
indecidabile; dar sunt cumva unele dintre ele mai grele decît altele?
Poate sã parã ciudat cã întrebãm astfel de lucruri despre
probleme pe care oricum nu le putem rezolva, dar rãspunsul este ºi
mai surprinzãtor.

<P>
Contextul matematic pentru a formula aceste întrebãri este numit al
``oracolelor''.  Putem gãsi o interpretare filozoficã interesantã
pentru acest gen de construcþii: sã zicem cã facem un pact cu
diavolul, care ne va rãspunde corect la anumite întrebãri
nedecidabile.  De pildã, ne va da întotdeauna rãspunsul corect la
întrebãri despre oprirea unei maºini Turing.  Vedeþi, rãspunsul
<EM>existã</EM>, orice maºinã fie se opreºte, fie nu se opreºte,
ceea ce nu existã este o metodã de a <EM>calcula</EM> rãspunsul.  Sã
zicem cã Mefistofel însã ne poate da rãspunsul, folosind puterile
sale supranaturale.

<P>
Vom vedea cã noþiunea de oracol este foarte utilã nu numai atunci
cînd vrem rãspunsuri la întrebãri nedecidabile, ci ºi atunci
cînd vrem rãspunsuri la întrebãri pentru care nu avem destule
resurse.  Mai multe despre asta în partea a doua a acestui articol,
în numãrul viitor al revistei.

<P>
Matematic, un oracol este o a doua bandã pentru maºina noastrã, pe
care sunt scrise dinainte rãspunsurile (corecte!) la întrebãrile pe
care maºina le pune (vedeþi figura&nbsp;<A HREF="complex-html.html#oracol">4</A>).

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="oracol"></A><A NAME="321"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 4:</STRONG>
Maºini cu Oracole: un oracol este o anumitã
funcþie pe care maºina nu o poate calcula, dar de care se poate
folosi.  Matematic modelãm oracolul printr-o bandã infinitã, pe
care sunt dinainte scrise rãspunsurile corecte la toate întrebãrile
pe care maºina le-ar putea pune.  În general ne intereseazã sã
vedem ce ar putea face în mod suplimentar o maºina Turing dacã ar
putea rãspunde unor anumite întrebãri (dar nu <EM>oricãrei</EM>
întrebãri); atunci o echipãm cu un oracol care ºtie toate
rãspunsurile la întrebãrile în chestiune.</CAPTION>
<TR><TD><IMG
 WIDTH="438" HEIGHT="247" BORDER="0"
 SRC="img32.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{oracol.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION02041000000000000000">
Ierarhia aritmeticã</A>
</H2>

<P>
Dacã avem un oracol, mai existã lucruri pe care nu le putem calcula?
Exista alte întrebãri la care nu putem rãspunde?

<P>
Ei bine,  da.  Existã întrebãri care sunt în continuare
ne-decidabile.  De exemplu, întrebarea ``este limbajul acceptat de
maºina M finit'' nu poate fi elucidatã nici în prezenþa unui
oracol pentru problema opririi.

<P>
Dar dacã presupunem cã avem un oracol care ne rãspunde ºi la
aceastã întrebare?  Mai existã ºi altceva care nu se poate
calcula?  Din nou, rãspunsul este ``da'': de exemplu nu putem
rãspunde nici acum la întrebarea ``este limbajul acceptat de maºina
M co-finit'' (adicã ºirurile ne-acceptate sunt în numãr finit).

<P>
ªi aºa mai departe: existã o ierarhie infinitã maºini de oracole
din ce în ce mai puternice, care pot rãspunde la aceste întrebãri,
dar care sunt neputincioase în faþa unor întrebãri mai complicate.
Aceastã ierarhie de probleme ne-decidabile se numeºte <EM>ierarhia
aritmeticã</EM>.

<P>

<H1><A NAME="SECTION02050000000000000000">
Concluzii</A>
</H1>

<P>
Voi încheia aici prima parte a acestui articol.  Subiectele
prezentate aici pot fi caracterizate ca fãcînd parte din pre-istoria
teoriei complexitãþii: sunt fapte cunoscute începînd din anii 1920
pînã prin deceniul ºase al secolului nostru.  În numãrul urmãtor
din PC Report îmi voi apleca atenþia asupra evoluþiilor recente din
domeniu, care sunt extrem de spectaculoase, ºi voi privi cu mai
multã atenþie problemele care se pot ataca avînd resurse limitate.

<P>
În textul de faþã am studiat mai mult problemele care nu se pot
rezolva, oricît de multe resurse computaþionale am avea la
dispoziþie, numite probleme indecidabile.  Am vãzut cã foarte multe
probleme practice sunt indecidabile; mai ales problemele care privesc
programele însele.

<P>
Dar importanþa acestui articol constã mai ales în faptul cã aratã
<EM>cum</EM> se pot formaliza foarte precis noþiunile de proces de
calcul ºi funcþie calculatã de un program, în aºa fel încît sã
le putem supune ochiului scrutãtor al matematicii.

<P>

<H1><A NAME="SECTION02060000000000000000">
Alte surse de informaþie</A>
</H1>

<P>
Cititorilor care doresc sã aprofundeze aceste subiecte le recomand
urmãtoarele cãrþi:

<P>
Automata and Computability, Dexter Kozen, Springer Verlag, 1996.

<P>
Computational Complexity, C. H. Papadimitriou, Addison-Wesley, 1994.

<P>
Introduction to Automata Theory, Languages and Computation,
J. E. Hopcroft and J. D. Ullman, Addison-Wesley, 1979.

<P>

<H1><A NAME="SECTION03000000000000000000">
Teoria clasicã a complexitãþii</A>
</H1>

<P>
Acest text este partea a doua a unui foileton despre teoria
complexitãþii, cea mai abstractã ramurã a informaticii.  Deºi
încerc ca fiecare articol din serie sã fie de sine-stãtãtor, o
vedere de ansamblu poate fi obþinutã parcurgîndu-le pe toate;
textele anterioare sunt disponibile (pe lîngã revista PC Report) ºi
din pagina mea de web.  

<P>
Am consacrat acestei teme douã texte în lunile octombrie ºi
noiembrie, despre problema satisfiabilitãþii boolene, ºi numãrul
din decembrie al revistei, care introducea obiectele de bazã cu care
opereazã teoria complexitãþii, dupã care discuta despre
calculabilitate.

<P>
Cu aceastã ocazie vreau sã fac ºi o corecturã: teorema pe care am
prezentat-o în numãrul anterior ca ``teorema gãurii'' este de fapt
numitã teorema ierarhiei; enunþul teoremei gãurii este altul, dar
nu o sã-l prezint aici.

<P>

<H1><A NAME="SECTION03010000000000000000">
Recapitulare</A>
</H1>

<P>
Voi reaminti cititorilor cã teoria complexitãþii discutã despre
ceea ce se poate calcula ºi nu se poate calcula atunci cînd avem
anumite resurse la dispoziþie.  Teoria calculabilitãþii discutã
cazul extrem al lucrurilor care nu se pot calcula deloc, chiar dacã
avem la dispoziþie o cantitate infinitã de resurse.  În mod
surprinzãtor, existã foarte multe lucruri care nu se pot calcula,
aºa cum am arãtat în articolul anterior.

<P>
Pentru a putea discuta precis despre ce se poate calcula, teoria
complexitãþii opereazã cu niºte modele matematice ale maºinilor
de calcul, descrise sub forma unor automate simple, care comunicã cu
lumea exterioarã folosind niºte benzi pe care sunt scrise litere,
ºi care au o unitate de control cu un numãr finit de reguli, care
indicã automatului care este pasul urmãtor de fãcut în fiecare
circumstanþã.

<P>
Modelul cel mai ades folosit este cel al maºinii Turing, numite în
cinstea marelui matematician englez, Alan Turing.  Turing a fost unul
dintre pionierii acestei teorii; el este însã mai cunoscut prin
activitatea lui din al doilea rãzboi mondial, cînd a contribuit la
spargerea cifrurilor maºinii Enigma, care cripta comunicaþiile
Germaniei naziste.  Munca lui Turing a permis aliaþilor sã
intercepteze informaþii foarte importante despre miºcãrile maºinii
de rãzboi germane.

<P>
Turing era un matematician de excepþie, care studiase la Princeton cu
Albert Einstein, ºi colaborase cu John von Neumann, pãrintele
american al calculatoarelor.  Din nefericire soarta lui Turing a fost
tragicã: contribuþiile sale militare din al doilea rãzboi mondial
au rãmas confidenþiale pentru multã vreme; dupã rãzboi a fost
condamnat pentru homosexualitate, ºi forþat sã urmeze un tratament
hormonal, despre care autoritãþile timpului credeau cã poate
``vindeca'' aceastã ``boalã''.  Influenþa medicamentelor ºi
umilirea înduratã însã au fost prea mult pentru Turing, care s-a
sinucis înghiþind cianura, în 1954, la doar 42 ani.  În cinstea
sa, cel mai important premiu care recunoaºte contribuþiile în
domeniul informaticii, decernat anual de prestigioasa asociaþie ACM
(Association for Computing Machinery), este numit premiul Turing.

<P>
În mod interesant, deºi maºina Turing este un mecanism foarte
``primitiv'', nimeni nu a reuºit sã sugereze un model de calcul mai
puternic.  În mãsura în care funcþionarea neuronilor din creierul
uman este cea descrisã de neurofiziologi, creierul însuºi poate fi
simulat cu o maºinã Turing (dar existã mult mai multe necunoscute
decît certitudini în ceea ce priveºte funcþionarea creierului).
Dacã acceptãm aceastã ipotezã (numitã ºi teza lui Church), putem
privi rezultatele teoriei complexitãþii ca pe niºte reguli
universale, care privesc toate ``aparatele'' care proceseazã
informaþie în univers.

<P>
Sã ne mai amintim cã obiectele procesate de maºinile Turing sunt
limbaje, adicã mulþimi de cuvinte.  O maºinã Turing primeºte la
intrare un cuvînt dintr-un anumit limbaj, ºi produce la ieºire un
cuvînt dintr-un alt limbaj, care este rãspunsul aºteptat.  Dacã
rãspunsurile sunt doar ``da'' sau ``nu'' (adicã un singur bit),
atunci spunem cã maºina Turing decide limbajul format din toate
cuvintele pentru care rãspunsul este ``da''.

<P>

<H1><A NAME="SECTION03020000000000000000">
Pietre de hotar</A>
</H1>

<P>
Putem împãrþi istoria teoriei complexitãþii, de la origini pînã
în prezent, în cinci etape mari.  Iatã-le descrise pe scurt:

<P>

<H2><A NAME="SECTION03021000000000000000">
Programul formalist al lui Hilbert</A>
</H2>

<P>
Putem considera ca pãrinte al teoriei complexitãþii pe marele
matematician german David Hilbert (1862-1943).  Hilbert a încercat
sã fundamenteze matematica pe baze axiomatice; el a recunoscut faptul
cã între logicã ºi matematicã existã o relaþie foarte
strînsã; el a observat cã demonstrarea oricãrei probleme din
matematicã se poate reduce la verificarea satisfiabilitãþii unei
formule din calculul predicativ<A NAME="tex2html8"
  HREF="#foot295"><SUP>2</SUP></A>.

<P>
Hilbert vedea ca încununare a matematicii producerea unui algoritm
care ar putea sã rezolve problema satisfiabilitãþii, care ar putea
fi atunci folosit pentru a demonstra în mod mecanic orice teoremã.

<P>

<H2><A NAME="SECTION03022000000000000000">
Teorema lui Gödel ºi teorema lui Turing</A>
</H2>

<P>
Visele lui Hilbert au fost însã spulberate de matematicianul Kurt
Gödel ºi faimoasa sa teoremã de incompletitudine.  Gödel a
arãtat cã un algoritm de decizie pentru satisfiabilitate <EM>nu
existã</EM>, pentru orice sistem axiomatic care este suficient de
cuprinzãtor pentru a descrie mulþimea numerelor naturale ºi
operaþiile aritmetice pe ea.  Dacã operãm cu structuri mai simple,
ca algebra booleanã, introdusã în articolul nostru despre
satisfiabilitate, problema este decidabilã; dacã însã structura
matematicã este suficient de bogatã, (ºi mulþimea numerelor
naturale este în definitiv o structurã foarte simplã, fãrã de
care cu greu putem vorbi de matematicã evoluatã), existã
propoziþii adevãrate care <EM>nu pot fi demonstrate matematic</EM>.
Voi clarifica într-un alt episod semnificaþia acestui enunþ.

<P>
O altã problemã fundamentalã, propusã de Hilbert, era de a
verifica dacã un sistem dat de axiome este consistent sau nu (cu alte
cuvinte, dacã axiomele nu se contrazic între ele).  De exemplu,
ºtim din liceu cã axioma paralelelor a lui Euclid, din geometria
planã, este independentã de celelalte axiome ale geometriei, ºi cã
putem construi geometrii în care aceastã axiomã este adevãratã,
precum ºi geometrii perfect coerente în care axioma este falsã.
Hilbert îºi dorea posibilitatea de a verifica dacã nu cumva un
sistem ales de axiome se contrazice pe sine.  A doua teoremã de
incompletitudine a lui Gödel a sfãrîmat ºi acest vis al lui
Hilbert, demonstrînd cã este imposibil de demonstrat consistenþa
unui sistem de axiome raþionînd doar în interiorul sistemului (cu
alte cuvinte, nu putem demonstra consitenþa axiomelor pornind doar de
la acele axiome); dacã vrem sã facem acest lucru, trebuie sã
raþionãm într-un sistem mai cuprinzãtor decît cel studiat.  Avem
astfel o reducere infinitã, pentru cã putem pune apoi chestiunea
consistenþei sistemului mai cuprinzãtor, etc.

<P>

<H2><A NAME="SECTION03023000000000000000">
Teorema lui Cook ºi NP-completitudinea</A>
</H2>

<P>
Cu timpul oamenii s-au obiºnuit cu ideea ca sunt lucruri care nu se
pot calcula.  Despre cele care se puteau calcula însã erau convinºi
cã sunt la-ndemînã.  Teoria complexitãþii însã a arãtat cã
fiecare problemã are o complexitate inerentã; anumite probleme se
pot rezolva repede, altele mai greu.  Existã probleme care au o
complexitate exponenþialã: dacã creºti datele de intrare cu o
constantã, timpul de calcul se dubleazã.  Astfel de probleme devin
foarte repede intractabile: dacã creºtem problema de 100 de ori,
complexitatea creºte de 2<sup>100</sup> ori, depãºind astfel vîrsta
estimatã a universului!  Chiar dacã începeam sã calculãm la
Big Bang, astãzi tot n-am fi terminat!

<P>
Teorema lui Cook, demonstratã în 1971, a turnat ºi mai mult gaz
peste foc: existã foarte multe probleme care au soluþii simple, ºi
uºor de verificat (adicã putem verifica foarte eficient dacã o
pretinsã soluþie este corectã), dar pentru care nimeni nu ºtie
<EM>cum</EM> sã gãseascã o soluþie suficient de rapid!

<P>
Din acel moment, problema centralã a teoriei complexitãþii s-a
mutat în aceastã zonã: am renunþat sã mai rezolvãm problemele
inerent grele, putem oare mãcar rezolva acest gen de probleme, ale
cãror soluþii se pot verifica uºor?  Aceste probleme formeazã o
clasã numitã <B>NP</B>, despre care vom vorbi mai mult în cuprinsul
acestui articol.  Întrebarea centralã a teoriei complexitãþii este
dacã <B>P</B>=<B>NP</B>.  (P este clasa problemelor pe care le putem rezolva
rapid.)

<P>
S-au publicat mai multe demonstraþii eronate ale ambelor aserþiuni:
<B>P</B>=<B>NP</B> ºi <B>P</B> <IMG
 WIDTH="19" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$\not=$"> <B>NP</B>.  Deocamdatã rãspunsul rãmîne un
mister.  Teoreticienii au atacat problema din tot felul de
perspective, încercînd sã demonstreze cã pentru problemele din
<B>NP</B> sunt necesare strict mai multe resurse decît pentru cele din
<B>P</B>; 
atunci am ºti cã cele douã clase sunt diferite.  Desigur, doar
existenþa unei diferenþe între cele douã clase nu este totul
pentru practicieni, dacã nu ºtim ºi cît de mare este aceastã
diferenþã.  Tot ce ºtim este cã <B>NP</B> este cuprinsã între <B>P</B>
ºi <B>EXP</B>; <B>P</B> este clasa problemelor cu o complexitate
polinomialã, 
iar <B>EXP</B> cea a problemelor cu complexitate exponenþialã; între 
aceste douã clase existã o sumedenie de clase intermediare, de
exemplu cea a problemelor cvasi-polinomiale, care sunt mai mari decît
cele polinomiale, dar mai mici decît cele exponenþiale (de exemplu
funcþia n<sup>log n</sup>).  Chiar un rezultat care ar separa <B>NP</B> de
<B>EXP</B> ar fi grozav, pentru cã ne-ar da soluþii pentru problemele din
<B>NP</B> mai bune decît cunoaºtem la ora actualã.

<P>
Teoreticienii aveau practic douã scule fundamentale în repertoriu
pentru a raþiona despre complexitate: diagonalizarea ºi simularea,
ambele prezentate pe scurt în prima parte a acestui articol, în
numãrul anterior al revistei.

<P>
Simularea se foloseºte de faptul cã o maºinã Turing adesea se
poate comporta ca o altã maºinã Turing, ``simulîndu-i'' execuþia.
Aceastã tehnicã se numeºte în viaþa de zi cu zi ``interpretare'',
ºi este exact ceea ce se întîmplã cu limbajele interpretate:
BASIC, Lisp, etc: interpretorul de BASIC simuleazã execuþia
programelor scrise în BASIC.

<P>
Diagonalizarea este o tehnicã foarte ingenioasã pentru a arãta cã
un obiect nu este într-o mulþime, pentru cã este diferit de fiecare
obiect din mulþime printr-o anumitã trãsãturã.  

<P>
Teoreticienii au încercat sã demonstreze cã <B>P</B> <IMG
 WIDTH="19" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$\not=$"> <B>NP</B> arãtînd cã maºinile din <B>NP</B> sunt diferite de toate maºinile din
<B>P</B>.  Dar aceste încercãri au fost brusc curmate de un rezultat
ºocant.

<P>

<H2><A NAME="SECTION03024000000000000000">
Teorema lui Solovay; relativizare</A>
</H2>

<P>
În 1977 logicianul Solovay a demonstrat o teoremã foarte
importantã, care a arãtat cã orice metodã bazatã pe diagonalizare
ºi simulare este sortitã eºecului.  Este deci un fel de
meta-teoremã, care aratã cã o întreagã clasã de metode de
demonstraþie sunt neputincioase în a diferenþia <B>P</B> de <B>NP</B>.
Acest rezultat a paralizat complet cercetarea din domeniu pentru
cîþiva ani.  Voi încerca sã prezint aici esenþa argumentului.

<P>
În episodul anterior am introdus noþiunea de maºinã Turing
echipatã cu un oracol.  Un oracol este un mecanism (fictiv) care
permite unei maºini Turing sã rezolve anumite probleme instantaneu.
Putem vedea un oracol ca pe o subrutinã, care se terminã
instantaneu, ºi care poate calcula rãspunsul la o anumitã
întrebare.  De exemplu, un oracol pentru problema primalitãþii unui
numãr este un dispozitiv care ne spune instantaneu dacã numãrul
este prim sau nu.

<P>
În acelaºi fel, un oracol pentru clasa <B>NP</B> este un dispozitiv care
rãspunde instantaneu la orice întrebare din clasa <B>NP</B>.  Dacã vã
deranjeazã aceastã abstracþie matematicã, imaginaþi-vã cã este
o subrutinã oricît de complicatã, dar al cãrei timp de execuþie
nu se cronometreazã.  Deºi abstracte, oracolele sunt  niºte scule
foarte utile pentru teorie, dupã cum vom vedea din teorema lui
Solovay.

<P>
Mai introducem o notaþie: dacã o maºinã Turing M are un oracol
pentru problema X, atunci notãm maºina cu M<sup>X</sup>.  Asta înseamnã
deci cã M poate calcula ca orice maºinã Turing obiºnuitã, dar
în plus poate rãspunde imediat la orice întrebare din X.

<P>
Teorema lui Solovay arãta cã existã douã oracole A ºi B care
au urmãtoarele proprietãþi: P<SUP>A</sup> = NP<sup>A</sup>, dar <!-- MATH
 ${\bf P}^B \not= {\bf NP}^B$
 -->
<IMG
 WIDTH="96" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="${\bf P}^B \not= {\bf NP}^B$">.
Asta înseamnã cã existã oracole care fac maºinile din <B>NP</B> mai
puternice decît cele din <B>P</B>, ºi existã oracole care fac ambele
tipuri de maºini la fel de puternice.

<P>
De ce este aceastã teoremã catastrofalã?  Pentru cã s-a arãtat
cã orice argument bazat pe diagonalizare sau simulare rãmîne
adevãrat atunci cînd maºinilor li se aplicã oracole.  Cu alte
cuvinte, dacã arãtãm prin diagonalizare cã o maºinã X nu este
într-o anumitã clasã C, atunci pentru orice oracol Q vom ºti
sîcã X<sup>Q</sup> nu este în clasa C<sup>Q</sup>.  Acest fenomen se
numeºte <EM>relativizare</EM>: teoremele care sunt demonstrate prin
diagonalizare sau 
simulare sunt adevãrate ºi atunci cînd maºinile din teoremã
capãtã oracole, deci teoremele sunt adevãrate relativ la orice
oracol.

<P>
Acum este clar de ce teorema a fost o veste foarte proastã: nu avem
nici o ºansã sã arãtãm cu aceste tehnici cã <B>P</B> = <B>NP</B>, pentru cã
aplicînd oracolul B de mai sus, am arãta automat cã P<sup>B</sup> = NP<sup>B</sup>,
ceea ce e nu poate fi adevãrat, conform teoremei lui Solovay.  La fel
stau lucrurile ºi pentru propoziþia opusã: <!-- MATH
 ${\bf P}\not= {\bf NP}$
 -->
<IMG
 WIDTH="72" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.png"
 ALT="${\bf P}\not= {\bf NP}$"> nu poate
fi demonstratã prin aceste tehnici, pentru cã oracolul A ar
contrazice acest rezultat.

<P>

<H2><A NAME="SECTION03025000000000000000">
Teorema lui Razborov-Rudich; demonstraþii naturale</A>
</H2>

<P>
Mulþi cercetãtori au fost foarte descurajaþi de acest rezultat, ºi
au abandonat studiul teoriei complexitãþii cu totul.  Toate sculele
pe care le aveau la dispoziþie erau inutile!  Încetul cu încetul
însã comunitatea ºi-a ieºit din apatie, ºi o nouã tehnologie de
demonstraþie a fost dezvoltatã.  Ultima parte a acestui articol va
discuta despre aceastã tehnologie mai pe larg, dar o sã o introduc
aici pe scurt.

<P>
Este clar cã metoda care este folositã nu trebuie sã sufere de
relativizare, pentru cã atunci conform teoremei lui Solovay ea este
neputincioasã în a diferenþia <B>P</B> ºi <B>NP</B>.

<P>
Cercetãtorii au început atunci sã opereze cu un alt model
computatîonal, cel al <EM>circuitelor</EM> neuniforme.  Acestea nu sunt
altceva decît niºte circuite combinaþionale, precum cele folosite
în construcþia calculatoarelor, formate din porþi logice ``sau'',
``ºi'', ``nu''.  Circuitele acestea primesc datele la intrare, ºi
genereazã rãspunsul la ieºire.  Pentru fiecare mãrime de date de
intrare avem de-a face cu un alt circuit: pentru datele de intrare de
mãrime 2 vom avea un circuit cu douã intrãri, pentru datele de
mãrime 3 vom avea un circuit cu 3 intrãri, etc<A NAME="tex2html9"
  HREF="#foot183"><SUP>3</SUP></A>.

<P>
Cercetarea pãrea sã fie pe calea cea bunã; cercetãtorii vroiau sã
demonstreze cã <B>P</B> <IMG
 WIDTH="19" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$\not=$"> <B>NP</B> arãtînd cã circuitele pentru probleme
<B>NP</B> au nevoie de niºte proprietãþi suplimentare pentru a putea
calcula, comparat cu cele din clasa <B>P</B>; de exemplu sperau sã arate cã
orice problemã din <B>P</B> se poate rezolva cu circuite de o anumitã
``adîncime'', pe cînd pentru <B>NP</B>este nevoie de mai mult de atît.

<P>
Rezultatele curgeau unul dupã altul, aparent apropiindu-se de þinã.
O loviturã de teatru însã a urmat în 1994: matematicianul rus
Razborov ºi americanul Steven Rudich au demonstrat o a doua teoremã
de relativizare, care a avut un ºoc comparabil cu cel al teoremei lui
Solovay.  Aceastã teoremã este tehnic mai complicatã decît cea a
lui Solovay, dar voi încerca sã expun aici esenþa ei.

<P>
Teorema Razborov-Rudich introduce noþiunea de demonstraþii
``naturale'' (natural proofs), care manipuleazã circuitele boolene
într-un anumit fel.  Apoi cei doi trec în revistã toate rezultatele
majore ºi aratã cã demonstraþiile folosite sunt naturale, sau
echivalente cu demonstraþii naturale.

<P>
Apoi cei doi demonstreazã un rezultat foarte interesant, pe care îl
voi parafraza simplificat: dacã existã probleme în <B>NP</B> mai grele
decît cele din <B>P</B> (adicã <B>P</B> <IMG
 WIDTH="19" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$\not=$"> <B>NP</B>), atunci <EM>nu exista</EM>
demonstraþii naturale cã <B>P</B> <IMG
 WIDTH="19" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$\not=$"> <B>NP</B>!  Cu alte cuvinte, dacã
faptul pe care vrei sã-l demonstrezi este adevãrat, atunci nu poþi
sã-l demonstrezi, cel puþin nu în acest fel!

<P>

<H2><A NAME="SECTION03026000000000000000">
Situaþia actualã</A>
</H2>

<P>
Aceasta este situaþia la ora actualã în teoria complexitãþii.
Cel puþin pe frontul <B>P</B>=<B>NP</B>, activitatea este din nou înþepenitã:
în lipsa unei tehnici noi de demonstraþie, orice efort este sortit
dinainte eºecului!

<P>
Desigur, aºa cum aratã teorema de incompletitudine a lui Gödel,
în orice sistem axiomatic existã teoreme adevãrate care nu pot fi
demonstrate.  Este posibil ca chiar teorema <B>P</B> <IMG
 WIDTH="19" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$\not=$"> <B>NP</B> sã fie o
astfel de teoremã!  Mai precis, este posibil ca acest enunþ sã fie
<EM>independent</EM> de teoria axiomaticã a mulþimilor Zermelo-Frankel.
Atunci clar nu existã nici o demonstraþie a acestui fapt (ori a
opusului lui), ºi singurul lucru pe care-l putem face este sã luãm
un astfel de enunþ ca pe o axiomã!

<P>
Mulþi cercetãtori însã cred cã aceastã problemã nu este
independentã, ºi sperã în continuare sã gãseascã un rãspuns.
Pe ce cale se va face aceasta, la ora actualã este complet neclar.

<P>

<H1><A NAME="SECTION03030000000000000000">
Reduceri ºi completitudine</A>
</H1>

<P>
În restul acestui articol ne vom ocupa de a doua perioadã din
istoricul de mai sus; vom vedea o sumã de rezultate obþinute de
teoreticieni, vom studia impactul a trei tipuri de resurse asupra
calculului: spaþiul, timpul ºi oracolele, ºi vom vedea o serie
întreagã de probleme nerezolvate, unele de o mare importanþã
practicã.

<P>
Vom introduce pentru început douã noþiuni fundamentale în teoria
complexitãþii: cea de reducere între probleme ºi cea de
completitudine a unei probleme într-o clasã de complexitate.

<P>

<H2><A NAME="SECTION03031000000000000000">
Reduceri</A>
</H2>

<P>
Am întîlnit noþiunea de reducere ºi în textul meu anterior despre
problema satisfiabilitãþii.  De data asta vom studia însã un caz
mai general.

<P>
Noþiunea de reducere este foarte ades folositã în matematicã, unde
spunem în mod frecvent cã ``o problemã transformatã într-un anume
fel se reduce la o alta''.  În teoria complexitãþii reducerea este
însã tot un proces de calcul, care transformã instanþe ale unui
probleme în instanþe ale alteia.  Ca orice procesare fãcutã de
automatele de care ne interesãm, reducerile transformã un limbaj
într-altul. 

<P>
În teoria complexitãþii ne intereseazã foarte mult ºi cît de
multe resurse consumã procesul de reducere.  În general vrem ca
reducerea însãºi sã fie mai simplã decît problema iniþialã sau
cea finalã; degeaba reducem o problemã de complexitate polinomialã
la alta dacã reducerea consumã un timp exponenþial!

<P>
Dacã problema A se reduce la problema B folosind o reducere de
complexitate m, notãm acest fapt cu <IMG
 WIDTH="69" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img49.png"
 ALT="$A \leq_{m} B$">.  Folosirea
semnului <IMG
 WIDTH="19" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$\leq$"> (mai mic sau egal) nu este întîmplãtoare: în
general o reducere induce o relaþie de ordine pe mulþimea
problemelor, fiind reflexivã (o problemã se reduce la sine
însãºi) ºi tranzitivã (dacã <IMG
 WIDTH="69" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.png"
 ALT="$A \leq_m B$"> ºi <IMG
 WIDTH="70" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="$B \leq_m C$">,
atunci <IMG
 WIDTH="69" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img53.png"
 ALT="$A \leq_m C$">).  Dacã douã probleme se reduc una la alta,
spunem cã sunt la fel de grele: <IMG
 WIDTH="69" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.png"
 ALT="$A \leq_m B$"> ºi <IMG
 WIDTH="69" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img54.png"
 ALT="$B \leq_m A$">, atunci A e la fel de grea ca B (aceasta este
 proprietatea de antisimetrie a relaþiei).  În general proprietatea de
 simetrie nu este adevãratã: dacã A se reduce la B, B nu se reduce neapãrat la
A; B poate sã fie mai grea decît A.

<P>
Odatã ce avem o noþiune de reducere, putem defini completitudinea
unei probleme referitoare la o clasã.  Dacã avem colecþia de
probleme X, ºi o problemã <IMG
 WIDTH="56" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$A \in X$">, atunci spunem cã A este
completã în X, sau A este X-completã, vis-a-vis de o reducere
cu complexitatea m, dacã pentru orice problemã <IMG
 WIDTH="57" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.png"
 ALT="$B \in X$">, <IMG
 WIDTH="69" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img54.png"
 ALT="$B \leq_m A$">.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="completitudine"></A><A NAME="383"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 5:</STRONG>
În aceastã figurã mulþimea de
probleme A are un set de probleme C care sunt A-complete.  Asta
înseamnã cã rezolvarea oricãrei probleme din A se reduce la o
problemã din C.  Dacã A include o sub-clasã B, atunci dacã B se
intersecteazã cu C, atunci B=A, în sensul cã ambele clase sunt la
fel de grele.  Singura posibilitate ca B sa fie diferit de A este ca B
sa nu se intersecteze cu C.  Aceste relaþii stau la baza multor
încercãri de a demonstra ca P = <B>NP</B>(sau opusul).</CAPTION>
<TR><TD><IMG
 WIDTH="103" HEIGHT="189" BORDER="0"
 SRC="img57.png"
 ALT="\begin{figure}\centerline{\epsfxsize=2.3cm\epsffile{completitudine.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H1><A NAME="SECTION03040000000000000000">
Clase de complexitate importante</A>
</H1>

<P>
Deocamdatã punem deoparte noþiunea de reducere, ºi discutãm
clasele de complexitate cele mai importante studiate.  Pentru fiecare
din aceste clase se cunosc probleme complete.  Vom prezenta clasele
în ordinea crescãtoare a complexitãþii lor; cel mai adesea însã
relaþia realã între clase consecutive este necunoscutã.

<P>

<H2><A NAME="SECTION03041000000000000000">
Spaþiu constant</A>
</H2>

<P>
Prima clasã interesantã de complexitate este cea a maºinilor care
folosesc o cantitate fixã de spaþiu pentru a-ºi face calculele,
care cantitate este independentã de mãrimea datelor de intrare.
Chiar cînd datele de intrare tind la infinit, maºina foloseºte la
fel de puþin spaþiu.

<P>
Un fapt interesant despre aceastã clasã este cã, de fapt, dacã dai
unei maºini spaþiu constant, nu are ce face cu el: existã o altã
maºinã care face acelaºi lucru fãrã nici un fel de spaþiu
suplimentar.  Existã un nume special pentru maºinile Turing care nu
folosesc nici un fel de spaþiu pe bandã (în afarã de a citi ºirul
de la intrare): ele se numesc automate finite.  

<P>
Toate limbajele care se pot decide în spaþiu constant se numesc
limbaje regulate.  Aceste limbaje sunt extrem de importante în
practicã; existã o seamã întreagã de medii de programare care
manipuleazã limbaje regulate.  Programe ºi interpretoare faimoase
care manipuleazã limbaje regulate sunt Perl, Lex, grep, awk, sed,
etc.  Perl este de pildã limbajul preferat pentru a scrie extensii
pentru serverele de web de pe Internet.

<P>
Limbajele regulate sunt atît de utile pentru cã se demonstreazã cã
ele pot fi acceptate în timp linear: cu alte cuvinte pentru orice
limbaj regulat existã o maºinã Turing care decide un cuvînt de
lungime n în timp O(n).  Acest  timp este practic cel mai mic
timp posibil, pentru cã în mai puþin de O(n) nu putem nici mãcar
citi toate literele de la intrare!

<P>
Un exemplu de limbaj regulat ne-trivial: adunarea.  Dacã primim trei
numere, a, b, c, scrise întreþesut pe bandã (adicã o cifrã
de la a, una de la b, una de la c, atunci putem verifica
folosind un automat finit dacã c = a+b.

<P>

<H2><A NAME="SECTION03042000000000000000">
Spaþiu logaritmic</A>
</H2>

<P>
O clasã foarte interesantã de complexitate este cea a limbajelor
care pot fi acceptate folosind spaþiu logaritmic în lungimea
cuvîntului de intrare.  Pentru orice cuvînt de lungime n maºina
foloseºte nu mai mult de O(log n) celule de memorie pentru a
procesa cuvîntul.

<P>
Clasa aceasta se noteazã cu <B>L</B>, de la Logaritm.  Se aratã cã
aceastã clasã este strict mai cuprinzãtoare decît cea a limbajelor
regulate: existã limbaje ne-regulate în <B>L</B>.

<P>
De ce folosim tocmai logaritmul?  În spaþiu logaritmic maºina poate
manipula un numãr finit de <EM>contoare</EM> a cãror valoare este
cuprinsã între 1 ºi n (fiecare contor are log n cifre).  Putem
spune deci cã clasa <B>L</B> este cea a maºinilor care au nevoie doar sã
þinã minte cîteva poziþii din ºirul de intrare, ºi nimic mai
mult.

<P>
Ce putem face în spaþiu logaritmic?  O mulþime de lucruri!  De
pildã putem înmulþi douã numere: folosim contoare pentru a parcurge
numerele de înmulþit, ºi pentru a face adunarea de la dreapta la
stînga.

<P>
O altã problemã foarte importantã pe care o putem rezolva doar în
spaþiu logaritmic este de a calcula valoarea unei formule boolene,
atunci cînd cunoaºtem valorile tuturor variabilelor care o compun.

<P>

<H2><A NAME="SECTION03043000000000000000">
Timp polinomial</A>
</H2>

<P>
Cea mai folositã clasã de complexitate este cea a timpului
polinomial, notatã cu <B>P</B>.  Putem defini foarte precis <B>P</B> matematic
folosind urmãtoarea notaþie TIME(f(n))= clasa problemelor care se
pot decide în timp f(n).  Atunci <!-- MATH
 ${\bf P}\ = \cup_{k \in N} TIME(n^k)$
 -->
<IMG
 WIDTH="176" HEIGHT="41" ALIGN="MIDDLE" BORDER="0"
 SRC="img66.png"
 ALT="${\bf P}\ = \cup_{k \in N} TIME(n^k)$">.

<P>
Se aratã imediat cã orice se poate calcula în spaþiu logaritmic,
nu are niciodatã nevoie de mai mult decît timp polinomial, sau
altfel spus, <!-- MATH
 ${\bf L}\ \subseteq {\bf P}$
 -->
<IMG
 WIDTH="61" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img67.png"
 ALT="${\bf L}\ \subseteq {\bf P}$">.

<P>
Practic toþi algoritmii eficace învãþaþi în ºcoalã sunt din
clasa <B>P</B>; teoreticienii considerã cã dacã o problemã nu este în
<B>P</B>, atunci nu poate fi rezolvatã practic, pentru cã resursele
cerute sunt prea multe.  De exemplu, programarea linearã, algoritmul
Gauss-Seidel de inversare a unei matrici, sau algoritmul care
calculeazã ieºirea unui circuit combinaþional cînd intrarea este
datã, sunt toþi algoritmi de timp polinomial.

<P>
De fapt ultima problemã este chiar <B>P</B>-completã, vis-a-vis de
reduceri în spaþiu logaritmic.  Deci orice altã problemã din <B>P</B> se poate reduce la problema evaluãrii unui circuit boolean!
Observaþi cã evaluarea unui circuit boolean este mai dificilã
decît a unei formule boolene, deºi orice formulã boolean poate fi
scrisã ca un circuit.

<P>
Relaþia exactã dintre <B>L</B> ºi <B>P</B> nu este cunoscutã; nu se ºtie
dacã <B>L</B> este strict inclusã în <B>P</B> sau cele douã clase sunt de
fapt egale.  Dacã cineva ar gãsi o metodã de a rezolva problema
valorii unui circuit boolean folosind un algoritm din <B>L</B>, atunci am
demonstra automat cã <B>L</B> = <B>P</B>, datoritã completitudinii problemei.

<P>
Aceastã întrebare este foarte importantã pentru practicã, pentru
cã algoritmii din <B>L</B> pot fi asimilaþi cu algoritmii care se pot
executa foarte eficient pe o maºinã masiv paralelã.  Chestiunea <B>L</B>
= <B>P</B> se poate deci interpreta ca întrebarea: ``poate orice algoritm
din <B>P</B> fi executat foarte eficient în paralel?''.

<P>

<H2><A NAME="SECTION03044000000000000000">
Spaþiu polinomial</A>
</H2>

<P>
În general este uºor de vãzut cã dacã o problemã are nevoie de
timp t atunci nu consumã mai mult de spaþiu t, pentru cã în
fiecare unitate de timp poate consuma cel mult o unitate nouã de
spaþiu.  Dacã notãm cu <B>PSPACE</B> clasa problemelor care consumã
spaþiu polinomial în mãrimea datelor de intrare, atunci avem deci
imediat <B>P</B> <IMG
 WIDTH="19" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.png"
 ALT="$\subseteq$"> <B>PSPACE</B>.

<P>
Ce putem rezolva avînd la dispoziþie spaþiu polinomial?  Ei bine,
putem rezolva toate jocurile cu informaþie perfectã.  Mai mult
decît atît, aceste probleme sunt <B>PSPACE</B>-complete vis-a-vis de
reduceri în timp polinomial.  Ce sunt jocurile cu informaþie
perfectã?  Sunt toate jocurile gen Go sau dame pe table de mãrime n x
n (aceasta este mãrimea datelor de intrare).  Aº spune 
ºah, dar este destul de greu de generalizat ºah-ul pentru table
arbitrar de mari.

<P>
Aºa cum ºtim din teoria jocurilor (sau dacã nu ºtim, vã spun eu),
orice joc de acest gen are o strategie perfectã pentru fiecare
jucãtor, care obþine cel mai bun rezultat, independent de miºcãrile
celuilalt.  Problema de a afla dacã primul la mutare poate cîºtiga
mereu este cea a jocurilor cu informaþie perfectã.

<P>
În mod surprinzãtor (sau poate v-aþi obiºnuit cu aceste
întrebãri nerezolvate, ºi vi se pare naturalã ignoranþa noastrã
în acest domeniu), nimeni nu ºtie dacã <B>P</B>= <B>PSPACE</B>.  Ceea ce ºtim
cu siguranþã este cã <B>L</B> <IMG
 WIDTH="19" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img71.png"
 ALT="$\subset$"> <B>PSPACE</B> este o incluziune
strictã.

<P>
Interesant, anumite probleme practice foarte utile sunt de asemenea
<B>PSPACE</B>-complete; de exemplu problemele de planificare care apar în
inteligenþa artificialã, cum ar fi programarea traseului unui robot.
O altã problemã importantã care este completã pentru
<B>PSPACE</B> este problema pe care o întîlnesc cei care scriu
compilatoare atunci cînd analizeazã un program cu pointeri pentru un
limbaj ca C, care permite crearea de pointeri cãtre funcþii:
determinarea la compilare a informaþiei ``points-to'', care spune
spre care obiecte un pointer poate arãta, este ºi ea completã
pentru <B>PSPACE</B>.

<P>

<H2><A NAME="SECTION03045000000000000000">
Timp exponenþial</A>
</H2>

<P>
Deºi nu am arãtat cum, acelaºi gen de demonstraþie care aratã cã
<B>L</B><IMG
 WIDTH="19" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.png"
 ALT="$\subseteq$"> <B>P</B> poate fi folosit pentru a arãta cã <B>PSPACE</B> 
<IMG
 WIDTH="19" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.png"
 ALT="$\subseteq$"> <B>EXP</B>.  <B>EXP</B> este definitã ca fiind clasa tuturor
problemelor care se rezolvã în timp exponenþial: <!-- MATH
 ${\bf EXP}= \cup_{k
\in N} TIME(2^{n^k})$
 -->
<IMG
 WIDTH="205" HEIGHT="46" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.png"
 ALT="${\bf EXP}= \cup_{k
\in N} TIME(2^{n^k})$">.

<P>
Nu avem habar dacã incluziunea <B>PSPACE</B><IMG
 WIDTH="19" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.png"
 ALT="$\subseteq$"> <B>EXP</B> este strictã
sau nu.

<P>

<H2><A NAME="SECTION03046000000000000000">
Spaþiu exponenþial</A>
</H2>

<P>
Dacã putem folosi timp exponenþial, putem folosi ºi spaþiu
exponenþial.  Aceastã clasã monstruoasã este puþin întîlnitã
în practicã, deºi existã probleme practice care pot fi plasate
aici.

<P>

<H2><A NAME="SECTION03047000000000000000">
Dincolo de spaþiu exponenþial</A>
</H2>

<P>
Existã ºi clase de complexitate mai mari decît acestea.  Vom
prezenta o astfel de clasã în ultima parte a acestui text, într-un
numãr ulterior, cînd discutãm despre complexitatea de decizie a
feluritelor teorii logice.

<P>

<H1><A NAME="SECTION03050000000000000000">
Complexitatea nedeterministã; maºini alternante</A>
</H1>

<P>
Modelul de maºinã cu care am lucrat pînã acum este destul de
realist, în sensul cã pare imediat construibil în practicã.
Singura ciudãþenie abstractã au fost oracolele.

<P>
Dar aºa cum modelul ezoteric al oracolelor, deºi ne-implementabil, a
fost de o enormã importanþã metodologicã, permiþindu-ne sã
tragem niºte concluzii foarte importante, teoreticienii au mai
elaborat douã variaþiuni la modelul maºinilor Turing, care se
dovedesc extrem de importante în practicã.  

<P>
Modelele pe care le voi introduce acum pot fi simulate cu maºini
Turing obiºnuite, cu o pierdere oarecare de eficacitate.  Dar
prezenþa acestor maºini ne permite sã facem niºte diviziuni mai
fine în interiorul feluritelor clase de complexitate, ºi sã punem
niºte întrebãri foarte importante.

<P>

<H2><A NAME="SECTION03051000000000000000">
Maºini nedeterministe</A>
</H2>

<P>
Vã reamintiþi cã definiþia maºinii Turing spunea exact ce trebuie
sã facã automatul în fiecare stare, în funcþie de simbolul de pe
bandã.  Ei bine, acum vom permite o oarecare ambiguitate: maºina
noastrã va avea posibilitatea sã facã nu una, ci mai multe miºcari
la un moment dat.

<P>
Trebuie sã redefinim conceptul de acceptare: înainte maºina accepta
dacã secvenþa ei de stãri parcurse se termina cu o stare anumitã,
numitã ``acceptare''.  Dar acum, cînd maºina poate urma mai multe
trasee, care este criteriul de acceptare?  Vom spune cã maºina
acceptã atunci existã <EM>cel puþin o cãrare</EM> care duce la o
acceptare.

<P>
Figura&nbsp;<A HREF="complex-html.html#nedeterminism">6</A> aratã cum stau lucrurile cu astfel de
maºini.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="nedeterminism"></A><A NAME="432"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 6:</STRONG>
O maºinã deterministã, de îndatã ce
are un ºir pe banda de intrare, are o traiectorie fixatã în
spaþiul stãrilor: putem spune oricînd în ce stare maºina se va
afla.  Prin contrast, maºinile nedeterministe se pot afla în stãri
cu mai mulþi succesori, în care pot alege traiectoria.  O maºinã
deterministã acceptã dacã cel puþin o traiectorie a ei accepta.</CAPTION>
<TR><TD><IMG
 WIDTH="486" HEIGHT="227" BORDER="0"
 SRC="img73.png"
 ALT="\begin{figure}\centerline{\epsfxsize=11cm\epsffile{nedeterminism.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Intuitiv putem sã ne imaginãm astfel de maºini în douã feluri;
alegeþi-l pe cel preferat:

<P>

<UL>
<LI>Putem sã ne imaginãm cã maºina atinge astfel de puncte de
decizie cu posibilitãþi multiple de execuþie, ºi atunci pur ºi
simplu ghiceºte pe care cãrare s-o ia.  Dacã existã o secvenþã
de ghiciri bune, maºina va accepta.  Aceastã perspectivã este
adesea folositã, iar maºinile de acest gen se numesc
``nedeterministe'', pentru cã comportamentul lor nu mai poate fi
descris dinainte precis.

<P>
</LI>
<LI>Un alt model de reprezentare foloseºte fire (threads) de
execuþie multiple: ne putem imagina cã maºina noastrã poate
executa în paralel un numãr nelimitat de fire de execuþie.  Atunci
cînd maºina atinge un punct de alegere nedeterministã, creazã
cîte un fir de execuþie separat pentru a explora fiecare
posibilitate.  Aceste fire se vor executa apoi perfect în paralel,
iar primul care va gãsi soluþia va termina întregul proces de
calcul.
</LI>
</UL>

<P>
Maºinile nedeterministe le generalizeazã pe cele deterministe; par
de asemenea mai puternice: e clar cã orice problemã care se poate
executa în timp determinist T se poate executa ºi în timp
nedeterminist T, pentru cã orice maºina deterministã este un caz
particular de maºinã nedeterministã.

<P>
Apar astfel clasele de complexitate prefixate cu litera <B>N</B>: <B>NL</B>,
<B>NP</B>, <B>NPSPACE</B>, <B>NEXP</B>.  De asemenea, o clasã nedeterministã este mai
slabã decît clasa deterministã superioarã: avem ierarhia: <!-- MATH
 $\L
\subseteq {\bf NL}\subseteq {\bf P}\subseteq {\bf NP}\subseteq {\bf PSPACE}\subseteq
{\bf NPSPACE}\subseteq {\bf EXP}\subseteq {\bf NEXP}$
 -->
<IMG
 WIDTH="524" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img74.png"
 ALT="$\L
\subseteq {\bf NL}\subseteq {\bf P}\subseteq {\bf NP}\subseteq {\bf PSPACE}\subseteq
{\bf NPSPACE}\subseteq {\bf EXP}\subseteq {\bf NEXP}$">.  Despre majoritatea
incluziunilor din acest lanþ nu ºtim dacã sunt stricte.

<P>
Un singur rezultat pozitiv lumineazã aceste incertitudini: în mod
surprinzãtor în 1970 Savitch a demonstrat cã <B>PSPACE</B>= <B>NPSPACE</B>,
deci nedeterminismul nu ajutã cu nimic puterea computaþionalã
pentru acest gen de probleme.

<P>
În plus mai ºtim adesea cã anumite incluziuni între clase distante
sunt stricte: de exemplu avem teoreme de genul ``fie <B>L</B><IMG
 WIDTH="19" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$\not=$"> <B>P</B>,
fie <B>P</B><IMG
 WIDTH="19" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$\not=$"> <B>PSPACE</B>'', sau, mai simplu spus, <!-- MATH
 ${\bf L}\not= {\bf PSPACE}$
 -->
<IMG
 WIDTH="120" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img76.png"
 ALT="${\bf L}\not= {\bf PSPACE}$">.

<P>
Aºa cum am mai menþionat, clasa asupra cãreia s-au aplecat cei mai
mulþi cercetãtori este <B>NP</B>.  Articolele mele anterioare arãtau cã
problema satisfiabilitãþii boolene (``are un circuit boolean
intrãri pentru care ieºire este 1'') este completã pentru <B>NP</B> vis-a-vis de reduceri polinomiale.

<P>
O sã menþionez în final o problemã completã pentru <B>NEXP</B>: jocul
de poker generalizat în trei adversari (jocuri în mai multe
persoane, cu aleatorism ºi informaþie ascunsã).

<P>

<H1><A NAME="SECTION03060000000000000000">
Clase complementare</A>
</H1>

<P>
O întrebare naturalã este: dacã putem generaliza maºina Turing sã
aibã astfel de stãri în care poate face o alegere, nu putem crea
ºi niºte stãri speciale în care <EM>orice</EM> alegere sã trebuiascã
sã ducã la o stare acceptoare?  În modelul paralel, cu fire de
execuþie, cerem ca <EM>toate</EM> firele lansate în paralel sã termine
cu succes, ºi nu unul singur dintre ele.

<P>
Vom distinge deci douã tipuri de stãri: stãrile <EM>existenþiale</EM>: cel puþin o cãrare care iese din ele trebuie sã
ducã la o acceptare (acestea sunt stãrile din maºinile
nedeterministe, introduse mai sus), ºi stãrile <EM>universale</EM>:
toate cãrãrile plecînd din acea stare trebuie sã ducã la o
acceptare.

<P>
Într-adevãr, aceste maºini recunosc alte clase de limbaje.  O
maºina care are doar stãri universale recunoaºte anumite clase de
limbaje interesante.  Se poate arãta cã aceste limbaje sunt
complementele limbajelor acceptate de maºinile nedeterministe, de
aceea numele lor se prefixeazã cu ``Co''.  De exemplu, avem clasa
limbajelor Co<B>L</B>, care pot fi acceptate de o maºinã cu stãri
universale în spaþiu logaritmic.  Avem Co<B>NP</B>, limbajele care pot fi
acceptate de maºinile polinomiale cu stãri universale.

<P>
Din nou, maºinile perfect deterministe sunt un caz particular de
maºini cu stãri universale, în care în fiecare stare avem o
singurã decizie posibilã.  De aici rezultã imediat o serie de
incluziuni: <!-- MATH
 ${\bf L}\subseteq {\bf NL}\cap Co{\bf NL}$
 -->
<IMG
 WIDTH="138" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img77.png"
 ALT="${\bf L}\subseteq {\bf NL}\cap Co{\bf NL}$">, <!-- MATH
 ${\bf P}\subseteq {\bf NP}\cap
Co{\bf NP}$
 -->
<IMG
 WIDTH="143" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img78.png"
 ALT="${\bf P}\subseteq {\bf NP}\cap
Co{\bf NP}$">, etc.

<P>
Ca sã fim mai concreþi, sã vedem o problemã care este în Co<B>NP</B>.
Problema este foarte interesantã: dacã am douã hãrþi, sunt ele
<EM>ne</EM>-izomorfe?  Adicã, oricum aº asocia þãrile dintr-una cu
þãrile din cealaltã, nu voi obþine niciodatã aceeaºi relaþie de
vecinãtate (dacã sunteþi familiari cu terminologia grafurilor,
aceasta este de fapt problema non-izomorfismului grafurilor).

<P>
Aceastã problemã este în Co<B>NP</B>, pentru cã vreau sã verific cã
<EM>orice</EM> permutare a unei hãrþi este diferitã de cealaltã.
Putem deci construi o maºinã cu o stare universalã, din care se
exploreazã în paralel toate permutãrile posibile.

<P>
Vedeþi, problema cealaltã, a izomorfismului grafurilor este în <B>NP</B>:
``sunt douã grafuri izomorfe?'' se poate rezolva în timp
nedeterminist polinomial.  Complementul acestei probleme este însã
în Co<B>NP</B>.  E interesant de observat cã adesea o problemã nu este la
fel de grea ca problema complementarã.  De pildã, e uºor sã
demonstrezi cã nu a plouat peste noapte: strãzile sunt uscate.  Dar
dacã strãzile sunt ude, nu poþi sã ºtii dacã nu cumva au spãlat
strada.  Un lucru ºi complementul lui nu sunt la fel de uºor de
demonstrat.

<P>
De fapt aici nu am exprimat decît o credinþã: relaþia dintre
clasele de complexitate ºi complementele lor este cel mai adesea
necunoscutã; singurul rezultat concret este dat teorema
Immerman-Szelepcsényi, din 1988, care arãta cã <B>NL</B>= Co<B>NL</B>.

<P>
Întrebarea <B>NP</B>= Co<B>NP</B> este o întrebare cu consecinþe foarte
importante pentru practicã; dacã aceste clase sunt egale (ceea ce
lumea crede foarte puþin probabil), atunci existã demonstraþii
scurte pentru non-izomorfismul grafurilor: poþi scrie o dovadã
sumarã cã douã grafuri nu sunt identice.

<P>

<H1><A NAME="SECTION03070000000000000000">
Maºini alternante, ierarhia polinomialã</A>
</H1>

<P>
Putem generaliza ºi mai departe maºinile Turing, permiþindu-le sã
aibã simultan stãri existenþiale ºi universale.  În acest fel
obþinem noi clase de complexitate.  Ceea ce caracterizeazã aceste
maºini nu este numãrul de stãri de fiecare fel, ci numãrul de <EM>alternanþe</EM> de stãri pe fiecare cãrare.  De exemplu, dacã avem o
stare existenþialã, urmatã apoi pe fiecare ramurã de stãri
universale, ºi doar atît, avem o alternanþã 2.  Cu cît permitem
mai multe alternanþe, cu atît maºina pare mai puternicã.

<P>
În mod interesant, putem modela aceste maºini ºi folosind oracole.
O maºinã care face o alternanþã existenþialã urmatã de una
universalã poate fi modelatã de o maºinã din <B>NP</B> care are un
oracol din Co<B>NP</B>.  Oracolul poate rãspunde la orice întrebare
universalã, iar maºina ia doar o decizie existenþialã.  Putem nota
aceastã maºinã cu <!-- MATH
 ${\bf NP}^{Co{\bf NP}}$
 -->
<IMG
 WIDTH="76" HEIGHT="23" ALIGN="BOTTOM" BORDER="0"
 SRC="img79.png"
 ALT="${\bf NP}^{Co{\bf NP}}$">.

<P>
Se definesc astfel clasele <!-- MATH
 $\Pi_k = Co{\bf NP}^{\Pi_{k-1}}$
 -->
<IMG
 WIDTH="135" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img80.png"
 ALT="$\Pi_k = Co{\bf NP}^{\Pi_{k-1}}$"> ºi <!-- MATH
 $\Sigma_k =
{\bf NP}^{\Sigma_{k-1}}$
 -->
<IMG
 WIDTH="112" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img81.png"
 ALT="$\Sigma_k =
{\bf NP}^{\Sigma_{k-1}}$">; punctul de pornire este <!-- MATH
 $\Sigma_1 = {\bf NP}$
 -->
<IMG
 WIDTH="79" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img82.png"
 ALT="$\Sigma_1 = {\bf NP}$">.
Figura&nbsp;<A HREF="complex-html.html#polinomiala">7</A> ilustreazã relaþia dintre aceste probleme.
O problemã din <IMG
 WIDTH="27" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img83.png"
 ALT="$\Pi_k$"> are un numãr de k alternanþe, ºi prima
stare este peste tot una universalã.  O problemã din <IMG
 WIDTH="27" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img84.png"
 ALT="$\Sigma_k$"> are
tot k alternanþe, dar prima stare pe orice cãrare este una
existenþialã.  Figura&nbsp;<A HREF="complex-html.html#polinomiala">7</A> ilustreazã aceastã
ierarhie de dificultãþi, numitã ``ierarhia polinomialã''.

<P>
Din nou, nu se cunoaºte nimic despre stricteþea incluziunilor.  Se
ºtie însã cã dacã pentru un k anume <!-- MATH
 $\Sigma_k = \Sigma_{k+1}$
 -->
<IMG
 WIDTH="88" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img85.png"
 ALT="$\Sigma_k = \Sigma_{k+1}$">,
atunci acest lucru este adevãrat pentru oricare numãr mai mare
decît k: ierarhia se prãbuºeºte la nivelul k: <!-- MATH
 $\Sigma_j =
\Sigma_k \forall j > k$
 -->
<IMG
 WIDTH="120" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img86.png"
 ALT="$\Sigma_j =
\Sigma_k \forall j &gt; k$">.  Totalitatea tuturor acestor clase pentru k
constant se noteazã cu <B>PH</B> <!-- MATH
 $=\cup_i \Sigma_i$
 -->
<IMG
 WIDTH="59" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img87.png"
 ALT="$=\cup_i \Sigma_i$">.  Dacã mergem mai
departe, ºi îi permitem ºi lui k sã varieze odatã cu
dimensiunea problemei, atingem <B>PSPACE</B>.

<P>
Pentru fiecare dintre aceste clase de complexitate existã probleme
care sunt complete prin reduceri polinomiale.  De exemplu, iatã un
limbaj complet pentru <IMG
 WIDTH="27" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img88.png"
 ALT="$\Pi_2$">: limbajul format din descrierea tuturor
circuitelor booleene care au numãrul minim de porþi care
implementeazã o anumitã funcþionalitate.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="polinomiala"></A><A NAME="484"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 7:</STRONG>
Ierarhia polinomialã PH.  Aproape nici una
dintre incluziunile din aceastã figurã nu sunt demonstrate a fi
stricte.  Lumea crede cã într-adevãr relaþia este cea din
figurã.  ER sunt limbajele regulate, L=spaþiu logaritmic, P=timp
polinomial.  Celelalte clase sunt definite in text.</CAPTION>
<TR><TD><IMG
 WIDTH="498" HEIGHT="317" BORDER="0"
 SRC="img89.png"
 ALT="\begin{figure}\centerline{\epsfxsize=11cm\epsffile{polinomiala.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H1><A NAME="SECTION03080000000000000000">
Concluzii</A>
</H1>

<P>
În acest text am vãzut ca nu tot ce se poate calcula în mod necesar
se poate calcula repede: existã clase de complexitate foarte
``grele''.

<P>
Am mai vãzut cã modelele matematice abstracte ale maºinilor cu
oracole, maºinilor nedeterministe ºi maºinilor alternante sunt
niºte scule foarte puternice pentru a explora structura diferitelor
probleme din punct de vedere al complexitãþii.  Am mai vãzut cã
existã clase de complexitate extrem de variate, ºi populate de
probleme foarte interesante: am vãzut de pildã clasa problemelor
care se pot paraleliza foarte eficient, <B>L</B>, clasa <B>PSPACE</B> a
jocurilor, care este (probabil) mult mai grea decît clasa problemelor
tractabile, ºi clase nedeterministe ºi alternante, care formeazã o
ierarhie infinitã de obiecte din ce în ce mai greu de calculat.

<P>
În episodul urmãtor vom ataca subiecte ºi mai stranii: vom vorbi
despre complexitatea circuitelor ne-uniforme, ºi vom vedea cum se pot
formaliza foarte precis noþiunile de criptare, pseudo-aleatorism ºi
calcul bazat pe întîmplare.  Pe luna viitoare!

<P>

<H1><A NAME="SECTION04000000000000000000">
Aleatorism ºi complexitate</A>
</H1>

<P>
Acest text este un al treilea episod consacrat teoriei
complexitãtii.  În oarecare mãsurã el este independent de
episoadele anterioare sau ulterioare, dar pentru cititorul doritor de
o privire de ansamblu, celelalte pãrþi sunt disponibile din pagina
mea de web.

<P>
Teoria complexitãþii este ramura cea mai abstractã a informaticii
teoretice, care studiazã ce se poate ºi nu se poate calcula, atunci
cînd punem tot felul de constrîngeri asupra resurselor de calcul pe
care le avem la dispoziþie.  

<P>
În primul text din aceastã serie, am discutat despre teoria extremã
a calculabilitãþii, care investigheazã lucruri care nu se pot
calcula oricît de multe lucruri am avea la dispoziþie.  În mod
surprinzãtor, existã mult mai multe lucruri ne-calculabile decît
calculabile; existã deci o infinitate de lucruri pe care nu le vom
putea dovedi niciodatã.

<P>
Al doilea episod a investigat cum se schimbã peisajul lucrurilor
calculabile dacã restrîngem timpul pe care i-l punem la dispoziþie
unui calculator, respectiv spaþiul de memorie pe care-l poate folosi.
Am vãzut cã existã probleme deosebit de interesante pentru care
este necesarã o cantitate foarte mare de resurse, de exemplu jocurile
între doi jucãtori.  Am vãzut însã cã se pot calcula lucruri
foarte interesante chiar dacã avem 0 resurse de memorie, ºi foarte
puþin timp la dispoziþie: acestea sunt limbajele
regulate<A NAME="tex2html13"
  HREF="#foot239"><SUP>4</SUP></A>, care au
foarte multe aplicaþii practice.

<P>
Acest al treilea episod are drept personaj central un tip foarte
surprinzãtor de resursã de calcul: aleatorismul.  Toate clasele de
complexitate prezentate în acest text sunt bazate în mod fundamental
pe aleatorism.

<P>

<H1><A NAME="SECTION04010000000000000000">
Aleatorism (randomness) ºi amplificare (boosting)</A>
</H1>

<P>
Ce este aleatorismul în teoria complexitãþii, ºi cum îl putem
modela?  Cum putem introduce în modelul simplu de calcul pe care l-am
folosit, al maºinii Turing, aleatorism?

<P>
Despre ce e aleatorismul în viaþa de zi cu zi, ºi cum poate fi el
produs, sunt încã dezbateri aprinse între filozofi.  Noi vom lua
drept bunã o sursã foarte simplã de aleatorism: un ban cu douã
feþe (diferite).  Vom presupune cã banul este perfect echilibrat,
ºi cã odatã aruncat, poate ateriza cu aceeaºi probabilitate, de
1/2, pe oricare dintre feþele sale.  Astfel, o fisã ne oferã de
fiecare datã cînd este aruncatã un bit aleator: un ``0'' sau un
``1'', fiecare cu probabilitate 1/2.  Presupunem de asemenea ca între
aruncãri independente ale banului nu existã nici o relaþie (adicã
ele sunt independente): presupunem cã faptul cã banul a aterizat de
zece ori la rînd cu faþa ``1'' în sus nu face mai probabilã
apariþia ulterioarã a unei feþe ``0''.  Unii filozofi ºi ``bunul
simþ'' al foarte multor inºi nu vor fi de acord cu aceste
presupuneri, dar acesta este luxul matematicii: putem face orice
presupuneri, atîta vreme cît le enunþãm clar.

<P>
Atunci cînd modelãm matematic aleatorismul pentru o maºinã Turing,
ne imaginãm cã cineva a dat dinainte cu banul ºi a înscris pe o
bandã infinitã rezultatele aruncãrilor.  Aceastã bandã este
disponibilã maºinii Turing, care de fiecare datã cînd are nevoie
de un bit aleator, citeºte un bit de pe aceastã bandã.  Aceastã
bandã, cu biþi aleatori, nu poate fi decît cititã, iar capul de
citire nu se poate niciodatã întoarce înapoi.  Aºa cum am zis,
biþii de pe bandã sunt uniform distribuiþi (adicã 0 ºi 1 apar
fiecare cu probabilitate 1/2) ºi independenþi unul de altul.

<P>
În general, atunci cînd introducem aleatorism în calcul, pierdem
certitudinea.  Putem pierde certitudinea în douã feluri diferite:
în primul fel, s-ar putea ca rezultatele calculate de algoritm sã
fie eronate.  În al doilea fel, s-ar putea ca rezultatele sã fie
sigur corecte, dar sã nu fie clar cît de repede algoritmul terminã
execuþia.  Cum de putem tolera aºa ceva?  Ce ne facem cu
calculatoarele, dacã întrebãm cît fac 7*9 ºi din cînd în cînd
primim rãspunsul 62?  Ce încredere mai putem avea în algoritmi,
atunci cînd ei nu sunt 100% fiabili?

<P>
Acestea sunt întrebãri foarte legitime; avem însã la dispoziþie o
tehnicã remarcabil de simplã prin care putem spori arbitrar
certitudinea unui rezultat.  Aceastã tehnicã se numeºte <EM>aplificare</EM> (boosting), ºi constã în repetarea de mai multe ori a
unui calcul incert<A NAME="tex2html14"
  HREF="#foot242"><SUP>5</SUP></A>.  

<P>
Ideea este destul de simplã ºi uºor de demonstrat matematic.  Voi
argumenta insã în cuvinte: sã presupunem cã facem un experiment
care are ºansa sã iasã prost cu o probabilitate micã, dar ne-nulã
(neapãrat mai micã de 1/2).  Atunci, dacã repetãm experimentul de
20 de ori, probabilitatea ca mai mult de 10 experimente sã iasã
prost este foarte micã.  Soluþia este deci de a repeta experimentul,
ºi de a considera rãspunsul corect pe cel care apare majoritar.
Probabilitatea de a greºi în acest fel scade în mod <EM>exponenþial</EM> cu numãrul de repetiþii.  Scãderea aceasta foarte
rapidã este esenþialã: este suficient sã facem un numãr relativ
mic de repetiþii pentru a reduce probabilitatea la o valoare infimã.
Un lucru foarte important este cã adesea numãrul de repetiþii pe
care trebuie sã-l facem <EM>nu depinde</EM> de mãrimea problemei pe
care o rezolvãm.  Vã reamintesc cã timpul de execuþie al unui
algoritm depinde practic întotdeauna de mãrimea datelor de intrare;
dacã însã probabilitatea de eºec a unui algoritm aleator este
independentã de mãrimea datelor de intrare (ºi cel mai adesea,
este), atunci numãrul de repetiþii este <EM>constant</EM>, acelaºi,
indiferent de cît de mare este problema!

<P>
Din punct de vedere practic algoritmii aleatori sunt perfect
tolerabili: putem reduce probabilitatea de eroare atît de micã
încît sã fie mai probabil ca între timp calculatorul însuºi sã
se strice, sau astfel încît sã fie mai probabil cã se va produce o
calamitate de mari proporþii, dupã care rezultatele calculului vor
mai interesa pe foarte puþinã lume.

<P>

<H1><A NAME="SECTION04020000000000000000">
Complexitate probabilisticã; RP, ZPP ºi BPP</A>
</H1>

<P>
În ultimii douãzeci de ani cercetãtorii din teoria complexitãþii
ºi a algoritmilor au gãsit aplicaþii surprinzãtoare ale
aleatorismului în rezolvarea de probleme.  Aºa cum avem clasa de
complexitate a problemelor care se pot rezolva în timp polinomial,
avem ºi clase de complexitate pentru probleme care se pot rezolva în
timp polinomial dacã folosim aruncarea cu banul ca resursã.

<P>
Am vãzut în episodul anterior al acestui foileton complex (adicã
``foileton despre complexitate'') cã despre foarte multe clase de
complexitate nu se ºtie dacã sunt identice sau doar incluse una
într-alta.  Astfel, nu se ºtie daca <B>P</B>=<B>NP</B>, sau dacã <B>P</B>=<B>PSPACE</B>,
etc.  Din pãcate la fel stau lucrurile ºi în ceea ce priveºte
aleatorismul: nu e clar dacã avînd aleatorism la-ndemînã putem
calcula rapid lucruri pe care altfel nu le putem face decît foarte
greu.  

<P>
Vom discuta mai jos în text despre relaþia dintre aleatorism ºi
dificultatea problemelor.  Pînã atunci sã notãm cã, la ora
actualã, existã o mulþime de probleme la care singurele soluþii
eficiente cunoscute sunt probabilistice: <EM>nimeni nu cunoaºte
soluþii deterministe de timp polinomial, dar existã soluþii
probabiliste de timp polinomial</EM>.  Mai mult de atît: problemele de
acest gen sunt extrem de importante în viaþa de zi cu zi; una dintre
cele mai importante probleme pe care nu ºtim s-o rezolvãm decît în
mod aleator este <EM>criptarea</EM>.

<P>
Pînã atunci sã aruncãm o privire asupra unor clase mari de
probleme care se pot rezolva probabilistic.  Ca ºi în cazul
maºinilor obiºnuite, deterministe, teoreticienii considerã cã
problemele care se pot rezolva în timp polinomial în dimensiunea
datelor de intrare sunt rezolvabile.  De aceea lumea este interesata
mai ales de clase de complexitate aleatoare pentru care timpul de
gãsire al soluþiei este de asemenea polinomial.  De aceea trebuie
sã vã aºteptaþi (dacã aþi uitat cumva cum se cheamã aceastã
secþiune) ca numele acestora sã se termine toate cu litera <B>P</B>,
de la ``polinomial''.

<P>

<H2><A NAME="SECTION04021000000000000000">
Monte Carlo ºi Las Vegas</A>
</H2>

<P>
Cum spuneam, existã douã clase de algoritmi aleatori, care pot
greºi rãspunsul, sau care pot depãºi timpul de execuþie.  Ambele
sunt numite dupã localitãþi faimoase prin jocurile de noroc.
Algoritmii care pot da rezultate greºite ocazional se numesc
Monte-Carlo.  Algoritmii care sunt întotdeauna corecþi în rezultat,
dar pot depãºi un timp rezonabil de execuþie se numesc Las Vegas.

<P>
Trebuie sã atragem atenþia cã pentru cele douã clase de algoritmi
de obicei se mãsoarã lucruri diferite: pentru algoritmii Monte-Carlo
masurãm, ca de obicei, cel mai mare timp de execuþie (worst case):
cînd spunem cã pentru date de intrare de mãrime n un algoritm
Monte-Carlo terminã în timp O(f(n)), înseamnã cã, indiferent de
cum dãm cu banul, cel mai lung dintre timpii de execuþie pentru
feluritele date de intrare de aceastã mãrime este mai mic de f(n).

<P>
Dimpotrivã, pentru algoritmii Las Vegas mãsurãm ceea ce se numeºte
<EM>timp mediu de execuþie pentru cazult cel mai rãu</EM> (worst-case
expected running time).  Asta pentru cã timpul de execuþie este o
<EM>variabilã aleatoare</EM>; asta înseamnã cã dacã dãm cu banul
ceva, timpul e unul, dacã dam cu banul altceva, timpul e altul, chiar
pentru aceleaºi date de intrare.  Fiecare secvenþã de aruncãri cu
banul are o anumitã probabilitate: secvenþa 00000 apare cu
probabilitatea 2<sup>-5</sup>, pentru cã vrem sã aparã cinci zerouri
consecutive, deci avem 1/2 * 1/2 * 1/2 * 1/2 * 1/2.  Timpul mediu de
execuþie este valoarea medie a variabilei aleatoare ``timp de
execuþie'': <!-- MATH
 $\Sigma_i p_i T(i, x)$
 -->
<IMG
 WIDTH="88" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img92.png"
 ALT="$\Sigma_i p_i T(i, x)$">.  În aceastã formulã suma se
face dupa toate ºirurile aleatoare posibile i; p<sub>i</sub> este
probabilitatea ca ºirul i sã aparã, iar T(i, x) este timpul de
execuþie pentru date de intrare x cînd ºirul aleator a fost
i<A NAME="tex2html15"
  HREF="#foot254"><SUP>6</SUP></A>
<P>
Iatã un exemplu foarte simplu de algoritm Las Vegas de sortare:
primim un ºir de numere de lungime n, îl amestecãm în mod
aleator, dupã care aplicãm QuickSort.  Rezultatul va fi întotdeauna
corect sortat, dar timpul de execuþie variazã între n log n ºi
n<sup>2</sup>.  Din fericire, existã foarte puþine ºiruri aleatoare pentru
care timpul de rulare este n<sup>2</sup>, aºa încît timpul mediu de
execuþie este n log n.  

<P>
Aparent n-am fãcut mare brînzã, pentru cã ºtim deja cã QuickSort
în general sorteazã în timp n log n$.  Dar acest lucru era
valabil dacã datele de intrare se presupuneau egal probabile în
orice ordine.  Ori, în anumite circumstanþe, s-ar putea ca datele de
intrare sã aparã mereu într-o ordine defavorabilã (de exemplu
dacã datele de intrare vin de la un echipament de monitorizare a
reþelei, s-ar putea ca fluctuãtiile diurne regulate sã facã ca
datele sã aibã mereu o formã nefavorabilã pentru un QuickSort
simplu.  Dar dacã noi amestecãm datele înainte de a le prelucra,
în aºa fel încît orice ºir de intrare sã devinã egal probabil,
am distrus ne-uniformitatea din datele de intrare, permiþînd
algoritmului sã opereze în cazul sãu mediu!

<P>

<H2><A NAME="SECTION04022000000000000000">
BPP ºi RP</A>
</H2>

<P>
Dacã ne restrîngem atenþia la probleme de decizie (adicã la
algoritmi care trebuie sã dea mereu doar unul din rãspunsurile
``da'' sau ``nu'')<A NAME="tex2html16"
  HREF="#foot256"><SUP>7</SUP></A>, atunci putem
distinge douã clase de complexitate printre algoritmii Monte-Carlo.

<P>
Prima clasã de complexitate se numeºte <B>RP</B>, de la Randomized
Polynomial time (timp aleator polinomial).  Aceºti algoritmi pot face
erori doar pentru unul din rãspunsuri; mai exact, dacã rãspunsul
pentru niºte date de intrare trebuie sã fie ``nu'', algoritmul
rãspunde 100% corect; dac'a r'aspunsul trebuie s'a fie ``da'',
algoritmul ar putea cu probabilitate &lt;1/4 sã dea din greºealã
rãspunsul ``nu''.  O problemã extrem de importantã practicã este
în clasa <B>RP</B>: testarea primalitãþii unui numãr.  La ora
actualã se cunosc numai algoritmi care vor recunoaºte întotdeauna
corect un numãr prim, dar care ar putea declara (eronat) cã anumite
numere compuse sunt de fapt prime, însã cu probabilitate micã
(adicã doar dacã sunt ghinioniste în aruncarea cu banul).  Acesta
este în sine un fapt foarte important, pentru cã toþi algoritmii
importanþi de criptografie cu cheie publicã se bazeazã în
construirea cheii pe generarea de numere prime, care la rîndul ei se
bazeazã pe testarea primalitãþii.  Asta înseamnã de fapt cã
toatã lumea care foloseºte RSA (o metodã foarte rãspînditã de
criptare; de exemplu atît Netscape cît ºi Internet Explorer
folosesc aceastã metodã pentru anumite comunicaþii criptate prin
Internet) are ºansa sã foloseascã o cheie care poate fi ``spartã''
uºor, pentru cã nu e compusã din produsul a douã numere prime!
Din fericire, folosind tehnica amplificãrii, lumea reduce
probabilitatea acestui eveniment la o valoare suficient de micã
pentru a face algoritmul foarte folositor în practicã.

<P>
A doua clasã de complexitate de algoritmi Monte-Carlo poate greºi cu
probabilitate micã în oricare sens: dacã rãspunsul e ``da'',
atunci ar putea zice ``nu'' cu probabilitate &lt;1/4, sau invers.
Aceastã clasã se numeºte <B>BPP</B>, de la Bounded-error
Probabilistic Polynomial time.  Amplificarea unui astfel de algoritm
se face repetînd execuþia sa, ºi luînd drept corect rãspunsul
care apare cel mai des.

<P>
Am vãzut în numãrul anterior al revistei cã pentru fiecare clasã
de complexitate putem vorbi de complementul sãu.  Astfel avem clasele
<B>CoRP</B>: clasa limbajelor pentru care dacã rãspunsul este ``da'',
atunci algoritmul îl gãseºte întotdeauna, iar dacã rãspunsul
este ``nu'', algoritmul poate greºi cu probabilitate &lt;1/4 (am
inversat în definiþia lui <B>RP</B>pe ``da'' cu ``nu'').  La fel se
defineºte <B>CoBPP</B>, dar, din cauzã cã definiþia lui <B>BPP</B>
este simetricã, <B>CoBPP</B> = <B>BPP</B>.  Pe de altã parte, <B>RP</B>
<IMG
 WIDTH="19" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$\not=$"> <B>CoRP</B>.

<P>
Mai mult de atît, intersecþia <B>RP</B><IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img96.png"
 ALT="$\cap$"> <B>CoRP</B> = <B>ZPP</B>
se numeºte Zero-error Probabilistic Polynomial time.  Se poate uºor
arãta cã de fapt <B>ZPP</B> este chiar clasa algoritmilor Las Vegas
cu timp mediu polinomial.

<P>
Se cunosc anumite relaþii între aceste clase de complexitate ºi
cele clasice, dar, ca de obicei, nu se ºtie dacã relaþiile de
incluziune sunt sau nu stricte: <!-- MATH
 ${\bf P}\subseteq {\bf RP}\subseteq {\bf NP}$
 -->
<IMG
 WIDTH="124" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img97.png"
 ALT="${\bf P}\subseteq {\bf RP}\subseteq {\bf NP}$">,
ºi <!-- MATH
 ${\bf RP}\subseteq {\bf BPP}$
 -->
<IMG
 WIDTH="100" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img98.png"
 ALT="${\bf RP}\subseteq {\bf BPP}$">.

<P>
Figura&nbsp;<A HREF="#relatii"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/local/lib/latex2html/icons/crossref.png"></A> sumarizeazã starea cunoºtinþelor noastre în
acest moment.

<P>
<B>Nota: revista PC Report ºi-a exprimat dezinteresul pentru 
articole pe teme atît de teoretice, ca atare acest articol 
este neterminat.</B>

<P>

<H1><A NAME="SECTION04030000000000000000">
Demonstraþii interactive</A>
</H1>

<H1><A NAME="SECTION04040000000000000000">
Demonstraþii verificabile probabilistic; teorema PCP</A>
</H1>

<P>

<H1><A NAME="SECTION04050000000000000000">
Complexitatea circuitelor</A>
</H1>

<H1><A NAME="SECTION04060000000000000000">
Secvenþe pseudo-aleatoare</A>
</H1>

<P>

<H1><A NAME="SECTION04070000000000000000">
Funcþii neinversabile</A>
</H1>

<H1><A NAME="SECTION04080000000000000000">
Criptografie</A>
</H1>

<P>

<H1><A NAME="SECTION04090000000000000000">
Relaþia dintre aleatorism ºi dificultate</A>
</H1>

<H1><A NAME="SECTION040100000000000000000">
Teorema elasticului</A>
</H1>

<P>

<H1><A NAME="SECTION05000000000000000000">
Logicã ºi complexitate</A>
</H1>

<P>
<BR><HR><H4>Note</H4>
<DL>
<DT><A NAME="foot120">... calculat</A><A NAME="foot120"
 HREF="complex-html.html#tex2html5"><SUP>1</SUP></A>
<DD>Rezervãm pentru
fiecare maºina Turing o stare specialã pentru a indica ``am terminat
de calculat''.

<DT><A NAME="foot295">... predicativ</A><A NAME="foot295"
 HREF="complex-html.html#tex2html8"><SUP>2</SUP></A>
<DD>Atenþie: problema SAT, a
satisfiabilitãþii, pe care am discutat-o în douã numere din PC
Report, se referea la calculul <EM>propoziþional</EM> ºi nu la cel
predicativ.  Cele douã probleme sunt foarte înrudite; în calculul
predicativ însã satisfiabilitatea este în general nedecidabilã, pe
cînd pentru calculul propoziþional am oferit chiar noi un algoritm
pentru decizia satisfiabilitãþii, chiar dacã de timp exponenþial.
Vom clarifica într-un articol ulterior relaþia dintre logicã ºi
complexitate.

<DT><A NAME="foot183">... etc</A><A NAME="foot183"
 HREF="complex-html.html#tex2html9"><SUP>3</SUP></A>
<DD>De ce se
numesc aceste circuite ``neuniforme'' vom vedea într-un episod
ulterior.

<DT><A NAME="foot239">...
regulate</A><A NAME="foot239"
 HREF="complex-html.html#tex2html13"><SUP>4</SUP></A>
<DD>În primul text din serie arãtam cã orice
operaþie de calcul poate fi vãzutã ca transformarea unui limbaj
într-un altul: fiecare ºir de caractere primit la intrare de o
maºina genereazã la ieºire un altul, care este rãspunsul maºinii.
Un limbaj era definit ca o mulþime de ºiruri de caractere.

<DT><A NAME="foot242">... incert</A><A NAME="foot242"
 HREF="complex-html.html#tex2html14"><SUP>5</SUP></A>
<DD>Pentru algoritmii a cãror duratã de
execuþie depinde de aleatorism, putem executa mai multe copii ale
algoritmului în paralel.

<DT><A NAME="foot254">...<IMG
 WIDTH="12" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img11.png"
 ALT="$i$"></A><A NAME="foot254"
 HREF="complex-html.html#tex2html15"><SUP>6</SUP></A>
<DD>În realitate trebuie sã fim puþin mai riguroºi,
pentru cã aceasta este (uneori) o sumã infinitã, deci trebuie sã
facem o trecere la limitã ºi sã discutãm ºi condiþii de
convergenþã.

<DT><A NAME="foot256">... ``nu'')</A><A NAME="foot256"
 HREF="complex-html.html#tex2html16"><SUP>7</SUP></A>
<DD>Tehnica de a restrînge atenþia la
problemele de decizie este foarte adesea folositã în teoria
complexitãþii; toate clasele mari de complexitate, de exemplu <B>P</B>,
<B>NP</B>, etc. sunt definite doar pentru probleme de decizie.  Am arãtat
însã într-un articol anterior cã acest gen de limitare nu este
foarte drastic, pentru cã putem extrapola adesea rezultatele
problemelor de decizie ºi pentru probleme la care rãspunsul nu e
doar ``da'' sau ``nu'', cum ar fi, de pildã, problemele de sortare.
De aceea în general nu facem distincþia explicitã.

</DL>
<BR><HR>

</BODY>
</HTML>
