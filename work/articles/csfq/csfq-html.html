<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Scalabilitatea în reþele de comunicaþii de date</TITLE>
<META NAME="description" CONTENT="Scalabilitatea în reþele de comunicaþii de date">
<META NAME="keywords" CONTENT="csfq-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>
<body>


<P>

<P>
<H1 ALIGN="CENTER">Scalabilitatea în reþele de comunicaþii de date</H1>
<P ALIGN="CENTER"><STRONG>Ion Stoica, Mihai Budiu -- <TT>istoica+@cs.cmu.edu, mihaib+@cs.cmu.edu</TT> 
<BR><TT><a
href="http://www.cs.cmu.edu/~istoica/">http://www.cs.cmu.edu/~istoica</a>,
<a
href="http://www.cs.cmu.edu/~mihaib">http://www.cs.cmu.edu/~mihaib</a></TT></STRONG></P> 
<P ALIGN="CENTER"><STRONG>18 aprilie 1999</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Un algoritm scalabil pentru alocarea echitabilã a
traficului în Internet
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>Cunoºtinþe elementare despre
funcþionarea reþelelor de calculatoare, rãbdare
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>ruter, flux, ratã de transmisie, disciplinele
cozilor, FIFO, fair queuing, core-stateless fair queuing,
scalabilitate
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html19"
  HREF="csfq-html.html">Rutere ºi fluxuri</A>
<UL>
<LI><A NAME="tex2html20"
  HREF="#SECTION00021000000000000000">Rutere</A>
<LI><A NAME="tex2html21"
  HREF="#SECTION00022000000000000000">Transmiterea pachetelor</A>
</UL>
<BR>
<LI><A NAME="tex2html22"
  HREF="#SECTION00030000000000000000">Congestie ºi controlul fluxului</A>
<UL>
<LI><A NAME="tex2html23"
  HREF="#SECTION00031000000000000000">Soluþia TCP</A>
<LI><A NAME="tex2html24"
  HREF="#SECTION00032000000000000000">Problemele soluþiei TCP</A>
</UL>
<BR>
<LI><A NAME="tex2html25"
  HREF="#SECTION00040000000000000000">Fair queuing: o disciplinã echitabilã</A>
<LI><A NAME="tex2html26"
  HREF="#SECTION00050000000000000000">Scalabilitatea</A>
<LI><A NAME="tex2html27"
  HREF="#SECTION00060000000000000000">O soluþie scalabilã pentru fair queuing: CSFQ</A>
<LI><A NAME="tex2html28"
  HREF="#SECTION00070000000000000000">Concluzii</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
În acest articol ilustrãm una dintre direcþiile cercetãrii
contemporane în domeniul Internetului: cãutarea de algoritmi
practici pentru a rezolva felurite probleme; problema pe care o
ilustrãm este cea a alocãrii echitabile a traficului pe legãturile
dintre calculatoare, în aºa fel încît toþi participanþii la
trafic sã primeascã aceeaºi cantitate.  Deºi infrastructura
curentã a Internetului nu permite acest lucru, implementarea acestui
gen de algoritmi va fi necesarã pentru a transforma Internetul
într-o reþea care poate garanta calitatea serviciilor pe care le
oferã.

<P>

<H1><A NAME="SECTION00020000000000000000">
Rutere ºi fluxuri</A>
</H1>

<P>

<H2><A NAME="SECTION00021000000000000000">
Rutere</A>
</H2>

<P>
Internetul este o reþea compusã din agregarea unui mare numãr de
reþele diferite într-o construcþie unicã.  Dacã douã
organizaþii au reþelele lor proprii, folosind tehnologii eventual
diferite, aceste douã reþele pot fi conectate între ele cu ajutorul
unui calculator special, care este cuplat la ambele reþele.  Rolul
acestui calculator este de a prelua dintr-o reþea datele care sunt
destinate cuiva din cealaltã reþea ºi de a le retransmite dincolo.
Aceastã funcþiune se numeºte <EM>rutare</EM>, iar calculatorul
însuºi se numeºte <EM>ruter</EM>.

<P>
Un ruter are deci douã funcþiuni:

<P>
<DL COMPACT>
<DT>(a)</DT>
<DD>De a discuta cu celelalte rutere pentru a descoperi
topologia reþelei.

<P>
</DD>
<DT>(b)</DT>
<DD>De a folosi informaþiile despre topologie pentru a trimite
fiecare pachet primit spre destinaþia lui.
</DD>
</DL>

<P>
Într-un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#internet">articol</a>
anterior din PC Report, Mihai a prezentat (a), rutarea în Internet<A
NAME="tex2html1" HREF="#foot60"><SUP>1</SUP></A>.  Subiectul acelui
articol era modul în care ruterele învaþã încotro trebuie trimis
fiecare pachet primit, ºi modul în care ruterele schimbã între ele
informaþii despre structura reþelei.

<P>
În textul de faþã vom complementa informaþiile oferite cu acea
ocazie, discutînd despre (b), modul în care ruterele transmit
pachete.

<P>

<H2><A NAME="SECTION00022000000000000000">
Transmiterea pachetelor</A>
</H2>

<P>
Un ruter este legat la fiecare reþea pe care o deserveºte printr-o
<EM>interfaþã</EM>.  Un ruter va avea deci cel puþin douã interfeþe.
Cînd un pachet apare prin una din interfeþe, ruterul pune acel
pachet într-o memorie internã.  Dupã aceea ruterul prelucreazã
pachetul ºi decide în ce direcþie trebuie sã-l trimitã.  Aceastã
informaþie este obþinutã din adresa destinaþie, care se aflã în
interiorul pachetului, ºi din tabela de rutare, care conþine
informaþii despre forma reþelei, ºi pe care ruterul a construit-o
conversînd cu vecinii sãi.  Dupã ce decide încotro trebuie trimis
pachetul, ruterul îl trimite pe interfaþa care este cea mai
potrivitã pentru destinaþie.

<P>
Figura&nbsp;<A HREF="csfq-html.html#rutare">1</A> ilustreazã arhitectura internã a unui ruter.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="rutare"></A><A NAME="147"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Operaþia de ``înaintare'' (forwarding) a unui
ruter: un pachet este primit pe o interfaþã, este clasificat în
funcþie de destinaþie, ºi este înaintat pe interfaþa de ieºire.
Pachetele adesea trebuie sã aºtepte în cozi prelucrarea pachetelor
anterioare.</CAPTION>
<TR><TD><IMG
 WIDTH="449" HEIGHT="342" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{rutare.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Aparent nimic nu este mai simplu: iei pachetul, cauþi destinaþia în
tabelã, ºi îl trimiþi mai departe.  O astfel de operaþie se
numeºte <EM>stocheazã ºi transmite</EM> (<EM>store and forward</EM>),
din motive evidente.  Ce mai e de discutat aici?

<P>
Dacã veþi încerca însã sã construiþi un ruter, veþi vedea cã
existã o sumedenie de întrebãri la care rãspunsul nu este de loc
evident.  Iatã unele din dificultãþile care se pot ivi:

<P>
<DL>
<DT><STRONG>Capacitate de prelucrare:</STRONG></DT>
<DD>O parte din probleme provin din
faptul cã viteza de prelucrare a unui ruter este finitã: de exemplu
se poate întîmpla ca mai multe intrãri simultan sã aducã pachete
cu o vitezã mai mare decît ruterul poate prelucra.  Din cauza asta
anumite pachete pot fi pur ºi simplu pierdute, pentru cã ruterul nu
poate þine pasul cu rata de transmisiune.  (Astfel de pachete vor fi
probabil retransmise de cãtre sursã mai tîrziu.)

<P>
</DD>
<DT><STRONG>Capacitatea legãturilor:</STRONG></DT>
<DD>Dar, chiar presupunînd cã ruterul
poate clasifica pachete infinit de rapid, se pot ivi probleme: de
exemplu imaginaþi-vã o reþea în care pachetele care vin pe douã
intrãri sunt destinate pentru o singurã ieºire; dacã cele trei
reþele au aceeaºi capacitate, atunci în mod clar ruterul nu va
putea trimite toate pachetele pe care le primeºte.  Ce trebuie sã
facã cu pachetele pe care le primeºte ºi nu le poate transmite?

<P>
Din cauza aceasta, ruterele conþin memorii, numite <EM>buffere</EM>, în
care stocheazã pachetele pe care nu le pot prelucra.  Pachetele se
aºeazã în <EM>cozi</EM>, de unde sunt extrase unul cîte unul.  Este
clar însã cã, oricît de multe buffere am avea, rafale mari de
pachete pentru aceeaºi destinaþie pot umple cozile, cauzînd din nou
pierderea pachetelor.

<P>
</DD>
<DT><STRONG>Calitate:</STRONG></DT>
<DD>Chiar presupunînd cã avem o memorie infinitã în
ruter, timpul de aºteptare în cozi se poate dovedi inacceptabil
pentru anumite aplicaþii.  De exemplu, dacã avem o aplicaþie de
telefonie prin Internet, dacã datele ajung dupã mai mult de 150ms de
la un capãt la altul, se creazã pauze neplãcute în conversaþie.
Chiar mai rãu este fenomenul care se petrece atunci cînd cozile
variazã în lungime: anumite pachete vor veni mai repede ºi altele
mai lent, distorsionînd vorbirea la receptor.  Asta ne sugereazã cã
anumitor pachete trebuie sã li se dea prioritate.  De asemenea,
anumite pachete pot fi preferate pentru a fi ``distruse'' (de exemplu
pachetele de voce care au întîrziat deja prea mult), pentru cã nu
mai sunt utile.
</DD>
</DL>

<P>
Una peste alta, un ruter trebuie sã ia urmãtoarele decizii:

<UL>
<LI>Care pachete ºi cînd pot fi aruncate;
</LI>
<LI>În ce ordine deserveºte pachetele din cozi.
</LI>
</UL>

<P>
Modul în care ia aceste decizii are consecinþe foarte importante
pentru comportarea reþelei.  În acest articol vom vedea cîteva
posibilitãþi ºi vom explora consecinþele lor, care sunt adesea
foarte diferite.

<P>
Trebuie spus însã cã majoritatea covîrºitoare a disciplinelor
studiate <EM>nu</EM> sunt implementate în sisteme reale, fiind
deocamdatã doar un subiect de cercetare.  Practic toate ruterele
operaþionale astãzi în lume folosesc o disciplinã foarte simplã:
au o singurã coadã pentru fiecare interfaþã, în care pun toate
pachetele.  Cînd coada este plinã, noile pachete venite sunt
pierdute.  Aceastã disciplinã se numeºte FIFO: First In First Out,
primul venit, primul plecat.

<P>
Din nefericire, deºi extrem de simplu de implementat, FIFO are niºte
proprietãþi indezirabile, despre care vom discuta puþin mai jos,
în secþiunea despre Fair Queuing, unde ilustrãm ºi o alternativã.
FIFO este inadecvatã din multe puncte de vedere, aºa cã multe
eforturi în cercetare sunt acum îndreptate spre studiul altor
discipline.

<P>
Însã, înainte de a vedea exemple de alte discipline, vom pune sub
reflector o proprietate extrem de importantã a reþelei, care este
influenþatã de modul în care ruterele ºi punctele terminale
opereazã.  Este vorba despre congestie.

<P>

<H1><A NAME="SECTION00030000000000000000">
Congestie ºi controlul fluxului</A>
</H1>

<P>
Atunci cînd un segment al reþelei este înecat cu pachete pe care nu
le poate transmite se produce un fenomen de <EM>congestie</EM>.
Congestia este extrem de periculoasã, pentru cã dacã nu este
tratatã corect poate periclita funcþionarea întregii reþele pentru
o perioadã nedeterminatã.

<P>
Scenariul cel mai sumbru aratã astfel: o anumitã legãturã
primeºte mai multe pachete decît capacitatea ei de transport.  Ca
atare, dupã ce cozile se umplu, inevitabil ruterul care deserveºte
acea legãturã începe sã piardã pachete.  Dupã o vreme sursele
care au trimis acele pachete încep sã dea semne de îngrijorare,
pentru cã nu primesc confirmarea de primire; ca atare încep sã
retransmitã pachetele pierdute.  Acestea vor cauza creºterea mai
mare a congestiei, pentru cã folosesc acelaºi traseu.  Cu cît
reþeaua este mai blocatã, cu atît mai multe pachete duplicate vor
apãrea (din cauza retransmisiilor), ºi cu atît mai blocatã va fi.
Din aceastã situaþie nu existã ieºire, dacã nu se intervine
imediat; reþeaua devine rapid nefuncþionalã.

<P>
Observaþi cã acest lucru se poate petrece chiar dacã fiecare
calculator terminal nu emite prea multe date; efectul se produce
datoritã <EM>agregãrii</EM> traficului de la mai multe conexiuni pe o
legãturã fizicã comunã.  De exemplu, în figura&nbsp;<A HREF="csfq-html.html#rutare">1</A>,
traficul între calculatoare din stînga ºi oricare calculator din
dreapta trebuie sã treacã pe linia dintre cele douã rutere.

<P>
În teoria reþelelor de transmisiuni de date se face distincþie
între douã clase de algoritmi:

<P>

<UL>
<LI>Algoritmi care controleazã traficul între cele douã puncte
terminale ale comunicaþiei, asigurînd faptul cã un calculator mai
rapid nu îneacã o destinaþie lentã cu pachete pe care nu le poate
primi.  O legãturã creatã între douã puncte pentru a transmite
date se numeºte <EM>flux</EM> (<EM>flow</EM>).  Algoritmii care
pãstreazã fluxul între limite admisibile pentru ambii participanþi
se numesc <EM>algoritmi de control al fluxului</EM> (flow-control).

<P>
</LI>
<LI>Algoritmi care controleazã traficul pe legãturi din interiorul
reþelei; aceºtia sunt algoritmi de control al congestiei (congestion
control).
</LI>
</UL>

<P>
Între aceste douã clase existã o suprapunere, pentru cã o reducere
a fluxului în mod implicit va reduce ºi congestia.  De fapt
secþiunea urmãtoare discutã singura soluþie actualmente
implementatã pe scarã largã în Internet, folositã de protocolul
TCP, care administreazã fluxuri între douã calculatoare.

<P>

<H2><A NAME="SECTION00031000000000000000">
Soluþia TCP</A>
</H2>

<P>
Soluþia folositã la ora actualã de majoritatea implementãrilor
existente ale protocolului TCP a fost propusã de van Jacobson în
1988.  Pentru a o înþelege ar trebui sã studiem un tip special de
protocol, numit protocolul cu <EM>fereastrã glisantã</EM> (<EM>sliding
window</EM>).  Subiectul este deosebit de interesant, dar prea generos
pentru acest articol, care are are un alt subiect.  Sperãm sã putem
trata acest subiect într-un alt articol; pentru cititorul impacient
trimitem la cartea lui Tanenbaum publicatã de editura Agora,
``Reþele de Calculatoare''.

<P>
Din protocolul cu fereastrã glisantã vom reþine numai însuºirile
care ne intereseazã.

<P>
TCP este un protocol care garanteazã trimiterea cu succes a tuturor
pachetelor.  Pentru asta, toate pachetele care nu au fost confirmate
la primire de cãtre capãtul celãlalt sunt pãstrate de emiþãtor,
chiar ºi dupã ce au fost deja transmise.  Pentru cã între
trimiterea unui pachet ºi recepþia confirmãrii se poate scurge mult
timp, emiþãtorul este gata sã emitã mai multe pachete la rînd,
chiar dacã nu a primit confirmãri pentru nici unul.  Numãrul de
pachete care se pot afla în tranzit fãrã confirmare se numeºte
<EM>fereastrã</EM> (window).

<P>
Fereastra glisantã este folositã de TCP cu succes ºi pentru
controlul fluxului.  Iatã cum:

<P>

<OL>
<LI>Sã zicem cã la un moment dat un flux TCP are o fereastrã de
30 de pachete.

<P>
</LI>
<LI>Sã ne imaginãm cã subit apare o congestie în reþea, pe o
linie folositã ºi de fluxul nostru.  Din cauza asta un ruter va
pierde pachete ale acestui flux.

<P>
</LI>
<LI>Dupã o vreme TCP observã ca nu a primit confirmãrile pentru
pachetele trimise.  Atunci, în loc sã le retrimitã pe toate, TCP
reduce fereastra curentã la un pachet (primul trimis care nu a primit
confirmare).

<P>
</LI>
<LI>TCP retransmite apoi pachetul din fereastrã.

<P>
</LI>
<LI>Dupã o vreme toate fluxurile care foloseau linia congestionatã
au pierdut pachete ºi ºi-au redus ferestrele.  În reþea au
început sã intre din ce în ce mai puþine pachete noi, deci linia
cu probleme s-a decongestionat.

<P>
</LI>
<LI>Acum fluxurile TCP încep sã primeascã confirmãri, deci
încep încet-încet sã-ºi mãreascã ferestrele la loc.

<P>
</LI>
<LI>Acest proces se repetã permanent.  Traficul pe acea legãturã
va oscila uºor în jurul valorii maxime posibile, fiind automat
ajustat de cãtre participanþii la trafic.
</LI>
</OL>

<P>
Soluþia aceasta este deosebit de elegantã.  Principala ei calitate
este cã nu implicã de loc reþeaua: numai nodurile terminale
ruleazã acest algoritm, fãrã nici un fel de informaþii de la
rutere.  În plus, aceastã soluþie funcþioneazã indiferent de
politica dupã care ruterele din reþea aruncã pachete.

<P>

<H2><A NAME="SECTION00032000000000000000">
Problemele soluþiei TCP</A>
</H2>

<P>
Controlul congestiei prin variaþia ferestrei are mai multe
dezavantaje, dar noi aici ne vom opri asupra unuia singur dintre ele.
Sã ne imaginãm cã avem cinci fluxuri printr-o legãturã
congestionatã.  Sã ne mai imaginãm cã 4 dintre ele sunt
implementãri ``normale'' ale TCP, dar cã unul dintre ele este o
implementare foarte agresivã, care în loc sã-ºi reducã traficul,
îl pãstreazã neschimbat.  

<P>
Ce se va întîmpla este uºor de imaginat: cele patru fluxuri
civilizate vor reduce traficul aºa cum trebuie, iar cel agresiv va
folosi toatã capacitatea posibilã a reþelei.  În mãsura în care
acest flux de unul singur nu congestioneazã reþeaua, va funcþiona
bine-mersi, furînd din porþia tuturor celorlalþi.

<P>
Dacã toate fluxurile ar fi lacome reþeaua s-ar congestiona
iremediabil, ºi nimeni n-ar primi nimic.  Deci schema aceasta
funcþioneazã numai dacã aproape toatã lumea este rezonabilã.

<P>
Partea neplãcutã este cã aceastã situaþie este deja întîlnitã,
într-o formã sau alta, în Internet:

<P>

<UL>
<LI>Anumiþi programatori lipsiþi de scrupule pot sã facã
aceastã modificare pe maºinile lor, pentru a beneficia de mai multe
resurse;

<P>
</LI>
<LI>O cantitate din ce în ce mai mare de aplicaþii de fapt nu
folosesc protocolul TCP pentru transmisiune.  TCP este un protocol
care garanteazã zero pierderi, cu costul eventual al multor
retransmiteri.  Pentru aplicaþii ca audio, video, jocurile în
reþea, etc. aceste trãsãturi sunt indezirabile: mai bine pierzi un
pachet din cînd în cînd ºi le aduci pe celelalte la timp, decît
sã întîrzii atît de mult.
</LI>
</UL>

<P>
Aplicaþiile de genul celor de mai sus folosesc protocolul UDP pentru
transmisiune, care nu este fiabil, ºi nu face nici un fel de control
al fluxului sau congestiei.

<P>
De altfel puteþi face chiar dumneavoastrã un experiment simplu dacã
aveþi acces la douã calculatoare legate în reþea, oarecare
cunoºtinþe de programare de reþea ºi o orã liberã:

<P>

<OL>
<LI>Deschideþi între aceste calculatoare niºte legãturi TCP pe
care transmiteþi date fictive; mãsuraþi cîte pachete primiþi în
fiecare secundã avînd 1, 2, 3, etc. legãturi în paralel.  În mod
normal, datoritã metodei de control a fluxului, aceste fluxuri vor
oscila simultan între valorile maximã ºi minimã, oferind aceeaºi
ratã medie de transmisiune pe o perioadã mai mare de timp (cîteva
secunde).

<P>
</LI>
<LI>Pentru ca acest experiment sã funcþioneze trebuie sã
reuºiþi sã congestionaþi reþeaua.  Dacã limita de transmisiune
va fi impusã nu de reþea, ci de hardware-ul sau software-ul pe care
îl posedaþi, acest experiment probabil nu va funcþiona întocmai.
Din momentul în care aþi congestionat reþeaua, suma ratelor medii
de transport ale legãturilor TCP va trebui sã fie constantã (adicã
fie cã aveþi 5, fie 10, rata<A NAME="tex2html3"
  HREF="#foot96"><SUP>2</SUP></A> totalã de
transport va fi egalã cu capacitatea legãturii dintre cele douã
calculatoare).

<P>
</LI>
<LI>Deschideþi apoi o legãturã UDP între cele douã
calculatoare, pãstrînd legãturile TCP deschise.  Pompaþi date în
toate cu viteza maximã.  Mãsuraþi din nou traficul.  Rata fiecãrui
flux va arãta ca în figura&nbsp;<A HREF="csfq-html.html#fifo">2</A>.
</LI>
</OL>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fifo"></A><A NAME="153"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Acest grafic aratã rata a 32 de fluxuri -- un
flux UDP (numãrul 1) ºi 31 de fluxuri TCP -- pe o legãturã
Ethernet de 10 Mbps.  Observaþi cã fluxurile TCP nici nu se vãd,
iar UDP consumã aproape toatã capacitatea canalului, cu circa 8
Mbps.</CAPTION>
<TR><TD><IMG
 WIDTH="267" HEIGHT="195" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=6cm\epsffile{fifo.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Veþi observa cã legãtura UDP obligã toate legãturile TCP sã-ºi
reducã traficul, folosind de una singurã toatã capacitatea
reþelei.  Suma dintre UDP ºi toate TCP-urile va fi constantã,
TCP-urile vor fi aproximativ egale între ele, dar la o valoare mult
mai scãzutã decît legãtura UDP.

<P>

<H1><A NAME="SECTION00040000000000000000">
Fair queuing: o disciplinã echitabilã</A>
</H1>

<P>
De fapt, dacã ruterele trateazã pachetele în ordinea sosirii
(FIFO), ºi le aruncã pe cele de la coadã, nici nu putem face mare
lucru.  O disciplinã simplã ca FIFO nu poate asigura o distribuþie
echitabilã a capacitãþii în caz de congestie.

<P>
O soluþie, propusã în literaturã, pentru aceasta problema este
utilizarea de discipline mai ``inteligente'' în rutere.  O astfel de
disciplinã este <EM>Fair Queueing</EM> (``cozi echitabile'', FQ).  În
continuare vom descrie FQ ºi vom arãta cã, spre deosebire de FIFO,
aceastã disciplinã asigurã o distribuþie echitabilã a
capacitãþii, independent de algoritmii de adaptare folosiþi de
surse.

<P>
FQ este definit în contextul unui sistem ideal, în care traficul
este transmis la nivel de biþi, ºi nu de pachete.  FQ se aplicã la
fiecare coadã de ieºire separat: fiecare interfaþã a ruterului va
calcula pentru propriul ei canal.  Într-un astfel de sistem, FQ se
reduce la tratarea fluxurilor în mod circular (<EM>round-robin</EM>: în
ordine fluxul 1, 2, 3, ..., n, 1, 2, 3, etc.).  Mai precis, în
cadrul fiecãrei runde, FQ transmite un bit de la fiecare flux care
este activ.

<P>
Spre deosebire de FIFO, FQ asigurã alocarea echitabilã a
capacitãþii.  În particular, capacitatea alocatã unui flux <EM>nu</EM>
depinde de rata fluxului.  De exemplu, dacã avem o conexiune de 1 
Mbps ºi douã fluxuri, unul cu rata de 0.5 Mbps ºi altul de 2 Mbps,
atunci fiecare flux va primi 0.5 Mbps.  Aceasta se întîmplã
deoarece atîta timp cît cele douã fluxuri sunt active, fiecare va
avea exact un bit transmis în cadrul fiecãrei runde.

<P>
Evident, într-un ruter real în care transmisia se face la nivel de
pachete ºi nu de biþi, FQ nu poate fi implementatã exact.  O primã
idee pentru implementarea FQ la nivel de pachet ar fi sã utilizãm
din nou round-robin.  Din pãcate, un moment de reflexie ne spune cã
aceastã soluþie nu este cea mai potrivitã.  Urmãtorul exemplu
ilustreazã problema: dacã avem doua fluxuri, unul care transmite
pachete de cîte 1000 octeþi, iar celãlalt care transmite pachete de
cîte 100 octeþi, este uºor de vãzut ca aplicînd round robin la
nivel de pachet are drept rezultat alocarea unei capacitãþi de 10
ori mai mare primului flux!  De aceea, în practicã, pentru
implementarea FQ-ului se utilizeazã algoritmi mai sofisticaþi.  

<P>
Un exemplu de astfel de algoritm este urmãtorul: pentru fiecare
pachet se calculeazã momentul de timp la care ultimul bit al acestuia
ar urma sã fie transmis într-un ruter ideal, în care traficul este
transmis bit cu bit; apoi pachetele sunt transmise în ordinea
crescãtoare a acestor timpi.

<P>
Descrierea de mai sus sugereazã principalul dezavantaj al disciplinei
FQ: complexitatea.  În esenþã ruterul trebuie sa þinã evidenþa
pentru fiecare flux ºi sa execute urmãtoarele operaþii:

<P>

<OL>
<LI>Sã identifice cãrui flux îi aparþine fiecare pachet; 

<P>
</LI>
<LI>Sã hotãrascã ce pachet sã elimine din memorie cînd aceasta
este depãºitã;

<P>
</LI>
<LI>Sã transmitã pachetele în ordinea crescãtoare a timpilor,
aºa cum am discutat mai sus.
</LI>
</OL>

<P>
Deci, pe de o parte, avem FIFO, care este foarte uºor de implementat
la viteze mari, dar nu asigurã o alocare echitabilã a capacitãþii,
iar pe de alta parte avem FQ care asigurã o distribuþie echitabilã a
capacitãþii, dar este mult mai complex de implementat.  O întrebare
fireascã este atunci dacã existã o cale de mijloc, care sa îmbine
simplitatea FIFO cu serviciul asigurat de FQ.  Vom vedea o astfel de
soluþie mai jos, dar înainte vom studia mai atent care este
trãsãtura indezirabilã a algoritmului FQ.

<P>

<H1><A NAME="SECTION00050000000000000000">
Scalabilitatea</A>
</H1>

<P>
Care este diferenþa dintre FIFO ºi FQ care face FQ mai dificil de
implementat?  Dacã încercãm sã scriem un program care sã le
implementeze, vom observa cã FIFO manipuleazã structuri de date
extrem de simple: de fapt o singurã structurã de date, care este o
listã înlãnþuitã de pachete, stocate în ordinea sosirii.  Listei
i se adaugã pachete la coadã ºi i se iau pachete de la cap.  Aceste
operaþii se pot implementa în cîteva linii de cod, deci se pot
executa extrem de rapid.

<P>
Pe de altã parte, dacã studiem FQ, o sã notãm faptul cã ruterul
trebuie sã facã contabilitate pentru fiecare flux care îl
traverseazã.  Asta înseamnã o sumedenie de lucruri destul de
neplãcute:

<P>

<OL>
<LI>Ruterul trebuie sã se uite la fiecare pachet ºi sã observe
pachetele care deschid noi conexiuni, pentru a le rezerva structuri de
date; fiecare conexiune va avea propria ei coadã;

<P>
</LI>
<LI>Ruterul trebuie sã clasifice fiecare pachet venit în funcþie
de conexiunea pe care circulã, ºi sã îl punã în coada lui;

<P>
</LI>
<LI>Ruterul trebuie sã reevalueze la trimiterea fiecãrui pachet
starea cozii sale, pentru a vedea cînd urmãtorul are dreptul sã
plece;

<P>
</LI>
<LI>Ruterul trebuie sã ``vîneze'' pachetele care terminã
conexiunea, pentru a distruge cozile respective.
</LI>
</OL>

<P>
Chiar dacã operaþiile acestea sunt relativ simple, structurile
manipulate sunt foarte complicate; avem de-a face cu cozi care cresc
independent, deci ne trebuie un alocator de memorie destul de
sofisticat<A NAME="tex2html5"
  HREF="#foot112"><SUP>3</SUP></A>, care trebuie
invocat la fiecare pachet venit sau plecat.  În plus, numãrul de
structuri de date manipulate depinde de numãrul de fluxuri din ruter.

<P>
Probleme extrem de greu de rezolvat apar dacã un calculator cu o
conexiune deschisã cade: el nu va trimite niciodatã semnalul de
închiderea conexiunii, deci ruterul va pãstra o coadã care teoretic
nu mai dispare niciodatã.  Vom vedea într-un alt articol cum se
rezolvã genul ãsta de neplãceri, folosind o tehnicã numitã <EM>soft state</EM>.

<P>
Cît de mare este numãrul de fluxuri dintr-un ruter care opereazã
în centrul reþelei?  Informaþii de la MCI, care este unul din cei
mai mari operatori de reþea din Statele Unite, aratã cã numãrul de
fluxuri active simultan într-un ruter de mare capacitate se poate
apropia de un milion!

<P>
Fiecare pachet venit trebuie deci clasificat într-unul din aproape un
milion de fluxuri!  Asta înseamnã, chiar cu algoritmi inteligenþi,
o prelucrare substanþialã pentru fiecare pachet venit.  Asta este
virtual imposibil pentru un ruter care deserveºte mai multe fluxuri
de sute de megabiþi pe secundã<A NAME="tex2html6"
  HREF="#foot114"><SUP>4</SUP></A>: pur ºi simplu nu are destul timp pentru a prelucra
pachetele!

<P>
Aceasta este diferenþa principalã în ceea ce priveºte
posibilitatea de a realiza FIFO ºi FQ: FQ trebuie sã facã din ce
în ce mai multe operaþii, dacã numãrul de fluxuri care
traverseazã ruterul creºte.  Operaþia lui FIFO pe de altã parte
este aceeaºi, independent de cîte fluxuri avem.

<P>
Internetul este unul dintre cele mai mari sisteme construite vreodatã
de om (ºi în viitor va deveni probabil cel mai mare); ca atare
dimensiunile cu care trebuie operat sunt uriaºe în multe
circumstanþe (de pildã un milion de fluxuri).  Din cauza asta
algoritmii executaþi de rutere trebuie sã fie eficienþi atît la un
numãr mic de conexiuni/pachete, cît ºi la valori astronomice.
Aceastã proprietate a unui algoritm se numeºte <EM>scalabilitate</EM>:
capacitatea de a funcþiona eficient la valori foarte variate ale
încãrcãturii de date prelucrate.

<P>
Dacã un cercetãtor propune pentru managementul Internetului un
algoritm care nu este scalabil, poate sã fie absolut sigur cã acel
algoritm nu va fi folosit niciodatã în afara unor sisteme mici,
experimentale.  Din cauza asta FQ nu este un algoritm practic; ne
trebuie o alternativã.

<P>

<H1><A NAME="SECTION00060000000000000000">
O soluþie scalabilã pentru fair queuing: CSFQ</A>
</H1>

<P>
Aºa cum am vãzut, complexitatea algoritmului FQ se datoreazã în
principal faptului cã ruterul trebuie sã menþinã starea fiecãrui
flux.  O schemã care sã reducã în mod semnificativ complexitatea
algoritmului FQ trebuie deci sã reducã sau sã elimine într-un mod
sau altul aceastã stare.  Problema este cã, dacã eliminãm pur ºi
simplu starea unui flux, nu mai este posibil sã ``protejãm'' acel
flux atunci cînd linia este congestionatã.  Suntem confruntaþi cu
urmãtoarea dilemã: pe de o parte dorim sã eliminãm starea pentru a
reduce complexitatea, dar pe de altã parte avem nevoie de aceastã
stare pentru a asigura protecþia fluxurilor.

<P>
Soluþia se bazeazã pe o idee foarte simplã: în loc sã menþinem
starea în rutere, o punem în pachete!  Fiecare pachet oricum trebuie
prelucrat de fiecare ruter, deci complexitatea procesãrii creºte
doar cu un factor constant (iar nu cu un factor depinzînd de numãrul
de fluxuri).  Algoritmul general aratã atunci în felul urmãtor:

<P>

<OL>
<LI>Sursa, sau eventual primul nod în reþea, evalueazã starea
fluxului, ºi o pune în pachetele acestuia.

<P>
</LI>
<LI>Nodurile urmãtoare trateazã pachetele pe baza informaþiei
conþinute în pachete.
</LI>
</OL>

<P>
În acest mod un nod interior nu are nevoie sã menþinã starea
pentru fiecare flux, ceea ce face posibilã implementarea eficientã a
algoritmului.  Pe de altã parte, sursele sau nodurile de la marginea
reþelei, care pun starea în pachete, trebuie sã menþinã stare
pentru fiecare flux, pentru a eticheta corect pachetele.  Din
fericire, aceste noduri suportã un trafic mult mai mic decît nodurile
interioare, ºi în consecinþã nu ridicã probleme de scalabilitate.
Aceasta soluþie ``împinge'' starea din nodurile interioare la
marginea reþelei ºi apoi foloseºte pachetele pentru a transmite
aceastã stare.

<P>
În continuare descriem pe scurt un algoritm, numit Core-Stateless
Fair Queueing (CSFQ), care implementeazã FQ în cadrul arhitecturii
prezentate mai sus.  ``Core-stateless'' înseamnã cã ruterele din
``miezul'' reþelei nu menþin nici un fel de informaþii despre
starea conexiunilor.  Pentru a defini algoritmul trebuie sã
precizãm:

<P>

<UL>
<LI>Informaþia de stare transportatã de pachete, care este
înscrisã de ruterele de la margine;

<P>
</LI>
<LI>Operaþiile executate de un nod interior la primirea unui
pachet.
</LI>
</UL>

<P>
În CSFQ, starea înscrisã în pachete reprezintã <EM>rata fluxului</EM>;
sursa sau primul nod din reþea calculeazã dinamic rata fiecãrui flux
ºi o pune în pachetele acestuia.  Nodurile interioare calculeazã pe
baza traficului primit ºi a celui transmis <EM>rata echitabilã</EM>
care trebuie sa fie alocatã fiecãrui flux.  Intuitiv, aceastã este
rata maximã care ar fi alocatã unui flux de algoritmul FQ la ruterul
respectiv (în exemplul dat mai sus, cu douã conexiuni pe o linie de 1
Mbps, rata echitabilã era de 0.5 Mbps).  Din lipsã de spaþiu nu
prezentãm amãnuntele calculãrii acestei rate.  Cititorul interesat
poate gãsi detaliile la <a
href="http://www.cs.cmu.edu/~istoica/csfq">http://www.cs.cmu.edu/~istoica/csfq</a>.
În continuare vom prezenta numai operaþia executatã de un ruter
interior la primirea unui pachet.

<P>
Ne vom concentra asupra unei singure ieºiri din ruter; pentru fiecare
ieºire vom menþine o altã valoare a ratei echitabile.

<P>
Sã ne uitãm la un ruter pentru care rata echitabilã este r<sub>b</sub>.
Aceastã ratã depinde numai de numãrul de fluxuri ºi de capacitatea
canalului de ieºire.  Sã zicem cã acest ruter primeºte un pachet
în care este înscrisã rata r.  Atunci ruterul transmite pachetul
cu probabilitatea P = max(1, r<sub>b</sub>/r) ºi îl ``aruncã'' cu
probabilitatea 1 - P.  Se poate arãta ca aceasta operaþie foarte
simplã duce la o buna aproximare a algoritmului FQ.  Intuitiv,
aceasta poate fi vãzut în urmãtorul exemplu didactic:

<P>
Sã presupunem cã avem un flux cu pachete de lungime egalã ºi cu o
ratã constantã r &gt; r<sub>b</sub>, unde valoarea r este înscrisã în
fiecare pachet de ruterele de la margine.  În acest caz P = r<sub>b</sub>/r.
Drept urmare, din n pachete vor fi transmise în medie numai n
r<sub>b</sub> / r pachete.  Deoarece fiecare pachet are aceeaºi 
lungime, rata fluxului se va reduce în medie cu r<sub>b</sub> / r,
ceea ce înseamnã ca rata finalã va fi r x r<sub>b</sub> / r =
r<sub>b</sub>.  În acest mod, fluxului îi este alocatã probabilistic o
ratã de cel mult r<sub>b</sub>, ratã care este egalã cu rata
echitabilã (adicã cea alocatã fluxului dacã FQ ar fi fost folosit)!
În final, dupã ce aruncã din pachete, ruterul schimbã rata înscrisã în
fiecare pachet cu r<sub>b</sub>.  Informaþia din pachet rãmîne astfel
consistentã cu noua ratã a fluxului dupã ce strãbate ruterul congestionat.

<P>
Astfel, CSFQ este capabil sã asigure o bunã aproximare a
algoritmului FQ la nodurile interioare, fãrã a menþine starea
fluxurilor.  În fapt, complexitatea acestui algoritm la nodurile
interioare este apropiatã de cea a algoritmului FIFO.  În concluzie,
CSFQ reuºeºte sã îmbine simplitatea FIFO cu funcþionalitatea
algoritmului FQ.

<P>
Figura&nbsp;<A HREF="csfq-html.html#csfq">3</A> aratã pentru comparaþi valorile fluxului obþinute
cu un simulator, în exact condiþiile din experimentul anterior cu
TCP.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="csfq"></A><A NAME="159"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
Valorile fluxurilor pentru o conexiune UDP
(numãrul 1) ºi 31 de conexiuni TCP peste o reþea de 10 Mbps, atunci
cînd disciplina de coadã a ruterelor este FQ, respectiv CSFQ.
Observaþi cã fiecare legãturã primeºte cam aceeaºi valoare din
flux, undeva în jur de 0,30 Mbps.  Între CSFQ ºi FQ nu existã
diferenþe notabile, arãtînd cã CSFQ realizeazã promisiunea de a
aproxima FQ pentru aceastã situaþie.  Valorile sunt obþinute cu un
simulator de reþea, care este accesibil din pagina de web a lui Ion.</CAPTION>
<TR><TD><IMG
 WIDTH="539" HEIGHT="191" BORDER="0"
 SRC="img13.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{csfq.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Existã o grãmadã de alte detalii despre funcþionarea CSFQ,
inclusiv simulãri detaliate ºi estimãri analitice ale calitãþii
sale; acestea sunt toate descrise pe larg în articolul ``Core
Stateless Fair Queueing: Achieving Approximately Fair Bandwidth
Allocations in High Speed Networks'', de Ion Stoica, Scott Shenker ºi
Hui Zhang, prezentat în 1998 la conferinþa SIGCOMM, a cãrui copie
este disponibilã din pagina de web a lui Ion.

<P>

<H1><A NAME="SECTION00070000000000000000">
Concluzii</A>
</H1>

<P>
În acest articol ilustrãm modul în care se poate proiecta o
soluþie pentru rezolvarea unei probleme specifice în Internet.
Articolul însã aparent bate mult timp cîmpii, pentru cã trebuie
sã construim o serie de concepte.  Iatã aici o vedere de ansamblu a
schemei articolului;

<P>

<OL>
<LI>Întîi discutãm despre modul în care ruterele proceseazã
pachetele pe care le înainteazã în Internet.  Vedem cã ruterele
pot decide ordinea în care deservesc cozile de pachete ºi ordinea
în care aruncã pachetele pe care nu le pot deservi.

<P>
</LI>
<LI>Apoi discutãm despre situaþiile în care ruterele <EM>trebuie</EM> sã piardã pachete, pentru cã reþeaua primeºte mai mult
decît poate transmite pe anumite segmente.  Aceasta se numeºte
congestie.

<P>
</LI>
<LI>Petrecem puþin timp pentru a vedea cum algoritmii contemporani
(TCP) rezolvã problema congestiei fãrã a avea nici un fel de ajutor
din partea reþelei.  Detecþia congestiei se bazeazã pe observaþia
cã anumite pachete nu primesc confirmãri.

<P>
</LI>
<LI>Vedem apoi cã o astfel de soluþie se bazeazã implicit pe
buna-credinþã a tuturor participanþilor, ºi cã nu este deloc
protejatã împotriva unor indivizi malefici, care în cazul
congestiei în loc sã reducã rata de transmisiune o mãresc,
beneficiind de reducerea fãcutã de toþi ceilalþi.

<P>
</LI>
<LI>Discutãm apoi o soluþie pentru aceastã problemã, care are
nevoie de cooperarea ruterelor din reþea: fair queuing.  Ruterele
proceseazã pachetele nu în ordinea primirii, ci pe rînd, cîte unul
de la fiecare sursã.  Asta înseamnã cã sursele care emit prea mult
sunt penalizate mai mult.

<P>
</LI>
<LI>Vedem apoi cã fair queuing, deºi foarte dezirabil, suferã de
problema <EM>scalabilitãþii</EM>.

<P>
</LI>
<LI>Discutãm apoi problema scalabilitãþii pe scurt: modul în
care complexitatea unui algoritm creºte în funcþie de datele de
intrare.  Observãm cã în Internet avem de-a face adesea cu probleme
extrem de mari (milioane de date de intrare), deci algoritmii
ineficienþi sunt ne-practici.

<P>
</LI>
<LI>În fine, vedem o soluþie de compromis, care este scalabilã
ºi <EM>aproximeazã</EM> fair queuing suficient de bine.
</LI>
</OL>

<P>
Cred cã e cinstit sã stãvilim aici fluxul de informaþii pe care le
transportã acest articol.  Vom reveni.

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot60">... Internet</A><A NAME="foot60"
 HREF="csfq-html.html#tex2html1"><SUP>1</SUP></A>
<DD>Acest articol este disponibil din pagina
sa de web.

<DT><A NAME="foot96">... rata</A><A NAME="foot96"
 HREF="csfq-html.html#tex2html3"><SUP>2</SUP></A>
<DD>Rata unui flux este definitã
ca numãrul de biþi transmiºi în unitatea de timp.

<DT><A NAME="foot112">...  sofisticat</A><A NAME="foot112"
HREF="csfq-html.html#tex2html5"><SUP>3</SUP></A> <DD>Vedeþi ºi <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#mem">articolul</a>
lui Mihai publicat cu ceva timp în urmã în PC Report despre alocarea
memoriei.

<DT><A NAME="foot114">... a</A><A NAME="foot114"
 HREF="csfq-html.html#tex2html6"><SUP>4</SUP></A>
<DD>Cel puþin pentru rutere
comerciale obiºnuite; inginerii care construiesc supercalculatoare au
mai multe tehnologii în mînecã pentru a rezolva astfel de
probleme.

</DL>
<BR><HR>

</BODY>
</HTML>
