<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>DDD -- Un debugger vizual</TITLE>
<META NAME="description" CONTENT="DDD -- Un debugger vizual">
<META NAME="keywords" CONTENT="ddd-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>
<body>


<P>

<P>
<H1 ALIGN="CENTER">DDD -- Un debugger vizual</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html1"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>18 mai 1999</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>corectitudinea programelor ºi scule pentru depanarea lor
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare despre
programare ºi sisteme de operare
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>verificare staticã, verificare dinamicã,
debugger
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html30"
  HREF="ddd-html.html">Corectitudinea programelor</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION00030000000000000000">Soluþii statice</A>
<LI><A NAME="tex2html32"
  HREF="#SECTION00040000000000000000">Soluþii dinamice</A>
<UL>
<LI><A NAME="tex2html33"
  HREF="#SECTION00041000000000000000">Trasarea: debugging dumps</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION00042000000000000000">Aserþiuni</A>
<LI><A NAME="tex2html35"
  HREF="#SECTION00043000000000000000">Cod care se auto-verificã</A>
<LI><A NAME="tex2html36"
  HREF="#SECTION00044000000000000000">Software Fault Isolation</A>
<LI><A NAME="tex2html37"
  HREF="#SECTION00045000000000000000">Debuggere</A>
</UL>
<BR>
<LI><A NAME="tex2html38"
  HREF="#SECTION00050000000000000000">Funcþionarea unui debugger</A>
<UL>
<LI><A NAME="tex2html39"
  HREF="#SECTION00051000000000000000">Tabela de simboluri</A>
<LI><A NAME="tex2html40"
  HREF="#SECTION00052000000000000000">Breakpoint-uri ºi watchpoint-uri</A>
<LI><A NAME="tex2html41"
  HREF="#SECTION00053000000000000000">Interfaþa sistemului de operare pentru depanare</A>
<LI><A NAME="tex2html42"
  HREF="#SECTION00054000000000000000">Core dumps</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION00055000000000000000">Bibliotecile; bibliotecile dinamice</A>
<LI><A NAME="tex2html44"
  HREF="#SECTION00056000000000000000">Funcþionarea unui debugger</A>
</UL>
<BR>
<LI><A NAME="tex2html45"
  HREF="#SECTION00060000000000000000">gdb: un debugger cu linie de comandã</A>
<LI><A NAME="tex2html46"
  HREF="#SECTION00070000000000000000">DDD - o interfaþa vizualã</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Societatea contemporanã se bazeazã din ce în ce mai mult pe
calculatoare; cu atît mai dramaticã este situaþia curentã a
software-ului: mulþi specialiºti estimeazã cã cea mai importantã
crizã a tehnologiei informaþionale contemporane este robusteþea
redusã a programelor produse.

<P>
Situaþia este într-adevãr îngrijorãtoare: productivitatea medie a
unui programator este de circa 3 linii de cod pe zi (cod comentat,
depanat ºi verificat); frecvenþa medie a erorilor este de una la o
mie de linii.

<P>
Productivitatea programatorilor nu s-a schimbat în mod substanþial
în ultimii douãzeci de ani, dar s-au schimbat enorm sculele pe care
le au la dispoziþie.  Limbajele folosite în ziua de azi sunt mult
mai expresive, ºi ca atare 3 linii de cod pot exprima mult mai mult.
Scule sofisticate asistã programatorul în scrierea, verificarea,
întreþinerea, portarea ºi depanarea programelor.

<P>
În acest text voi face reclamã unui produs de excelentã calitate
pentru depanarea programelor.  Foarte interesant este faptul cã
produsul în seamã este în întregime free software, ºi ca atare este
disponibil oricui de pe Internet, pe gratis (am scris un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#open">articol</a>
întreg despre fenomenul ``free software'' cu mai mult timp în urmã în
PC Report; copia articolului este accesibilã din pagina mea de web.)

<P>
Programul în sine este ceea ce se numeºte un ``debugger vizual'';
``vizual'' pentru cã permite o interacþiune foarte intuitivã
utilizatorului.  Calitatea sa rivalizeazã cu produse de firmã
renumite, cum ar fi debugger-ul vizual al lui Microsoft.  Pentru cei
nerãbdãtori, programul se numeºte DDD (Data Display Debugger), ºi
poate fi obþinut, în surse sau executabile, cu documentaþia
aferentã, de la Universitatea Tehnicã din Braunschweig din Germania:
<TT><A NAME="tex2html2"
  HREF="http://www.cs.tu-bs.de/softech/ddd">http://www.cs.tu-bs.de/softech/ddd</A></TT>.  De fapt vom vedea cã DDD
este doar un înveliº vizual care poate colabora cu alte debuggere
care au interfeþe mai simple (linie de comandã).

<P>
Trebuie sã recunosc cã eu însumi sunt un ins destul de conservator,
care în general preferã interfaþã seacã în linie de comandã,
stil Unix, unei interfeþe vizuale ``desktop'', gen Microsoft Windows.
Dar criteriul care ne face sã alegem între cele douã nu trebuie sã
fie unul religios, ci unul pragmatic.  Productivitatea pe care o am
în depanarea codului este mult crescutã cu DDD<A NAME="tex2html3"
  HREF="#foot60"><SUP>1</SUP></A>, aºa cã programul meritã încercat.

<P>

<H1><A NAME="SECTION00020000000000000000">
Corectitudinea programelor</A>
</H1>

<P>
Corectitudinea programelor este o noþiune mult mai complicatã decît
pare la prima vedere; existã o sumedenie de definiþii posibile,
unele implicînd un aparat matematic sofisticat.  Trebuie însã spus
cã, deºi existã o cantitate enormã de cercetare în ingineria
programãrii (software engineering), în metode de verificare
automatã a programelor, în generatoare de programe, rezultatele
practice sunt cu douãzeci de ani în urma cerinþelor proiectelor
moderne.

<P>
Fãrã a mã avînta în detalii (în care dealtfel nu sunt expert)
pot totuºi face cîteva observaþii generale, sper interesante pentru
cititor.  Existã douã clase mari de metode folosite pentru a
garanta/analiza corectitudinea programelor.  Prima clasã mare
priveºte programele în întregime, ºi studiind codul sursã poate
garanta proprietãþi pe care programul le va avea oricînd,
indiferent de datele de intrare.  Aceste soluþii se numesc <EM>statice</EM>.

<P>
A doua clasã studiazã programele în execuþie cu anumite date de
intrare, ºi garanteazã oricînd cã anumite lucruri nu se vor
întîmpla niciodatã, pentru cã vor fi prevenite în mod explicit.
Aceste metode sunt cele <EM>dinamice</EM>.  Debugger-ele fac parte din
clasa metodelor dinamice, deci vor avea partea leului în acest text.
De aceea sã acordãm cîteva cuvinte soluþiilor statice.

<P>

<H1><A NAME="SECTION00030000000000000000">
Soluþii statice</A>
</H1>

<P>
Trebuie spus dintru început cã cele douã clase de soluþii (statice
ºi dinamice) sunt fundamental diferite, pentru cã proprietãþile pe
care le pot garanta sunt altele.  Existã astfel proprietãþi care
pot fi garantate numai cu soluþii statice, proprietãþi care pot fi
garantate numai cu soluþii dinamice, sau cu ambele (sau, din pãcate,
cu nici una).

<P>
Scula staticã cea mai comunã este compilatorul.  Un compilator
traduce un program dintr-un limbaj sursã într-un limbaj destinaþie.
Proprietatea pe care trebuie s-o garanteze compilatorul este cã
ambele programe au acelaºi ``înþeles'' (semanticã).

<P>
Depinzînd de expresivitatea limbajului sursã, compilatoarele pot
garanta static anumite proprietãþi ale programelor.  De exemplu, în
limbajele puternic tipizate (strongly typed), anumite erori sunt pur
ºi simplu imposibile.  În Java, de pildã, nu poþi nicicum aduna un
numãr cu un caracter; aceastã operaþie nici nu are sens, ºi este
explicit interzisã prin sistemul de tipuri al limbajului.  Din cauza
asta, putem fi siguri cã programatorul nu va face niciodatã o astfel
de eroare.

<P>
Folosind proprietãþile deduse ale programului, compilatoarele
moderne nu numai cã transformã un program într-altul, ci
efectueazã ºi o serie întreagã de <EM>optimizãri</EM>.  Analiza
staticã pe care compilatoarele o efectueazã garanteazã cã
optimizãrile fãcute sunt corecte, în sensul cã nu schimbã
semnificaþia programului (ci doar viteza lui de execuþie sau poate
mãrimea lui, sau alþi parametri de interes pentru optimizare).

<P>
Existã proprietãþi care nu se pot garanta static niciodatã; astfel
de proprietãþi se numesc <EM>nedecidabile</EM>.  De exemplu la
întrebarea ``va avea variabila <TT>X</TT> vreodatã valoarea 0?'' nu se
poate, în general, rãspunde în mod static.  Fireºte, pentru unele
programe, acest lucru poate fi dovedit, dar nu pentru <EM>orice</EM>
program care manipuleazã variabila <TT>X</TT>.  Acest lucru poate fi
demonstrat matematic.  Îmi propun ca într-un articol ulterior,
consacrat logicii matematice, sã revin asupra acestui fapt.  O
ramurã a informaticii, numitã teoria calculabilitãþii, se ocupã
cu astfel de fapte.

<P>
Mi se pare interesant de menþionat ºi urmãtorul fapt, care este tot
o consecinþã a teoriei calculabilitãþii: am vãzut cã existã mai
multe programe diferite care fac acelaºi lucru (de exemplu un program
ºi versiunea lui optimizatã.)  Ei bine, în general este imposibil de
determinat care este <EM>cel mai mic program</EM> care face anumit lucru.
Acest enunþ se mai numeºte ºi <EM>Teorema Non-ªomajului</EM> pentru
cei care scriu compilatoare (<EM>full-employment theorem for compiler
writers</EM>).  Asta înseamnã practic cã seria de optimizãri pe care
le pot implementa compilatoarele este nesfîrºitã!  Formal vorbind,
dacã cineva implementeazã un compilator pe care-l decreteazã
perfect, atunci eu pot construi un alt compilator, care pentru cel
puþin un program va genera un rezultat optimizat mai bine!

<P>

<H1><A NAME="SECTION00040000000000000000">
Soluþii dinamice</A>
</H1>

<P>
Pe de altã parte, o proprietate ca ``<TT>X</TT> este 0'' poate fi
detectatã cu o soluþie dinamicã: pur ºi simplu este suficient sã
verificãm înainte de fiecare instrucþiune care se executã dacã nu
cumva efectul ei va fi sã dea aceastã valoare lui <TT>X</TT>.

<P>
În mod dinamic putem garanta o sumedenie de proprietãþi care nu pot
fi garantate static.  De pildã, pentru limbaje de gen Java, care nu
permit accesul înafara marginilor unui vector, putem garanta acest
lucru folosind teste dinamice: de fiecare datã cînd accesãm un
vector, testãm indicele dacã are o valoare între limitele admise.

<P>
Analiza dinamicã are ºi ea limitãrile ei.  De pildã, analiza
dinamicã nu va putea <EM>elimina</EM> astfel de teste din program; pe
cînd un compilator inteligent va observa cã într-un cod ca acesta:

<P>
<PRE>
int a[10], i;
for (i=3; i &lt; 7; i++) a[i] = 0;
</PRE>

<P>
variabila <TT>i</TT> va fi tot timpul între 0 ºi 9, limitele
vectorului, deci va putea elimina testele indicelui din interiorul
buclei <TT>for</TT>.  Aºa ceva nu putem realiza în mod dinamic.

<P>
Este foarte important sã înþelegem o altã limitare esenþialã a
metodelor dinamice: ele depind de datele de intrare.  Dacã un program
verificat dinamic nu face nici un fel de eroare pentru anumite date,
nu avem nici o garanþie cã cu alte date nu se va comporta prost.
Prin contrast, în mod static putem verifica adesea proprietãþi care
sunt valabile pentru orice intrãri.

<P>
Vom trece în revistã mai jos o serie de alte metode dinamice de
garantare a corectitudinii.  Deºi depanarea nu garanteazã
proprietãþi, ci doar permite verificarea lor în cursul execuþiei,
o vom categorisi ca metodã dinamicã.  Vreau sã subliniez cã
metodele care urmeazã sunt <EM>metode practice</EM>, care se bucurã de
un deosebit succes în activitatea programatorilor, ºi sã vã
îndemn sã le folosiþi în proiectele dumneavoastrã.

<P>

<H2><A NAME="SECTION00041000000000000000">
Trasarea: debugging dumps</A>
</H2>

<P>
O metodã relativ primitivã, dar extrem de eficace, este de a face
programul însuºi sã indice progresul, inserînd în cod
instrucþiuni de tipãrire.  Metoda este cîteodatã singura
posibilã: de exemplu cînd depanaþi nucleul unui sistem de operare,
acesta nu are o noþiune de intrare/ieºire, ºi nici nu poate fi pus
sub controlul unui debugger (adesea poate fi <EM>observat</EM> cu un
debugger, dar nu oprit ºi modificat).

<P>
În programele mele eu pun în anumite zone de cod instrucþiuni de
genul:

<P>
<PRE>
if (NIVEL_DEPANARE_OPTIMIZARE &gt; 2)
        fprinf(log, "Am ajuns in acest punct si X=%d\n", X);
</PRE>

<P>
Apoi inventez o metodã prin care pot controla nivelul de depanare
fãrã a fi nevoie sã recompilez, sau chiar sã reopresc programul.
De pildã, programul poate avea opþiuni în linia de comandã, care
modificã nivelul de depanare.  În acest fel pot controla nivelul de
depanare independent în diferite pãrþi ale programului; schimbînd
nivelul obþin informaþii de detalii diferite.

<P>
În Unix se foloseºte adesea o metodã interesantã pentru a controla
nivelul de depanare a unor programe care nu se opresc niciodatã din
execuþie, cum ar fi demonii care se ocupã de comunicaþia în
Internet: nivelul de depanare poate fi controlat trimiþînd anumite
semnale acestor procese, cîteodatã în conjuncþie cu modificarea
unor fiºiere de configurare care controleazã operaþiile demonilor.

<P>

<H2><A NAME="SECTION00042000000000000000">
Aserþiuni</A>
</H2>

<P>
O tehnicã de o utilitate greu de supraestimat este cea a folosirii
aserþiunilor.  Toate limbajele moderne pun la dispoziþie aserþiuni;
o aserþiune este o funcþie care terminã execuþia programului dacã
primeºte un argument nul.  (Tocmai am mãsurat numãrul de aserþiuni
în codul scris de mine: am în medie o aserþiune la 40 de linii de
cod scrise.)

<P>
Aserþiunile sunt folosite pentru a verifica dacã anumiþi <EM>invarianþi</EM> ai programului sunt adevãraþi.  De exemplu mãrimea
unui vector care se schimbã dinamic trebuie sã fie pozitivã.  Putem
avea deci în codul care modificã acest vector ceva de genul:

<P>
<PRE>
char* resize(char* vector, int marime)
{
   assert(marime &gt; 0);
   ....
}
</PRE>

<P>
De îndatã ce vom viola aceastã condiþie programul se va opri din
execuþie.

<P>

<H2><A NAME="SECTION00043000000000000000">
Cod care se auto-verificã</A>
</H2>

<P>
Adesea aserþiunile pe care vrem sã le verificãm sunt mai
complicate; de pildã vrem sã vedem dacã toate elementele dintr-un
vector se însumeazã la 1000.  Astfel de verificãri sunt foarte
costisitoare, ºi nu ne putem permite sã le facem permanent.  Dar
dacã suspectãm cã avem un bug care violeazã acest invariant,
atunci putem proceda astfel (în C cel puþin): creãm o funcþie
specialã care verificã invariantul, pe care o invocãm apoi dintr-o
zonã de cod controlatã de nivelul de depanare:

<P>
<PRE>
if (NIVEL_DEPANARE)
        assert(suma_vector() == 1000);
</PRE>

<P>
Astfel, folosim viteza calculatorului însuºi pentru a verifica
corectitudinea programului, fãcînd teste complicate.  Cînd
programul este ``complet'' depanat (mai exact cînd credem noi asta),
putem scoate aserþiunile ºi astfel de fragmente din cod foarte
simplu; de pildã în C dacã definim macro-ul <TT>NDEBUG</TT> toate
aserþiunile dispar automat din cod.

<P>

<H2><A NAME="SECTION00044000000000000000">
Software Fault Isolation</A>
</H2>

<P>
De fapt tehnologiile dinamice descrise mai sus fac parte dintr-o
clasã foarte largã, numitã <EM>software fault isolation</EM>.
Tehnologia aceasta este folositã cu mult succes în mai multe
produse, începînd cu nuclee ale sistemelor de operare, care permit
utilizatorilor sã le insereze în nucleu cod, ºi terminînd cu
programe comerciale ca Purify ºi Insure.

<P>
Cele mai sofisticate astfel de scule funcþioneazã chiar fãrã a
avea la dispoziþie programul sursã; ele fac ceea ce se numeºte <EM>binary instrumentation</EM>: modificã chiar fiºierele executabile,
inserînd verificãri în anumite puncte cheie.  De exemplu, foarte
popularul program Purify, de la Pure Software, insereazã cod special
care verificã toate accesele la memorie, ºi modificã funcþiile de
alocare a memoriei din biblioteca standard.  Astfel de software prinde
foarte multe erori de acces la memorie, cum ar fi accese în zone de
memorie nealocate, re-folosirea memoriei de-alocate, citirea unor zone
de memorie neiniþializate, scurgeri de memorie (adicã uitarea de a
dealoca memoria alocatã: ``memory leaks''), etc.  Anumite clase de
erori, ca cele cauzate de pointeri eronaþi, sunt adesea foarte uºor
de depanat cu astfel de scule (ºi foarte greu altfel).

<P>

<H2><A NAME="SECTION00045000000000000000">
Debuggere</A>
</H2>

<P>
În fine, ajungem la subiectul acestui articol.  Debugger-ele sunt
programe sofisticate, care permit executarea altor programe într-un
mod controlat; ele permit execuþia, observarea ºi modificarea altui
program.  Debugger-ele folosesc o sumedenie de tehnici, înrudite cu
software fault isolation (vom vedea cum), ºi suport din partea
sculelor care genereazã programele, ºi a sistemului de operare.
Debugger-ele se comportã vis-a-vis de programul depanat asemãnãtor
cu niºte <EM>interpretoare</EM>, executînd instrucþiunile una cîte
una.  Pentru cã scrierea unui interpretor (interpretoarele de
cod-maºinã se numesc ``emulatoare'') este o treabã foarte
complicatã, debugger-ele folosesc anumite servicii puse la dispoziþie
de cãtre sistemul de operare.

<P>
Sistemul de operare este el însuºi o uriaºã sculã care face
software fault isolation: el permite execuþia paralelã a mai multor
programe, dar previne interferenþa lor, claustrînd accesele
fiecãruia în propria lui zonã de memorie, cu ajutorul memoriei
virtuale, ºi controlînd interacþiunea dintre procese ºi resurse
prin apelurile de sistem.  (Despre sisteme de operare am scris o
mulþime de articole în PC Report în trecut).

<P>

<H1><A NAME="SECTION00050000000000000000">
Funcþionarea unui debugger</A>
</H1>

<P>
Vom discuta aici numai despre debugger-ele care permit depanarea unui
program în limbajul în care a fost scris (limbajul sursã);
debugger-ele care depaneazã numai limbaj maºinã sunt substanþial
mai simple, ºi mai puþin utile.

<P>
Figura&nbsp;<A HREF="ddd-html.html#debugger">1</A> ilustreazã interacþiunile unui debugger; vom
detalia pe fiecare în parte în secþiunile urmãtoare.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="debugger"></A><A NAME="221"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
Un debugger interacþioneazã cu sistemul de
operare, pentru a controla programul depanat, cu fiºierul executabil,
pentru a extrage informaþiile de depanare ºi cu fiºierele sursã,
pentru a conversa cu utilizatorul.</CAPTION>
<TR><TD><IMG
 WIDTH="361" HEIGHT="261" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{debugger.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00051000000000000000">
Tabela de simboluri</A>
</H2>

<P>
Cel mai important suport îl primeºte un debugger de la compilatorul
care translateazã fiºierul din sursã în limbaj maºinã.
Compilatorul poate fi rugat sã depunã în fiºierul executabil
informaþii despre structura programului.  Aceste informaþii sunt
ceea ce se numeºte ``tabela de simboluri''.  Informaþiile asociazã
fiecare instrucþiune din codul maºinã rezultat cu linia din codul
sursã din care provine, indicã adresele tuturor variabilelor din
programul sursã, tipurile lor, adresele procedurilor ºi tipurile
lor, etc.  Adesea mai mult de 60% din m'arimea unui fi'sier
executabil constã doar în informaþii de acest gen.  Pe sistemele
Unix existã un utilitar numit <TT>strip</TT> (dezbracã) care ºterge
astfel de informaþii; el poate fi folosit pentru a face economie de
spaþiu pe disc.

<P>
Fãrã informaþiile de depanare însã, debugger-ul nu poate face
corespondenþa între codul obiect ºi fiºierele sursã.

<P>
Existã o sumedenie de standarde de reprezentare a informaþiilor de
depanare, care sunt menite sã facã posibilã depanarea unui program
generat de orice compilator cu orice debugger.  

<P>

<H2><A NAME="SECTION00052000000000000000">
Breakpoint-uri ºi watchpoint-uri</A>
</H2>

<P>
Pentru a fi eficace, un debugger foloseºte ºi suportul oferit de
hardware.  Acest suport îi permite sã execute programele de depanat
cu vitezã maximã, intervenind numai atunci cînd este nevoie, în
loc de a le urmãri execuþia pas cu pas, emulînd fiecare
instrucþiune separat.

<P>
Iatã cum funcþioneazã aceste mecanisme: microprocesoarele moderne au
niºte regiºtri speciali, în care se pot scrie felurite adrese.
Procesoarele promit cã atunci cînd aceste adrese apar în program,
hardware-ul genereazã o excepþie, care poate fi tratatã apoi de
software.

<P>
Un <EM>breakpoint</EM> (punct de întrerupere) este o valoare care este
comparatã cu adresa curentã a codului din registrul PC (Program
Counter): cu alte cuvinte, cînd programul atinge adresa indicatã de
un breakpoint, se genereazã automat o întrerupere.

<P>
În mod alternativ, un breakpoint poate fi o instrucþiune care
genereazã ea însãºi o întrerupere atunci cînd este executatã,
numitã chiar ``instrucþiune breakpoint''.  Debugger-ele pot folosi
ambele feluri de breapoint-uri.

<P>
O variantã de breakpoint-uri sunt cele <EM>condiþionale</EM>: acestea
opresc execuþia numai dacã o anumitã expresie are o anumitã
valoare, altfel continuã.

<P>
Un <EM>watchpoint-uri</EM> (punct de supraveghere) este o valoare care este
comparatã cu adresa datelor; dacã un program vrea sã citeascã sau
sã scrie la o anumitã adresã, se genereazã o întrerupere.

<P>

<H2><A NAME="SECTION00053000000000000000">
Interfaþa sistemului de operare pentru depanare</A>
</H2>

<P>
Debugger-ul este un program, iar programul depanat este un altul.  Cum
de poate debugger-ul sã controleze un program independent, care nu a
fost scris în acest scop?  Sistemele moderne de operare izoleazã
programele unul faþã de altul; atunci cum de poate debugger-ul sã se
uite la cele mai intime informaþii din spaþiul de adrese al
celuilalt program?

<P>
Fãrã ajutorul sistemului de operare nici n-ar putea.

<P>
Tot sistemul de operare pune la dispoziþie o interfaþã specialã,
prin care un program poate observa comportarea altuia.  De asemenea,
sistemul de operare asigurã respectarea unor reguli de securitate:
numai utilizatorul care a pornit un proces are dreptul sã-l depaneze;
altfel debugger-ele ar putea fi folosite pentru a extrage informaþii
nepermise.

<P>
Voi discuta aici interfaþa oferitã de sistemele de tip Unix; deºi
nu ºtiu ce oferã sistemele de tip Windows, este probabil cã au
mecanisme înrudite.

<P>
Existã în Unix în mod tradiþional douã interfeþe pentru depanare
oferite de sistemul de operare.  Prima este mai veche, ºi mai
puþin elegantã.  Ea constã dintr-un singur apel de sistem, numit
<TT>ptrace</TT>.

<P>

<H3><A NAME="SECTION00053100000000000000">
<TT>ptrace</TT></A>
</H3>

<P>
Ptrace vine de la <EM>process trace</EM>: urmãreºte execuþia altui
proces.  Acest apel de sistem de fapt implementeazã un mic limbaj,
prin care debugger-ul converseazã cu nucleul sistemului de operare.
Iatã cum aratã <TT>ptrace</TT> pe Linux:

<P>
<PRE>
int ptrace(int operatie, int proces, int adresa, int date);
</PRE>

<P>
Prin execuþia acestui apel, debugger-ul cere nucleului sã efectueze
operaþia indicatã asupra procesului descris, la adresa ºi cu
valorile pasate.

<P>
Iatã exemple de operaþii: citeºte un cuvînt (de date, de cod, de
stivã), scrie un cuvînt, trimite un semnal, opreºte procesul,
reporneºte procesul, etc.

<P>
Un debugger pune un breakpoint în celãlalt proces astfel: citeºte o
instrucþiune din proces, o memoreazã local, ºi o înlocuieºte cu o
``instrucþiune breakpoint''.  Apoi nucleul este rugat sã continue
execuþia procesului, iar cînd breakpoint-ul este executat, o
întrerupere transferã din nou control debugger-ului, care pune la
loc instrucþiunea originalã ºi decide apoi ce sã facã cu
procesul.

<P>
Un breakpoint condiþional poate fi implementat ca un breakpoint
obiºnuit, doar cã debugger-ul va verifica la fiecare oprire condiþia
(citind din spaþiul celuilalt proces valorile necesare), ºi va
reporni programul doar dacã condiþia este falsã.

<P>
Interfaþa aceasta este oarecum incomodã, din mai multe motive.

<P>

<UL>
<LI>În primul rînd, ideea de a avea un mic limbaj de comunicare
între nucleu ºi debugger prin argumentul ``operaþie'' nu este în
spiritul Unix, care are interfeþe cu semanticã foarte simplã ºi
clarã;

<P>
</LI>
<LI>În al doilea rînd, interfaþa este foarte restrictivã, pentru
cã permite accesul numai la nivel de cuvînt; mai mult, pentru
fiecare cuvînt debugger-ul trebuie sã execute un apel de sistem.  Ori
un apel de sistem este foarte costisitor, în termeni de timp de
execuþie; din cauza asta un breakpoint condiþional va încetini
substanþial execuþia programului depanat.
</LI>
</UL>

<P>
Din cauza aceasta, în 1984, cercetãtorii de la AT&amp;T (unde a fost
dezvoltat Unix-ul original) au propus o interfaþã alternativã,
extrem de elegantã, bazatã pe un sistem de fiºiere virtual.

<P>

<H3><A NAME="SECTION00053200000000000000">
<TT>/proc</TT></A>
</H3>

<P>
Sistemul de fiºiere <TT>proc</TT> oferã acces la toate procesele în
execuþie în acelaºi fel în care oferã acces la fiºiere.  Am mai
vorbit în alte articole despre eleganþa interfeþei Unix pentru
accesul la fiºiere, ºi despre sistemul de fiºiere <TT>proc</TT>; aici
nu voi face decît sã recapitulez faptele esenþiale.  

<P>
În parantezã voi nota cã tot cercetãtorii de la AT&amp;T au împins
ideea accesului la obiecte prin interfaþa de fiºiere ºi mai departe
în proiectul lor de sistem distribuit numit Plan9, care însã din
pãcate nu a devenit niciodatã un produs comercial.

<P>
Dacã aveþi un sistem Linux la-ndemînã puteþi experimenta
<TT>proc</TT> în mod direct, ºi veþi înþelege mai precis ce vreau
sã povestesc.  Mergeþi în directorul <TT>/proc</TT> ºi uitaþi-vã.
Fiecare proces în execuþie are aici un fiºier care îi corespunde;
procesul cu identificatorul 100 va avea un director cu numele
<TT>100</TT>.

<P>
În acest director se aflã o mulþime de ``fiºiere virtuale'', care
descriu informaþiile nucleului despre acest proces.  Aceste fiºiere
nu existã pe disc; atunci cînd cineva încearcã sã citeascã din
aceste fiºiere, nucleul de fapt extrage datele din memorie, din
anumite structuri de date, ºi le returneazã cititorului.

<P>
În acest director existã ºi un fiºier virtual care reprezintã
întreg spaþiul de memorie al acestui proces; citind octetul 5 din
acest fiºier se citeºte de fapt octetul de la adresa virtualã 5 din
spaþiul de adrese al acestui proces.

<P>
Utilizînd acest fiºier, debugger-ul are imediat o vedere de ansamblu
asupra întregului proces, putînd citi ºi scrie zone întregi cu un
singur apel de sistem de citire, respectiv scriere.

<P>

<H2><A NAME="SECTION00054000000000000000">
Core dumps</A>
</H2>

<P>
Sistemele de operare pun adesea la dispoziþie încã o interesantã
funcþiune: fiºierele-imagine (<EM>core</EM>).  Utilizatorul poate
inhiba crearea acestora cu apelul de sistem <TT>setrlimit</TT>.  

<P>
Atunci cînd un proces executã o operaþie ilegalã, nucleul îl
omoarã ºi simultan creazã un fiºier numit <TT>core</TT>, care este
foarte asemãnãtor cu fiºierul din <TT>proc</TT> care descrie imaginea
de memorie a procesului; acest fiºier conþine imaginea procesului
aºa cum arãta el în momentul rãposãrii.  Debugger-ul poate folosi
acest fiºier pentru a studia cauzele morþii: poate inspecta
variabilele, stiva, etc. în momentul morþii, dar nu poate executa
programul.

<P>

<H2><A NAME="SECTION00055000000000000000">
Bibliotecile; bibliotecile dinamice</A>
</H2>

<P>
Dacã bibliotecile cu care programul este legat vin cu informaþii de
depanare, debugger-ul poate fi folosit pentru a le depana ºi pe ele.
Debugger-ul capteazã apelurile prin care procesele îºi leagã
bibliotecile dinamice în momentul execuþiei, ºi le citeºte
simbolurile de îndatã ce sunt încãrcate.

<P>

<H2><A NAME="SECTION00056000000000000000">
Funcþionarea unui debugger</A>
</H2>

<P>
Iatã aici recapitulatã funcþionarea unui debugger, pas cu pas:

<P>

<OL>
<LI>Un debugger poate lansa procesul de depanat ca pe un
proces-copil, sau se poate <EM>ataºa</EM> (attach) unui proces care deja
se executã;

<P>
</LI>
<LI>Dupã aceea debugger-ul extrage informaþiile de depanare din
tabela de simboluri a fiºierului executabil;

<P>
</LI>
<LI>Apoi debugger-ul încearcã sã localizeze fiºierele sursã din
care programul a fost compilat; utilizatorul poate de obicei indica
debugger-ului în ce directoare sã caute aceste fiºiere;

<P>
</LI>
<LI>Apoi debugger-ul intrã într-o buclã, aºteptînd comenzi de la
utilizator.

<P>
</LI>
<LI>Dupã fiecare comandã debugger-ul acþioneazã asupra imaginii
executabile în conformitate cu comanda;

<P>
</LI>
<LI>Dacã utilizatorul vrea sã vadã o variabilã, de pildã,
debugger-ul va cãuta în tabela de simboluri adresa variabilei, apoi
va citi zona de memorie unde variabila se aflã.  Pentru variabilele
locale, care pot avea mai multe instanþe, debugger-ul le va cãuta pe
stivã, iar nu în segmentul de date; pentru asta debugger-ul trebuie
sã ºtie cum îºi aranjeazã datele pe stivã fiecare procedurã;

<P>
</LI>
<LI>Cînd utilizatorul vrea sã execute programul pentru un numãr
de paºi, debugger-ul instaleazã un breakpoint, dupã care roagã
nucleul sã porneascã programul, el dormitînd apoi în aºteptarea
semnalului de oprire prin care nucleul indicã faptul ca breakpoint-ul
a fost atins;

<P>
</LI>
<LI>Debugger-ul poate de asemenea sã roage nucleul sã trimitã
semnale pentru a întrerupe un proces în execuþie;

<P>
</LI>
<LI>Utilizatorul poate cere modificarea unor valori, pe care
debugger-ul le înscrie în zonele de memorie corespunzãtoare;

<P>
</LI>
<LI>Debugger-ul poate permite utilizatorilor sã întrerupã
secvenþa normalã de execuþie; de exemplu utilizatorii pot termina
imediat procedura curentã, pot cere apelul unor anumite funcþii, sau
pot cere ca execuþia sã se continue de la un anumit punct, ºi nu de
la instrucþiunea urmãtoare.
</LI>
</OL>

<P>

<H1><A NAME="SECTION00060000000000000000">
gdb: un debugger cu linie de comandã</A>
</H1>

<P>
În aceastã secþiune voi discuta pe scurt despre unul dintre cele mai
rãspîndite debuggere, cel al proiectului GNU (despre proiectul GNU
puteþi citi în articolul meu anterior despre free software, pe care
l-am mai menþionat).  GDB a fost scris iniþial de Richard Stallman,
celebrul iniþiator al Fundaþiei pentru Free Software (FSF), care a
scris ºi editorul de texte Emacs (despre care am avut un alt <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#emacs">articol</a>
în PC Report) ºi compilatorul de C numit GCC (Gnu C Compiler).

<P>
La data apariþiei sale, gdb avea tot felul de trãsãturi inovatoare.
Voi menþiona pe scurt unele dintre cele mai exotice; gdb poate face
toate lucrurile pe care le-am descris mai sus, cînd am vorbit în
general despre debuggere.

<P>
Gdb este un debugger în linie de comandã, dar existã mai multe
interfeþe vizuale pentru el.  O interfaþã excelentã permite
folosirea lui gdb din editorul de texte Emacs; alte interfeþe sunt
xxgdb, gdbtk, ºi DDD, care este pretextul acestui articol.

<P>

<UL>
<LI>Gdb poate permite utilizatorului sã evalueze expresii arbitrar
de complicate; de la aflarea valorii unei variabile, la expresii care
conþin operatori complicaþi, sau chiar apeluri de funcþii;

<P>
</LI>
<LI>Gdb poate fi folosit atît pentru inspectat cît ºi pentru
modificat valori.  În ambele cazuri comanda este <TT>print</TT>.  De
exemplu putem spune:

<P>
<PRE>
(gdb) print a
$1 = 5
(gdb) print a=3
$2 = 3
(gdb) print sin(a)
$3 = .14112000805986722210
(gdb) print $1
$4 = 5
</PRE> 
<P>
Semnele $ de mai sus pot fi folosite pentru a re-evalua expresii
complicate.  $1 þine locul expresiei <TT>a</TT> mai sus.

<P>
</LI>
<LI>Comenzile gdb pot fi abreviate, daca nu sunt ambigue; de pildã
<TT>print</TT> se poate scrie simplu <TT>p</TT>.  De asemenea, tastînd
ENTER drept comandã va repeta execuþia comenzii precedente, ceea ce
este foarte economic.

<P>
</LI>
<LI>Gdb poate permite tipãrirea vectorilor, ºi tipãreºte
ºirurile de caractere într-un mod inteligent.  De pildã, dacã în
program aveþi un vector alocat cu 

<P>
<PRE>
int *array = (int *) malloc (lungime * sizeof (int));
</PRE>

<P>
puteþi tipãri array-ul cu:

<P>
<PRE>
(gdp) p *array@lungime
</PRE>

<P>
</LI>
<LI>Puteþi folosi gdb ºi pentru a chema propriile dumneavoastrã
funcþii.  Eu implementez în codul meu funcþii care tipãresc
structurile de date complicate.  Cind folosesc gdb pot inspecta aceste
structuri chemînd funcþiile din linia de comandã:

<P>
<PRE>
(gdb) print tipareste_arbore(t)
1
|--2
|--3
   |--4
   |  |--5
   |--6
$1 = void
(gdb)
</PRE> 
<P>
Rezultatul evaluãrii funcþiei <TT>tipareste_arbore</TT> este nul
(<TT>void</TT>), dar efectul executãrii ei se vede pe ecran.

<P>
</LI>
<LI>Gdb oferã o multitudine de comenzi pentru controlul stivei:
<DL>
<DT><STRONG>backtrace:</STRONG></DT>
<DD>aratã procedurile în curs de execuþie pe
stivã, cu argumentele lor;
</DD>
<DT><STRONG>down/up:</STRONG></DT>
<DD>mutã punctul de interes în procedura apelatã,
respectiv apelantã (dar nu ºi execuþia); se pot apoi inspecta
variabilele locale ale acestor proceduri;
</DD>
<DT><STRONG>return:</STRONG></DT>
<DD>terminã imediat procedura curentã, returnîndu-se la
apelant;
</DD>
<DT><STRONG>frame:</STRONG></DT>
<DD>face o anumitã procedurã de pe stivã punctul de
interes.
</DD>
</DL>

<P>
</LI>
<LI>Gdb poate face ca breakpoint-urile sã evalueze de fiecare datã
o expresie ºi sã continue execuþia dacã expresia e falsã.  Sau
poate ignora fiecare breakpoint pentru un numãr de repetiþii.
Breakpoint-Uri se instaleazã cu comanda <TT>break</TT>, se ºterg cu
comanda <TT>delete</TT>, ºi pot avea ataºate condiþii cu comanda
<TT>cond</TT>.  Watchpoint-uri se pot instala cu comanda <TT>watch</TT>;

<P>
</LI>
<LI>Gdb poate fi folosit pentru a depana programe care au mai multe
thread-uri concurente în execuþie.

<P>
</LI>
<LI>Gdb permite definirea de variabile noi, numite cu $ în faþã.
Sã zicem cã avem un vector de structuri, ºi vrem sã vedem din
fiecare cîmpul <TT>cheie</TT>; putem face asta în felul urmãtor:

<P>
<PRE>
(gdb) set $i = 0
(gdb) p vector[$i++].cheie
(gdb) ENTER
(gdb) ENTER
...
</PRE>

<P>
La fiecare ENTER se va re-executa instrucþiunea anterioarã, care va
incrementa variabila <TT>$i</TT>, plimbîndu-se prin vector;

<P>
</LI>
<LI>Cu comanda <TT>display</TT> gdb poate fi rugat sã evalueze ºi
tipãreascã o expresie de fiecare datã cînd se programul urmãrit
se opreºte din execuþie;

<P>
</LI>
<LI>Gdb poate tipãri informaþii despre tipurile obiectelor, ºi
chiar ºi tipuri:

<P>
<PRE>
(gdb) whatis v
type = struct complex
(gdb) ptype v
type = struct complex {
    double real;
    double imag;
}
</PRE>

<P>
</LI>
<LI>Gdb poate fi folosit pentru a depana programe la distanþã, pe
alte calculatoare; gdb poate fi conectat prin reþea la programul
depanat.  În felul asta se pot depana nucleele unor sisteme de
operare, sau programe pe sisteme de operare care nu suportã
debuggere.  Programele vor trebui atunci sã fie legate cu niºte
proceduri speciale, care transformã programul depanat într-un
server, debugger-ul fiind un client pe o maºinã la distanþã.
Pentru a depana la distanþã pe sisteme care suportã debuggere,
programul <TT>gdbserver</TT> funcþioneazã simultan ca un debugger ºi
ca un server (ºi atunci nu mai trebuie legat codul special în
programul depanat).  Gdbserver ruleazã pe aceeaºi maºinã cu
programul de depanat, iar gdb se conecteazã la server prin reþea,
permiþînd depanarea la distanþã.

<P>
</LI>
<LI>Gdb oferã un limbaj simplu în care poate fi programat, ºi
poate executa ``scripturi'' (mici programe).  Oferã construcþiile
<TT>if</TT>, <TT>while</TT>, <TT>define</TT> (care defineºte macrouri).
</LI>
</UL>

<P>

<H1><A NAME="SECTION00070000000000000000">
DDD - o interfaþa vizualã</A>
</H1>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="ddd-splash"></A><A NAME="257"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
</CAPTION>
<TR><TD><IMG
 WIDTH="225" HEIGHT="76" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=5cm\epsffile{ddd-splash.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
În fine, voi spune cîteva cuvinte despre DDD.  DDD nu este un
debugger, ci doar o interfaþã pentru un alt debugger.  DDD
beneficiazã de toatã puterea debugger-ului pe care îl foloseºte,
pentru cã una din ferestrele sale oferã de fapt chiar interfaþa în
linie de comandã clasicã cu debugger-ul.  

<P>
DDD face practic inutilã învãþarea majoritãþii comenzilor gdb,
pentru cã oferã interfeþe foarte intuitive.  Figura&nbsp;<A HREF="ddd-html.html#ddd">3</A>
aratã principalele ferestre ale lui DDD.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="ddd"></A><A NAME="263"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3:</STRONG>
Cele trei ferestre ale lui DDD: <B>sus</B> pentru
inspecþia valorilor, <B>centru</B> pentru surse, <B>jos</B> pentru
consola depanatorului.</CAPTION>
<TR><TD><IMG
 WIDTH="543" HEIGHT="431" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{ddd.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Iatã ce poate face DDD mai bine decît debugger-ele:

<P>

<UL>
<LI>Afiºeazã simultan consola de interacþiune cu debugger-ul, o
vedere asupra fiºierului sursã, ºi o imagine instantanee a
structurilor de date care se doresc vizualizate;

<P>
</LI>
<LI>Drag-and-drop breakpoint-uri: poþi sã creezi, muþi ºi modifici
breakpoint-uri cu uºurinþã;

<P>
</LI>
<LI>Controlul sesiunilor: DDD þine minte o grãmadã de lucruri pe
care le faci, le poate salva, ºi reîncãrca altã datã.  De exemplu
DDD poate pune automat la loc toate breakpoint-urile.  Cînd debugger-ul
``crapã'' (se mai întîmplã ºi asta) DDD îl reporneºte automat;

<P>
</LI>
<LI>DDD se poate interfaþa cu debuggere multiple, nu numai cu gdb.
ªtie de multe alte debuggere comerciale, ca dbx, sau debuggere
specializate;

<P>
</LI>
<LI>Ca atare DDD suportã o mulþime de limbaje, nu numai C ºi C++:
folosind debuggere specializate, DDD poate fi folosit pentru a depana
programe Perl, Python, Modula-2, Java;

<P>
</LI>
<LI>Cea mai impresionantã trãsãturã a lui DDD este modul în
care poate afiºa structuri de date complexe ºi relaþiile dintre
ele.  Figura&nbsp;<A HREF="ddd-html.html#display">4</A> aratã cum DDD înfãþiºeazã structuri.
Un simplu dublu-click pe un cîmp al unei structuri va afiºa apoi
cîmpul respectiv;

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="display"></A><A NAME="272"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 4:</STRONG>
Un display care afiºeazã relaþii
complicate între variabile de tip structurã.</CAPTION>
<TR><TD><IMG
 WIDTH="677" HEIGHT="401" BORDER="0"
 SRC="img4.png"
 ALT="\begin{figure}\centerline{\epsfxsize=15cm\epsffile{display.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
</LI>
<LI>Pe lîngã afiºarea datelor, DDD poate folosi programul de
desenat grafice <TT>gnuplot</TT> pentru a face grafice ale unor array-uri
enorme.  Asta este foarte util pentru cei care scriu cod pentru
calcule cu matrici mari;

<P>
</LI>
<LI>Utilizatorul îºi poate defini propriile butoane, care cînd
sunt apãsate trimit comenzi complexe debugger-ului;

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="butoane"></A><A NAME="279"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 5:</STRONG>
Butoane definite de utilizator, cu funcþiuni
complexe.</CAPTION>
<TR><TD><IMG
 WIDTH="631" HEIGHT="20" BORDER="0"
 SRC="img5.png"
 ALT="\begin{figure}\centerline{\epsfxsize=14cm\epsffile{butoane.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
</LI>
<LI>Este suficient sã duci mouse-ul pe o variabilã din fereastra
cu sursa programului pentru a vedea valoarea ei;

<P>
</LI>
<LI>Debugger-ul memoreazã valorile afiºate atunci cînd programul
se opreºte, ºi permite mersul înainte ºi înapoi pentru a
vizualiza valori din trecut, cu butoanele Undo/Redo.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="comanda"></A><A NAME="285"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 6:</STRONG>
Panoul de comandã central al lui DDD, cu
funcþiunile cele mai importanta.</CAPTION>
<TR><TD><IMG
 WIDTH="87" HEIGHT="242" BORDER="0"
 SRC="img6.png"
 ALT="\begin{figure}\centerline{\epsfxsize=2cm\epsffile{comanda.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
</LI>
</UL>

<P>
Una peste alta, DDD este o sculã extrem de ergonomicã, ºi care se
poate dovedi de un ajutor de nepreþuit pentru cei care au de depanat
programe complexe.

<P>
Vã doresc programe cît mai corecte!

<P>
<BR><HR><H4>Note</H4>
<DL>
<DT><A NAME="foot60">... DDD</A><A NAME="foot60"
 HREF="ddd-html.html#tex2html3"><SUP>1</SUP></A>
<DD>ªi aici
putem dezbate: putem zice cã atunci cînd nu avem la dispoziþie un
debugger, vom fi motivaþi sã scriem un cod de calitate mai bunã,
gîndindu-ne mai mult la structura lui, tocmai pentru cã depanarea
este dificilã.

</DL>
<BR><HR>

</BODY>
</HTML>
