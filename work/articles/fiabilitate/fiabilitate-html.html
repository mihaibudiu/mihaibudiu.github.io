<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Fiabilitatea în arhitectura calculatoarelor</TITLE>
<META NAME="description" CONTENT="Fiabilitatea în arhitectura calculatoarelor">
<META NAME="keywords" CONTENT="fiabilitate-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY>

<P>

<P>
<H1 ALIGN="CENTER">Fiabilitatea în arhitectura calculatoarelor</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>decembrie 2001</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>fiabilitatea în sistemele de calcul
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>noþiuni elementare despre arhitectura calculatoarelor
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>fiabilitate, redundanþã, toleranþa
  defectelor, cost
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html56"
  HREF="fiabilitate-html.html">Introducere</A>
<LI><A NAME="tex2html57"
  HREF="#SECTION00030000000000000000">Fiabilitate</A>
<UL>
<LI><A NAME="tex2html58"
  HREF="#SECTION00031000000000000000">Definiþie</A>
<LI><A NAME="tex2html59"
  HREF="#SECTION00032000000000000000">Redundanþã</A>
<LI><A NAME="tex2html60"
  HREF="#SECTION00033000000000000000">Erori tranziente ºi erori permanente</A>
<LI><A NAME="tex2html61"
  HREF="#SECTION00034000000000000000">Costul fiabilitãþii; sisteme echilibrate</A>
</UL>
<BR>
<LI><A NAME="tex2html62"
  HREF="#SECTION00040000000000000000">Creºterea fiabilitãþii</A>
<UL>
<LI><A NAME="tex2html63"
  HREF="#SECTION00041000000000000000">Evitarea defectelor</A>
<LI><A NAME="tex2html64"
  HREF="#SECTION00042000000000000000">Scheme de votare</A>
<LI><A NAME="tex2html65"
  HREF="#SECTION00043000000000000000">Procesorul IBM G5 din sistemul S/390</A>
<LI><A NAME="tex2html66"
  HREF="#SECTION00044000000000000000">Un procesor superscalar tolerant la erori tranziente</A>
<LI><A NAME="tex2html67"
  HREF="#SECTION00045000000000000000">DIVA</A>
<LI><A NAME="tex2html68"
  HREF="#SECTION00046000000000000000">Coduri detectoare ºi corectoare de erori</A>
<LI><A NAME="tex2html69"
  HREF="#SECTION00047000000000000000">RAID</A>
</UL>
<BR>
<LI><A NAME="tex2html70"
  HREF="#SECTION00050000000000000000">Rezumat</A>
<LI><A NAME="tex2html71"
  HREF="#SECTION00060000000000000000">Fiabilitatea programelor</A>
<UL>
<LI><A NAME="tex2html72"
  HREF="#SECTION00061000000000000000">Verificare formalã</A>
</UL>
<BR>
<LI><A NAME="tex2html73"
  HREF="#SECTION00070000000000000000">Expunerea defectelor</A>
<UL>
<LI><A NAME="tex2html74"
  HREF="#SECTION00071000000000000000">Internetul</A>
<LI><A NAME="tex2html75"
  HREF="#SECTION00072000000000000000">Teramac</A>
</UL>
<BR>
<LI><A NAME="tex2html76"
  HREF="#SECTION00080000000000000000">Algoritmi aleatori</A>
<UL>
<LI><A NAME="tex2html77"
  HREF="#SECTION00081000000000000000">Amplificarea probabilitãþilor</A>
<LI><A NAME="tex2html78"
  HREF="#SECTION00082000000000000000">Criptografie</A>
<LI><A NAME="tex2html79"
  HREF="#SECTION00083000000000000000">Algoritmi aleatori în reþele</A>
</UL>
<BR>
<LI><A NAME="tex2html80"
  HREF="#SECTION00084000000000000000">Spre o nouã arhitecturã a calculatoarelor</A>
<LI><A NAME="tex2html81"
  HREF="#SECTION00090000000000000000">Alte surse de informaþie</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>

<H1><A NAME="SECTION00020000000000000000">
Introducere</A>
</H1>

<P>
În acest text voi prezenta arhitectura sistemelor de calcul dintr-un
singur punct de vedere, ºi anume cel al <EM>fiabilitãþii</EM>.
Prezentarea nu va fi exhaustivã ºi nici matematizatã; voi folosi
mai ales exemple pentru a ilustra cum felurite consideraþii despre
fiabilitate influenþeazã design-ul sistemelor de calcul.

<P>
Principalul subiect al teoriei fiabilitãþii (reliability theory)
este construirea sistemelor fiabile din componente nefiabile.  Dacã
un sistem ar funcþiona numai atunci toate componentele sale ar fi
funcþionale, ar fi virtual imposibil de construit un sistem complex,
pentru cã fiabilitatea ar descreºte exponenþial cu numãrul de
componente.

<P>
Principala unealtã folositã în construirea sistemelor complexe este
<EM>abstracþia</EM>.  Un sistem este construit pe nivele; nivelul B este
alcãtuit din componente de nivel A.  La rîndul lor, componente de
nivel B sunt folosite ca ºi cum ar fi atomice, indivizibile, pentru a
construi nivelul C, ºi aºa mai departe.  Acest proces este inspirat
din matematicã, unde lemele ºi teoremele sunt folosite drept
componente elementare în demonstraþiile altor leme ºi teoreme.  În
acest text vom privi alcãtuirea unor nivele din arhitectura
sistemelor de calcul din punctul de vedere al fiabilitãþii pe care o
oferã nivelelor superioare.  Astfel putem distinge:

<P>

<OL>
<LI>Nivele care <EM>mãresc fiabilitatea</EM>, construind un tot mai
  fiabil din componente mai puþin fiabile.  Acest lucru este obþinut
  folosind <EM>redundanþã</EM> în stocarea sau calculul informaþiei.
  Acest tip de nivel este cel mai adesea folosit în construcþia
  calculatoarelor contemporane.  Secþiunea&nbsp;<A HREF="fiabilitate-html.html#fiabilitate">3</A> discutã
  multe astfel de exemple.
</LI>
<LI>Nivele care <EM>expun lipsa de fiabilitate</EM> nivelelor
  superioare, lãsîndu-le pe acestea sã rezolve imperfecþiunile.
  Nivelele superioare au adesea informaþii suplimentare despre
  cerinþele reale de fiabilitate ale sistemului, ºi ca atare pot
  construi fiabilitate pe mãsura necesitãþilor.  Arhitectura
  Internetului, pe care o vom discuta sumar în
  secþiunea&nbsp;<A HREF="#expunere"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/local/lib/latex2html/icons/crossref.png"></A> din numãrul viitor al revistei este unul
  dintre cele mai notorii exemple de acest gen.
</LI>
<LI>În fine, anumite nivele <EM>partiþioneazã</EM> resursele în
  parþi oarecum independente, izolate una de alta.  Partiþionarea
  are drept efect <EM>izolarea defectelor</EM> (fault containment / fault
  isolation), astfel încît o defecþiune într-o parte sã nu afecteze
  celelalte pãrþi.  În calculatoare aceastã tehnicã este folositã
  în sistemele de operare ºi clustere-le de calculatoare.
</LI>
</OL>

<P>
La ora actualã circuitele integrate pe scarã largã (Very Large
Scale Integrated circuits, VLSI) au ajuns la nivele incredibile
de fiabilitate.  Ca atare arhitecþii calculatoarelor în general
privesc nivelul hardware ca fiind ``perfect'' ºi folosesc aceastã
abstracþie foarte convenabilã în proiectarea nivelelor superioare.
Anumite clase de aplicaþii însã au nevoie de o fiabilitate foarte
ridicatã (de exemplu, controlul de trafic aerian sau supervizarea
centralelor nucleare).  În astfel de sisteme critice arhitecþii
sistemelor de calcul iau în considerare ºi posibilitatea defectelor
hardware, pe care le trateazã în software.

<P>
Miniaturizarea continuã a circuitelor integrate va duce la schimbãri
în aceastã stare de fapt; trebuie sã ne aºteptãm ca în viitor
circuitele sã conþinã din ce în ce mai multe defecþiuni ºi sã
fie din ce în ce mai sensibile la fluctuaþii termodinamice ºi
particule de înaltã energie din radiaþia cosmicã sau chiar din
degradarea radioactivã a circuitului integrat!  Astfel de schimbãri
vor cere probabil o regîndire completã a arhitecturii sistemelor de
calcul.

<P>

<H1><A NAME="SECTION00030000000000000000">
Fiabilitate</A>
</H1>

<P>
În aceastã secþiune voi introduce terminologia folositã în restul
articolului.

<P>

<H2><A NAME="SECTION00031000000000000000">
Definiþie</A>
</H2>

<P>
Chiar dacã acest text nu este matematic, voi da o definiþie precisã
a noþiunii de fiabilitate.

<P>
<BLOCKQUOTE>
Fiabilitatea unui obiect (o componentã sau un sistem) este o funcþie
de timp <I>F(t)</I>, definitã ca probabilitatea ca, în condiþii de mediu
specificate, obiectul sã funcþioneze adecvat în intervalul de timp
<I>[0,t)</I>.
</BLOCKQUOTE>

<P>
Putem face cîteva observaþii foarte importante legate de aceastã
definiþie:

<P>

<UL>
<LI>Fiabilitatea este o probabilitate, cuprinsã între 0 ºi 1.
</LI>
<LI>Nu existã sisteme perfect fiabile, pentru care pentru care <I>F(t) = 1</I>
  dacã <I>t &gt; 0</I>.  Putem însã vorbi de sisteme ``destul de fiabile'',
  atunci cînd avem în minte anumite condiþii de utilizare ºi
  constrîngeri bugetare pentru implementarea sistemului.
</LI>
<LI>Nu putem defini fiabilitatea fãrã a specifica mediul în
  care sistemul opereazã.  Un calculator care merge foarte bine pe
  birou nu este neapãrat potrivit pe un satelit.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00032000000000000000"></A><A NAME="redundanta"></A>
<BR>
Redundanþã
</H2>

<P>
Ingredientul cel mai folosit pentru a construi sisteme fiabile este
redundanþa.  Putem distinge douã genuri de redundanþã, spaþialã
ºi temporalã:

<P>
<DL>
<DT><STRONG>Redundanþa spaþialã</STRONG></DT>
<DD>foloseºte mai multe componente decît
  strict necesar pentru a implementa un anumit sistem.  Resursele
  adiþionale fac calcule suplimentare ºi rezultatele sunt comparate
  între ele.  În general, cu cît redundanþa unui sistem este mai
  mare, cu atît poate detecta sau tolera mai multe erori.
  
</DD>
<DT><STRONG>Redundanþa temporalã</STRONG></DT>
<DD>constã în folosirea aceluiaºi
  dispozitiv pentru a calcula acelaºi lucru în mod repetat, dupã
  care rezultatele sunt comparate între ele.
</DD>
</DL>

<P>

<H2><A NAME="SECTION00033000000000000000">
Erori tranziente ºi erori permanente</A>
</H2>

<P>
Putem clasifica defectele în douã mari categorii:

<P>
<DL>
<DT><STRONG>Erori tranziente</STRONG></DT>
<DD>sunt erori care se manifestã printr-o
  malfuncþie temporarã a unei componente, dar nu prin defectarea ei
  definitivã.  În sistemele de calcul contemporane, cea mai mare
  parte a erorilor sunt tranziente.
  
</DD>
<DT><STRONG>Erori permanente:</STRONG></DT>
<DD>se produc la un moment dat ºi persistã
  pînã cînd sistemul este reparat.  În aceastã categorie includem
  ºi defectele din fabricaþie.
</DD>
</DL>

<P>
Dupã cum vã puteþi imagina, redundanþa temporalã poate fi
folositã numai pentru a tolera defecte tranziente.  Pentru a tolera
efecte permanente trebuie sã avem o formã de redundanþã
spaþialã.

<P>

<H2><A NAME="SECTION00034000000000000000">
Costul fiabilitãþii; sisteme echilibrate</A>
</H2>

<P>
Cînd proiectãm un sistem complex este foarte important sã
``echilibrãm'' fiabilitatea pãrþilor.  De exemplu, dacã memoria
unui sistem are o fiabilitate mult mai mare decît procesorul, atunci
sistemul se va defecta cel mai adesea cu probleme de procesor.  Faptul
cã memoria este de foarte bunã calitate nu ne ajutã cu nimic;
dimpotrivã, probabil cã am plãtit un preþ mai mare pentru memorie
decît ar fi fost strict necesar.  În general, o componentã este
``destul de bunã'' dacã nu are cea mai mare probabilitate de
defectare.

<P>
Întotdeauna cînd discutãm despre fiabilitate trebuie sã socotim nu
numai costul componentelor fiabile, ci ºi costul întreþinerii
sistemului.  Cît pierdem pe orã atunci cînd sistemul nu
funcþioneazã?  Dacã cumpãrãm componente foarte fiabile plãtim
prea mult pentru construcþia sistemului, dar dacã cumpãrãm
componente cu fiabilitate prea redusã, ne va costa prea mult
întreþinerea sistemului.  Numai contextul poate dicta cît de fiabil
trebuie sã fie un sistem: de exemplu, în aplicaþiile critice
descrise mai sus, costul ne-funcþionãrii sistemului este uriaº,
aºa încît are sens sã investim în componente extrem de fiabile.

<P>

<H1><A NAME="SECTION00040000000000000000"></A><A NAME="fiabilitate"></A>
<BR>
Creºterea fiabilitãþii
</H1>

<P>
În aceastã secþiune voi discuta cîteva tehnici folosite pentru a
construi sisteme de calcul fiabile.

<P>

<H2><A NAME="SECTION00041000000000000000">
Evitarea defectelor</A>
</H2>

<P>
Evitarea defectelor este o metodologie idealizatã, care presupune cã
toate componentele sunt perfecte.  Pentru cã hardware-ul de astãzi
are o calitate excepþionalã, nivelul software în calculatoarele
obiºnuite adoptã o astfel de viziune idealizatã.  Programatorii
presupun cã sistemul pe care se ruleazã programele lor este lipsit
de defecþiuni.

<P>
Fiabilitatea excelentã a dispozitivelor hardware este obþinutã
printr-o combinaþie de tehnici, cum ar fi felurite forme de
redundanþã, proiectare ºi fabricaþie cu precizie foarte ridicatã,
ºi o fazã agresivã de testare ºi ``ardere'' (burn-in).

<P>
Empiric s-a observat cã sistemele tind sã aibã o mortalitate care
urmãreºte o curbã numitã albie, ilustratã în figura&nbsp;<A HREF="fiabilitate-html.html#albie">1</A>:
sistemele foarte tinere ºi cele foarte uzate se stricã mult des
decît sistemele ``mature''.  ``Burn-in'' este o fazã de testare care
foloseºte componentele pînã devin mature; în acest fel,
componentele cu mortalitate infantilã ridicatã sunt eliminate.

<P>
În plus fabricanþii proiecteazã ºi testeazã sisteme de calcul în
condiþii mai nefavorabile decît cele specificate.  De exemplu, pe
acest fapt se bazeazã cei care fac ``overclocking'': specificaþiile
unui procesor indicã frecvenþa de ceas la care acesta poate opera.
Dar în mod frecvent un procesor cu specificaþie de ceas de 1Ghz
poate opera la 1.2Ghz, datoritã marginilor de toleranþã din
fabricaþie.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="albie"></A><A NAME="204"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
<I>Graficul ratei de eroare a unui dispozitiv în
  funcþie de vîrsta sa are adesea forma de albie: dispozitivele
  foarte noi ºi foarte vechi au o probabilitate mai mare de a se defecta.</I></CAPTION>
<TR><TD><IMG
 WIDTH="315" HEIGHT="189" BORDER="0"
 SRC="img5.png"
 ALT="\begin{figure}\centerline{\epsfxsize=7cm\epsffile{albie.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Metoda evitãrii defectelor este cu adevãrat extremã.  În restul
acestui text vom vedea metode mai pesimiste, care recunosc cã fiecare
din componente se poate defecta ºi încearcã se menþinã sistemul
în funcþionare; aceastã paradigmã se numeºte ``toleranþa
defectelor'' (fault-tolerance).

<P>

<H2><A NAME="SECTION00042000000000000000">
Scheme de votare</A>
</H2>

<P>
O metodã foarte simplã dar scumpã de a tolera erori este de a
multiplica fiecare componentã.  De exemplu, dacã duplicãm întreg
sistemul de calcul, apariþia unui defect poate fi detectatã
comparînd rezultatele celor douã subsisteme.

<P>
Prima schemã de toleranþã a defectelor a fost propusã de
John von Neumann în 1956 ºi se numeºte ``redundanþã modularã
triplã'' (Triple Modular Redundancy).  În aceastã schemã trei
module fac aceeaºi operaþie ºi un modul de ``vot'' alege rezultatul
majoritar.  Dacã fiecare componentã are o fiabilitate de peste 50%,
fiabilitatea ansamblului este mai mare decît a componentelor.
Existã ºi scheme în care sistemul de votare este replicat, pentru a
nu depinde de o singurã componentã.

<P>
Un astfel de sistem de votare este folosit în calculatoarele care
controleazã naveta spaþialã: sistemul este compus din cinci
calculatoare, din care patru fac aceleaºi calcule ºi al cincilea
este folosit pentru operaþiuni ne-critice.  Rezultatele celor patru
calculatoare se duc pînã la sistemele controlate (motoare), care
calculeazã local rezultatul votului.  În plus, fiecare calculator
comparã rezultatele cu celelalte trei; cînd unul dintre ele dã
rezultate diferite este scos din funcþiune.

<P>
Dacã douã calculatoare se defecteazã sistemul intrã într-un mod
de funcþionare în care rezultatele sunt comparate ºi recalculate
cînd diferã.  Al cincilea calculator conþine un sistem de control
complet separat, dezvoltat de altã companie, care intrã în
funcþiune cînd un bug identic este detectat în celelalte patru
programe (aceastã metodã va fi prezentatã în
secþiunea&nbsp;<A HREF="fiabilitate-html.html#nversiuni">5.0.2</A>).

<P>

<H2><A NAME="SECTION00043000000000000000">
Procesorul IBM G5 din sistemul S/390</A>
</H2>

<P>
În aceastã secþiune vom discuta un tip de redundanþã hibridã,
care foloseºte redundanþa spaþialã pentru a detecta erori
tranzitorii ºi redundanþa temporalã pentru a le remedia.  Acest
sistem este asemãnãtor cu modul de funcþionare cu douã defecþiuni
folosit de naveta spaþialã, descris mai sus.  Aceastã tehnicã e
utilizatã în multe sisteme comerciale, dar noi vom discuta
microprocesorul G5 folosit de compania IBM în calculatoarele sale
mainframe.

<P>
Microprocesorul G5 conþine douã benzi de execuþie identice, care
sunt controlate de acelaºi ceas.  Toate instrucþiunile sunt
executate în mod sincron de ambele benzi, iar la sfîrºitul benzii
rezultatele sunt comparate.  Dacã rezultatele sunt identice,
rezultatul instrucþiunii este scris în registrul destinaþie sau în
memorie.  Dacã nu, se genereazã o excepþie software, care de obicei
se soldeazã cu re-execuþia instrucþiunii-problemã.  Erorile
tranziente sunt astfel reparate în mod transparent.  Aceastã schemã
este funcþionalã pentru cã probabilitatea ca o eroare tranzientã
sã afecteze ambele benzi în acelaºi fel este foarte foarte micã.

<P>
Calculatorul S/390 foloseºte redundanþa în multe alte feluri: toate
sursele de curent, sistemele de rãcire, discurile, etc., sunt
duplicate.  Sistemul nu are un singur punct critic.  Acesta este deci
un sistem echilibrat: ce sens ar avea un microprocesor deosebit de
fiabil dacã sursa de curent se poate arde adesea?

<P>

<H2><A NAME="SECTION00044000000000000000">
Un procesor superscalar tolerant la erori tranziente</A>
</H2>

<P>
O schemã foarte originalã care foloseºte doar redundanþã
temporalã pentru a tolera erori tranziente a fost propusã anul
acesta la conferinþa de microarhitecturã MICRO 2001 de un grup de
cercetãtori de la universitatea Carnegie Mellon.  În aceastã
schemã, unui procesor superscalar obiºnuit i se fac cîteva
modificãri simple, astfel încît fiecare instrucþiune cititã sã
fie lansatã în execuþie în mod repetat.  Mecanismele de redenumire
a regiºtrilor folosite în procesorul superscalar fac executarea unor
instrucþiuni suplimentare, care nu afecteazã sistemul, un lucru
foarte simplu.  La sfîrºitul benzii de asamblare rezultatele
copiilor lansate în execuþie sunt comparate între ele.  Robusteþea
depinde de gradul de redundanþã: dacã fiecare instrucþiune este
executatã de douã ori, o eroare se manifestã prin rezultate
diferite ºi instrucþiunea trebuie re-executatã; dacã o
instrucþiune este executatã de mai mult de douã ori, se poate
folosi o schemã de votare cu majoritate.

<P>
Un astfel de procesor poate fi proiectat sã lucreze fie în mod
normal, fie în mod cu fiabilitate crescutã, depinzînd de tipul de
program executat.  Performanþa în modul cu fiabilitate ridicatã
este invers proporþionalã cu gradul de redundanþã; de exemplu,
dacã fiecare instrucþiune este executatã de douã ori, ne-am
aºtepta la o scãdere a vitezei de calcul la 50%.  In realitate,
penalizarea este ceva mai micã, din cauzã cã un program nu
foloseºte toate resursele computaþionale.  De exemplu, dacã un
program foloseºte 80% din resurse, cind executam programul
duplicînd fiecare instrucþiune avem nevoie de 160% resurse, ceea ce
se traduce într-o degradare a performanþei cu 37,5% (100/160 = 62,5
= 100 - 37,5).

<P>

<H2><A NAME="SECTION00045000000000000000">
DIVA</A>
</H2>

<P>
O schemã deosebit de interesantã de redundantã spaþialã a fost
propusã în aceeaºi conferinþã în 1999 de cãtre Todd Austin,
profesor la universitatea Michigan.  Acest proiect e numit DIVA,
de la Dynamic Implementation Verification Architecture: arhitecturã cu
verificare dinamicã.

<P>
Spre deosebire de schemele anterioare, DIVA e proiectatã pentru a
tolera atît erori tranziente, cît ºi permanente (cele din urmã doar
în anumite pãrþi ale sistemului).  Observaþia centralã pe care se
bazeazã DIVA este cã e mai uºor de verificat dacã rezultatul unui
calcul e corect decît este de efectuat calculul însuºi.  Ca atare,
arhitectura DIVA este compusã din douã procesoare diferite:

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="diva"></A><A NAME="211"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
<I>Procesorul DIVA este compus dintr-un procesor
  performant care efectueazã calculele ºi un procesor lent ºi
  foarte robust care le verificã corectitudinea.</I></CAPTION>
<TR><TD><IMG
 WIDTH="359" HEIGHT="248" BORDER="0"
 SRC="img6.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{diva.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<UL>
<LI>Un procesor complex, superscalar, foarte optimizat, care face
  calculele în mod normal;
</LI>
<LI>Un procesor extrem de simplu, mai lent, dar foarte fiabil,
  care executã instrucþiunile în ordine, ºi este construit
  folosind tehnici de evitare a defectelor.
</LI>
</UL>

<P>
Procesorul DIVA funcþioneazã astfel:

<P>
Procesorul complex executã toate instrucþiunile ºi calculeazã
rezultatele lor.  Rezultatele însã nu sunt scrise, ci sunt transmise
procesorului simplu.

<P>
Procesorul simplu merge ceva mai încet, ºi verificã în paralel
toate detaliile rezultatelor primite.  Deºi acest procesor este mai
simplu, are o treabã mai uºoarã, ºi ca atare poate atinge aceeaºi
performanþã ca cel rapid (exprimatã în instrucþiuni procesate pe
secundã).  Cînd verificarea descoperã o eroare, procesorul simplu
calculeazã rezultatul corect ºi re-porneºte procesorul complex de
la instrucþiunea urmãtoare.

<P>
Foarte interesant este cã o arhitecturã DIVA poate tolera chiar
erori de proiectare în procesorul foarte complicat, pentru cã
acestea sunt detectate ºi corectate de procesorul lent ºi simplu.
Poate fi chiar avantajos ca procesorul rapid sã fie proiectat
``incorect'', dar extrem de rapid, în cazul în care nu produce
rezultate eronate prea frecvent.  De exemplu, într-un procesor normal
foarte multe circuite suplimentare sunt introduse pentru a trata
corect cazul programelor care se auto-modificã.  În realitate,
practic nici un program modern nu foloseºte aceastã tehnicã în mod
curent; procesorul rapid fãrã aceste circuite poate fi fãcut mult
mai eficient.  Corectitudinea va fi asiguratã de procesorul lent.

<P>

<H2><A NAME="SECTION00046000000000000000">
Coduri detectoare ºi corectoare de erori</A>
</H2>

<P>
Am vãzut deja mai multe exemple de folosire a redundanþei spaþiale
pentru detectarea ºi corectarea erorilor.  Costul schemelor
prezentate mai sus este substanþial: ele cer o replicare identicã a
unui întreg sistem.  De exemplu, redundanþa modularã triplã are o
eficienþã de 33%, pentru ca hardware-ul este replicat de trei ori.

<P>
E interesant de explorat dacã nu putem obþine aceleaºi beneficii
cheltuind mai puþine resurse suplimentare.  Deschizãtori de drumuri
au fost în aceastã privinþã Claude Shannon ºi Richard Hamming,
spre sfîrºitul anilor '40.  Vom discuta despre metodele propuse de
ei pentru a stoca informaþie în mod fiabil.

<P>
Sã presupunem cã vrem sã stocãm niºte informaþii codificate în
baza doi într-un mod fiabil.  Putem atunci de pildã face douã copii
ale informaþiei.  Dar o defecþiune a unui singur bit va face
informaþia de nerecuperat, pentru cã acel bit va fi diferit în cele
douã copii, ºi nu putem deduce care este valoarea originalã.
Slãbiciunea acestei metode constã în faptul cã biþii stocaþi nu
sunt ``robuºti'': fiecare bit din mesaj este reprezentat în doar doi
biþi din cod.  Dacã ``amestecãm'' biþii din mesaj putem face mult
mai bine de atît.

<P>
Pentru a obþine rezilienþã la erori trebuie sã adãugãm
redundanþã în cod; astfel, vom codifica <I>n</I> biþi de informaþie
folosind <I>m &gt; n</I> biþi de cod.  Cu cît <I>m</I> e mai mare ca <I>n</I>, cu
atît mai robust va fi codul nostru.  Cuvintele de <I>m</I> biþi care
reprezintã coduri corecte se numesc ``cuvinte de cod'' (code words).
Observaþi cã nu toate cuvintele de <I>m</I> biþi sunt cuvinte de cod, ci
numai 2<sup><i>n</i></sup> dintre ele.

<P>
Putem defini <EM>distanþa Hamming</EM> între douã ºiruri de biþi ca
fiind numãrul de diferenþe între cele douã ºiruri.  De exemplu,
distanþa Hamming dintre 1111 ºi 1010 este 2, pentru cã cele douã 
ºiruri diferã în poziþiile a doua ºi a patra.  Cea mai micã
distanþã Hamming dintre cuvintele unui cod este o mãsurã foarte
bunã a robusteþii codului.  De exemplu, dacã distanþã Hamming
între oricare douã cuvinte este mai mare decît 3, atunci o
schimbare de 1 bit poate fi întotdeauna corectatã: cel mai apropiat
cuvînt de cod este cel care a fost modificat de eroare, pentru cã
toate celelalte cuvinte de cod se vor afla la o distanþã mai mare de
2 de cuvîntul eronat.  Astfel, un cod cu distanþã Hamming 3 poate
corecta orice eroare de 1 bit, ºi poate detecta orice eroare de doi
biþi.  Un astfel de cod va detecta ºi alte erori, de exemplu va
detecta unele erori de trei biþi, dar nu orice eroare de trei biþi.

<P>
Existã efectiv zeci de coduri diferite, fiecare potrivit în alte
circumstanþe.  Vom prezenta niºte exemple în ceea ce urmeazã.

<P>

<H3><A NAME="SECTION00046100000000000000">
Memorii</A>
</H3>

<P>
Dacã aþi cumpãrat vreodatã memorie pentru PC-ul dumneavoastrã,
v-aþi lovit desigur de dilema ``care tip de memorie trebuie
cumpãrat''.  Din punct de vedere al fiabilitãþii, existã trei
tipuri de memorie pe piaþã: memorii neprotejate, memorii cu paritate
ºi memorii ECC.

<P>
<DL>
<DT><STRONG>Memoriile neprotejate</STRONG></DT>
<DD>stocheazã fiecare bit de date în mod
  separat ºi nu oferã nici o protecþie împotriva erorilor.  Ca
  atare sunt cele mai ieftine.  Cum însã dimensiunea memoriilor a
  crescut foarte repede, la ora actualã aceastã soluþie este
  riscantã, cãci probabilitatea ca nici un bit sã nu se defecteze
  este foarte redusã.
  
</DD>
<DT><STRONG>Memoriile cu paritate</STRONG></DT>
<DD>folosesc o metodã foarte simplã
  pentru a detecta erori de un bit în fiecare octet (ºi, în general,
  erori care schimbã un numãr impar de biþi).  Pentru fiecare 8
  biþi de date aceste memorii stocheazã un al nouãlea bit de
  paritate, a cãrui valoare este calculatã astfel încît oricare
  cuvînt de nouã biþi are un numãr par de biþi ``1'' (de aici ºi
  numele schemei).

<P>
Cînd hardware-ul acceseazã memoria, automat verificã ºi
  paritatea.  Dacã paritatea nu este corectã se declanºeazã o
  excepþie ºi sistemul de operare decide cum trebuie sã
  acþioneze.  O soluþie este de a omorîprogramul care folosea acea
  memorie ºi de a marca memoria ca fiind defectã, astfel încît
  alte programe sã nu o poatã refolosi.  Verificarea paritãþii
  este o operaþie foarte rapidã, care se poate face foarte simplu
  în hardware în paralel cu transferul informaþiei.

<P>
</DD>
<DT><STRONG>Memoriile ECC</STRONG></DT>
<DD>sunt protejate cu un cod sofisticat de
  corecþie a erorilor (Error Corecting Code).  Acest cod poate
  corecta automat orice eroare de 1 bit care apare într-un cuvînt de
  64 de biþi.  Pentru acest scop memoria stocheazã fiecare cuvînt
  de 64 de biþi folosind cuvinte de cod de 72 de biþi.  Observaþi
  cã ``risipa'' (overhead) acestei scheme este aceeaºi cu cea a
  paritãþii (9/8 = 72/64); aceastã schemã oferã corecþie cu o
  robusteþe mai micã, pentru cã poate corecta o eroare la 64 de
  biþi, spre deosebire de cealaltã schemã care poate detecta o
  eroare la 8 biþi.  

<P>
La fiecare acces la memorie hardware-ul verificã dacã cuvîntul de
  cod este corect; dacã nu automat calculeazã cel mai apropiat
  cuvînt de cod pe care apoi îl decodificã.  Aceste operaþii sunt
  destul de complicate, astfel încît un sistem cu memorii ECC merge
  cu aproximativ 5% mai lent dec'it unul cu memorii cu paritate.
</DD>
</DL>

<P>

<H3><A NAME="SECTION00046200000000000000"></A><A NAME="discuri"></A>
<BR>
Discuri
</H3>

<P>
Cel mai comun suport persistent de informaþie este discul, în
multiplele lui încarnãri: hard disc, dischetã, disc optic,
compact-disc, etc.  Informaþiile din aceastã secþiune sunt valabile
pentru multe din aceste tipuri de discuri.

<P>
Discurile folosesc simultan douã metode diferite de redundanþã
spaþialã; o protecþie sporitã este necesarã din cauzã cã
discurile funcþioneazã într-un mediu mult mai aspru decît
memoriile: discurile au pãrþi mecanice în miºcare, care se uzeazã
ºi se pot strica mai uºor.

<P>
Informaþia este stocatã pe disc în <EM>sectoare</EM>.  Un sector este
relativ mare (comparat cu un cuvînt de memorie), fiind de ordinul a
jumãtate de kilooctet (512 octeþi).  Discurile folosesc sectoare
mari pentru cã la viteza lor de rotaþie (peste 5000 de revoluþii pe
minut) capetele de citire/scriere nu se pot plasa foarte precis pe
suprafaþã.  Astfel, unitatea elementarã în care se scrie pe un
disc este sectorul: chiar dacã vrem sã modificãm un singur bit,
trebuie sã rescriem tot sectorul.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="disc"></A><A NAME="218"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3:</STRONG>
<I>Formatul unui sector de disc: informaþia servo
este folositã pentru controlul miºcãrii capului, identificatorul
indicã numãrul sectorului curent, informaþia de sincronizare este
folositã pentru a sincroniza poziþia capului cu începutul
sectorului; datele sunt stocate într-un ºir compact, codificate
folosind un cod detector de erori.  Între douã sectoare consecutive
este o gaurã, care-i dã capului ceva libertate cînd rescrie
sectorul (niciodatã nu va rescrie începînd chiar din acelaºi
loc).</I></CAPTION>
<TR><TD><IMG border="0" SRC="img11.png" ALT="disc"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Codurile folosite pentru discuri se numesc CRC, de la Cyclic
Redundancy Check: coduri ciclice.  Un cuvînt de cod constã din chiar
cuvîntul de date urmat de informaþii de control; decodificarea
codurilor CRC este foarte simplã: se extrage direct cuvîntul de
date.  Codul de control verificã dacã vreunul din biþii stocaþi e
incorect.  Un cod ciclic are proprietatea cã orice permutare a
datelor este protejatã de acelaºi cuvînt de control.

<P>
Cînd codul de control indicã defectarea unui sector, discurile
folosesc în mod automat a doua formã de redundanþã spaþialã:
sectoare de rezervã.  Pe disc sunt ascunse sectoare invizibile, care
sunt folosite atunci cînd sectoarele de date încep sa dea rateuri.
În mod transparent software-ul alocã un sector de rezervã în locul
unuia defect.  Identificatorul de sector este folosit pentru a indica
cine pe cine înlocuieºte.

<P>
Discurile stocheazã o <EM>hartã de defecte</EM> care indicã sectoarele
înlocuite; asta le permite sã funcþioneze ºi dupã ce apar
defecþiuni, ºi permite de asemenea un proces de fabricaþie mai
imperfect ºi mai ieftin.

<P>

<H3><A NAME="SECTION00046300000000000000">
Turbo-coduri</A>
</H3>

<P>
Codurile detectoare ºi corectoare de erori sunt folosite pe larg în
reþelele de calculatoare.  Am scris cu alte ocazii în PC Report
despre acest subiect, astfel încît în aceastã secþiune voi
discuta despre un caz extrem.

<P>
Depinzînd de caracteristicile canalului de comunicaþii (distanþã,
cost de transmisiune, viteza semnalului, zgomot) se pot folosi coduri
mai mult sau mai puþin robuste.  În anumite cazuri e preferabil ca
erorile sã fie detectate ºi datele incorecte sã fie retransmise,
în alte cazuri costul retransmisiei este prea mare, ºi ca atare se
folosesc coduri corectoare.  Folosirea unui cod corector în
transmisiunea de date se mai numeºte ºi codare preventivã (Forward
Error Correction).

<P>
Pentru comunicaþia cu sondele spaþiale se folosesc coduri corectoare
de erori extrem de robuste, pentru cã la astfel de distanþe semnalul
electromagnetic are nevoie de multe minute pentru a se propaga.  În
1993 un grup de cercetãtori francezi a inventat o clasã de coduri
extrem de robuste, numite Turbo-coduri, care folosind o redundanþã
relativ redusã, de 200% ob'tin o rezilien't'a excep'tional'a la
zgomot, fiind foarte aproape de limitele maxime teoretice.

<P>
Turbo-codurile ilustreazã un nou tip de compromis pe care arhitectul
îl poate face în ecuaþia robusteþe/cost: costul cel mare al unui
turbo-cod nu este în cantitatea mare de informaþie suplimentarã, ci
în algoritmul de decodificare, care este foarte complicat ºi
necesitã multe iteraþii.  Dupã cum am vãzut ºi în cazul
memoriilor, cu aceeaºi redundanþã putem obþine garanþii diferite
de fiabilitate, în funcþie de algoritmul de codificare folosit.  În
cazul comunicaþiei interplanetare costul transmisiunii face costul
decodificãrii insignifiant, deci turbo-codurile sunt potrivite.

<P>

<H2><A NAME="SECTION00047000000000000000">
RAID</A>
</H2>

<P>
În aceastã secþiune voi ilustra un alt tip de sistem fiabil
redundant, care, spre deosebire de alte soluþii prezentate, are o
performanþã mai bunã decît sistemul de bazã.  În plus, acest
sistem adaugã o dimensiune nouã în spaþiul opþiunilor
fiabilitãþii, ºi anume capacitatea de a fi reparat în timp ce
funcþioneazã (maintainability).

<P>
RAID este o prescurtare de la Redundant Array of Inexpensive Disks,
sau set redundant de discuri ieftine.  Ideea a fost introdusã în
1987 de cercetãtori de la universitatea Berkeley din California, ºi
la ora actualã este obiectul unei industrii anuale de 12 miliarde de
dolari.

<P>
Ideea centralã în RAID este de a stoca informaþie pe mai multe
discuri simultan.  Informaþia este codificatã redundant, astfel
încît sã poatã fi recuperatã dacã oricare din discuri se
defecteazã.  Aceastã proprietate este foarte utilã pentru sisteme
care trebuie sã funcþioneze în foc continuu. 

<P>
Observaþi cã tipul de defecþiune pe care RAID o adreseazã este
diferit de cel descris în secþiunea&nbsp;<A HREF="fiabilitate-html.html#discuri">3.6.2</A>: aici vrem sã
operãm cînd un disc este complet distrus, acolo ne interesa sã
detectãm alteraþii ale informaþiei stocate.  Într-un sistem RAID
toate aceste tehnici opereazã simultan: fiecare disc foloseºte
coduri CRC ºi sectoare de rezervã, iar sistemul RAID foloseºte
stocare a informaþiei redundantã.

<P>
Existã mai multe tipuri de sisteme RAID, dar aici vom discuta unul
singur, în care informaþia este scrisã pe 5 discuri, din care 4
conþin date ºi unul paritate.

<P>
Un astfel de sistem RAID se poate afla într-unul din trei moduri de
funcþionare:

<P>
<DL>
<DT><STRONG>Funcþionare normalã:</STRONG></DT>
<DD>operaþiile de citire extrag date de
  pe cele patru discuri cu date.  O operaþie de scriere însã
  strînge patru blocuri de informaþie ºi calculeazã un al cincilea
  bloc de paritate; fiecare bloc este stocat pe alt disc.  Acest mod
  de scriere se numeºte ``striping'', adicã ``feliere'', pentru cã
  datele sunt scrise în paralel, cîte o felie pe fiecare disc.
  
</DD>
<DT><STRONG>Funcþionarea degradatã:</STRONG></DT>
<DD>este începutã cînd un disc se
  defecteazã.  Atunci citirile ºi scrierile de pe discul stricat
  trebuie sã acceseze celelalte patru discuri ºi sã calculeze
  informaþia lipsã.  Avantajul paritãþii este cã oricare din
  biþii lipsã poate fi recalculat ca paritatea celorlalþi patru
  biþi.
  
</DD>
<DT><STRONG>Reconstrucþia:</STRONG></DT>
<DD>este începutã cînd un disc defect este
  înlocuit.  Un proces secundar recalculeazã informaþia lipsã ºi
  o scrie pe noul disc.
</DD>
</DL>

<P>
[Restul acestui articol va fi publicat în numãrul din februarie]

<P>
<HR>
<P>

<H1><A NAME="SECTION00050000000000000000">
Rezumat</A>
</H1>

<P>
În numãrul anterior din Net Report am publicat prima parte a unui
articol despre fiabilitatea sistemelor de calcul.  Iatã aici
rezumatul ideilor importante:

<P>

<UL>
<LI>Fiabilitatea este definitã ca fiind probabilitatea ca un
  sistem sã se defecteze într-o anumitã perioadã de timp ºi în
  anumite condiþii de mediu;
</LI>
<LI>Sistemele de calcul sunt construite din succesiuni de nivele
  abstracte, care au diferite fiabilitãþi; 
</LI>
<LI>Fiabilitatea unui mecanism poate fi sporitã folosind
  redundanþa spaþialã sau temporalã; redundanþa temporalã poate
  tolera efectul unor erori tranziente, pe cînd redundanþa
  spaþialã poate ascunde ºi erori permanente;
</LI>
<LI>Un sistem de calcul trebuie sã fie echilibrat din punct de
  vedere al fiabilitãþii: toate nivelele trebuie sã fie
  comparabile, altfel cel mai nefiabil nivel este veriga cea mai
  slabã a lanþului;
</LI>
<LI>Codurile detectoare ºi corectoare de erori pot descoperi ºi
  repara stricãciuni ale datelor stocate sau transmise folosind grade
  relativ reduse de redundanþã.
</LI>
</UL>

<P>

<H1><A NAME="SECTION00060000000000000000">
Fiabilitatea programelor</A>
</H1>

<P>
Ne-am putea aºtepta, în mod naiv, ca, spre deosebire de hardware,
software-ul sã nu aibã nici un fel de probleme de fiabilitate: în
definitiv programele nu se uzeazã, ºi sunt executate într-un mediu
foarte specializat; în plus, programele sunt obiecte deterministe,
deci ar trebui sã se comporte de fiecare datã în acelaºi fel cînd
proceseazã aceleaºi date de intrare.  Cu toate acestea, de fapt
fiabilitatea programelor este mult mai scãzutã decît a sistemelor
hardware; este potrivit sã modelãm deci programele ca sisteme cu
fiabilitate imperfectã.  În aceastã secþiune discutãm în mod
superficial unele dintre motivele lipsei de fiabilitate a programelor
ºi menþionãm unele tehnici care pot fi folosite pentru a
``întãri'' programele.

<P>
Cea mai importantã cauzã a malfuncþiilor programelor sunt
bug-urile, adicã implementãri incorecte.  Chiar ºi programatori
foarte pricepuþi produc programe cu defecte.  Nu exagerãm deci dacã
afirmãm cã nu existã nici un program substanþial fãrã bug-uri,
aºa cum nu existã vreo carte tipãritã care sã nu aibã erori
tipografice.  Complexitatea componentelor software este pur ºi simplu
prea mare pentru a putea fi stãpînitã de cãtre oameni, ºi cu tot
progresul în tehnici de programare, cum ar fi descompunerea
programelor în module mici, folosirea unor limbaje de programare
evoluate ºi a unor scule complexe pentru dezvoltarea, testarea ºi analiza
programelor, rezultatele sunt încã foarte departe de perfecþiune,
ºi productivitatea programatorilor nu a crescut substanþial în
ultimele douã decenii.

<P>
Cel mai adesea problemele rezolvate în software sunt atît de
complicate încît nici nu pot fi specificate în mod precis.  În
consecinþã programatorii întîlnesc tot felul de incertitudini
cînd încearcã sã implementeze soluþiile.  O cauzã fundamentalã
a lipsei de fiabilitate a programelor este deci specificaþia
incompletã ºi imprecisã.

<P>
Cele mai insidioase defecþiuni software se manifestã numai cu ocazia
unor anumite combinaþii de valori pentru datele de intrare sau pentru
anumite succesiuni de evenimente externe, care nu au fost prevãzute de
programator.  Asemenea combinaþii apar cu probabilitate foarte micã
în timpul procedurilor normale de testare, deci adesea
supravieþuiesc pînã în faza operaþionalã.

<P>

<H3><A NAME="SECTION00060100000000000000">
Biþi ``putrezi''</A>
</H3>

<P>
A vedea programele software ca pe o entitate monoliticã este o
aproximare grosolanã a realitãþii: un program trece prin
nenumãrate revizii ºi îmbunãtãþiri, cum pot mãrturisi cei care
sunt forþaþi periodic sã facã ``upgrades''.  Versiunile noi sunt
construite pe scheletul celor vechi, reparînd defecþiunile
descoperite ºi adãugînd noi funcþionalitãþi.  Cu toate acestea,
procesul reparãrii defecþiunilor introduce adesea noi defecþiuni,
pentru cã efectele unei reparaþii au uneori consecinþe nebãnuite.

<P>
Uluitoarea creºtere a performanþei hardware-ului este o motivaþie
constantã pentru reînnoirea sistemelor software.  Pe mãsurã ce
dispozitivele hardware devin mai ieftine ºi mai compacte, ele pot fi
integrate în dispozitive electronice mai ``deºtepte''.  Toate aceste
noi dispozitive au nevoie de nou software care sã le manipuleze.  Pe
mãsurã ce costul dispozitivelor de stocare a informaþiei scade, din ce
în ce mai complexe ºi bogate tipuri de informaþie pot fi stocate ºi
prelucrate.  De exemplu, imagini ºi muzicã sunt tipuri curent
manipulate de PC-urile contemporane, ºi capacitatea lor de prelucrare
a devenit de curînd suficient de puternicã pentru a manipula în mod
interactiv filme.

<P>
Un fenomen legat de acest ciclu permanent de înnoiri este
``putrezirea biþilor'' (bit rot).  Acest fenomen se manifestã pe
douã planuri: datele stocate cu mult timp în urmã nu mai pot fi
folosite în noile sisteme de calcul, pentru cã dispozitivele
periferice învechite nu mai sunt suportate de fabricanþi, ºi
programe vechi, care mergeau foarte bine, încep sã manifeste erori.
``Boala'' programelor este legatã de mediul în care programele se
executã, ºi care este în continuã schimbare.  De exemplu, multe
programe vechi fãceau anumite presupuneri despre cît de mari vor fi
seturile de date pe care le vor prelucra.  Cea mai faimoasã astfel de
presupunere este cea care a cauzat bug-ul Y2K: programatorii din anii
'60 au presupus cã programele lor nu vor manipula niciodatã date
calendaristice al cãror an nu va începe cu cifrele 19.  Chiar dacã
Y2K a fãcut mai mult zgomot decît pagube, astfel de presupuneri se
întîlnesc la tot pasul în programele de astãzi.  De exemplu, auzim
adesea despre dificultatea de a transporta programe de la procesoare
pe 32 de biþi la procesoare pe 64 de biþi.  Din moment ce orice
valoare pe 32 de biþi se poate reprezenta exact atunci cînd folosim
64 de biþi, teoretic nu ar trebui sã fie nici o problemã, ºi
vechile programe ar trebui sã funcþioneze corect.  În realitate
multe programe depind în feluri subtile de precizia datelor pe care
le manipuleazã.  Cînd un astfel de program este mutat pe o
platformã nouã toate aceste dependinþe se transformã în bug-uri.

<P>

<H3><A NAME="SECTION00060200000000000000"></A><A NAME="nversiuni"></A>
<BR>
Programare cu N versiuni
</H3>

<P>
Domeniul ingineriei programelor (software engineering) se ocupã de
metode prin care se poate cuantifica ºi îmbunãtãþi calitatea
programelor.  Una dintre soluþiile studiate este foarte înruditã cu
tehnicile de votare folosite pentru toleranþa erorilor hardware, care
au fost prezentate în prima parte a acestui text.  Numele acestei
soluþii în lumea software este ``programare cu N versiuni''.  Votarea
foloseºte redundanþã spaþialã: dispozitivul de calcul este
replicat de N ori ºi rezultatul final este obþinut prin votul
majoritar al rezultatelor individuale.

<P>
Bug-urile software sunt persistente: aflat în aceleaºi condiþii
programul se va comporta în acelaºi fel.  Tehnicile de votare sunt
neputincioase dacã toate componentele fac aceeaºi eroare în
acelaºi timp.  Votarea este utilã pentru tratamentul erorilor
tranziente.  Programarea cu N versiuni se face deci prin executarea
în paralel a N programe diferite, scrise de echipe diferite de
programatori, dacã e posibil, folosind scule ºi tehnologii
diferite.  Toate cele N programe rezolvã aceeaºi problemã, dar în
moduri diferite.  Numai folosind o astfel de strategie tehnica
votãrii poate funcþiona în cazul programelor.

<P>
Specificaþii imprecise ale problemei pot fi detectate cu uºurinþã
de aceastã tehnicã, pentru cã implementãrile diferite pot lua
decizii diferite pentru cazurile nespecificate clar.  Din nefericire,
programarea cu N versiuni este o metodologie foarte scumpã, folositã
numai pentru aplicaþii critice, unde siguranþa este fundamentalã.  

<P>

<H3><A NAME="SECTION00060300000000000000">
Întinerirea programelor</A>
</H3>

<P>
Diferenþa fundamentalã între hardware ºi software este cã un
program poate avea o stare internã arbitrar de complicatã.  În
general, dispozitivele hardware pot fi aproximate ca fiind automate
finite (adicã spaþiul stãrilor în care se pot afla, chiar dacã
este foarte mare, este totuºi finit).  Chiar ºi cele mai simple
programe au un spaþiu de stãri infinit, mai exact, nu putem pune
nici o limitã arbitrarã dimensiunii spaþiului lor.

<P>
Aceastã diferenþã este foarte importantã ºi din punct de vedere
teoretic: foarte multe proprietãþi interesante ale automatelor
finite sunt <EM>decidabile</EM>, adicã se pot scrie algoritmi care,
atunci cînd primesc descrierea unui automat finit, pot rãspunde în
mod exact la întrebãri legate de orice evoluþie viitoare a
automatului.  Din pãcate, aceleaºi întrebãri pentru un sistem cu
stare infinitã sunt adesea nedecidabile.  Într-adevãr,
matematicienii au arãtat în anii '30 cã foarte multe dintre
proprietãþile unui sistem software în general nu pot fi calculate
de un alt sistem software.

<P>
O consecinþã practicã a dimensiunii infinite a spaþiului de stãri
al programelor este cã, pe mãsurã ce un program se executã mai
mult timp, cu atît mai complicatã poate deveni starea sa internã.
Dacã un program nu îºi întrerupe execuþia, chiar dacã va primi
aceleaºi date la intrare, ar putea calcula un rãspuns diferit.  Un
bug în program poate corupe starea internã, dar efectele acestei
stricãciuni pot deveni vizibile mult mai tîrziu în execuþia
programului, cînd programul ia o decizie bazatã pe elementele de
stare incorecte.  Un tip faimos de problemã, în mod normal benignã,
asociatã cu programele care se executã un timp îndelungat, este
scurgerea de memorie (memory leak).  

<P>
Adesea programele alocã spaþiu temporar de memorie, pe care îl
elibereazã dupã ce au terminat calculele care aveau nevoie de el.
Dacã programatorul uitã sã elibereze aceastã memorie se spune cã
memoria se scurge (leak).  Aceasta este o eroare frecvent întîlnitã
în programare, relativ greu de descoperit.  În mod normal o astfel
de eroare nu afecteazã <EM>corectitudinea</EM> programului: rezultatele
produse la final sunt corecte.  Cînd programul îºi terminã
execuþia, sistemul de operare recupereazã automat memoria scursã.
În cazul programelor care se executã timp îndelungat, cum ar fi
sistemele de operare sau servere de web, dacã o scurgere se
întîlneºte în interiorul unei bucle, cu timpul memoria pierdutã
va creºte pînã cînd toatã memoria sistemului este pierdutã.  În
astfel de cazuri de obicei sistemul îºi înceteazã execuþia sau
funcþionarea sa devine extrem de lentã, din cauzã cã resursele
rãmase sunt insuficiente.

<P>
Utilizatorii sistemului de operare Windows de la Microsoft au
descoperit ºi o soluþie pentru aceastã problemã: reboot-area
calculatorului.  Numele ºtiinþific pentru aceastã soluþie este
``reîntinerirea programelor'' (software rejuvenation).  Reîntinerirea
este cauzatã de repornirea periodicã a programelor.  Repornirea
cauzeazã iniþializarea stãrii interne la o aceeaºi valoare iniþialã.
Tehnica aceasta este aplicabilã numai dacã starea internã a
programului nu este importantã ºi poate fi pierdutã; altfel,
întinerirea trebuie sã fie combinatã cu ``checkpoint''-uri.  Un
checkpoint salveazã informaþia importantã pe un mediu de memorie
persistent, ºi o restaureazã dupã ce programul este repornit.

<P>
Reîntinerirea se aplicã cu precãdere programelor de tip server,
care executã tot timpul o buclã, acceptînd cereri de la clienþi
ºi rãspunzîndu-le.  Multe servere sunt lipsite de stare
(stateless), adicã nu pãstreazã nici un fel de informaþii despre o
tranzacþie cu un client dupã ce tranzacþia s-a consumat.
Reîntinerirea este eficace dacã costul repornirilor periodice este
mai redus decît costul repornirii dupã o cãdere catastroficã, care
poate sã implice o procedurã sofisticatã de recuperare a datelor
pierdute.  Reîntinerirea este de asemenea folositã cu succes cînd
serverele care oferã serviciul au rezerve, astfel încît servere de
rezervã pot rãspunde clienþilor în timp ce altele se
reiniþializeazã.

<P>

<H2><A NAME="SECTION00061000000000000000">
Verificare formalã</A>
</H2>

<P>
Verificarea formalã este un nume generic pentru o serie întreagã de
tehnici sofisticate care certificã corectitudinea, mai ales a
sistemelor hardware, dar în ultima vreme ºi a unor sisteme
software.  Verificarea formalã se ocupã de descoperirea ºi
eliminarea bug-urilor, ºi în acest sens este o tehnicã de creºtere
a fiabilitãþii programelor.

<P>
Cheia metodelor de verificare formalã este specificarea foarte
precisã a comportãrii componentelor sistemului de analizat (folosind
formule matematice) ºi verificarea automatã a proprietãþilor
sistemului în întregime.  Dacã ºtim cum este construit sistemul,
ºi dacã ºtim comportarea fiecãreia din componente, putem raþiona
despre comportarea ansamblului.  Raþionamentele pot fi fãcute foarte
precise folosind diferite variante de logici matematice.  Fiecare
raþionament este o serie de derivãri, în care din fapte ºtiute ca
fiind adevãrate deducem alte adevãruri.  Verificarea formalã
studiazã aceste derivãri, ºi verificã faptul cã sunt corecte.

<P>
Douã aspecte fac verificarea formalã o tehnicã foarte puternicã: (1)
calculele minuþioase sunt efectuate de cãtre calculatoare, a cãror
atenþie nu oboseºte niciodatã, (2) certitudinea nu vine din
faptul cã demonstrãm ceva, ci din faptul cã putem verifica dacã
demonstraþia este corectã!  Am menþionat ºi în prima parte a acestui
articol, cînd am descris sistemul DIVA, cã a verifica corectitudinea
unui rezultat este mult mai simplu decît a demonstra rezultatul
însuºi.  Acest fapt este extrem de folositor în contextul verificãrii
formale, în care programul care face demonstraþiile este extrem de
complicat, ºi ca atare poate conþine erori (ca orice alt program
complex) ºi deci genera demonstraþii eronate.  Un program care verificã
dacã o demonstraþie este corectã însã este mult mai simplu, ºi ca
atare ne oferã mai multã încredere.

<P>

<H1><A NAME="SECTION00070000000000000000">
Expunerea defectelor</A>
</H1>

<P>
În secþiunile din numãrul anterior al revistei, ºi în cele de mai sus,
despre fiabilitatea programelor, am discutat despre tehnici care pot
fi folosite în arhitectura calculatoarelor pentru a mãri fiabilitatea
pe care un nivel arhitectural o expune nivelelor superioare.  Am
observat cã, cel mai adesea, nivelul hardware este perceput de nivelele
superioare ca fiind ``perfect'', fãrã defecte.  Am vãzut o mulþime de
mecanisme folosite în construcþia hardware-ului pentru a oferi aceastã
iluzie.

<P>
În aceastã secþiune voi discuta o metodã complet diferitã, folositã cu
mult succes în construcþia a douã sisteme complexe.  Aceastã tehnicã
pleacã de la asumpþia cã nivelul inferior este inerent nefiabil, ºi cã
în loc de a consuma resurse pentru a-i mãri fiabilitatea, e preferabil
sã <EM>expunem</EM> lipsa sa de fiabilitate nivelelor superioare.

<P>
Raþionamentul din spatele acestei decizii aparent paradoxale se
bazeazã pe mai multe argumente:

<P>

<UL>
<LI>Costul fiabilitãþii poate fi prea mare: dacã fiecare nivel
  introduce un cost suplimentar pentru a oferi fiabilitate, costul
  total al nivelelor suprapuse creºte exponenþial cu numãrul de
  nivele.  Pentru anumite situaþii acest cost poate deveni prohibitiv.
</LI>
<LI>Nivelele superioare au propriile lor scheme de toleranþã la
  defecte.  Dacã schemele nivelelor superioare sunt suficient de
  eficace, ele pot tolera ºi defecþiunile nivelelor inferioare.  De
  exemplu, folosind coduri corectoare de erori foarte eficace
  între douã noduri terminale
  într-o reþea de comunicaþii poate face nenecesarã transmisiunea
  fiabilã pe fiecare segment al reþelei.
</LI>
<LI>În unele cazuri, nivelele superioare nu au nevoie decît de o
  formã redusã de fiabilitate, ºi nu de una perfectã.  De exemplu,
  în unele tipuri de aplicaþii interactive, cum ar fi telefonia, e
  preferabil ca datele sã vinã repede ºi distorsionate decît sã
  fie livrate cu întîrziere ºi impecabile.  Date eronate cauzeazã
  mici zgomote la recepþie, care sunt tolerate de cãtre urechea
  umanã; sosirea cu întîrziere a semnalului sonor este însã
  foarte puþin folositoare pentru a crea iluzia unei conversaþii
  interactive, ºi este mult mai perceptibilã.
</LI>
</UL>

<P>

<H2><a name="expunere"><A NAME="SECTION00071000000000000000">
Internetul</A></a>
</H2>

<P>
Una dintre cele mai uimitoare tehnologii a secolului douãzeci este cu
siguranþã Internetul.  Acesta este o reþea de calculatoare,
proiectatã iniþial pentru a conecta reþele militare de calculatoare
ºi de a le permite sã opereze chiar ºi în condiþiile distrugerii
unui mare numãr de echipamente din reþea, în cazul unei
conflagraþii nucleare.  Internetul a evoluat într-o reþea
comercialã care acoperã toate continentele, cu mai mult de 125 de
milioane de calculatoare ºi peste 1 miliard de utilizatori.

<P>
Internetul nu este prima reþea de dimensiune globalã; cu mai mult de
un secol înainte de crearea Internetului a apãrut telefonul;
reþelele telefonice au cu siguranþã întîietatea în acoperirea
planetei.  Ne-am aºtepta ca proiectanþii Internetului sã fi folosit
multe din tehnologiile folosite în construcþia reþelelor
telefonice, despre care existã o cantitate mare de informaþii ºi o
experienþã substanþialã.  În realitate, nimic nu poate fi mai
departe de adevãr: arhitectura Internetului pare a fi în mod
deliberat opusã reþelei de telefonie.  Nicãieri nu se vede mai bine
diferenþa dintre cele douã reþele decît în felul în care
trateazã fiabilitatea.

<P>
Reþeaua telefonicã a fost proiectatã dintru început pentru o
fiabilitate excepþionalã.  O centralã telefonicã trebuie sã
însumeze mai puþin de trei minute de indisponibilitate în fiecare
an.  Numai în circumstanþe absolut excepþionale o conversaþie
iniþiatã poate fi întreruptã datoritã unor probleme din reþea.
Reþeaua telefonicã va permite stabilirea unei legãturi numai dupã
ce a rezervat toate resursele necesare pentru transmisiunea promptã a
semnalelor vocale pe întregul traseu dintre cele douã puncte care
comunicã.  Standarde stricte dicteazã cît de mult timp poate dura faza de
construcþie a legãturii; dacã toate resursele nu pot fi
obþinute utilizatorul primeºte un ton de ocupat.  Capacitatea
reþelei este planificatã atent pe baza unor statistici detaliate
despre comportarea vorbitorilor astfel încît în condiþiuni normale
ºansa obþinerii unui ton de ocupat din cauza resurselor insuficiente
din reþea sã fie extrem de redusã.

<P>
Un factor crucial care garanteazã calitatea conexiunilor telefonice
este prealocarea tuturor resurselor necesare înainte ca legãtura
sã fie stabilitã.  Pornind de la numãrul format, prima centralã
telefonicã calculeazã o secvenþã de centrale prin care semnalul
trebuie sã treacã pentru a lega apelantul cu apelatul; acest calcul
se bazeazã pe tabele de rutare pre-calculate cu mare grijã ºi
stabilite de cãtre proiectanþii reþelei.  Fiecare centralã negociazã
apoi cu cea succesivã folosind un protocol sofisticat de semnalizare,
ºi alocã capacitate pentru transportul datelor ºi pentru comutarea
datelor (care în centralã leagã circuitul de intrare cu cel de
ieºire).  Cînd toate conexiunile punct-la-punct între centrale sunt
stabilite se genereazã un ton de ``sunat''.  Cînd conversaþia a
fost iniþiatã, semnalul vocal este eºantionat ºi digitizat în
prima centralã.  Pentru fiecare bit din acest semnal s-a prealocat
deja o cuantã periodicã de timp pe fiecare din
circuitele pe care le va traversa.  Biþii sunt transmiºi unul cîte
unul ºi traverseazã toate trunchiurile în aceeaºi ordine în care
au fost generaþi, sosind la destinaþie la timp pentru a fi
reasamblaþi ºi convertiþi la loc într-un semnal auditiv.  Din
cauza prealocãrii, de îndatã ce un bit intrã în reþea, cu o
probabilitate extrem de ridicatã el va ajunge la celãlalt capãt
exact cînd trebuie.  Cînd unul dintre vorbitori închide telefonul,
protocolul de semnalizare intrã din nou într-o fazã complicatã
prin care elibereazã toate resursele alocate la momentul apelului.

<P>
Internetul are o arhitecturã fundamental diferitã.  Nu numai cã nu
existã garanþii despre timpul necesar pentru a ajunge de la
emiþãtor la receptor, dar nu existã nici o garanþie cã datele nu
sunt pierdute sau modificate în timpul transferului.  Utilizatorii
Internetului obþin un serviciu extrem de ``slab'', care poate fi
enunþat pe scurt astfel: ``tu pui date în reþea ºi zici unde vrei
sã ajungã; reþeaua o sã încerce sã livreze datele acolo''.

<P>
Felul în care informaþia circulã în Internet este complet diferit
de reþeaua telefonicã: datele sunt divizate în pachete care sunt
introduse în reþea în ordinea sosirii.  Fiecare pachet poate
cãlãtori pe o rutã complet diferitã pînã la destinaþie.  Unele
pachete se pot pierde, alte pot fi duplicate, ºi ele pot sosi la
destinaþie în altã ordine decît au fost emise, sau chiar sparte
în pachete mai mici.

<P>
Pachetele sunt plimbate prin Internet de un protocol numit IP,
Internet Protocol.  IP funcþioneazã aproximativ astfel: cînd un
calculator intermediar primeºte un pachet se uitã întîi la adresa
destinaþie înscrisã.  Apoi el face niºte calcule simple
pentru a decide în ce direcþie pachetul trebuie trimis, mai precis,
cãruia dintre vecinii sãi trebuie sã-i dea pachetul.  Pachetul este
apoi trimis vecinului.  Dacã la un calculator intermediar pachetele
vin mai repede decît apucã sã le trimitã mai departe, ºi dacã
nici nu are unde sã le stocheze pentru o vreme, are dreptul sã le
facã pierdute.  Aceasta este principala cauzã pentru care datele se
pot pierde în Internet.

<P>
Spre deosebire de reþeaua telefonicã, structura Internetului nu este
controlatã de un numãr mic de companii, ci este în continuã
schimbare, de la zi la zi ºi de la orã la orã, pe mãsurã ce noi
calculatoare se conecteazã, noi utilizatori sunã folosind modemuri,
accidente întrerup conectivitatea ºi noi linii de transmisiune sunt
instalate.  Calculatoarele responsabile pentru transmiterea datelor,
numite rutere, discutã între ele permanent pentru a afla care este
forma curentã aproximativã a reþelei.  Aceste informaþii sunt
utilizate în procesul de decizie care selecteazã vecinul folosit pentru
transmisiunea fiecãrui pachet spre destinaþie.

<P>
Datã fiind aceastã infrastructurã, este uimitor cã Internetul
funcþioneazã cîtuºi de puþin, ºi cã informaþia ajunge
cîteodatã neperturbatã la destinaþie.  Fiabilitatea aplicaþiilor
din Internet este construitã pe baza acestui mediu extrem de
nefiabil, folosind douã ingrediente:

<P>
<DL>
<DT><STRONG>Lipsa de stare (statelessness):</STRONG></DT>
<DD>ruterele din Internet nu stocheazã nici un
  fel de informaþii despre traficul care le parcurge.  (Prin contrast,
  în reþeaua telefonicã, comutatoarele ºtiu despre fiecare bit
  care le traverseazã de unde vine, unde se duce, ºi cînd
  succesorul lui va sosi.)  Un ruter primeºte un pachet, calculeazã
  vecinul cãruia sã-i dea pachetul, ºi livreazã pachetul.  Starea
  internã a ruterului dupã livrarea pachetului este aceeaºi cu cea
  de dinainte.  Aºa cum am vãzut în cazul reîntineririi
  programelor, lipsa stãrii interne face mult mai simplã repornirea
  unui ruter dupã o defecþiune.  O defecþiune nu pierde
  informaþii vitale, care nu pot fi recuperate prin alte metode.  De
  asemenea, lipsa stãrii face relativ uºoarã sarcina altor rutere
  de a prelua traficul în cazul defectãrii unuia.

<P>
</DD>
<DT><STRONG>TCP:</STRONG></DT>
<DD>este un protocol numit Transmission Control Protocol,
  care se executã deasupra protocolului IP.  Dacã într-o reþea
  toate nodurile din interior executã IP, numai sursa ºi destinaþia
  executã TCP.  TCP este protocolul care construieºte o transmisiune
  fiabilã: el asigurã cã toate pachetele trimise ajung la
  destinaþie, fãrã lipsuri sau duplicate, în ordinea în care au
  fost trimise.  TCP reuºeºte aceastã performanþã folosind
  urmãtoarele mecanisme:
  
<UL>
<LI>Numeroteazã pachetele trimise;
</LI>
<LI>Foloseºte pachete de confirmare pentru a anunþa sosirea
    datelor la capãtul celãlalt;
</LI>
<LI>Foloseºte alarme pentru a detecta pachetele care nu
    sunt confirmate pentru un timp îndelungat;
</LI>
<LI>Foloseºte retransmisii pentru a retrimite pachetele care se
    pierd în reþea.
  
</LI>
</UL>

<P>
Din cauzã cã pachetele cu confirmãri se pot pierde la rîndul
  lor, unele pachete sunt injectate în mod repetat în reþea, ceea
  ce poate duce la livrarea unor duplicate; TCP trebuie le eliminã
  folosind numerele de serie ale pachetelor.
</DD>
</DL>

<P>
Întregul Internet este construit pe nucleul nefiabil oferit de IP: nu
numai datele ºi confirmãrile sunt trimise în mod nefiabil, dar
chiar ºi mesajele de control schimbate între rutere, prin care aflã
despre schimbãrile din topologia reþelei, ºi traficul folosit
pentru monitorizarea ºi mentenanþa reþelei folosesc aceleaºi
mecanisme nefiabile de transmisiune.

<P>
În pofida structurii sale aparent ºubrede, Internetul este un competitor
formidabil al altor forme de distribuþie a informaþiei: radio,
televiziune ºi telefonie.  Costul transmisiunii vocii prin Internet
este mult mai scãzut decît folosind reþelele specializate de
telefonie.  Multe companii importante de telefonie investesc în mod
serios în echipamente care vor transporta voce peste protocolul IP.

<P>
De ce are Internetul atîta succes, în pofida lipsei sale de
fiabilitate?

<P>
Rãspunsul constã, în parte, în faptul cã Internetul nu oferã un
serviciu de fiabilitate costisitor de care poate aplicaþtiile nu au nevoie.
Reþeaua de telefonie face un efort substanþial pentru a oferi un
serviciu de o fiabilitate foarte ridicatã, dar sistemul folosit este
foarte inflexibil ºi consumã o cantitate uriaºã de resurse.
Practic, fiabilitatea reþelei de telefoane <EM>costã prea mult</EM>.

<P>
Internetul mutã problema fiabilitãþii la un nivel superior, de la
IP la TCP.  TCP oferã o fiabilitate perfect adecvatã pentru multe
aplicaþii.  TCP este executat numai de cãtre calculatoarele
terminale implicate în comunicaþie, ºi nu de cãtre rutere.  Ca
atare algoritmii complicaþi folosiþi de acest protocol nu taxeazã
resursele reþelei, care scaleazã în mod natural la dimensiuni
globale.

<P>
Mai mult: aplicaþii care nu au nevoie de livrarea fiabilã a datelor
a lui TCP nu sunt obligate sã foloseascã acest protocol.  De
exemplu, protocoalele folosite pentru posturile de radio din Internet
folosesc coduri puternice de corecþie a erorilor (discutate în prima
parte a acestui articol) ºi nu au nevoie de retransmisii.  Pachete
pierdute sau întîrziate sunt pur ºi simplu ignorate.  Acest lucru
este acceptabil pentru cã utilizatorul final, omul, tolereazã
semnale cu zgomot.

<DIV ALIGN="CENTER"><A NAME="plasare-rutare"></A><A NAME="234"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura:</STRONG>4<I> <B>stînga:</B> Procesul de plasare
  asociazã fiecare poartã logicã din circuitul de implementat cu o
  poartã universalã.  Procesul de rutare conecteaza' porþile
  universale folosind segmente de sîrmã legate cu comutatoare. </I><I><B>dreapta:</B> Dacã unele din porþile universale sunt defecte, plasarea
  ºi rutarea le pot ocoli, sintetizînd un circuit perfect funcþional.</I></CAPTION>
<TR><TD><IMG
 WIDTH="542" HEIGHT="509" BORDER="0"
 SRC="img12.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{plasare-rutare.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<H2><A NAME="SECTION00072000000000000000">
Teramac</A>
</H2>

<P>
În aceastã secþiune voi discuta pe scurt despre Teramac, un sistem
de calcul dezvoltat de cercetãtori de la Hewlett-Packard care
demonstreazã o metodologie extremã în tratamentul fiabilitãþii
sistemelor.  Acest calculator este construit din componente defecte:
mai mult de 70% din circuitele sale componente au o malfuncþie
oarecare.  Cu toate acestea, sistemul funcþioneazã minunat ºi poate
efectua calcule extrem de performante.  

<P>
Sã observãm cã arhitectura Teramac tolereazã numai defecþiuni
permanente, care sunt prezente încã de la fabricaþie.  Componentele
Teramac sunt circuite hardware de un tip anume, numit hardware
reconfigurabil.  Înainte de a discuta sistemul Teramac voi face o
prezentare succintã a structurii hardware-ului reconfigurabil ºi voi
explica de ce un sistem fiabil poate fi construit din componente
reconfigurabile nefiabile.

<P>

<H3><A NAME="SECTION00072100000000000000">
Hardware reconfigurabil</A>
</H3>

<P>
Într-o primã aproximaþie, circuitele digitale obiºnuite sunt
compuse din elemente computaþionale simple, numite porþi logice,
conectate între ele prin sîrme.  Porþile logice sunt construite din
tranzistori.  Fiecare poartã logicã face calcule pe mai multe valori
de 1 bit.  Porþile logice sunt universale, în sensul cã orice
proces calcul poate fi exprimat în termeni de operaþii ale porþilor
logice.

<P>
În hardware-ul reconfigurabil porþile logice nu au o
funcþionalitate fixatã, iar sîrmele formeazã o grilã.  Fiecare
poartã este configurabilã, adicã poate fi forþatã sã efectueze
orice operaþie logicã.  La fiecare intersecþie de sîrme se aflã
un mic comutator configurabil, care poate fi de asemenea programat sã
conecteze sîrmele.  Configurarea porþilor ºi a sîrmelor se face
prin semnale electrice.  Fiecare poartã ºi fiecare comutator are o
micã memorie asociatã, în care-ºi stocheazã configuraþia.
Pentru cã schimbînd conþinutul acestor memorii putem schimba
funcþionalitatea hardware-ului, circuitele acestea se numesc
``reconfigurabile''.

<P>
Hardware-ul reconfigurabil este echivalent cu cel obiºnuit, în
sensul cã orice circuit poate fi implementat folosind ambele
tehnologii.  Hardware-ul reconfigurabil tinde însã sã fie mai
ineficient: memoriile ºi porþile configurabile ocupã mult mai mult
loc decît porþile obiºnuite.  Pe de altã parte, semnalele
electrice care traverseazã doar sîrme într-un circuit obiºnuit
trebuie sã treacã printr-o serie de comutatoare în hardware-ul
reconfigurabil, ceea ce face circuitele mai lente.  Un factor de 10
diferenþã în vitezã ºi densitate este de aºteptat între
hardware obiºnuit ºi cel configurabil de aceeaºi generaþie.

<P>
Pentru a programa un circuit reconfigurabil cu funcþiunea unui circuit obiºnuit,
trebuie sã asociem fiecare poartã din circuit cu o poartã
configurabilã; acest proces se numeºte ``plasare''; de asemenea,
fiecare sîrmã trebuie asociatã cu succesiuni de segmente legate prin comutatoare, în
procesul de ``rutare''.

<P>

<H3><A NAME="SECTION00072200000000000000">
Fiabilitatea sistemului Teramac</A>
</H3>

<P>
Calitatea circuitelor reconfigurabile exploatatã de Teramac pentru a
obþine fiabilitate este faptul cã porþile logice configurabile sunt
esenþialmente interschimbabile.  Cercetãtorii proiectului Teramac au
dezvoltat un program de plasare care foloseºte o hartã de defecte
ale circuitelor reconfigurabile.  Aceastã sculã ocoleºte
porþiunile inutilizabile ºi ruteazã conexiunile în jurul
defectelor, exploatînd doar porþiunile funcþionale ale fiecãrui
circuit.  Cercetãtorii au creat ºi o serie de scule care descoperã
ºi catalogheazã defectele.  Sculele acestea folosesc chiar
programabilitatea circuitelor pentru a le configura ca dispozitive
care se auto-testeazã.  Fiecare porþiune din fiecare circuit este
programatã se efectueze calcule simple ºi sã verifice
corectitudinea rezultatelor.  Micile programe de test sunt
``plimbate'' pe suprafaþa circuitului, acoperind toate porþile
logice.  Proiectarea unor programe de auto-testare este o sarcinã mai
complicatã decît ar putea pãrea la prima vedere.  Programele
trebuie sã descopere o mulþime de defecte posibile ºi trebuie sã
nu poatã fi pãcãlite de defecþiuni (de exemplu, dacã chiar partea
care comparã rezultatele cu cele corecte este defectã).  Programele
de testare aplicã în mod repetat calcule care amestecã toþi
biþii; astfel, apariþia unei singure erori se va propaga rapid la
toþi biþii din rezultat, fiind uºor de depistat.

<P>
Proiectul Teramac a avut un succes enorm, apãrînd chiar pe prima
paginã a unor ziare de mare tiraj.  Principala sa contribuþie a
constat în a demonstra cã defectele din hardware pot fi expuse
nivelelor superioare, ºi pot fi tratate în întregime în software,
fãrã ca costul plãtit în performanþã sã fie prohibitiv.  Aceastã metodologie
este o schimbare completã de paradigmã în arhitectura
calculatoarelor, care probabil va avea din ce în ce mai multe
aplicaþii în viitor.

<P>

<H1><A NAME="SECTION00080000000000000000">
Algoritmi aleatori</A>
</H1>

<P>
În aceastã secþiune voi discuta o nouã direcþie în gîndirea
despre calculatoare, care acceptã lipsa de fiabilitate ca pe un lucru
natural, chiar ºi la nivelele cele mai ridicate.  E vorba de
folosirea algoritmilor aleatori, care incorporeazã un element de
ºansã, ºi care, ca atare, nu se comportã întotdeauna la fel, ba
chiar, cîteodatã pot da rãspunsuri eronate.

<P>
Teoria complexitãþii ne învaþã cã în general existã un
compromis între timpul de execuþie al unui program ºi calitatea
rezultatelor pe care le poate oferi.  Pentru multe clase importante de
probleme nu existã algoritmi care sã fie simultan rapizi ºi care
gãsesc soluþia optimã.

<P>
Singura soluþie în astfel de cazuri este sã renunþãm la una
dintre calitãþi.  Dacã nu avem suficient timp, va trebui sã ne
mulþumim cu soluþii care nu sunt optime, dar poate sunt suficient de
aproape de optim, presupunînd cã le putem calcula rapid.  

<P>
Cei mai spectaculoºi algoritmi care au apãrut folosesc evenimente
aleatoare pentru a calcula rãspunsurile rapid, dar pierd din
precizie.  Trebuie sã ne imaginãm aceºti algoritmi ca avînd
capacitatea sã arunce un zar ºi în funcþie de rezultat sã facã o
acþiune sau alta.  Putem distinge douã mari clase de astfel de
algoritmi:

<P>
<DL>
<DT><STRONG>Algoritmii Monte Carlo</STRONG></DT>
<DD>de obicei dau rãspunsuri corecte, dar
  ocazional pot da un rãspuns greºit.  ``Ocazional'' trebuie citit
  ``cu probabilitate foarte micã''.  Cu alte cuvinte, dacã
  ``zarurile'' nu ies mereu ``ºase-ºase'', algoritmul va da un
  rãspuns corect, altfel rezultatul poate fi eronat.  Algoritmii
  Monte-Carlo sunt folosiþi pe larg în simularea fenomenelor fizice
  pe calculator, aproximînd calcule complicate prin eºantionare.
  
</DD>
<DT><STRONG>Algoritmii Las-Vegas</STRONG></DT>
<DD>dau întotdeauna rãspunsuri corecte.
  Cel mai adesea aceºti algoritmi se ºi executã rapid.  Cu
  probabilitate foarte scãzutã însã, ei ar putea sã se execute
  pentru un timp foarte îndelungat.  Un exemplu tipic de astfel de
  algoritm este ``quicksort'', care aranjeazã un ºir de numere în
  ordine crescãtoare.  Quicksort alege (într-una din variantele
  sale) în mod aleator un ``pivot'', un element din ºir, dupã care
  mutã toate elementele mai mici decît pivotul la stînga ºi cele
  mai mari la dreapta ºi sorteazã în mod recursiv cele douã
  ºiruri obþinute.  Pentru cele mai multe alegeri ale pivotului
  timpul de execuþie este scurt; dacã însã algoritmul are ghinion
  ºi alege mereu cîte un pivot aproape de valoarea maximã din ºir,
  timpul de execuþie este mult mai lung.
</DD>
</DL>

<P>

<H2><A NAME="SECTION00081000000000000000">
Amplificarea probabilitãþilor</A>
</H2>

<P>
Foarte surprinzãtor este faptul cã pentru unele probleme nu se
cunoaºte nici un algoritm eficient determinist, dar  sunt cunoscuþi
algoritmi aleatori rapizi.  ªi mai surprinzãtor este
faptul cã astfel de algoritmi sunt folosiþi pe scarã foarte largã,
fiind un pilon de bazã al comerþului electronic!

<P>
Cum de ne bazãm pe algoritmi care ºtim cã pot eºua?

<P>
Totul este o chestiune de valori ale probabilitãþilor de eºec.
ªtim cã orice sistem poate eºua; cu o probabilitate foarte
micã se poate petrece un cutremur în urmãtoarea orã, care poate
strica un calculator oricît de solid.  Dacã algoritmii aleatori au
probabilitãþi mai mici de atît, pînã la urma ei reprezintã un
risc acceptabil.

<P>
Din fericire existã metode pentru a scãdea probabilitatea de eroare
a unui algoritm aleator.  Aceste metode sunt asemãnãtoare cu
metodele care cresc fiabilitatea sistemelor hardware, prezentate în
prima parte a acestui articol, folosind redundanþa.

<P>
O metodã foarte similarã cu redundanþa temporalã este folositã
pentru a <EM>amplifica</EM> probabilitatea de succes a algoritmilor
Monte-Carlo.  Aceastã metodã pur ºi simplu executã algoritmul în
mod repetat ºi alege rezultatul folosind un vot majoritar.
Probabilitatea ca majoritatea instanþelor algoritmului sã eºueze
scade foarte repede cu numãrul de repetiþii (exponenþial de
repede), ºi poate fi adusã practic la o valoare oricît de micã.

<P>

<H2><A NAME="SECTION00082000000000000000">
Criptografie</A>
</H2>

<P>
Importanþa criptografiei pentru societatea modernã nu poate fi
supraestimatã.  Timpurile cînd criptografia era apanajul armatelor
este de mult apus.  De fiecare datã cînd tastaþi o parolã într-un
calculator, folosiþi criptografie; de fiecare datã cînd faceþi
cumpãrãturi prin Internet, browser-ul dumneavoastrã foloseºte
criptografie pentru a trimite numãrul cãrþii de credit.

<P>
Cu atît mai interesant este faptul cã nici unul dintre sistemele
criptografice folosit pe scarã largã este demonstrat în mod
matematic ca fiind sigur!  De fapt întreaga tehnologie a
criptografiei se bazeazã pe niºte probleme matematice al cãror
rãspuns este încã necunoscut.

<P>
Una dintre aceste probleme este dacã întrebarea dacã un numãr
poate fi descompus rapid în factori primi.  Deºi aþi
învãþat în ºcoala primarã cum se face asta, dacã veþi încerca
sã aplicaþi algoritmul acela unor numere mari (de exemplu, cu
cîteva sute de cifre), nu aveþi nici o speranþã.  Nici mãcar
calculatoarele nu vã pot ajuta aici: la ora aceasta toþi algoritmii
cunoscuþi pentru a descompune un numãr în factori primi sunt foarte
costisitori (ca timp de execuþie).  Unele dintre cele mai folosite
criptosisteme sunt bazate pe presupunerea cã descompunerea în
factori este grea (adicã cã nu existã nici un algoritm rapid).

<P>
Putem vedea siguranþa unui sistem criptografic tot ca pe o formã de
fiabilitate: dacã probabilitatea ca sistemul sã fie înfrînt
într-o perioadã lungã de timp este foarte scãzutã, atunci
sistemul criptografic este fiabil.

<P>
Un alt fapt surprinzãtor despre mulþi dintre algoritmii folosiþi
în criptografie este cã ei sunt de tip Monte-Carlo, cu alte cuvinte, ei
pot funcþiona incorect cu o probabilitate nenulã.  De
exemplu, mulþi algoritmi încep calculele generînd un numãr prim
foarte mare.  De exemplu, programul <TT>ssh</TT>, (secure shell) care
este probabil cel mai folosit program sigur pentru acces la un
calculator la distanþã în mod interactiv, trebuie sã asigneze
calculatorului de pe care porneºte conexiunea un identificator bazat
pe un astfel de numãr prim generat aleator.  Generarea acestui numãr
prim poate eºua în mai multe feluri:

<P>

<OL>
<LI>Douã calculatoare diferite ar putea genera acelaºi numãr din
  întîmplare, ºi atunci unul ar putea sã pretindã cã este
  celãlalt;
</LI>
<LI>Nu se cunoaºte nici un algoritm eficient determinist care
  genereazã numere prime.  Felul în care numãrul
  prim este generat este urmãtorul: un numãr aleator impar este
  generat, dupã care se verificã dacã este prim.  Procesul se
  repetã pînã cînd se obþine un numãr prim.  Acest proces este
  un algoritm Las Vegas, pentru cã probabilitatea de a genera
  într-una numere compuse este nenulã;
</LI>
<LI>Nu se cunoaºte nici un algoritm eficient determinist pentru a
  verifica dacã un numãr este prim!  Toþi algoritmii practici sunt
  de tip Monte-Carlo, pentru cã ar putea declara (cu probabilitate
  micã) un numãr compus ca fiind prim.  Într-un astfel de caz
  securitatea oferitã de <TT>ssh</TT> nu este garantatã.
</LI>
</OL>

<P>
Cu toate acestea, în practicã <TT>ssh</TT> funcþioneazã foarte bine
pentru cã:

<P>

<OL>
<LI>Existã aproximativ 10<sup>150</sup> numere prime cu 512 cifre,
  adicã mai multe decît numãrul estimat de atomi din univers.
  Probabilitatea ca douã calculatoare sã aleagã acelaºi numãr
  este infimã;
</LI>
<LI>Densitatea numerelor prime este relativ ridicatã: între
  primele <I>n</I> numere întregi existã aproximativ <I>n/log n</I> numere
  prime.  Cu probabilitate mare algoritmul Las Vegas de generare a
  unui numãr prim va gãsi deci unul destul de repede (dupã un
  numãr de repetiþii proporþional cu numãrul de cifre dorite);
</LI>
<LI>Probabilitatea de eroare a algoritmului Monte-Carlo de
  verificare a primalitãþii poate fi micºoratã în mod arbitrar
  folosind tehnica amplificãrii, descrisã mai sus.
</LI>
</OL>

<P>

<H2><A NAME="SECTION00083000000000000000">
Algoritmi aleatori în reþele</A>
</H2>

<P>
Dacã credeþi cã algoritmii aleatori sunt apanajul teoreticienilor,
vã înºelaþi.  Ei sunt folosiþi în contexte extrem de aplicate.
Voi ilustra cu un exemplu de folosire a unui algoritm Las-Vegas în
reþelele de calculatoare.  Acest algoritm este folosit cu variaþii
în (cel puþin) douã contexte:

<P>

<UL>
<LI>Este folosit în protocolul Ethernet ca sã arbitreze
  transmisiunea de date a mai multor calculatoare pe un singur cablu
  care le conecteazã;
</LI>
<LI>Este folosit în protocolul Bluetooth de comunicaþie radio
  pentru a alege un nod ``master'' care va arbitra comunicaþia prin
  mediul electromagnetic a tuturor nodurilor din vecinãtatea sa.
</LI>
</UL>

<P>
În aceste protocoale algoritmul Las Vegas este folosit pentru a
distruge simetria intrinsecã în algoritmii determiniºti.  Dacã doi
algoritmi determiniºti pleacã din acelaºi punct ºi fac mereu
aceleaºi operaþii, ei vor fi mereu în aceeaºi stare.  Dacã dorim
cumva sã diferenþiem între cei doi algoritmi, simetria
poate fi indezirabilã.

<P>
Voi ilustra aceastã problemã cu protocolul Ethernet.  Ethernet este
cel mai folosit tip de reþea localã, inventat de Bob Metcalfe în
1973.  În varianta originalã de Ethernet, despre care discut aici,
mai multe calculatoare sunt legate la un cablu coaxial.  Acest cablu e
folosit în mod asemãnãtor cu televiziunea prin cablu pentru a transmite
date: un calculator emite datele, iar celelalte ascultã cablul;
calculatorul care este destinaþia finalã a datelor (identificat în
pachetul de date) preia datele din reþea, celelalte calculatoare le
ignorã.  Spre deosebire de televiziunea prin cablu, în care
emiþãtorul este unul singur, în cazul Ethernet-ului oricare din
calculatoarele conectate poate transmite.  Problema este cã douã
calculatoare diferite nu pot transmite simultan, pentru cã atunci
semnalul este bruiat.  Algoritmul aleator este folosit pentru a decide
cine transmite atunci cînd mai multe calculatoare vor simultan sã
foloseascã cablul, astfel:

<P>

<OL>
<LI>Cînd un calculator are date de transmis, el începe prin a
  asculta cablul, ca sã vadã dacã este ocupat;
</LI>
<LI>Cînd transmisiunea curentã se terminã, calculatorul 
  începe sã transmitã el însuºi datele, în speranþa cã nimeni
  altcineva nu mai doreºte sã facã acelaºi lucru; 
</LI>
<LI>Dacã douã calculatoare transmit simultan ele vor observa
  semnalul bruiat ºi atunci intrã în faza aleatoare, care
  selecteazã cine transmite primul:
  
<OL>
<LI>Ambele calculatoare dau cu zarul, alegînd un numãr între
    1 ºi 2.  Fiecare numãrã pînã la valoarea aleasã ºi apoi
    încearcã din nou sã transmitã;
</LI>
<LI>Dacã ambele au ales acelaºi numãr se va petrece o nouã
    ``coliziune''; atunci ambele aleg un numãr între 1 ºi 4 ºi
    repetã procedura;
</LI>
<LI>La fiecare nouã coliziune intervalul în care se aleg
    numerele aleatoare îºi dubleazã lungimea, pînã cînd un
    calculator alege un numãr mai mic ºi ca atare emite primul.
  
</LI>
</OL>
</LI>
</OL>

<P>
Creºterea exponenþialã a intervalului în care se genereazã
numerele aleatoare se numeºte ``exponential back-off''.  Aceastã
creºtere rapidã asigurã faptul cã probabilitatea de coliziune
descreºte exponenþial de rapid cu timpul.

<P>
Algoritmul descris mai sus se mai numeºte ºi CSMA/CD, de la
Carrier-Sense Multiple Access, Collision Detect, adicã ``ascultarea
mediului de transmisie pentru accese multiple cu detectarea
coliziunilor''; este un algoritm Las Vegas relativ simplu.  Reþelele
moderne Ethernet sunt ceva mai complicate, dar continuã sã se bazeze
pe acest algoritm.  Eficacitatea sa este demonstratã de succesul
acestui tip de reþea.

<P>

<H1><A NAME="SECTION00084000000000000000">
Spre o nouã arhitecturã a calculatoarelor</A>
</H1>

<P>
În acest text, întins pe douã numere de revistã, am discutat mai
multe feluri în care consideraþii privind fiabilitatea
influenþeazã construcþia calculatoarelor.  Un mesaj important al
acestui text este cã, deºi fiabilitatea ridicatã este dezirabilã,
un arhitect întotdeauna trebuie sã ia în consideraþie ºi costul
plãtit pentru a o obþine.

<P>
Calculatoarele moderne sunt construite dintr-o serie de nivele
abstracte, care oferã funcþionalitãþi din ce în ce mai
puternice.  Fiecare nivel are o fiabilitate diferitã ºi foloseºte
tehnici diferite pentru a oferi nivelelor superioare imaginea unei
fiabilitãþi sporite.  În general hardware-ul oferã lumii software
aparenþa perfecþiunii în aceastã privinþã, adicã o fiabilitate
excepþional de ridicatã.

<P>
Tendinþele tehnologiei indicã însã cã arhitectura calculatoarelor
viitorului va fi supusã unor schimbãri radicale, unul dintre motive
fiind chiar schimbarea majorã a fiabilitãþii unora dintre
nivele.  De exemplu, miniaturizarea continuã a componentelor
electronice va fi însoþitã de o degradare a fiabilitãþii
însoþitã de apariþia tot mai frecventã a defecþiunilor
permanente ºi tranziente.  Costul plãtit pentru a masca aceste
defecte prin tehnici tradiþionale creºte extrem de rapid: costul
extrem de ridicat al unei fabrici de semiconductoare de ultima
generaþie, de ordinul a cîteva miliarde de dolari, este doar primul
simptom al acestui fenomen.

<P>
Îmi permit sã speculez cã o schimbare de perspectivã în ceea ce
priveºte abordarea fiabilitãþii poate avea consecinþe enorme.  De
exemplu, dacã renunþãm sã mai construim hardware ``perfect'',
putem reduce în mod absolut dramatic costul de fabricaþie.
Proiectul Teramac a arãtat o metodã prin care hardware cu defecte
poate fi folosit cu succes.

<P>
Mai multe grupuri de cercetare lucreazã în mod activ pentru a defini
arhitecturile viitorului.  Am prezentat de curînd în Net Report
(mai-iunie 2001) eforturile grupului din care fac eu parte.
Propunerea noastrã poate fi rezumatã astfel:

<P>

<UL>
<LI>Iluzia unui hardware perfect trebuie eliminatã;
  imperfecþiunile din nivelul hardware trebuie sã fie expuse
  nivelului software ºi rezolvate de acesta;
</LI>
<LI>Pentru a face acest lucru, baza sistemelor de calcul trebuie sã fie
  hardware-ul reconfigurabil, care este suficient de flexibil pentru a
  fi reprogramat dupã nevoi;
</LI>
<LI>Microprocesorul trebuie sã fie redus la un rol secundar ºi
  înlocuit cu hardware generat specific pentru fiecare aplicaþie cu
  ajutorul compilatoarelor;
</LI>
<LI>Numãrul de nivele abstracte trebuie sã fie micºorat în mod dramatic, pentru a reduce
costul suplimentar plãtit (overhead), care creºte exponenþial;
<LI>Trebuie folosite în mod constant tehnici care descoperã
  defecte ºi folosesc rezerve pentru a ocoli defectele de
  fabricaþie;
</LI>
<LI>Calculele trebuie sã fie efectuate folosind date codificate
  folosind coduri robuste, pentru a preveni efectele erorilor
  tranziente;
</LI>
<LI>În fine trebuie folosite pe scarã largã metodele de verificare
  formalã pentru a ne asigura cã sistemele de calcul pe care le
  folosim sunt corect construite.
</LI>
</UL>

<P>
ªtiinþa calculatoarelor este relativ tînãrã; cu siguranþã cã
viitorul ne rezervã o mulþime de surprize în ceea ce priveºte
tehnologiile, arhitectura ºi algoritmii cei mai eficienþi.

<P>

<H1><A NAME="SECTION00090000000000000000">
Alte surse de informaþie</A>
</H1>

<P>

<UL>
<LI>Douã articole din IBM Journal of Research despre
microprocesoarele fiabile G4 ºi G5 de la IBM:

<UL>
<LI><TT><A NAME="tex2html6"
  HREF="http://www.research.ibm.com/journal/rd/435/spainhower.html">http://www.research.ibm.com/journal/rd/435/spainhower.html</A></TT>,
</LI>
<LI><TT><A NAME="tex2html7"
  HREF="http://www.research.ibm.com/journal/rd/414/webb.html">http://www.research.ibm.com/journal/rd/414/webb.html</A></TT>
</LI>
</UL>

<P>
</LI>
<LI>Informaþii despre procesorul DIVA:

<UL>
<LI>Douã prezentãri fãcute de inventatorului acestui sistem:

<UL>
<LI><TT><A NAME="tex2html8"
  HREF="http://huron.cs.ucdavis.edu/Micro32/presentations/p_austin.pdf">http://huron.cs.ucdavis.edu/Micro32/presentations/p_austin.pdf</A></TT>
</LI>
<LI><TT><A NAME="tex2html9"
  HREF="http://www.cs.utexas.edu/users/cart/arch/slides/austin.pdf">http://www.cs.utexas.edu/users/cart/arch/slides/austin.pdf</A></TT>
</LI>
</UL>
</LI>
<LI>Un articol care descrie schema DIVA:
  <TT><A NAME="tex2html10"
  HREF="http://jilp.org/vol2/v2paper7.ps">http://jilp.org/vol2/v2paper7.ps</A></TT>
</LI>
</UL>

<P>
</LI>
<LI>Articolul meu din PC Report din iulie 1999 despre redenumirea
  regiºtrilor, tehnicã folositã de procesorul superscalar tolerant
  la erori:
  <TT><A NAME="tex2html11"
  HREF="http://www.cs.cmu.edu/~mihaib/articole/articole.html#redenumire">http://www.cs.cmu.edu/~mihaib/articole/articole.html#redenumire</A></TT>.

<P>
</LI>
<LI>Un articol care descrie microprocesorul superscalar tolerant la
erori: 
<BR><TT><A NAME="tex2html12"
  HREF="http://www.ece.cmu.edu/~babak/papers/micro01-dual.ps">http://www.ece.cmu.edu/~babak/papers/micro01-dual.ps</A></TT>
<P>
</LI>
<LI>Un articol din PC Guide despre structura hard-discurilor: 
<BR><TT><A NAME="tex2html13"
  HREF="http://www.pcguide.com/ref/hdd/index.htm">http://www.pcguide.com/ref/hdd/index.htm</A></TT>
<P>
</LI>
<LI>O paginã de web dedicatã Turbo-codurilor: 
<BR><TT><A NAME="tex2html14"
  HREF="http://www.ee.virginia.edu/CSL/turbo_codes/home.html">http://www.ee.virginia.edu/CSL/turbo_codes/home.html</A></TT>.

<P>
</LI>
<LI>Un articol despre sisteme RAID din Byte.com: 
<BR>  <TT><A NAME="tex2html15"
  HREF="http://www.usbyte.com/common/raid_systems.htm">http://www.usbyte.com/common/raid_systems.htm</A></TT>.

<P>
</LI>
<LI>Articole ale mele anterioare din PC Report:
  
<UL>
<LI>Despre funcþionarea Internetului: mai 1998
    <TT><A NAME="tex2html16"
  HREF="http://www.cs.cmu.edu/~mihaib/articole/articole.html#internet">http://www.cs.cmu.edu/~mihaib/articole/articole.html#internet</A></TT>, 
</LI>
<LI>Despre hardware reconfigurabil: iulie 1998
    <TT><A NAME="tex2html17"
  HREF="http://www.cs.cmu.edu/~mihaib/articole/articole.html#reconf">http://www.cs.cmu.edu/~mihaib/articole/articole.html#reconf</A></TT>, 
</LI>
<LI>Despre algoritmi aleatori: august 1997
    <TT><A NAME="tex2html18"
  HREF="http://www.cs.cmu.edu/~mihaib/articole/articole.html#algoritmi">http://www.cs.cmu.edu/~mihaib/articole/articole.html#algoritmi</A></TT>, 
</LI>
<LI>Despre nanotehnologie ºi arhitectura calculatoarelor:
    mai-iunie 2001,
    <TT><A NAME="tex2html19"
  HREF="http://www.cs.cmu.edu/~mihaib/articole/articole.html#nano">http://www.cs.cmu.edu/~mihaib/articole/articole.html#nano</A></TT>, 
    <TT><A NAME="tex2html20"
  HREF="http://www.cs.cmu.edu/~mihaib/articole/articole.html#spatial">http://www.cs.cmu.edu/~mihaib/articole/articole.html#spatial</A></TT>  
</LI>
</UL>
</LI>
</UL>

<P>
<BR><HR>

</BODY>
</HTML>
