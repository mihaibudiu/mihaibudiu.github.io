<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Kerberos</TITLE>
<META NAME="description" CONTENT="Kerberos">
<META NAME="keywords" CONTENT="kerberos-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Kerberos</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>20 iulie 1998</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Protocolul de autentificare Kerberos
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare de matematica,
fundamente de Unix
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>autentificare, tichet, parola, securitate,
funcþie neinversabilã
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html20"
  HREF="kerberos-html.html">Securitate</A>
<UL>
<LI><A NAME="tex2html21"
  HREF="#SECTION00021000000000000000">Sisteme sigure</A>
</UL>
<BR>
<LI><A NAME="tex2html22"
  HREF="#SECTION00030000000000000000">Autentificare</A>
<LI><A NAME="tex2html23"
  HREF="#SECTION00040000000000000000">Criptografie</A>
<UL>
<LI><A NAME="tex2html24"
  HREF="#SECTION00041000000000000000">Funcþii ``ne-inversabile''</A>
<LI><A NAME="tex2html25"
  HREF="#SECTION00042000000000000000">P = NP?</A>
</UL>
<BR>
<LI><A NAME="tex2html26"
  HREF="#SECTION00050000000000000000">Pericole</A>
<LI><A NAME="tex2html27"
  HREF="#SECTION00060000000000000000">Protocolul Kerberos</A>
<UL>
<LI><A NAME="tex2html28"
  HREF="#SECTION00061000000000000000">Principii</A>
<LI><A NAME="tex2html29"
  HREF="#SECTION00062000000000000000">Mesajele (protocolul Needham-Schroeder)</A>
</UL>
<BR>
<LI><A NAME="tex2html30"
  HREF="#SECTION00070000000000000000">Implementarea Kerberos</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION00080000000000000000">Slãbiciunile lui Kerberos</A>
<LI><A NAME="tex2html32"
  HREF="#SECTION00090000000000000000">Kerberos pentru un utilizator</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION000100000000000000000">Concluzie</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>

<H1><A NAME="SECTION00020000000000000000">
Securitate</A>
</H1>

<P>
O definiþie largã a noþiunii de ``securitate'' pentru calculatoare
ar fi urmãtoarea: interzicerea accesului unor persoane neautorizate
la anumite date.  Putem distinge douã tipuri de restricþii:
restricþii asupra citirii unor date secrete ºi restricþii asupra
modificãrii de cãtre persoane ne-autorizate.  Existã mecanisme
speciale pentru fiecare din aceste scopuri, ºi existã mecanisme care
pot fi adaptate amîndurora.

<P>

<H2><A NAME="SECTION00021000000000000000">
Sisteme sigure</A>
</H2>

<P>
Înainte de a plonja în detalii sã observãm cã <EM>orice schemã
de securitate trebuie sã înceapã cu securitatea fizicã a unor
dispozitive de calcul</EM> (în sensul cã accesul la aparatul însuºi
este îngrãdit).  Dacã nu poþi avea încredere în nici un
calculator, atunci nu poþi face nici un fel de comunicaþie sau
stocare de date sigurã.  Dacã cineva are control asupra sistemul de
operare al unui calculator atunci el poate intercepta toate tastele
apãsate ºi toate caracterele scrise pe ecran.

<P>
Atunci cînd lucraþi pe un calculator trebuie sã aveþi deplinã
încredere cel puþin în consola la care lucraþi ºi în celãlalt
capãt al liniei.  Dacã nu puteþi garanta aceste lucruri nu trebuie
sã vã aºteptaþi la nici un fel de garanþii de securitate din
partea sistemului.  Marile bãnci au calculatoarele îngropate în
niºte buncãre subterane extrem de bine pãzite; unul dintre motive
este, desigur, acela de a nu pierde informaþii extrem de importante
în cazul unei calamitãþi, dar una dintre raþiunile primordiale
este garantarea securitãþii fizice a sistemului.

<P>
Oricare ar fi scopul pentru care vrem sã protejãm date, politica pe
care o aplicãm în acest sens va fi o funcþie de entitatea care vrea
sã acceseze datele.  De pildã anumite documente militare vor fi
secrete pentru gradele mici, dar vor putea fi accesate de un general.

<P>
Pentru a putea face astfel de distincþii este deci necesar sã avem
la dispoziþie un mecanism de <EM>autentificare</EM>.

<P>

<H1><A NAME="SECTION00030000000000000000">
Autentificare</A>
</H1>

<P>
Autentificarea (authentication) este procesul prin care se verificã
identitatea unei instanþe (de exemplu un utilizator) care a produs
niºte date.  Cele mai sigure metode de autentificare sunt cele
biometrice, care mãsoarã caracteristici fizice unice ale unui
individ (cum ar fi amprentele digitale sau forma irisului).  Acestea
sunt foarte greu de pãcãlit.  Din (ne)fericire sunt încã foarte
costisitoare ºi puþin rãspîndite.

<P>
Metoda prin care în mod uzual calculatoarele identificã identitatea
unei entitãþi cu care comunicã este verificarea cã acea entitate
ºtie o informaþie care foarte probabil nu mai este cunoscutã de
nimeni altcineva.  În sistemele tipice Unix acel secret este <EM>parola</EM> pe care utilizatorul trebuie sã o tasteze înainte de a
începe lucrul.

<P>
Sã mai observãm cã pentru a putea vorbi despre autentificare
trebuie sã avem o noþiune de <EM>identitate</EM> a utilizatorilor.
Calculatorul trebuie sã poatã distinge cumva între diferiþii
indivizi care îl folosesc.  Trebuie sã existe un <EM>spaþiu de
nume</EM> pentru utilizatori; autentificarea atunci va pune în
corespondenþã o entitate activã cu un astfel de nume.  În Unix
numele utilizatorilor autorizaþi sunt trecute într-o micã bazã de
date într-un fiºier numit <TT>/etc/passwd</TT> (sistemele mai moderne
au scheme mai complicate, dar înrudite); pentru un sistem Unix a
autentifica un utilizator constã în a asigna unul dintre aceste nume
cunoscute unui set de procese executate de acel utilizator.  Dacã un
individ nu are un nume în acel fiºier atunci el nu existã pentru
calculator.

<P>
Cu alte cuvinte, pentru a putea vorbi despre autentificare trebuie ca
pãrþile implicate în comunicare sã aibã un spaþiu de nume comun
pentru utilizatori.

<P>

<H1><A NAME="SECTION00040000000000000000">
Criptografie</A>
</H1>

<P>
Dacã întreg sistemul cu care lucrãm este sigur fizic atunci nu avem
mare nevoie de autentificare; noþiunea de securitate fizicã implicã
faptul cã persoane neautorizate nu pot accesa sistemul.  De îndatã
însã ce datele trebuie sã traverseze porþiuni nesigure trebuie sã
luãm mãsuri suplimentare de precauþie.  Transformarea datelor în
scopul de a împiedica accesul persoanelor neautorizate se numeºte
<EM>criptare</EM>.  Criptarea transformã un text <EM>inteligibil</EM>
(plaintext) într-un <EM>cifru</EM> (ciphertext).  Procesul de codificare
se numeºte <EM>cifrare</EM> sau <EM>criptare</EM> (encryption) iar procesul
invers se numeºte descifrare sau <EM>decriptare</EM> (decryption).

<P>

<H2><A NAME="SECTION00041000000000000000">
Funcþii ``ne-inversabile''</A>
</H2>

<P>
Putem vedea criptarea unui mesaj ca o transformare a mesajului.  În
mod normal aceastã transformare este una funcþionalã, în sensul
cã unui mesaj îi corespunde un singur cod.  Pentru a putea folosi la
ceva mesajele codificate, trebuie sã existe ºi o transformare
inversã, prin care dintr-un cifru obþinem textul iniþial.

<P>
Dacã notãm funcþia de criptare cu E (de la ``encryption'') ºi cea 
de decriptare cu D, pentru un mesaj x trebuie sã avem relaþia
D(E(x)) = x.  De aici rezultã în primul rînd cã funcþia E
trebuie sã fie injectivã (altfel inversa nu este bine definitã), cu
alte cuvinte oricare douã codificãri ale unor cuvinte diferite
trebuie sã fie diferite.

<P>
În realitate funcþiile de criptare ºi decriptare mai au un
parametru relativ mic (comparat cu lungimea mesajului x, numit
<EM>cheia</EM> de criptare.  Cheia este un obiect relativ uºor de
descris ºi manipulat, spre deosebire de funcþiile D ºi E.  E va fi atunci
de forma E(x, k), unde k este cheia.  D(x, k<sub>1</sub>) este funcþia de
decriptare, k<sub>1</sub> fiind cheia pentru decriptare.

<P>
Se deosebesc douã feluri de sisteme de criptare: simetrice, în care
k = k<sub>1</sub> ºi asimetrice în care cheile sunt diferite.

<P>
Ceea ce este important este cã funcþiile D ºi E sunt cunoscute
de toatã lumea; atunci cînd vreau sã stabilesc un canal sigur cu un
alt individ noi trebuie doar sã cãdem de acord asupra cheilor pe
care le folosim (k ºi k<sub>1</sub>).

<P>
Nu oricare douã funcþii care satisfac cerinþele anterioare sunt
bune pentru criptare.  Dacã fixãm cheia k ºi notãm funcþia
<IMG
 WIDTH="56" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img10.png"
 ALT="$E(k, \cdot)$"> cu E<sub>k</sub>, trebuie ca din cunoaºterea valorii lui
y = E<sub>k</sub>(x) (cifrul) sã fie practic imposibil de calculat x.
Din cauza asta funcþiile de criptare se numesc (nu foarte precis)
``neinversabile'' sau ``greu inversabile'' (one-way functions).

<P>
Ce înseamnã de fapt ``imposibil de calculat''?  Pentru a rãspunde
la aceastã întrebare ne trebuie ceva cunoºtinþe de teoria
complexitãþii, pe care o sã le omitem din prezentarea de faþã.
În principiu asta înseamnã cã orice algoritm care ar calcula cheia
k ºtiind y, D ºi E trebuie sã aibã o complexitate mai mare
decît polinomialã (de exemplu exponenþialã).

<P>
Sã observãm cã existã întotdeauna algoritmi care pot calcula
inversa, pur ºi simplu iterînd prin toate cheile posibile k ºi
vãzînd dacã D(y,k) este un cuvînt din limbajul de intrare.  Dar
dacã cheia are n biþi, trebuie încercate 2<sup>n</sup> combinaþii
diferite.  Pentru un n suficient de mare sunt mult prea multe
încercãri, chiar ºi pentru cel mai perfecþionat supercalculator.

<P>
De altfel unul dintre cele mai populare programe pentru ``spart''
parole pentru Unix, Crack, se bazeazã pe faptul cã cheile de fapt nu
sunt egal probabile; utilizatorii vor alege cu mare probabilitate
anumite cuvinte (pe care le vor mutila în mici feluri), pentru cã
sunt mai uºor de memorat.  ``Crack'' are la dispoziþie un dicþionar
enorm ºi o suitã de reguli pentru a modifica cuvintele, ºi pur ºi
simplu încearcã toate variantele; deºi asta poate pãrea mult, o
limbã umanã are în jur de 200 000 de cuvinte, o bagatelã pentru un
calculator (comparaþi de pildã cu 128<sup>8</sup>=72 057 594 037 927 936,
cît ar fi toate combinaþiile de 8 caractere ASCII).

<P>

<H2><A NAME="SECTION00042000000000000000">
P = NP?</A>
</H2>

<P>
Într-un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#algoritmi">articol</a>
mai vechi din PC Report despre algoritmi am prezentat felurite clase
de complexitate, printre care ºi clasele P ºi NP, ale problemelor a
cãror soluþie se poate calcula în timp polinomial, cu un calculator
determinist, respectiv nedeterminist.

<P>
Problema P=NP este probabil cea mai importantã problemã deschisã
din informatica; de peste 25 de ani s-au depus eforturi susþinute
pentru a vedea dacã existã probleme care se pot rezolva cu maºini
nedeterministe (care ``ghicesc'' o parte din soluþie) repede dar nu
ºi cu maºini deterministe (cum sunt toate calculatoarele reale).

<P>
Ei bine, pentru a fi rezonabilã, problema aflãrii cheii cu care este
criptat un mesaj nu poate fi mai complicatã decît o problemã din
clasa NP.  Lucrurile se pot justifica perfect riguros; ideea de bazã
este cã cel care cunoaºte cheia trebuie sã decodifice relativ rapid
mesajul primit (dacã decodificarea însãºi ar dura foarte mult
metoda n-ar mai fi practicã).  Un strãin care posedã însã o
maºinã (deocamdatã fictivã) nedeterministã ar putea folosi
maºina pentru a ``ghici'' cheia, dupã care ar decodifica cu aceastã
cheie ºi ar verifica corectitudinea ghicirii.

<P>
De aici rezultã o consecinþã foarte interesantã: dacã se va
demonstra cã P=NP <EM>nu existã criptografie</EM>!  Atunci orice
cifru cunoscut ar putea fi spart în timp polinomial!  Dacã nu aþi
crezut pînã acum cã problema P=NP meritã atenþie, poate acum
v-aþi schimbat opinia: rezolvarea ei (în sensul confirmãrii
egalitãþii) ar supãra o grãmadã de agenþii de spionaj ºi
militare.

<P>
Desigur, cele spuse anterior considerã cã orice problemã care are o
complexitate polinomialã este uºoarã (chiar dacã polinomul este
ceva de genul x<sup>10000</sup>) ºi cã toate problemele exponenþiale sunt
grele.  Este adevãrat cã 1.0001<sup>x</sup> depãºeºte cu mult pe
x<sup>10000</sup>, dar asta numai de la o valoare foarte mare a lui x
încolo.

<P>
Dar sã lãsãm pentru moment teoria complexitãþii.  Sã presupunem
cã <IMG
 WIDTH="72" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img21.png"
 ALT="$P \not= NP$">, cãci altfel nu mai avem ce studia, ºi sã aruncãm
o privire la <EM>modul</EM> în care poate fi folositã criptografia
pentru a transmite secrete.  Treaba asta este cu mult mai grea decît
pare.

<P>

<H1><A NAME="SECTION00050000000000000000">
Pericole</A>
</H1>

<P>
Cînd se proiecteazã un protocol sigur (de pildã de autentificare)
trebuie sã ºtim exact de ce anume vrem sã ne pãzim.  Un model
rãspîndit, pe care îl vom folosi ºi în textul de faþã face
urmãtoarele presupuneri:

<P>

<UL>
<LI>Agenþii finali sunt siguri: terminalul pe care lucrez eu ºi
serverele care conþin informaþiile sunt la adãpost în mod fizic
ºi nu pot fi controlate de ``duºmani'';

<P>
</LI>
<LI>Canalul de comunicaþii între agenþii finali este complet
nesigur;

<P>
</LI>
<LI>Un agent strãin poate intercepta absolut toate mesajele din
reþea ºi le poate studia: <EM>ascultare pasivã</EM>; (passive
wiretapping sau eavesdropping);

<P>
</LI>
<LI>Un agent strãin poate injecta mesaje noi în reþea între
mesajele existente (active wiretapping, tampering).  Anume inamicul
poate modifica mesajele existente, poate ºterge unele dintre ele,
poate modifica mesajele de pe reþea sau poate stoca mesaje transmise
ºi le poate retransmite mai tîrziu.
</LI>
</UL>

<P>
Este de asemenea important de ºtiut cã uºurinþa spargerii unui
protocol creºte cu cantitatea de mesaje avute la dispoziþie; cu cît
mai multe cifruri sunt observate, cu atît mai mult succes pot fi
fãcute anumite atacuri statistice.

<P>

<H1><A NAME="SECTION00060000000000000000">
Protocolul Kerberos</A>
</H1>

<P>
Protocolul Kerberos a fost proiectat la Universitatea MIT
(Massachusetts Institute of Techonology) în cadrul proiectului
Athena, în jurul anului 1984.  Scopul protocolului Kerberos este de a
permite unui client sã-ºi demonstreze identitatea unui server aflat
la distanþã, undeva dincolo de o reþea complet nesigurã.
Protocolul garanteazã de asemenea cã clientul nu poate conversa cu
un calculator care se dã drept server; autentificarea se face în
ambele direcþii.

<P>
Protocolul în sine constã dintr-un schimb de mesaje între un client
ºi o serie de servere, fiecare cu o altã misiune.  Idea de bazã
aparþine lui Needham ºi Schroeder care au publicat ideea iniþialã
în 1978 în Communications of the ACM.  Descrierea detaliatã a
protocolului se gãseºte în documentul numit RFC 1510, care este
disponibil de pe Internet<A NAME="tex2html1"
  HREF="#foot78"><SUP>1</SUP></A>.  Cei care
administreazã Kerberos pot pune întrebãri pe grupul de News <TT>comp.protocols.kerberos</TT>.

<P>
Protocolul Kerberos indicã de fapt o serie de mesaje care trebuie
schimbate între pãrþile care doresc sã comunice; unele din mesaje
sunt criptate.  Ce funcþie de criptare/decriptare se foloseºte
teoretic nu conteazã prea tare, atîta vreme cît funcþia este greu
inversabilã.  Implementãrile curente folosesc un algoritm standard
de criptare numit DES (Data Encryption Standard).

<P>
Kerberos este un protocol; pentru a fi util anumite aplicaþii (cele
care au nevoie de comunicaþie client-server) trebuie modificate
pentru a folosi autentificarea oferitã de Kerberos.  (Aplicaþiile
modificate sunt atunci numite ``kerberized'').  În mod normal
într-un domeniu administrativ în care se foloseºte Kerberos
programe ca <TT>telnet</TT>, <TT>rlogin</TT>, POP (post-office protocol),
fiºiere la distanþã (AFS), etc. trebuie rescrise în aºa fel
încît clientul sã se autentifice serverului folosind noua metodã
(toate aceste aplicaþii sunt de tip client-server).

<P>

<H2><A NAME="SECTION00061000000000000000">
Principii</A>
</H2>

<P>
Protocolul pare destul de complicat, dar dacã aveþi rãbdare o sã
înþelegeþi tot ce se întîmplã; nu e mare ºtiinþã la mijloc.

<P>
Premiza iniþialã este cã existã un server central, numit serverul
de autentificare (AS), care cunoaºte identitãþile tuturor
clienþilor posibili.  De asemenea, fiecare client a stabilit o
parolã secretã pe care ºi acest server o ºtie.  Parola ajunge la
server printr-o cale sigurã, de exemplu prin poºtã sau printr-un
mesager uman (mã rog, sigurã cel puþin din punct de vedere
software).  Parola asta nu este cunoscutã de nimeni altcineva, nici
mãcar de celelalte servere cu care clientul va comunica (de la care
va obþine serviciile care-l intereseazã de fapt).  Toate celelalte
servere din domeniul administrativ sunt ºi ele clienþi ai AS: au o
parolã unicã ºtiutã numai de AS ºi de acel server.

<P>
Niciodatã parola nu va circula în clar pe reþea; atunci oricine ar
putea sã o citeascã ºi sã o foloseascã în locul clientului de
drept.

<P>
Pentru a se proteja împotriva duºmanilor care vor înregistra sau
ºterge mesaje, mesajele vor avea informaþii ca ora la care au fost
trimise ºi un numãr de ordine (pentru a detecta omisiunile).

<P>
O altã regulã interesantã este cã cheile folosite în comunicarea
dintre client ºi servere se schimbã frecvent.  Implementarea
standard expirã o cheie dupã 25 de ore.  În felul acesta un atac
criptanalitic nu va avea prea mult succes: dacã dureazã mai mult de
25 de ore atunci cheia descoperitã este deja inutilã (desigur,
eventualele mesaje deja interceptate ºi stocate vor putea fi citite,
dar stricãciunile sunt limitate).  Cheia pe care un client ºi un
server o folosesc în comun se numeºte <EM>cheie de sesiune</EM> ºi
este generatã aleator.

<P>

<H2><A NAME="SECTION00062000000000000000">
Mesajele (protocolul Needham-Schroeder)</A>
</H2>

<P>
Sã presupunem cã clientul nostru vrea sã vorbeascã cu un server de
disc.  Protocolul esenþial este compus din 4 mesaje (protocolul real
este o simplã extensie a ideii pe care o prezint aici):

<P>

<OL>
<LI>Un mesaj de la client spre AS, prin care se indicã intenþia de
a comunica cu serverul de disc;

<P>
</LI>
<LI>Un mesaj de rãspuns de la AS pentru client, prin care AS îi
trimite clientului noua cheie de sesiune ºi un pacheþel pentru
serverul de disc;

<P>
</LI>
<LI>Un mesaj de la client spre serverul de disc, în care este
inclus pacheþelul de mai sus, pentru a garanta faptul cã clientul a
discutat cu AS (pacheþelul poate veni numai de la AS);

<P>
</LI>
<LI>Un mesaj de rãspuns de la serverul de disc prin care clientul
este convins cã serverul a putut deschide pacheþelul, deci cã
discutã într-adevãr cu serverul de disc.
</LI>
</OL>

<P>
Dupã acest schimb iniþial de mesaje clientul ºi serverul de disc
vor folosi cheia de sesiune generatã de AS pentru a cripta cu DES
toatã comunicaþia dintre ei.

<P>
Vom vedea cã mesajele sunt relativ încîlcite pentru a preveni toate
atacurile de mai sus.  Dacã veþi încerca sã simplificaþi
protocolul aproape sigur îl veþi face vulnerabil la anumite tipuri
de atacuri.

<P>
Sã notãm cele 3 entitãþi care colaboreazã astfel: C clientul, AS
serverul de autentificare ºi S serverul de disc (vedeþi ºi
figura&nbsp;<A HREF="kerberos-html.html#baza">1</A>).

<P>
O tehnicã importantã a protocolului, care este folositã pentru a
contraataca folosirea unor mesaje vechi înregistrate este de a
eticheta mesajele cu ora emiterii (într-un mod care nu poate fi
contrafãcut) ºi de a verifica la recepþie dacã ora este
rezonabilã.  Sincronizarea ceasurilor este o problema extrem de grea
în sistemele distribuite, aºa cã pentru Kerberos ``rezonabil''
înseamnã cã ceasul local la recepþie aratã plus/minus 5 minute de
ora din mesaj (ora de transmitere).

<P>
Un alt truc interesant este folosirea a ceea ce se numeºte <B>nonce</B>: un obiect care este folosit o singurã datã.  Acesta este
practic un numãr aleator.  Vom vedea mai jos cum este acesta folosit.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="baza"></A><A NAME="199"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Protocolul de bazã (simplificat).</CAPTION>
<TR><TD><IMG
 WIDTH="361" HEIGHT="227" BORDER="0"
 SRC="img22.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{baza.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Vom mai introduce urmãtoarele notaþii:

<P>

<UL>
<LI>K<sub>a,b</sub> este cheia de sesiune pe care o folosesc pentru
discuþie a ºi b; de exemplu K<sub>C,S</sub> va fi cheia folositã
pentru criptare/decriptare între client ºi serverul de disc;

<P>
</LI>
<LI>Cum am spus mai sus, AS este serverul de autentificare, care
ºtie parola fiecãrei alte entitãþi din sistem;

<P>
</LI>
<LI>K<sub>z</sub> este cheia pe care clientul z ºi AS o folosesc în
comun (parola clientului z); de pildã K<sub>s</sub> este parola
serverului de disc (cunoscutã numai de el ºi de AS);

<P>
</LI>
<LI>Voi scrie {mesaj<sub>1</sub>, mesaj<sub>2</sub>}<sub>K</sub>
pentru a indica faptul cã mesajele 1 ºi 2 sunt puse laolatã într-un
pachet care este apoi criptat cu cheia K.

<P>
</LI>
<LI>O abreviere utilã este cea de <EM>tichet</EM> (ticket): T<sub>a,b</sub>
= { K<sub>a,b</sub>, a, ora curenta }: un mesaj în care sunt
împachetate 3 informaþii: o cheie de sesiune între a ºi b,
numele lui a ºi ora curentã.
</LI>
</UL>

<P>
Cu aceste notaþii putem scrie complet ne-ambiguu toate mesajele
schimbate între C, S ºi AS.  Sãgeata indicã traseul fiecãrui
mesaj:

<P>
<DL COMPACT>
<DT>C ---&gt; AS:</DT>
<DD>C, S, ora expirare, N (nonce, aleator).

<P>
Clientul afirmã propria identitate, identitatea serverului cu care
vrea sã discute, trimite un numãr aleator ºi cît timp ar dori sã
converseze cu S.  Pînã aici totul e simplu.  AS va rãspunde astfel:

<P>
</DD>
<DT>AS ---&gt; C$:</DT>
<DD>{K<sub>C,S</sub>, S, ora expirare, N}<sub>K<sub>C</sub></sub>,
{T<sub>C,S</sub>}<sub>K<sub>S</sub></sub\> .

<P>
Acest complicat mesaj are mai douã pãrþi mari: prima este
destinatã clientului, ºi este criptatã cu cheia clientului
K<sub>C</sub>, iar a doua este un tichet pentru S, criptat cu cheia
lui S.  Sã vedem la ce folosesc feluritele pãrþi din mesaj:

<P>

<UL>
<LI>Prima parte a mesajului este criptatã cu cheia K<sub>C</sub> a lui C.
Pentru cã aceastã cheie este secretã, nimeni altcineva nu poate
decripta acest mesaj decît C; pentru restul lumii mesajul este gunoi.
La fel stau lucrurile ºi pentru partea a doua a mesajului, care fiind
criptatã cu K<sub>S</sub> este inteligibilã numai pentru S.

<P>
</LI>
<LI>K<sub>C,S</sub> este un numãr aleator generat de AS, care va fi
folosit ca cheie de sesiune între C ºi S.  Observaþi cã cheia
de sesiune apare în ambele pãrþi ale mesajului, în aºa fel
încît va fi cunoscutã atît de cãtre C cît ºi de S.

<P>
</LI>
<LI>AS îi confirmã lui C identitatea serverului de disc S ºi
indicã durata de validitate a lui K<sub>C,S</sub> (care poate fi
diferitã decît a dorit C în primul mesaj).

<P>
</LI>
<LI>Faptul cã N apare în mesajul cãtre C garanteazã cã acest
mesaj a fost criptat de AS: nimeni altcineva nu putea sã-l bage pe
N înauntru.  De asemenea, acest mesaj nu putea fi un mesaj mai
vechi dintr-o comunicaþie anterioarã, pentru cã N diferã.

<P>
</LI>
<LI>Partea a doua a mesajului este opacã pentru C; tot ce poate
face C cu ea este sã o înainteze lui S.  C (sau oricine altcineva)
nu o poate citi.  Dacã cineva ar modifica partea a doua, S nu ar mai
putea-o decodifica ºi obþine un mesaj corect, deci tichetul nu poate
fi contrafãcut sau modificat.
</LI>
</UL>

<P>
</DD>
<DT>C ---&gt; S:</DT>
<DD>{C, ora curenta, suma de control}<sub>K<sub>C,S</sub></sub>,
{T<sub>C,S</sub>}<sub>K<sub>S</sub></sub>. 

<P>
Mesajul are din nou douã pãrþi.  

<P>

<UL>
<LI>Partea a doua este exact partea a doua a mesajului 2, aºa cum a
fost primitã de la AS.

<P>
</LI>
<LI>Prima parte a mesajului are scopul de a demonstra cã acest
mesaj este ``proaspãt'': S va extrage K<sub>C,S</sub> din partea a
doua a mesajului ºi o va folosi pentru a citi prima parte a mesajului.
De acolo aflã ora la care a fost trimis mesajul, ºi îl rejecteazã
dacã ora diferã prea tare de ora localã.  (Asta ar putea sã
însemne cã mesajul a fost capturat de un inamic ºi re-lansat).
Suma de control ne asigurã cã mesajul nu a fost modificat de nimeni;
este practic imposibil sã modifici un mesaj criptat ºi sã repari
ºi suma de control dacã nu ºtii cheia.
</LI>
</UL>

<P>
</DD>
<DT>S ---&gt; C:</DT>
<DD>{ora curenta+1}<sub>K<sub>C,S</sub></sub>.  

<P>
Prin acest mesaj S în convinge pe C cã a ajuns la destinaþia doritã:
mesajul are ora curentã trimisã anterior de C plus 1.  Dar ora putea
fi extrasã numai de cel care avea K<sub>C,S</sub>, care fiind o cheie
de sesiune era ºtiutã numai de S.  Nu era suficient sã returneze
aceeaºi valoare, pentru cã atunci acest mesaj putea fi o copie a (unei
pãrþi a) mesajului anterior.

<P>
</DD>
</DL>

<P>
La sfîrºitul acestei comunicaþii atît C cît ºi S sunt siguri de
identitatea celuilalt ºi în plus au la dispoziþie o cheie de sesiune
K<sub>C,S</sub> cu care pot cripta toate mesajele pe care le schimbã.
Autentificarea a fost fãcutã.

<P>

<H1><A NAME="SECTION00070000000000000000">
Implementarea Kerberos</A>
</H1>

<P>
Între un protocol de autentificare pe hîrtie ºi o implementare
realã pe un calculator e o distanþã considerabilã.  Secþiunea
urmãtoare, consacratã slãbiciunilor lui Kerberos va ilustra ºi mai
pregnant acest lucru.

<P>
Implementarea lui Kerberos încearcã sã mai þinã cont de anumite
particularitãþi ale lumii reale care fac realizarea protocolului mai
dificilã.

<P>
Prima întrebare spinoasã care se iveºte este: unde este stocatã parola
fiecãrui client K<sub>C</sub>, K<sub>S</sub>, etc.).  AS trebuie sã fie
o maºinã foarte sigurã, undeva într-un subsol ferit, dar maºinile
client vor fi probabil peste tot la-ndemînã.  Dacã parola unui client
este stocatã pe disc atunci este mai la-ndemîna atacurilor asupra
clientului.

<P>
Ca atare Kerberos nu memoreazã parola nicãieri!  Utilizatorul este
obligat sã o tasteze de fiecare datã cînd vrea sã fie autentificat.
Observaþi cã K<sub>C</sub> este folositã în mesajele de mai sus numai
pentru a decripta mesajul 2; în rest este inutilã.  Deci procedura
este urmãtoarea: programul kerberizat al clientului va lua legãtura cu
AS, iar cînd rãspunsul soseºte utilizatorul trebuie sã tasteze parola
K<sub>C</sub>.  Parola este imediat folositã pentru a decripta mesajul
de la AS dupã care este complet ºtearsã din memorie.  În acest fel
fereastra de vulnerabilitate este redusã la maximum.

<P>
Pe de altã parte asta poate fi foarte neplãcut, pentru cã atunci
utilizatorul va trebui sã tasteze parola pentru fiecare nou server S
pe care vrea sã-l foloseascã (adicã pentru fiecare nouã sesiune).
ªi cum ºtim cã utilizatorii sunt leneºi, aºa ceva este
inadmisibil.  Kerberos a introdus atunci un al doilea server central
numit ``Serverul care dã tichete'': Ticket Granting Server, TGS.
Ideea este TGS are de fapt toate parolele K<sub>S</sub>.  Clientul C se
autentificã la TGS exact în acelaºi fel ca la oricare server S:
obþinînd un tichet de la AS.  Odatã autentificat la TGS ºi
folosind cheia de sesiune K<sub>C, TGS</sub> clientul poate solicita
oricîte chei pentru alte servere S, S<sub>1</sub>, etc.

<P>
Figura&nbsp;<A HREF="kerberos-html.html#complet">2</A> ºi
tabela&nbsp;<A HREF="kerberos-html.html#mesajele">1</A> aratã situaþia
realã: mesajele 1,2 sunt schimbate numai cînd utilizatorul face
<TT>login</TT>.  Mesajele 3,4 sunt schimbate de fiecare datã cînd 
utilizatorul vrea sã contacteze un nou server (adicã sã deschidã o
nouã sesiune).  Mesajul 5 este folosit de client pentru a se
autentifica fiecãrui nou server, iar mesajul 6 este opþional,
autentificînd serverul pentru client.  În mesajul 5 apare un element
nou, numit K<sub>subsesiune</sub>: clientul poate alege aici o nouã
cheie de sesiune care sã fie folositã în locul cheii oferite de TGS,
K<sub>C,S</sub>.  Asta nu schimbã prea tare natura protocolului.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="complet"></A><A NAME="205"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Protocolul Kerberos complet.</CAPTION>
<TR><TD><IMG
 WIDTH="446" HEIGHT="274" BORDER="0"
 SRC="img51.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{complet.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="162"></A>
<TABLE>
<CAPTION><STRONG>Table 1:</STRONG>
Schimbul complet de mesaje în protocolul Kerberos.</CAPTION>
<TR><TD>h
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Nr.</TD>
<TD ALIGN="CENTER">Între</TD>
<TD ALIGN="LEFT">Conþinutul mesajului</TD>
</TR>
<TR><TD ALIGN="LEFT">1</TD>
<TD ALIGN="CENTER">C ---&gt; AS</TD>
<TD ALIGN="LEFT">C, TGS, ora de expirare, N</TD>
</TR>
<TR><TD ALIGN="LEFT">2</TD>
<TD ALIGN="CENTER">AS ---&gt; C</TD>
<TD ALIGN="LEFT">K<sub>C, TGS</sub>, ora de expirare,
N}<sub>K_C</sub>, {T<sub>C,TGS</sub>}<sub>K<sub>TGS</sub></sub></TD>
</TR>
<TR><TD ALIGN="LEFT">3</TD>
<TD ALIGN="CENTER">C ---&gt; TGS</TD>
<TD>{ora locala}<sub>K<sub>C,TGS</sub></sub>,
{T<sub>C,TGS</sub>}<sub>K<sub>TGS</sub></sub>, S, ora de expirare,
N<sub>1</sub></TD>
</TR>
<TR><TD ALIGN="LEFT">4</TD>
<TD ALIGN="CENTER">TGS ---&gt; C</TD>
<TD ALIGN="LEFT">{K<sub>C,S</sub>, S, ora de expirare,
N<sub>1</sub>}<sub>K<sub>C, TGS</sub></sub>,
{T<sub>C,S</sub>}<sub>K<sub>S</sub></sub></TD>
</TR>
<TR><TD ALIGN="LEFT">5</TD>
<TD ALIGN="CENTER">C ---&gt; S</TD>
<TD ALIGN="LEFT">{ora locala, suma de
control,K<sub>subsesiune</sub>}<sub>K<sub>C,S</sub></sub>,
{T<sub>C,S</sub>}<sub>K<sub>S</sub></sub></TD>
</TR>
<TR><TD ALIGN="LEFT">6</TD>
<TD ALIGN="CENTER">S ---&gt; C</TD>
<TD ALIGN="LEFT">{ora locala}<sub>K<sub>C,S</sub></sub></TD>
</TR>
</TABLE>

<A NAME="mesajele"></A></DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Kerberos este implementat sub forma unor procese server (AS, TGS) ºi
a unor biblioteci care se pot lega în programele clienþilor ºi
serverelor.  Funcþioneazã sub o mare varietate de sisteme de
operare: Unix ºi Windows NT fiind cele mai notabile.  Mai are tot
felul de zorzoane, legate de pildã de autentificarea între domenii
administrative diferite, transmiterea tichetelor, etc.

<P>

<H1><A NAME="SECTION00080000000000000000">
Slãbiciunile lui Kerberos</A>
</H1>

<P>
Chiar dacã în teorie Kerberos este minunat, implementarea lui în
practicã este cel puþin dificilã.  Condiþiile ideale existente pe
hîrtie sunt greu de obþinut într-o reþea de calculatoare reale.

<P>
La ora actualã nu existã nici un fel de metodã complet riguroasã
pentru a arãta ca un protocol criptografic nu scapã informaþii;
existã metode pentru a testa dacã un protocol rezistã la atacurile
cunoscute, dar foarte adesea se publicã algoritmi care mai tîrziu se
dovedesc greºiþi.  În general, raþionamentele cu astfel de
protocoale sunt foarte complicate.  Cercetarea în domeniu este în
plinã desfãºurare ºi foloseºte tehnici foarte exotice, ca teoria
informaþiei, teoria complexitãþii, logici speciale (ex. knowledge
theory), etc.

<P>
Voi ilustra aici numai unele dintre deficienþe, pentru a da o idee
despre natura lor.

<P>
Sã observãm cã clientul trebuie sã pãstreze undeva cheile de
sesiune pentru a putea conversa cu serverele: fiecare mesaj dupã cele
de autentificare va fi criptat cu aceste chei.  Clientul trebuie sã
posede deci practic permanent K<sub>C, TGS</sub> ºi K<sub>C,S</sub>.
E adevãrat cã aceste chei expirã în 25 de ore, deci sunt mai puþin
importante decît o parolã care teoretic este folositã luni întregi.
Întrebarea este însã: unde sunt þinute pe calculatorul clientului
aceste chei?

<P>
Pe o staþie obiºnuitã Unix lucreazã în mod normal mai mulþi
utilizatori.  Tichetele unuia ar trebui sã fie ferite de ceilalþi.
Dar pe un sistem Unix practic nimic nu poate fi adãpostit împotriva
administratorului (root).  Administratorul unui sistem poate citi
orice fiºier, ºi poate inspecta memoria fizicã a oricãrui proces.
Acesta este un cãlcîi al lui Ahile al lui Kerberos; toate metodele
cunoscute pentru a penetra un sistem Unix ameninþã siguranþa
întregului protocol.  Ori securitatea unui sistem Unix, care este
foarte complicat, este extrem de greu de controlat; existã o
sumedenie de breºe de care un atacator ar putea profita.

<P>
O altã mare problemã este cu staþiile de lucru fãrã disc
(diskless); aceste staþii de obicei importã discuri prin reþea.
Deci de îndatã ce o astfel de staþie stocheazã un tichet pe disc,
tichetul va cãlãtori prin reþea, care am stabilit cã este expusã
la tot felul de atacuri!

<P>
Nici pãstrarea tichetului în memorie nu este neapãrat mai sigurã:
algoritmii de paginare stocheazã paginile pe disc (în partiþia de
swap) atunci cînd calculatorul nu are destulã memorie, deci am
revenit la aceeaºi problemã.

<P>
Iatã încã un exemplu: am vãzut cã prospeþimea unui tichet este
verificatã comparînd ora localã a serverului cu ora din tichet.
Pentru un interval de 5 minute serverul memoreazã toate tichetele
primite, pentru a depista duplicate, eventual rezultate dintr-un atac
care re-transmite pachete vechi capturate.  Un tichet mai vechi de 5
minute este considerat expirat ºi ignorat.  În felul acesta un
server nu va primi niciodatã acelaºi pachet de douã ori.  Asta
presupune cã serverul ºi clientul au ceasuri relativ sincronizate.

<P>
Într-o reþea mare de calculatoare sincronizarea ceasurilor se face
automat, folosind un protocol numit NTP: Network Time Protocol.  Un
atac foarte spectaculos este urmãtorul: un atacator înregistreazã o
serie de mesaje de la un client care ºtie cã reprezintã o
tranzacþie importantã.  Peste o sãptãmînã atacatorul
infiltreazã în reþea mesaje false NTP prin care seteazã ceasul
unui server cu o sãptãmînã în urmã.  Dupã asta atacatorul
retransmite mesajele capturate, care vor fi re-executate, pentru cã
serverului îi par proaspete.

<P>
Asta face securitatea în calculatoare o problemã foarte spinoasã:
adesea protocoalele propuse sunt eronate, dar nu existã nici o
metodã formalã pentru a depista ºi verifica asta.  Chiar dacã un
protocol este corect formal, se poate baza pe asumpþii nerezonabile
asupra mediului în care opereazã, cum ar fi ceasurile sincronizate.
ªi chiar dacã se bazeazã pe asumpþii rezonabile, implementarea
scrisã de un programator uman poate sã aibã bug-uri care o fac
vulnerabilã.

<P>

<H1><A NAME="SECTION00090000000000000000">
Kerberos pentru un utilizator</A>
</H1>

<P>
Voi încheia acest articol ilustrînd cum se manifestã Kerberos
pentru un utilizator obiºnuit.  Domeniul administrativ în care
lucrez eu de obicei este complet kerberizat.  Programul meu <TT>login</TT> a fost modificat ca imediat ce tastez parola sã discute cu AS
ºi sã obþinã un tichet pentru serverul care dã tichete, TGS.
Directorul meu casã este de pe un disc din reþea, aflat undeva
departe, pe un server de disc (protocolul folosit este AFS: Andrew
File System).  Atunci cînd comunic prima oarã cu serverul de AFS
demonul local de pe maºina mea foloseºte tichetul obþinut de la AS
pentru a obþine de la TGS un tichet pentru serverul de disc.  Dupã
aceea se autentificã serverului de disc, exact ca în schema de mai
sus.

<P>
Dupã autentificarea cu serverul de disc toatã comunicaþia între
maºina mea ºi serverul de disc se va face folosind un alt protocol,
numit Secure RPC (Remote Procedure Call): apel sigur de procedurã la
distanþã, care foloseºte iniþial cheia de sesiune oferitã de TGS.

<P>
Pentru mine ca utilizator final totul este aproape complet
transparent.  Singura neplãcere este cã la fiecare 25 de ore
tichetele pentru TGS expirã, ºi atunci trebuie sã-mi tastez din nou
parola pentru a obþine tichete proaspete.  Asta poate fi neplãcut
dacã vrei sã rulezi o simulare mai îndelungatã.

<P>
Pot sã vãd în orice clipã tichetele pe care le posed cu comanda
<TT>klist</TT>:

<P>
<PRE>
$ klist
Ticket file:	/tkt/7108-0401-35ae552f
Principal:	me@CS.CMU.EDU

  Issued           Expires          Principal
Jul 20 10:50:34  Jul 21 12:16:55  krbtgt.CS.CMU.EDU@CS.CMU.EDU
Jul 20 10:50:34  Jul 21 12:16:55  afs@CS.CMU.EDU
Jul 20 10:51:30  Jul 21 12:17:51  zephyr.zephyr@CS.CMU.EDU
</PRE>

<P>
Tichetele sunt þinute în fiºierul <TT>/tkt/7108-0401-35ae552f</TT> pe
discul local.  Am în clipa asta 3 tichete: unul pentru TGS, unul
pentru serverul de disc AFS ºi unul pentru sistemul de mesagerie
zephyr (care nu ne intereseazã prea tare acum).

<P>
Mai am la dispoziþie urmãtoarele comenzi:

<P>
<DL>
<DT><STRONG>kinit</STRONG></DT>
<DD>prin care pot sã-mi schimb identitatea Kerberos (de
pildã dacã un coleg vrea sã lucreze pe calculatorul meu o sã
tasteze <TT>kinit numele-lui</TT> ºi apoi parola lui personalã;

<P>
</DD>
<DT><STRONG>kdestroy</STRONG></DT>
<DD>prin care toate tichetele de pe maºina localã sunt
distruse; foarte util dacã plec ºi nu vreau ca cineva sã poatã
lucra în numele meu;

<P>
</DD>
<DT><STRONG>kpasswd</STRONG></DT>
<DD>prin care îmi pot schimba cheia (parola) stocatã pe
AS.  Schimbarea parolei este sigurã, pentru cã parola va fi trimisã
criptat la un server special care face managementul parolelor ºi
modificã baza de date din care citeºte AS.  Autentificarea la
managerul de parole se face tot folosind Kerberos.  Asta înseamnã
cã odatã ce am o parolã Kerberos (care trebuie introdusã manual
în baza de date a lui AS) schimbarea o pot face fãrã sã mai bat
vreun administrator la cap;

<P>
</DD>
<DT><STRONG>kdb_init</STRONG></DT>
<DD>este o comandã folositã de administrator pentru a
crea o nouã bazã de date Kerberos atunci cînd porneºte serviciul;

<P>
</DD>
<DT><STRONG>kdb_admin</STRONG></DT>
<DD>este comanda prin care administratorul adaugã un
nou utilizator în baza de date;

<P>
</DD>
<DT><STRONG>kdb_edit</STRONG></DT>
<DD>este comanda prin care se pot adãuga noi
administratori în baza de date AS: persoane care au dreptul sã
modifice baza de date.
</DD>
</DL>

<P>
În plus, în domeniul în care lucrez eu, majoritatea comenzilor care
opereazã în reþea au fost kerberizate.  De pildã demonul ºi
clientul de telnet (terminal virtual): cînd eu fac <TT>telnet</TT> pe o
maºinã la distanþã clientul îmi cere parola dupã care obþine un
tichet de la TGS pentru demonul <TT>telnetd</TT> de pe maºina de la
distanþã; în acest fel parola mea nu circulã niciodatã prin
reþea (cum ar fi fost cazul dacã telnet nu era kerberizat).

<P>

<H1><A NAME="SECTION000100000000000000000">
Concluzie</A>
</H1>

<P>
Securitatea în calculatoare este o problemã de mare importanþã
economicã, mai ales acum cînd tot mai multe tranzacþii se fac prin
Internet.  Proiectarea unui protocol de securitate este o treabã
foarte complicatã, iar implementarea nu este deloc simplã.  Domeniul
este în plinã cercetare în continuare.  Dificultãþile sunt
amplificate de faptul cã lanþul este tot atît de slab cît cea mai
slabã verigã, iar verigi sunt destul de multe.  Fiþi deci cu
ochii-n patru.

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot78">... Internet</A><A NAME="foot78"
HREF="kerberos-html.html#tex2html1"><SUP>1</SUP></A> <DD>Într-un
articol <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#internet">anterior</a>
din PC Report am arãtat cã standardele privitoare la Internet se
publicã în astfel de documente numite Request For Comments.

</DL>
<BR><HR>

</BODY>
</HTML>
