<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Anatomia unui apel de sistem în Linux</TITLE>
<META NAME="description" CONTENT="Anatomia unui apel de sistem în Linux">
<META NAME="keywords" CONTENT="linux-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Anatomia unui apel de sistem în Linux</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT>http://www.cs.cmu.edu/~mihaib</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>15 decembrie 1997</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Execuþia unui apel de sistem urmãritã pas cu pas
în sistemul de operare Linux;
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>Noþiuni elementare despre sisteme de
operare, limbajul C foarte bine, noþiuni despre setul de
instrucþiuni al microprocesoarelor Intel 80x86;
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>apel de sistem, trap, monitor, cod re-entrant,
nucleu.
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html25"
  HREF="linux-html.html">Nucleul sistemului de operare</A>
<UL>
<LI><A NAME="tex2html26"
  HREF="#SECTION00021000000000000000">Reentranþa</A>
</UL>
<BR>
<LI><A NAME="tex2html27"
  HREF="#SECTION00030000000000000000">Linux</A>
<UL>
<LI><A NAME="tex2html28"
  HREF="#SECTION00031000000000000000">Arborele de directoare al sursei</A>
</UL>
<BR>
<LI><A NAME="tex2html29"
  HREF="#SECTION00040000000000000000">Un apel de sistem: <TT>getpid(2)</TT></A>
<UL>
<LI><A NAME="tex2html30"
  HREF="#SECTION00041000000000000000">Apelul funcþiei de bibliotecã</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION00042000000000000000">Întreruperea</A>
<LI><A NAME="tex2html32"
  HREF="#SECTION00043000000000000000">Poarta de intrare în nucleu</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION00044000000000000000">Tabela de dispecerizare</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION00045000000000000000">Funcþia <TT>sys_getpid()</TT></A>
<LI><A NAME="tex2html35"
  HREF="#SECTION00046000000000000000">Întoarcerea</A>
<LI><A NAME="tex2html36"
  HREF="#SECTION00047000000000000000">Livrarea semnalelor</A>
<LI><A NAME="tex2html37"
  HREF="#SECTION00048000000000000000">Sfîrºitul întreruperii</A>
<LI><A NAME="tex2html38"
  HREF="#SECTION00049000000000000000">Terminarea funcþiei de bibliotecã</A>
</UL>
<BR>
<LI><A NAME="tex2html39"
  HREF="#SECTION00050000000000000000">Rezumat</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Acest articol este un ``studiu de caz'' (case study) în sisteme de
operare.  Vom urmãri (aproape) pas cu pas operaþiile executate de
microprocesor pentru execuþia unui foarte simplu apel de sistem;
cobaiul experimentului nostru (înafarã de cititor) este sistemul de
operare Linux.  Citirea codului unui sistem de operare ``adevãrat'' 
este una dintre cele mai bune metode de a înþelege cum
funcþioneazã mãruntaiele acestuia.  În definitiv ce poate fi mai
concret de atîta?

<P>

<H1><A NAME="SECTION00020000000000000000">
Nucleul sistemului de operare</A>
</H1>

<P>
În aceastã secþiune voi revizui pe scurt noþiunea de ``nucleu al unui
sistem de operare'' (kernel); un tratament mai amplu al chestiunii
poate fi gãsit într-un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#nucleu">articol</a>
din PC Report din septembrie-octombrie 1996, a cãrui copie este
disponibilã ºi din pagina de web a autorului (ca ºi toate celelalte
articole ale sale la care face referinþã).

<P>
Ce este un sistem de operare?  Un set de programe care trateazã multe
din funcþiile cel mai des utilizate de programele utilizatorilor
(cum ar fi accesul la disc) ºi permite simultan executarea pe un acelaºi 
calculator a unor programe independente.  Cea mai importantã
parte a unui sistem de operare este <I>nucleul</I> lui.  Acesta este
practic o colecþie de funcþii (numite ``apeluri de sistem'' --
system calls) care pot fi executate de programele utilizatorilor ºi
care îndeplinesc funcþiuni utile.  Nucleul unui sistem de operare se
bucurã de oarecare privilegii relativ la programele scrise de
utilizatorii obiºnuiþi, în sensul cã anumite operaþii sunt
permise numai nucleului, dar nu ºi programelor care beneficiazã de
serviciile sale.  De pildã utilizatorii nu pot accesa discul în nici
un fel; ei au la dispoziþie însã un set de funcþii ale nucleului
care fac (teoretic) tot ce utilizatorul ar avea nevoie într-un mod
organizat: creazã ºi distrug fiºiere, permit scrierea datelor ºi
citirea lor în fiºiere, precum ºi accesul controlat la aceste
resurse.

<P>
Motivaþia pentru care accesul utilizatorului este interzis la disc
este în principal legatã de <I>integritatea</I> discului: dacã
programe diferite ar vrea sã foloseascã fiecare pentru sine discul
într-un alt fel, ar putea sã interfereze între ele.  Nucleul oferã un
acces limitat la disc, încercînd sã garanteze anumite proprietãþi
de consistenþã a datelor: de pildã dacã datele scrise în fiºiere
diferite nu au nici o legãtura unele cu altele, pentru cã creºterea
ambelor fiºiere este supervizatã atent de nucleu<A NAME="tex2html1"
  HREF="#foot54"><SUP>1</SUP></A>.

<P>
Funcþiile nucleului mai sunt ciudate pentru cã (pe lîngã faptul
cã pot folosi anumite operaþii privilegiate), ele sunt comune
tuturor programelor care se executã pe acel calculator, fie cã
programele se executã unul dupã altul sau simultan.  De fapt una din
misiunile esenþiale ale nucleului este lansarea programelor în
execuþie (ºi atunci ele capãtã denumirea de ``procese'') ºi
controlarea execuþiei lor.  Toate nucleele moderne suportã execuþia
``simultanã'' a mai multor procese (ceea ce se numeºte
``multiprogramare'').  Multiprogramarea poate fi ``realã'', în cazul
în care calculatorul are mai multe procesoare, sau simulatã prin
ceea ce se numeºte ``time-sharing'' (punerea în comun a timpului):
oprirea unor programe din execuþie temporar pentru a executa altele.
Comutarea de la un proces la altul are numele englezesc de ``context
switch'': comutarea contextului.  Raþiunea principalã pentru
time-sharing este una economicã: nu toate pãrþile unui calculator
funcþioneazã cu aceeaºi vitezã, deci dacã douã dintre ele
comunicã cea mai rapidã trebuie sã aºtepte dupã cea mai lentã
(discul de pildã este de cam un milion de ori mai lent decît
procesorul).  Cînd sunt mai multe lucruri de fãcut putem executa
unele dintre ele în timp ce altele aºteaptã dupã operaþiile
lente.

<P>

<H2><A NAME="SECTION00021000000000000000">
Reentranþa</A>
</H2>

<P>
Nucleul este deci o colecþie de funcþii ºi de structuri de date
care oferã utilizatorului o sumedenie de operaþii utile.  Vom vedea
cã nucleul are o singurã colecþie de structuri de date pentru
<I>toate</I> procesele care se executã.

<P>
Aceste douã atribute (multiprogramarea ºi unicitatea structurilor de
date) puse cap la cap ridicã o problemã foarte dificilã: sã
presupunem cã un proces A executã un apel de sistem pentru un acces
la disc.  O astfel de operaþie este foarte costisitoare (în timp),
aºa cã nucleul roagã discul sã-i trimitã datele, ºi pentru cã
are la dispoziþie timp pentru un milion de instrucþiuni suspendã
procesul A ºi porneºte procesul B.  Ce facem însã dacã B face el
însuºi un apel de sistem pentru operaþii pe fiºiere în timp ce
apelul lui A nu s-a terminat?  Poate B ºterge fiºierul pe care A
tocmai îl modificã sau altceva de genul ãsta.

<P>
Un astfel de cod, care se poate executa <I>simultan</I> în contextul
mai multor procese se numeºte <I>cod re-entrant</I> (se poate intra
din nou într-o funcþie în timp ce se executã).  Codul re-entrant
trebuie proiectat cu foarte multã grijã dintru început ºi trebuie
scris cu mare atenþie.  Nucleele tuturor sistemelor de operare
moderne sunt re-entrante.

<P>
Subiectul este extrem de interesant ºi de subtil; toate cursurile
universitare despre sisteme de operare îi consacrã o parte relativ
importantã.  Noi nu ne vom izbi în acest articol explicit de
re-entranþã, deºi ea este de fapt ``ascunsã'' undeva, ºi o
grãmadã de funcþii (despre care <I>nu</I> vom discuta) colaboreazã
la a ascunde natura re-entrantã a nucleului.  Principala tehnicã
folositã pentru a scrie cod re-entrant este <I>regiunea criticã</I>;
aceasta este o regiune de cod care nu poate fi executatã de mai multe
procese simultan.  O soluþie la problema de mai sus a proceselor A
ºi B ar fi de a nu permite nici unui proces sã facã operaþii pe
fiºiere pînã A nu ºi-a terminat-o pe a lui (atunci practic toate
operaþiile pe fiºiere ar fi constituit o regiune criticã).  În
realitate nucleele încearcã sã permitã cît mai multã activitate
concurentã, pentru cã de obicei procesele au nevoie de resurse
distincte.  De pildã ar fi pãcat sã nu-l lãsãm pe B sã ºteargã
alt fiºier decît cel cu care opereazã A doar pentru cã A nu ºi-a
terminat treaba.

<P>
Dar ºtiu cã sunteþi anxioºi sã vedeþi cod, aºa cã voi
întrerupe aici discuþia despre secþiuni critice.

<P>

<H1><A NAME="SECTION00030000000000000000">
Linux</A>
</H1>

<P>
Voi baza discuþia mea pe sistemul de operare Linux.  Linux este un
sistem de operare de tip Unix<A NAME="tex2html2"
  HREF="#foot62"><SUP>2</SUP></A>, scrisã iniþial în 1991 de un student
Finlandez pe nume Linus Torvalds.  El este în continuare principalul
``scriitor'' al nucleului Linux, dar nu cantitativ, pentru cã la cele
peste 800 000 linii ale codului au contribuit deja mii de voluntari din
întreaga lume.  Trebuie spus cã sistemul este de o calitate foarte
bunã, rivalizînd cu succes cu produse ale marilor firme care costã
bani grei.  Diferenþa este cã Linux este disponibil în surse oricui
îl doreºte; poate fi obþinut contra cost sau gratuit de pe
Internet.  Linux evolueazã foarte rapid; noi versiuni ale nucleului
apar la fiecare cîteva zile.  Voi baza discuþia mea pe versiunea
2.0.30.  Aceasta este ultima versiune mare stabilã a nucleului.

<P>
<FONT SIZE="-1">Dezvoltarea nucleului se face pe douã linii: cele cu un numãr par
dupã' primul punct sunt versiuni stabile, care sunt recomandate
celor care folosesc Linux pentru nevoile lor, iar versiunile cu un
numãr impar (2.1.x) conþin cod experimental, care nu a fost încã
îndeajuns testat pentru a fi recomandabil celor care au nevoie de
fiabilitate.  Versiunile impare sunt folosite de cei care dezvoltã
sistemul, sau care au neapãratã nevoie de anumite lucruri
neimplementate încã în celelalte versiuni.
</FONT>
<P>
Linux este suficient de bine scris încît poate rula pe
calculatoare extrem de diferite; la ora aceasta el merge pe procesoare
80x86/Pentium (de la Intel), Sparc (SUN), Power PC (IBM), Alpha
(Digital, cumpãrat de curînd de Compaq), MIPS (acum la Silicon
Graphics), M68K (Motorola).  Noi ne vom referi la versiunea pentru
procesoare Intel, pentru cã este cea mai rãspînditã.  Principiile
care emerg sunt însã valabile pentru toate celelalte procesoare.

<P>

<H2><A NAME="SECTION00031000000000000000">
Arborele de directoare al sursei</A>
</H2>

<P>
Este instructiv sã aruncãm o scurtã privire asupra arborelui de
directoare care constituie sursele nucleului.  De obicei acesta este
instalat în directorul <TT>/usr/src/linux</TT> pe maºinile Linux.
În acest articol voi referi toate cãrãrile de directoare relativ 
la acest punct.

<P>
Subdirectoarele principale sunt:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Director</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>Conþine</TD>
<TD ALIGN="RIGHT">Linii de cod</TD>
</TR>
<TR><TD ALIGN="LEFT">fs</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>sisteme de fiºiere (File System)</TD>
<TD ALIGN="RIGHT">68 000</TD>
</TR>
<TR><TD ALIGN="LEFT">mm</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>memorie (Memory Management)</TD>
<TD ALIGN="RIGHT">17 000</TD>
</TR>
<TR><TD ALIGN="LEFT">init</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>procesul init (nr 1, care porneºte maºina)</TD>
<TD ALIGN="RIGHT">4000</TD>
</TR>
<TR><TD ALIGN="LEFT">kernel</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>funcþii esenþiale ale nucleului</TD>
<TD ALIGN="RIGHT">7200</TD>
</TR>
<TR><TD ALIGN="LEFT">lib</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>utilitare diverse</TD>
<TD ALIGN="RIGHT">1800</TD>
</TR>
<TR><TD ALIGN="LEFT">include</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>fiºiere header cu declaraþii pentru compilarea
           nucleului ºi programelor utilizatorilor</TD>
<TD ALIGN="RIGHT">78 000</TD>
</TR>
<TR><TD ALIGN="LEFT">net</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>protocoalele reþelelor de calculatoare</TD>
<TD ALIGN="RIGHT">56 000</TD>
</TR>
<TR><TD ALIGN="LEFT">ipc</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>mecanisme de comunicare între procese (Inter Process
           Communication)</TD>
<TD ALIGN="RIGHT">2500</TD>
</TR>
<TR><TD ALIGN="LEFT">drivers</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>programe care mînuiesc perifericele</TD>
<TD ALIGN="RIGHT">412 000</TD>
</TR>
<TR><TD ALIGN="LEFT">modules</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>nu conþine surse</TD>
<TD ALIGN="RIGHT">0</TD>
</TR>
<TR><TD ALIGN="LEFT">arch</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=283>cod dependent de procesor</TD>
<TD ALIGN="RIGHT">150 000<A NAME="footfnm3"
 HREF="#fnm3"><SUP>3</SUP></A></TD>
</TR>
</TABLE>
</DIV>

<P>
Dupã cum vedeþi mai mult de jumãtate de cod este în drivere.
Codul driverelor este însã pentru toate plãcile posibile; un anumit
sistem va avea compilate numai driverele pentru hardware-ul instalat.
Mulþimea aceasta de drivere se datoreºte popularitãþii enorme a
hardware-ului de PC, pentru care tot omul fabricã cîte o nouã
placã.

<P>
Douã cuvinte ºi despre unele din subdirectoarele acestor directoare:

<P>
<DL>
<DT><STRONG>fs/*</STRONG></DT> <DD>Linux suportã o mulþime de sisteme
de fiºiere (organizãri ale fiºierelor pe disc).  Lista lor este
include sistemul de fiºiere din MS-DOS, din Amiga ºi din OS/2,
sistemul de fiºiere de reþea (NFS, Network File System) de la Sun,
sistemul vfat al lui Windows NT, sistemele de fiºiere din Unix-ul
original, System V (sysv) ºi sistemul de fiºiere din Berkeley Unix,
UFS (numit ºi Fast File System, FFS, în literaturã), ºi altele!.
Intenþionez sã consacru un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#vfs">articol</a>
special arhitecturii sistemelor de fiºiere în nucleele Unix (douã
articole <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#sistem-f">(1)</a>
<a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#2fs">(2)</a>
înrudite despre aceastã temã au apãrut deja în PC Report), aºa cã nu
voi divaga în continuare.

<P>
</DD>
<DT><STRONG>include/*</STRONG></DT>
<DD>conþine headere cu declaraþiile structurilor de 
date ºi prototipurile funcþiilor publice din nucleu;

<P>
</DD>
<DT><STRONG>/drivers/net/*</STRONG></DT>
<DD>felurite plãci de reþea;

<P>
</DD>
<DT><STRONG>drivers/block/*</STRONG></DT>
<DD>toate perifericele tratate de Unix drept colecþii
de blocuri: discuri în special;

<P>
</DD>
<DT><STRONG>drivers/char/*</STRONG></DT>
<DD>majoritatea tuturor celorlalte periferice;

<P>
</DD>
<DT><STRONG>drivers/*</STRONG></DT>
<DD>alte periferice.
</DD>
</DL>

<P>

<H1><A NAME="SECTION00040000000000000000">
Un apel de sistem: <TT>getpid(2)</TT></A>
</H1>

<P>
Am ales pentru vivisecþia noastrã un apel
de sistem foarte simplu; poate cel mai simplu.  Cu toate acestea
periplul nostru pînã la el va fi destul de lung, sî, sperãm,
instructiv.  Vom discuta despre funcþia <TT>getpid</TT>, ``GET
Process IDentifier''.  Nucleul Unix asigneazã fiecãrui proces în
curs de execuþie un numãr unic între 0 ºi 30000 care poate fi
folosit pentru comunicarea între procese (semnalele se trimit
indicînd acest pid).  Pagina de manual Unix care descrie apelul de
sistem este în secþiunea 2 a manualului (unde sunt toate celelalte
apeluri de sistem); am indicat acest lucru în modul standard, punînd
secþiunea între paranteze.  Manualul poate fi citit tastînd comanda
<TT>man 2 getpid</TT>.  Pagina de manual ne spune ca <TT>getpid</TT>
nu are argumente ºi întoarce ca rezultat PID-ul procesului care face
apelul.  Iatã mai jos ºi un exemplu de folosire:

<P>
<PRE>
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
        int p = getpid();
        printf("Pid = %d\n", p);
}
</PRE>

<P>
Restul acestui articol va explora un singur lucru, ºi anume, cum se
executã prima linie a programului de mai sus.

<P>

<H2><A NAME="SECTION00041000000000000000">
Apelul funcþiei de bibliotecã</A>
</H2>

<P>
În primul rînd trebuie sã rãspundem la întrebarea: unde este
codul funcþiei <TT>getpid</TT>?  Cînd l-a scris ºi de unde-l ia
programul de mai sus.

<P>
Rãspunsul este: codul este în biblioteca de funcþii a limbajului C
care vine împreunã cu compilatorul de C ºi nucleul sistemului.
Fiecare apel de sistem are o astfel de funcþie asociatã în
bibliotecã.  Declaraþia funcþiei este în fiºierul header
<TT>/usr/include/unistd.h</TT>.  Funcþia a fost compilatã de cei
care au scris compilatorul ºi legatã în biblioteca de funcþii C
<TT>/lib/libc.a</TT>.  Corpul funcþiei a fost generat anterior din
urmãtoarea sursã C:

<P>
<PRE>
#include &lt;linux/unistd.h&gt;

_syscall0(int, getpid)
</PRE>

<P>

<H3><A NAME="SECTION00041100000000000000">
Un macro ciudat</A>
</H3>

<P>
Fiºierul <TT>include/linux/unistd.h</TT> conþine definiþia
macro-ului <TT>syscall0</TT>, care este folosit pentru a genera
funcþiile C care cheamã apeluri de sistem cu 0 argumente.  În
acelaºi fiºier existã ºi codul macrourilor <TT>syscall1</TT>, etc,
care genereazã corpul apelurilor de system cu mai multe argumente.

<P>
Iatã cum aratã cel care ne intereseazã:

<P>
<PRE>
#define _syscall0(type,name) \
type name(void) \
{ \
long __res; \
__asm__ volatile ("int $0x80" \
        : "=a" (__res) \
        : "0" (__NR_##name)); \
if (__res &gt;= 0) \
        return (type) __res; \
errno = -__res; \
return -1; \
}
</PRE>

<P>
Trebuie sã recunoaºteþi ca nu vedeþi prea des astfel de cod C, nu?
Codul foloseºte mai multe trãsãturi mai puþin cunoscute (dar
absolut standard) ale preprocesorului de C, plus cã amestecã
asamblare cu C (ceea ce în standardul C nu existã, dar Linux se
compileazã numai cu compilatorul gcc, aºa cã nu conteazã prea tare
ce zice standardul).

<P>
Ce e ciudat cu acest macro?

<P>

<UL>
<LI>Este un macro pe mai multe linii, scris folosind caracterul
<IMG
 WIDTH="15" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img1.png"
 ALT="$\backslash$"> inainte de sfîrºitul liniei pentru a indica o
continuare pe cea urmãtoare;
</LI>
<LI>Acest macro nu genereazã o <I>expresie</I> cînd este expandat,
ci corpul unei funcþii!
</LI>
<LI>Unul din argumente (<TT>type</TT>) apare în corpul macro-ului
într-o poziþie în care trebuie sã aparã un tip;
</LI>
<LI>Alt argument (<TT>name</TT>) apare în poziþia unde trebuie sã
aparã un nume de funcþie;
</LI>
<LI>Se foloseºte operatorul <TT>##</TT>, care concateneazã
simbolurile de la stînga ºi de la dreapta sa.
</LI>
</UL>

<P>
Sã vedem ce iese dupã pre-procesare din programul de o linie de mai
sus:

<P>
<PRE>
#include &lt;linux/unistd.h&gt;

_syscall0(int, getpid)
</PRE>

<P>
dã naºtere la (þinînd contul cã in acel header avem
definiþia: <TT>#define __NR_getpid 20</TT>, ceea ce înseamnã
cã numãrul apelului de sistem <TT>getpid</TT> este 20):

<P>
<PRE>
int getpid(void)
{
        long __res;
        __asm__ volatile ("int $0x80"
                : "=a" (__res)
                : "0" (20));
        if (__res &gt;= 0)
                return (int) __res;
        errno = -__res;
        return -1;
}
</PRE>

<P>
Asta se traduce cam aºa:

<P>
<BLOCKQUOTE>
Definesc funcþia <TT>getpid</TT> fãrã argumente care dã ca
rezultat un întreg.  Funcþia va executa întîi instrucþiunea
<TT>int 0x80</TT>, care genereazã o întrerupere, avînd în
registrul 0 numãrul <TT>__NR_getpid</TT>, adicã 20, iar la
sfîrºitul executãrii lui <TT>int 0x80</TT> rezultatul din registrul
A trebuie pus în variabila <TT>__res</TT> (aºa se traduce linia
care începe cu <TT>__asm__</TT>, care este scrisã într-un idiom
special al compilatorului gcc).
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Dupã aceea, dacã <TT>__res</TT> este pozitiv, acesta este
rezultatul funcþiei; altfel rezultatul este -1, iar valoarea lui
<TT>__res</TT> este pusã în variabila globalã a procesului,
<TT>errno</TT>.

</BLOCKQUOTE>

<P>
Deja am învãþat un lucru interesant despre apelurile de sistem
(dacã inspectaþi macrourile celelalte, pentru apeluri de sistem cu
mai multe argumente, veþi observa aceeaºi comportare): nucleul va
întoarce întotdeauna un numãr pozitiv ca rãspuns la un apel de
sistem.  O valoare negativã reprezintã codul unei erori.  Funcþia
de bibliotecã ia codul erorii ºi îl pune într-o variabilã
globalã a procesului, <TT>errno</TT>.  Rãspunsul unui apel de sistem
în caz de eroare este -1.  Valorile pe care le poate lua
<TT>errno</TT> sunt în fiºierul header standard <TT>errno.h</TT>;
studiaþi-l, cãci este interesant.  Variabila aceasta mai este
folositã de funcþii ca <TT>perror(3)</TT> sau <TT>strerror(3)</TT>
pentru a tipãri mesaje de eroare.

<P>

<H2><A NAME="SECTION00042000000000000000">
Întreruperea</A>
</H2>

<P>
Am vãzut deci cã pentru a invoca serviciile nucleului programele pun
un numãr care descrie serviciul cerut (<TT>getpid()</TT> în cazul
nostru) în registrul 0 (la 386 este registrul EAX), dupã care
executã o întrerupere software, cea cu numãrul 80 în hexazecimal
(128).

<P>
Ce mai e ºi cu întreruperea asta?

<P>
Dacã vã reamintiþi, am spus cã programele utilizatorului nu au
dreptul sã execute orice operaþii, pe cînd nucleul da.  Aceastã
segregare este realizatã de microprocesor printr-un bit intern de
stare, care indicã dacã programul curent se executã <I>în mod
nucleu (kernel mode)</I> (ºi atunci este privilegiat), sau în <I>mod
utilizator (user mode)</I><A NAME="tex2html3"
  HREF="#foot123"><SUP>4</SUP></A>.
Microprocesorul trece automat în mod nucleu atunci cînd se
întîmplã un eveniment excepþional, cum ar fi:

<P>

<UL>
<LI>Un periferic genereazã o întrerupere;
</LI>
<LI>Un program executã o instrucþiune ilegalã;
</LI>
<LI>Un program acceseazã zone de memorie interzise;
</LI>
<LI>Un program executã o întrerupere software;
</LI>
<LI>O eroare gravã este detectatã (ex: a cãzut curentul);
</LI>
<LI>etc.
</LI>
</UL>

<P>
Trecerea în mod nucleu înseamnã nu doar o schimbare a valorii
bitului care indicã modul, ci ºi <I>un salt</I> la o adresã
dinainte stabilitã.  Raþionamentul este urmãtorul: cel care scrie
sistemul de operare scrie pentru fiecare din cazurile de mai sus un
program (handler) care ia acþiunile corespunzãtoare pentru a remedia
evenimentul excepþional.  Aceste programe sunt instalate apoi în
memorie la început (în procesul de boot-are al calculatorului), iar
apoi avem garanþia cã utilizatorul nu poate face nici o stricãciune
(intenþionatã sau nu), pentru cã orice acþiune excepþionalã va
transfera controlul la unul dintre aceste programe scrise dinainte ºi
în care avem mare încredere.

<P>
Pentru a fi ºi mai preciºi: fiecare eveniment excepþional are la
nivelul microprocesorului un numãr asociat.  Instalarea handler-elor
pentru excepþii constã în construirea unui vector de adrese de
proceduri, care indicã pentru fiecare excepþie ce procedurã trebuie
s-o trateze, cam aºa<A NAME="tex2html4"
  HREF="#foot127"><SUP>5</SUP></A>:

<P>
<PRE>
codul exceptiei
  |
  |
  |      ---------
  |     0|       |-------&gt;procedura pentru tratarea impartirii la 0
  |      ---------
  \----&gt;1|       |-------&gt;procedura pentru depanare
         ---------
         .........
         ---------
      128|       |-------&gt;procedura pentru tratarea unui apel de sistem
         ---------

         vector de
         exceptii
</PRE>

<P>
Vectorul de excepþii este construit imediat dupã pornirea
sistemului; funcþia rãspunzãtoare de acest lucru este în fiºierul
<TT>arch/i386/kernel/traps.c</TT>, ºi este numitã
<TT>trap_init()</TT>.  Codul esenþial aratã cam aºa:

<P>
<PRE>
void trap_init(void)
{
	.....
        set_trap_gate(0,&amp;divide_error);
        set_trap_gate(1,&amp;debug);
        set_trap_gate(2,&amp;nmi);
        set_system_gate(3,&amp;int3);       /* int3-5 can be called from all */
        set_system_gate(4,&amp;overflow);
        set_system_gate(5,&amp;bounds);
        set_trap_gate(6,&amp;invalid_op);
        set_trap_gate(7,&amp;device_not_available);
        set_trap_gate(8,&amp;double_fault);
        set_trap_gate(9,&amp;coprocessor_segment_overrun);
        set_trap_gate(10,&amp;invalid_TSS);
        set_trap_gate(11,&amp;segment_not_present);
        set_trap_gate(12,&amp;stack_segment);
        set_trap_gate(13,&amp;general_protection);
        set_trap_gate(14,&amp;page_fault);
        set_trap_gate(15,&amp;spurious_interrupt_bug);
        set_trap_gate(16,&amp;coprocessor_error);
        set_trap_gate(17,&amp;alignment_check);
        for (i=18;i&lt;48;i++)
                set_trap_gate(i,&amp;reserved);
        set_system_gate(0x80,&amp;system_call);
	.....
}
</PRE>

<P>
Asta e relativ simplu de ghicit ce înseamnã: excepþia nr 0, care se
declanºeazã cînd se împarte la 0, va fi tratatã de funcþia
<TT>divide_error</TT>, care este undeva prin nucleu, excepþia 1 de
funcþia <TT>debug</TT>, etc.

<P>
Cît despre codul macro-ului <TT>set_trap_gate()</TT>, îl puteþi
gãsi în fiºierul <TT>include/asm-i386/system.h</TT>.  Codul este
încîlcit pentru cã procesoarele x86 nu conþin în cãsuþa din
vectorul de excepþii doar adresa unei proceduri, ci ºi o mulþime de
alte informaþii, legate de privilegiile pe care le are un program în
timp ce executã excepþia, de tipul excepþiei (excepþie,
întrerupere), etc.  Studiul detaliat al tabelei ne-ar îndepãrta de
la scopul nostru, ºi anume de a vedea cum se executã un apel de
sistem.  Important este de reþinut:

<P>

<OL>
<LI>Dupã executarea întreruperii software execuþia sare la o
procedurã specificatã de vectorul de excepþii
(<TT>system_call</TT> pentru exemplu nostru concret);
</LI>
<LI>Microprocesorul intrã în mod nucleu;
</LI>
<LI>Microprocesorul schimbã stiva curentã la cea indicatã de noul
privilegiu.
</LI>
</OL>

<P>

<H3><A NAME="SECTION00042100000000000000">
Stiva</A>
</H3>

<P>
Acest ultim punct meritã o clarificare.

<P>
Cum se executã procedurile?  Folosind o stivã pentru a-ºi pãstra
variabilele locale; cînd o procedurã o cheamã pe alta se contruieºte
un nou <I>cadru de stivã</I> (stack frame) pentru procedura nouã, în
care aceasta-ºi þine variabilele personale, argumentele ºi alte
lucruºoare.  (Pe îndelete despre rolul stivei am scris în PC Report
din ianuarie 1997, în articolul ``<a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#threads">Multithreading</a>''.)

<P>
Nucleul însuºi este practic o colecþie de proceduri, care deci au
nevoie de o stivã pentru a se putea executa.  Dar de unde s-o ia pe
aceasta?  Nucleul nu poate folosi stiva pe care o foloseºte procesul
în mod obiºnuit, pentru cã nu poate avea încredere în proces.
Diferenþa este cã dacã procesul manipuleazã stiva într-un mod
eronat, nu poate face rãu decît sieºi, datoritã faptului cã
mecanismele de memorie virtualã împiedicã un proces sã acceseze
memoria alocatã altor procese.  Cu nucleul lucrurile nu mai stau
aºa: privilegiile lui ridicate i-ar putea permite sã scrie oriunde,
ºtergînd orice.

<P>
Din cauza aceasta, la procesoarele x86, o schimbare de privilegiu a
procesorului implicã <I>automat</I> o schimbare de stivã.  Cum se
face asta?  Fiecare proces are o tabelã cu pointeri cãtre stive,
cîte una pentru fiecare nivel de privilegiu.  Acest lucru poate fi
vãzut în fiºierul <TT>include/asm-i386/processor.h</TT>, unde cele
4 stive, corespunzînd celor 4 nivele de privilegiu ale familiei x86,
sunt indicate în structura numitã TSS (Task Segment Selector,
terminologie Intel):

<P>
<PRE>
struct thread_struct {
        unsigned short  back_link,__blh;
        unsigned long   esp0;                 \
        unsigned short  ss0,__ss0h;           |
        unsigned long   esp1;                 | 3 stive
        unsigned short  ss1,__ss1h;           |
        unsigned long   esp2;                 |
        unsigned short  ss2,__ss2h;           /
        unsigned long   cr3;
        unsigned long   eip;
        unsigned long   eflags;
        unsigned long   eax,ecx,edx,ebx;
        unsigned long   esp;                  | virful stivei curente
        unsigned long   ebp;
        unsigned long   esi;
        unsigned long   edi;
        unsigned short  es, __esh;            | segmentul stivei curente
        unsigned short  cs, __csh;
        unsigned short  ss, __ssh;
        unsigned short  ds, __dsh;
        unsigned short  fs, __fsh;
        unsigned short  gs, __gsh;
        unsigned short  ldt, __ldth;
        unsigned short  trace, bitmap;
        unsigned long   io_bitmap[IO_BITMAP_SIZE+1];
        unsigned long   tr;
        unsigned long   cr2, trap_no, error_code;
/* floating point info */
        union i387_union i387;
/* virtual 86 mode info */
        struct vm86_struct * vm86_info;
        unsigned long screen_bitmap;
        unsigned long v86flags, v86mask, v86mode;
}
</PRE>

<P>
Cînd nucleul creazã un proces îi alocã douã stive: una pentru
modul utilizator ºi una pentru modul nucleu.  (Celelalte douã stive
nu sunt niciodatã folosite de Linux).  Cînd microprocesorul îºi
schimbã privilegiul îºi schimbã automat ºi stiva curentã.

<P>
Stiva nucleului în general este micã (4K), pentru cã nucleul este o
bucatã fixã de cod, care nu conþine apeluri recursive de funcþii,
deci consumã relativ puþinã stivã.

<P>
Deci funcþia <TT>sys_call</TT>, chematã indirect prin întrerupere,
ºi toate funcþiile chemate de ea, se vor executa pe stiva procesului
curent care corespunde modului nucleu.

<P>

<H2><A NAME="SECTION00043000000000000000">
Poarta de intrare în nucleu</A>
</H2>

<P>
Sã vedem ce se întîmplã mai departe.  Codul funcþiei
<TT>system_call</TT> este (din pãcate) scris în asamblare.  Se
gãseºte în fiºierul <TT>arch/i386/kernel/entry.S</TT>, ºi
foloseºte din plin macro-uri foarte simple definite în alte pãrþi
(cele mai interesante în <TT>include/asm-i386/linkage.h</TT>), (cum
ar fi <TT>ENTRY</TT>, <TT>SYMBOL_NAME</TT>, <TT>SAVE_ALL</TT>,
etc.).  Zic ``din pãcate'', pentru cã dialectul de asamblare al
compilatorului gcc nu este acelaºi sintactic cu cel al firmei Intel,
aºa cã acelaºi program se scrie în feluri diferite folosind cele
douã limbaje.  Mã rog, nu o sã ne împiedicãm noi de atîta lucru;
sã încercãm sã ne facem o idee despre ce se întîmpla în codul
urmãtor:

<P>
<PRE>
ENTRY(system_call)
        pushl %eax                      # save orig_eax
        SAVE_ALL
#ifdef __SMP__
        ENTER_KERNEL
#endif
        movl $-ENOSYS,EAX(%esp)
        cmpl $(NR_syscalls),%eax
        jae ret_from_sys_call
        movl SYMBOL_NAME(sys_call_table)(,%eax,4),%eax
        testl %eax,%eax
        je ret_from_sys_call
#ifdef __SMP__
        GET_PROCESSOR_OFFSET(%edx)
        movl SYMBOL_NAME(current_set)(,%edx),%ebx
#else
        movl SYMBOL_NAME(current_set),%ebx
#endif
        andl $~CF_MASK,EFLAGS(%esp)     # clear carry - assume no errors
        movl %db6,%edx
        movl %edx,dbgreg6(%ebx)  # save current hardware debugging status
        testb $0x20,flags(%ebx)         # PF_TRACESYS
        jne 1f
        call *%eax
        movl %eax,EAX(%esp)             # save the return value
        jmp ret_from_sys_call
</PRE>

<P>
Paºii mari sunt urmãtorii:

<P>

<UL>
<LI>Se salveazã registrul AX, care conþine codul apelului de
sistem;
</LI>
<LI>Se salveazã toþi regiºtrii (care au valorile pe care le aveau
cînd s-a executat întreruperea 0x80);
</LI>
<LI>Dacã calculatorul este un calculator cu mai multe procesoare se
executã un cod special pentru sincronizarea nucleelor de pe
diferitele procesoare<A NAME="tex2html5"
  HREF="#foot158"><SUP>6</SUP></A>.
</LI>
<LI>Numãrul apelului de sistem este comparat cu numãrul total de
apeluri existente (<TT>NR_syscalls</TT>, un macro definit în
<TT>include/asm-i386/unistd.h</TT>).
</LI>
<LI>Dacã numãrul este înafara limitelor atunci nucleul se
întoarce imediat la utilizator (prin salt la
<TT>ret_from_sys_call</TT>) cu eroarea <TT>ENOSYS</TT> (``nu avem
un astfel de apel de sistem'');
</LI>
<LI>Nucleul indexeazã cu codul apelului într-o tabelã care
conþine adresele tuturor funcþiilor care trateazã apeluri de sistem
(tabela numitã <TT>sys_call_table</TT> este discutatã în
secþiunea urmãtoare); adresa funcþiei de tratare este pusã în
registrul EAX;
</LI>
<LI>Dacã o înregistrarea din tabelã este 0, funcþia respectivã
nu existã, deci din nou ne întoarcem la utilizator cu eroare;
</LI>
<LI>Se fac felurite procesãri legate de multiprocesoare ºi
eventuala depanare a procesului curent; le ignorãm;
</LI>
<LI>Instrucþiunea principalã este <TT>call *%eax</TT>, adic'a
salt la adresa din registrul EAX.  Aceastã instrucþiune executã
funcþia corespunzãtoare apelului de sistem; rezultatul acestei
funcþii este întors prin convenþie tot în registrul EAX.
</LI>
<LI>Rezultatul din registrul EAX este pus pe stivã;
</LI>
<LI>Se sare la eticheta <TT>ret_from_sys_call</TT>, discutatã
mai jos.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00044000000000000000">
Tabela de dispecerizare</A>
</H2>

<P>
Am vãzut cã funcþia de bibliotecã a pus în registrul EAX un cod
de apel de sistem, cã întreruperea a comutat privilegiul ºi stiva,
iar apoi cã în nucleu s-a indexat într-o tabelã mare cu codul din
EAX.  Aceastã tabelã este construitã tot în fiºierul
<TT>arch/i386/kernel/entry.S</TT>, ºi aratã cam aºa:

<P>
<PRE>
.data
ENTRY(sys_call_table)
        .long SYMBOL_NAME(sys_setup)            /* 0 */
        .long SYMBOL_NAME(sys_exit)
        .long SYMBOL_NAME(sys_fork)
        .long SYMBOL_NAME(sys_read)
        .long SYMBOL_NAME(sys_write)
        .long SYMBOL_NAME(sys_open)             /* 5 */
        .........................
        .long SYMBOL_NAME(sys_getpid)           /* 20 */
        .........................
        .space (NR_syscalls-165)*4              /* neimplementate */
</PRE>

<P>
Dupã cum vedeþi în cãsuþa 20 a tabelei se gãseºte adresa unei
funcþii, numitã <TT>sys_getpid</TT>.  Aceastã funcþie va fi deci
executatã atunci cînd codul apelului de sistem este 20.

<P>

<H2><A NAME="SECTION00045000000000000000">
Funcþia <TT>sys_getpid()</TT></A>
</H2>

<P>
Am ajuns în fine la funcþia din nucleu care face procesarea
corespunzãtoare.  Codul ei este în fiºierul
<TT>kernel/sched.c</TT>, ºi este banal; îl reproducem în
întregime:

<P>
<PRE>
asmlinkage int sys_getpid(void)
{
        return current-&gt;pid;
}
</PRE>

<P>
Prin convenþie compilatorul gcc pune rezultatul unei funcþii C în
registrul EAX; din aceastã cauzã valoarea întoarsã de aceastã
funcþie poate fi consumatã de codul de mai sus.

<P>
Dar cine este <TT>current</TT>?  Este nimeni altul decît ``procesul''
curent.  Cum vine asta?

<P>

<H3><A NAME="SECTION00045100000000000000">
Structura Task</A>
</H3>

<P>
Pentru a rãspunde la aceastã întrebare trebuie sã aflãm ce este
un proces pentru nucleu.  Ei bine, pentru nucleu un proces este nimic
altceva decît o structurã de date.  Putem vedea aceastã structurã
de date în fiºierul <TT>include/linux/sched.h</TT>; unul dintre
cîmpurile ei este structura TSS de care am vorbit mai sus.  Ea aratã
cam aºa:

<P>
<PRE>
struct task_struct {
/* these are hardcoded - don't touch */
        volatile long state;    /* -1 unrunnable, 0 runnable, &gt;0 stopped */
        long counter;
        long priority;
        unsigned long signal;
        unsigned long blocked;  /* bitmap of masked signals */
        unsigned long flags;    /* per process flags, defined below */
        int errno;
        long debugreg[8];  /* Hardware debugging registers */
        struct exec_domain *exec_domain;
/* various fields */
        struct linux_binfmt *binfmt;
        struct task_struct *next_task, *prev_task;
        struct task_struct *next_run,  *prev_run;
        unsigned long saved_kernel_stack;
        unsigned long kernel_stack_page;
        int exit_code, exit_signal;
        /* ??? */
        unsigned long personality;
        int dumpable:1;
        int did_exec:1;
        /* shouldn't this be pid_t? */
        int pid;
        int pgrp;
        int tty_old_pgrp;
        int session;
        /* boolean value for session group leader */
        int leader;
        int     groups[NGROUPS];
        /* 
         * pointers to (original) parent process, youngest child, younger sibling,
         * older sibling, respectively.  (p-&gt;father can be replaced with 
         * p-&gt;p_pptr-&gt;pid)
         */
        struct task_struct *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr;
        struct wait_queue *wait_chldexit;       /* for wait4() */
        unsigned short uid,euid,suid,fsuid;
        unsigned short gid,egid,sgid,fsgid;
        unsigned long timeout, policy, rt_priority;
        unsigned long it_real_value, it_prof_value, it_virt_value;
        unsigned long it_real_incr, it_prof_incr, it_virt_incr;
        struct timer_list real_timer;
        long utime, stime, cutime, cstime, start_time;
/* mm fault and swap info: this can arguably be seen as either
	mm-specific or thread-specific */ 
        unsigned long min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;
        int swappable:1;
        unsigned long swap_address;
        unsigned long old_maj_flt;      /* old value of maj_flt */
        unsigned long dec_flt;          /* page fault count of the last time */
        unsigned long swap_cnt;         /* number of pages to swap on next pass */
/* limits */
        struct rlimit rlim[RLIM_NLIMITS];
        unsigned short used_math;
        char comm[16];
/* file system info */
        int link_count;
        struct tty_struct *tty; /* NULL if no tty */
/* ipc stuff */
        struct sem_undo *semundo;
        struct sem_queue *semsleeping;
/* ldt for this task - used by Wine.  If NULL, default_ldt is used */
        struct desc_struct *ldt;
/* tss for this task */
        struct thread_struct tss;
/* filesystem information */
        struct fs_struct *fs;
/* open file information */
        struct files_struct *files;
/* memory management info */
        struct mm_struct *mm;
/* signal handlers */
        struct signal_struct *sig;
#ifdef __SMP__
        int processor;
        int last_processor;
        int lock_depth;         /* Lock depth. We can context switch
			in and out of holding a syscall kernel lock... */  
}
#endif
</PRE>

<P>
Nucleul manipuleazã în principiu douã mari clase de structuri de
date:

<P>

<UL>
<LI>Structuri de date private care aparþin unui singur proces; de
exemplu pid-ul, prioritatea, pointeri spre fiºierele deschise, etc.
</LI>
<LI>Structuri de date <I>globale</I> întregului sistem: fiºiere,
memorie, procesoare, etc.
</LI>
</UL>

<P>
Practic tot ce este per-proces este þinut într-un array mare de
structuri de tipul <TT>struct task_struct</TT>.  Un array de pointeri
spre aceste structuri este declarat în fiºierul
<TT>kernel/sched.c</TT>:

<P>
<PRE>
struct task_struct * task[NR_TASKS] = {&amp;init_task, };
</PRE>

<P>
<TT>current</TT> este un macro definit în
<TT>include/linux/sched.h</TT> spre un <TT>task_struct</TT>, care
puncteazã spre procesul care tocmai se executã pe procesorul curent.
Planificatorul (scheduler) are grijã ca de fiecare datã cînd
comutã de la procesul curent la un altul sã schimbe valoarea acestui
pointer.

<P>

<H2><A NAME="SECTION00046000000000000000">
Întoarcerea</A>
</H2>

<P>
Gata, am ajuns pînã în ``centrul nucleului''.  Acum trebuie sã
ieºim la suprafaþã, cu valoarea calculatã.  Credeþi cã nu poate
fi decît mai simplu?  Ehe, vã înºelaþi.

<P>
Reluãm periplul din fiºierul <TT>arch/i386/kernel/entry.S</TT>; acum
trebuie sã vedem cum se executã funcþia
<TT>ret_from_sys_call</TT>, a cãrei misiune este sã pãrãseascã
modul privilegiat.  Codul este mai complicat decît ne aºteptãm
pentru cã aceastã funcþie nu este chematã numai la sfîrºitul
unui apel de sistem, ci ºi la sfîrºitul unei întreruperi hardware.
Problema este cã întreruperile hardware pot surveni oricînd, chiar
ºi atunci cînd se executã deja un apel de sistem sau o altã
întrerupere hardware.  Din cauza asta nucleul trebuie întîi sã
verifice dacã trebuie sã se întoarcã la modul utilizator sau
trebuie sã rãmînã în mod nucleu; acþiunile sunt diferite în
cele douã cazuri.

<P>
<PRE>
        ALIGN
        .globl ret_from_sys_call
ret_from_sys_call:
        cmpl $0,SYMBOL_NAME(intr_count)
        jne 2f
9:      movl SYMBOL_NAME(bh_mask),%eax
        andl SYMBOL_NAME(bh_active),%eax
        jne handle_bottom_half
        movl EFLAGS(%esp),%eax          # check VM86 flag: CS/SS are
        testl $(VM_MASK),%eax           # different then
        jne 1f
        cmpw $(KERNEL_CS),CS(%esp)      # was old code segment supervisor ?
        je 2f
1:      sti
        orl $(IF_MASK),%eax             # these just try to make sure
        andl $~NT_MASK,%eax             # the program doesn't do anything
        movl %eax,EFLAGS(%esp)          # stupid
        cmpl $0,SYMBOL_NAME(need_resched)
        jne reschedule
#ifdef __SMP__
        GET_PROCESSOR_OFFSET(%eax)
        movl SYMBOL_NAME(current_set)(,%eax), %eax
#else
        movl SYMBOL_NAME(current_set),%eax
#endif
        cmpl SYMBOL_NAME(task),%eax     # task[0] cannot have signals
        je 2f
        movl blocked(%eax),%ecx
        movl %ecx,%ebx                  # save blocked in %ebx for signal handling
        notl %ecx
        andl signal(%eax),%ecx
        jne signal_return
2:      RESTORE_ALL
</PRE>

<P>
Pînã la eticheta ``1:'' în programul de mai sus asta se petrece:
bazîndu-se pe felurite numere, cum ar fi numãrul de întreruperi în
curs de tratare sau numãrul de drivere active în ``partea de jos''
(bh: bottom half), sau în funcþie de poziþia segmentului de stivã
al apelantului se poate deduce din ce loc a fost chemat codul curent.
Deºi este deosebit de instructiv de urmat calea în fiecare din
aceste cazuri, noi o sã pretindem încãpãþînaþi cã tocmai de
întoarcem în spaþiul utilizator.

<P>
Variabila <TT>need_reschedule</TT> este nenulã în cazul în care
în timpul execuþiei procesului curent în nucleu s-au petrecut
evenimente care cer întreruperea procesului curent ºi comutarea la
un altul.  Hai sã zicem cã nu s-a întîmplat nimic de acest gen, ca
sã vedem cum ne întoarcem în spaþiul utilizator.

<P>
Dar înainte de acest pas se petrece un alt lucru foarte important: se
verificã dacã procesul curent are semnale de primit.

<P>

<H2><A NAME="SECTION00047000000000000000">
Livrarea semnalelor</A>
</H2>

<P>
Semnalele sunt o metodã simplistã de comunicaþie inter-proces în
Unix.  Un semnal este un eveniment identificat printr-un nume ºi
printr-un numãr asociat.  Un proces poate trimite semnale altui
proces folosind apelul de sistem <TT>kill(2)</TT>, cu care indicã
PID-ul ºi numãrul semnalului.  Semnalele pot fi trimise spontan de
nucleu în anumite circumstanþe.

<P>
Un proces poate reacþiona la un semnal în mai multe feluri, ºi
poate controla într-o oarecare mãsurã livrarea semnalelor folosind
o serie de funcþii de bibliotecã ºi apeluri de sistem
(<TT>signal, sigsuspend, sigpending, sigaction</TT>, etc.).  Am vãzut
nu demult în PC Report un articol amplu consacrat semnalelor, aºa ca
nu voi discuta despre ce fac.

<P>
Ce înseamnã cã nucleul ``transmite un semnal''?  Fiecare proces are
un array de biþi, cîte unul pentru fiecare semnal.  Cînd un proces
primeºte un semnal nucleul nu face altceva decît sã punã bitul
corespunzãtor pe 1 ºi sã continue.  Adevãrata livrare a semnalului
se va face mai tîrziu, cînd procesul destinatar se executã.

<P>
Din timp în timp un proces verificã dacã nu i-au fost trimise
semnale.  De obicei face asta înainte de a se bloca în aºteptarea
unei activitãþi care dureazã mult timp, ºi întotdeauna verificã
dacã nu are semnale în momentul cînd terminã executarea unui apel
de sistem.

<P>
Aici am ajuns ºi noi cu explicaþiile; codul cu pricina este în
fiºierul <TT>arch/i386/kernel/entry.S</TT>:

<P>
<PRE>
signal_return:
        movl %esp,%ecx
        pushl %ecx
        testl $(VM_MASK),EFLAGS(%ecx)
        jne v86_signal_return
        pushl %ebx
        call SYMBOL_NAME(do_signal)
        popl %ebx
        popl %ebx
        RESTORE_ALL
</PRE>

<P>
Aici nu se întîmplã mare lucru; se cheamã doar funcþia
<TT>do_signal</TT> cu felurite argumente pe stivã.  Aceastã
funcþie se ocupã de tot ce trebuie, livrînd unul cîte unul toate
semnalele acumulate între timp.  Aceste semnale ar putea avea drept
efect omorîrea procesului curent, ºi atunci funcþia
<TT>do_signal</TT> nu se mai întoarce niciodatã.

<P>

<H2><A NAME="SECTION00048000000000000000">
Sfîrºitul întreruperii</A>
</H2>

<P>
Presupunînd cã <TT>do_signal()</TT> se întoarce, execuþia în mod
nucleu se terminã cu codul lui <TT>RESTORE_ALL</TT>, care extrage
regiºtrii salvaþi pe stivã atunci cînd s-a început execuþia în
mod nucleu.  Codul este tot în fiºierul
<TT>arch/i386/kernel/entry.S</TT>.

<P>
<PRE>
#define RESTORE_ALL \
        cmpw $(KERNEL_CS),CS(%esp); \
        je 1f;   \
        GET_PROCESSOR_OFFSET(%edx) \
        movl SYMBOL_NAME(current_set)(,%edx), %eax ; ; \
        movl dbgreg7(%eax),%ebx; \
        movl %ebx,%db7; \
1:      LEAVE_KERNEL \
        popl %ebx; \
        popl %ecx; \
        popl %edx; \
        popl %esi; \
        popl %edi; \
        popl %ebp; \
        popl %eax; \
        pop %ds; \
        pop %es; \
        pop %fs; \
        pop %gs; \
        addl $4,%esp; \
        iret
</PRE>

<P>
Cea mai importantã instrucþiune aici este ultima, <TT>iret</TT>.
Asta înseamnã ``Interrupt RETurn'', adicã ``întoarcere din
întrerupere''.

<P>
Aceastã instrucþiune face exact opusul unei înteruperi, ºi anume
descreºte privilegiul, comutã stivele ºi se întoarce la programul
întrerupt.

<P>

<H2><A NAME="SECTION00049000000000000000">
Terminarea funcþiei de bibliotecã</A>
</H2>

<P>
Iatã cum periplul nostru prin nucleu s-a terminat.  Ne-am întors
înapoi în corpul funcþiei de bibliotecã <TT>getpid()</TT>, avînd
în registrul EAX valoarea PID-ului pentru procesul curent.  Funcþia
aceasta vede dacã valoarea este negativã (nu ar avea nici un motiv
sã fie în cazul nostru), seteazã <TT>errno</TT> dupã cum am
descris mai sus ºi se întoarce la programul apelant.

<P>

<H1><A NAME="SECTION00050000000000000000">
Rezumat</A>
</H1>

<P>
Am încãlecat pe program counter ºi am strãbãtut împreunã un
periplu în grotele mai superficiale ale nucleului (alte apeluri de
sistem au coduri infinit mai complexe, cu multe regiuni critice ºi cu
probleme grele de re-entranþã).

<P>
Sã revedem etapele strãbãtute:

<P>

<OL>
<LI>Utilizatorul cheamã o funcþie de bibliotecã
(<TT>getpid(2)</TT>);
</LI>
<LI>Funcþia de bibliotecã împacheteazã numãrul apelului (20)
într-un registru ºi eventualele argumente în alþi regiºtri;
</LI>
<LI>Funcþia de bibliotecã genereazã o întrerupere software
(0x80);
</LI>
<LI>Automat întreruperea comutã în mod nucleu, schimbã stivele
ºi sare la o procedurã de intercepþie (handler);
</LI>
<LI>Procedura de intercepþie extrage numãrul apelului ºi
indexeazã într-o tabelã de apeluri de sistem;
</LI>
<LI>Se sare la funcþia care executã cu adevãrat apelul
(<TT>sys_getpid()</TT>); folosind structurile de date ale nucleului
funcþia calculeazã rãspunsul;
</LI>
<LI>Codul de întoarcere verificã dacã sunt semnale de livrat
procesului curent; dacã da, acestea sunt procesate înainte de
întoarcerea în mod utilizator;
</LI>
<LI>Se executã o instrucþiune RETI care terminã o întrerupere,
restaureazã privilegiile scãzute ºi comutã stivele înapoi;
</LI>
<LI>Funcþia de bibliotecã despacheteazã rãspunsul ºi dacã este
necesar seteazã variabila <TT>errno</TT> la eroarea survenitã;
</LI>
<LI>Funcþia de bibliotecã întoarce rezultatul primit de la
nucleu.  Execuþia apelului de sistem s-a terminat.
</LI>
</OL>

<P>
Cum vi s-a pãrut?

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot54">... nucleu</A><A NAME="foot54"
 HREF="linux-html.html#tex2html1"><SUP>1</SUP></A>
<DD>Ideea
aceasta este binecunoscutã în ingineria programãrii sub numele de
``tipuri de date abstracte''.  Lãsãm cititorului sarcina explorãrii
similitudinii.

<DT><A NAME="foot62">... Unix</A><A NAME="foot62"
 HREF="linux-html.html#tex2html2"><SUP>2</SUP></A>
<DD>O scurtã istorie a evoluþiei
Unix-ului, publicatã mai demult în BYTE România, puteþi obþine din
pagina de web a autorului.

<DT><A NAME="footfnm3">... 000<SUP>3</SUP></A>
<DD>

<DT><A NAME="foot123">... mode)</A><A NAME="foot123"
 HREF="linux-html.html#tex2html3"><SUP>4</SUP></A>
<DD>De fapt familia x86 are nu 2 ci 4
moduri de privilegiu, dar Linux foloseºte numai 2 dintre ele.

<DT><A NAME="foot127">... sa</A><A NAME="foot127"
 HREF="linux-html.html#tex2html4"><SUP>5</SUP></A>
<DD>Procesoarele Intel disting mai multe
tipuri de evenimente excepþionale, clasificînd separat
întreruperile generate de hardware, erorile de execuþie, etc.
Diferitele tipuri funcþioneazã însã la fel, doar cã fiecare tip
are alt vector de excepþii.

<DT><A NAME="foot158">... procesoare</A><A NAME="foot158"
 HREF="linux-html.html#tex2html5"><SUP>6</SUP></A>
<DD>SMP înseamnã Symmetric Multi
Processing, ºi este o tehnicã în care pe un calculator cu mai multe
procesoare fiecare procesor executã cod atît de proces utilizator
cît ºi de nucleu.  Scrierea de cod pentru multiprocesoare simetrice
este mult mai grea decît scrierea de cod re-entrant, din motive pe
care nu avem timp sã le explorãm acum, dar asupra cãrora sperãm
sã revenim altãdatã.  Oricum, Linux aici ``triºeazã'' un pic,
nepremiþînd unui procesor sã execute cod nucleu dacã un alt
procesor executã deja cod nucleu pentru un alt proces.

</DL>
<BR><HR>

</BODY>
</HTML>
