<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Mãsurãtori</TITLE>
<META NAME="description" CONTENT="Mãsurãtori">
<META NAME="keywords" CONTENT="masuri-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Mãsurãtori</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>16 septembrie 1998</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Mãsurãtori de performanþã
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>Noþiuni elementare de sisteme de
operare, programare în C, noþiuni elementare despre limbaje de
asamblare
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>timp, cicli pe instrucþiune, cache
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION01000000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><UL>
<LI><UL>
<LI><A NAME="tex2html35"
  HREF="masuri-html.html">Introducere: mãsurãtori de performanþã</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html36"
  HREF="#SECTION02000000000000000000">Mãsurãtori directe</A>
<UL>
<LI><A NAME="tex2html37"
  HREF="#SECTION02010000000000000000">O procedurã pentru mãsurarea timpului în Unix</A>
<UL>
<LI><A NAME="tex2html38"
  HREF="#SECTION02011000000000000000">Funcþiile <TT>setitimer</TT> ºi <TT>getitimer</TT></A>
<LI><A NAME="tex2html39"
  HREF="#SECTION02012000000000000000">Timp real ºi timp virtual</A>
<LI><A NAME="tex2html40"
  HREF="#SECTION02013000000000000000">Mãsurarea timpului</A>
<LI><A NAME="tex2html41"
  HREF="#SECTION02014000000000000000">Mãsurarea rezoluþiei ceasului</A>
<LI><A NAME="tex2html42"
  HREF="#SECTION02015000000000000000">Mãsurarea unor evenimente foarte scurte</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION02016000000000000000">Surse de eroare</A>
</UL>
<LI><A NAME="tex2html44"
  HREF="#SECTION02020000000000000000">Mãsurãtori de performanþã</A>
<UL>
<LI><A NAME="tex2html45"
  HREF="#SECTION02021000000000000000">Frecvenþa ceasului procesorului</A>
<LI><A NAME="tex2html46"
  HREF="#SECTION02022000000000000000">Costul unui apel de procedurã</A>
<LI><A NAME="tex2html47"
  HREF="#SECTION02023000000000000000">Durata unui apel de sistem simplu</A>
<LI><A NAME="tex2html48"
  HREF="#SECTION02024000000000000000">Durata comutãrii de procese</A>
</UL>
<LI><A NAME="tex2html49"
  HREF="#SECTION02030000000000000000">Încheiere temporarã</A>
</UL>
<BR>
<LI><A NAME="tex2html50"
  HREF="#SECTION03000000000000000000">Mãsurãtori indirecte</A>
<UL>
<LI><A NAME="tex2html51"
  HREF="#SECTION03010000000000000000">Mãsurarea parametrilor cache-urilor microprocesorului</A>
<UL>
<LI><A NAME="tex2html52"
  HREF="#SECTION03011000000000000000">O digresiune</A>
<LI><A NAME="tex2html53"
  HREF="#SECTION03012000000000000000">Cache-uri: o recapitulare sumarã</A>
<LI><A NAME="tex2html54"
  HREF="#SECTION03013000000000000000">Dimensiunea cache-ului</A>
<LI><A NAME="tex2html55"
  HREF="#SECTION03014000000000000000"><EM>Write back</EM> sau <EM>write through</EM>?</A>
<LI><A NAME="tex2html56"
  HREF="#SECTION03015000000000000000"><EM>Write allocate on write miss</EM>?</A>
<LI><A NAME="tex2html57"
  HREF="#SECTION03016000000000000000">I-cache ºi D-cache</A>
<LI><A NAME="tex2html58"
  HREF="#SECTION03017000000000000000">Asociativitatea cache-ului</A>
<LI><A NAME="tex2html59"
  HREF="#SECTION03018000000000000000">Cache-ul victimã</A>
<LI><A NAME="tex2html60"
  HREF="#SECTION03019000000000000000">Mãrimea liniei din cache</A>
<LI><A NAME="tex2html61"
  HREF="#SECTION030110000000000000000">Cache-uri blocante</A>
</UL>
<LI><A NAME="tex2html62"
  HREF="#SECTION03020000000000000000">Concluzii</A>
<LI><A NAME="tex2html63"
  HREF="#SECTION03030000000000000000">Derivarea duratei de execuþie</A>
</UL></UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Acest articol va construi un mic set de rutine pentru a mãsura durata
execuþiei unor bucãþele de program dupã care va folosi aceste
rutine pentru a estima tot felul de parametri arhitecturali.  Am spart
articolul în douã bucãþi: în prima voi discuta despre
mãsurãtori în general; apoi voi construi infrastructura necesarã
mãsurãtorilor, dupã care arãt cum putem mãsura anumiþi parametri
ai calculatorului.  În a doua parte a articolului urmeazã sã fac o
muncã ``detectivistã'' care aratã cum se pot folosi mãsurãtorile
de performanþã pentru a trage concluzii despre anumiþi parametri
arhitecturali care influenþeazã viteza doar în mod indirect.  Ca
exemplu, intenþionez sã ilustrez cum se pot face tot felul de
mãsurãtori ale caracteristicilor cache-ului microprocesorului
Pentium II.  Majoritatea ideilor ºi codului din acest articol au fost
dezvoltate ca teme la cursul de arhitectura calculatoarelor pe care
autorul l-a luat în toamna anului 1997 la CMU.  Creditul pentru
aceste idei i se cuvine unuia dintre profesori, Randy Bryant.

<P>

<H1><A NAME="SECTION01010000000000000000">
Introducere: mãsurãtori de performanþã</A>
</H1>

<P>
Într-un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#watchdogs">articol</a>
anterior, despre natura cercetãrii în ``sisteme'' (PC Report din
martie 1998), discutam despre importanþa evaluãrii programelor.
Majoritatea articolelor de cercetare din domeniu conþin mãsurãtori
ample, care controleazã feluriþi parametri ºi studiazã variaþia
altora.  Mãsurarea unui sistem complex este foarte dificilã, ºi existã
o sumedenie întreagã de tehnici care se pot utiliza.  Importanþa
mãsurãtorilor a fost recunoscutã ºi de proiectanþii de
microprocesoare: toate procesoarele moderne oferã suport extins pentru
mãsurarea a tot felul de evenimente importante.  Un articol recent din
PC Report (``Tehnologia MMX, partea a II-a'', Iulie 1998, de Valer
Bocan) arãta lista tuturor mãsurãtorilor pentru care procesorul
Pentium are suport din fabricaþie: o paginã întreagã.

<P>
Existã foarte multe feluri de mãsurãtori; o privire superficialã
poate distinge urmãtoarele clasificãri:

<P>
<DL>
<DT><STRONG>Mãsurãtori statistice vs. exacte.</STRONG></DT>
<DD>Numãrul de evenimente
petrecute la rularea unui program este uriaºã; contorizarea
fiecãrui eveniment poate genera o cantitate enormã de informaþie, a
cãrei colectare poate interfera cu programul însuºi.

<P>
Probabil cele mai frecvente mãsurãtori sunt cele fãcute pentru a
vedea unde un program îºi petrece cel mai mult timp.  Acest tip de
mãsurãtoare se numeºte <EM>profiling</EM>.  Metoda obiºnuitã pentru
astfel de mãsurãtori este de a genera periodic întreruperi ºi de a
marca locul execuþiei programului în clipa întreruperii.  Acesta
este un exemplu tipic de mãsurãtoare statisticã.  Compilatoarele de
C genereazã cod cu mãsurãtori prin folosirea opþiunii <TT>-p</TT>.
Programe ca <TT>prof</TT> ºi <TT>gprof</TT> sunt folosite pentru a analiza
rezultatele.

<P>
</DD>
<DT><STRONG>Mãsurãtori reale vs. simulãri.</STRONG></DT>
<DD>Unul din scopurile
mãsurãtorilor este de a vedea dacã o nouã idee oferã
într-adevãr mai multã eficienþã decît metodele tradiþionale.
Dar, mai ales cînd este vorba de proiectarea de hardware, un sistem
nu poate fi construit pînã nu suntem siguri cã este bun; de asta nu
putem fi siguri însã pînã cînd nu l-am mãsurat.  Soluþia
tradiþionalã este de a construi un <EM>simulator</EM> al sistemului ºi
de a mãsura parametrii de interes cu acesta.

<P>
Este inutil de zis cã a construi un simulator foarte precis este o
treabã extrem de complicatã.  Se întîmplã adesea ca unele dintre
fenomenele care nu sunt luate în considerare de cãtre simulare sã
aibã în realitate un impact foarte important asupra performanþei.

<P>
</DD>
<DT><STRONG>Mãsurãtori cu instrumente externe vs. sisteme
auto-instrumentate.</STRONG></DT>
<DD>În mod ideal mãsurãtoarea nu trebuie
sã disturbe sistemul însuºi de loc; în realitate lucrurile stau
altfel.  O mãsurãtoare care nu interferã foloseºte analizoare de
magistralã (care înregistreazã tot traficul pe magistrala
calculatorului între procesoare, controlere ºi memorie) sau
captureazã pachetele dintr-o reþea.  O problemã cu astfel de
mãsurãtori este cantitatea enormã de informaþie pe care o
genereazã ºi care trebuie stocatã pentru prelucrãri ulterioare.

<P>
Pe de altã parte, atunci cînd mãsurãm un program, putem modifica
programul însuºi pentru a înregistra chiar el numai evenimentele
importante.  Problema este cã aceste modificãri afecteazã programul
însuºi; nu numai din cauzã cã strîngerea informaþiei ia timp,
dar ºi pentru cã aºezarea codului ºi datelor în memorie se
schimbã, de unde tot felul de efecte noi în cache-uri, în
interferenþe cu memoria virtualã, etc.

<P>
</DD>
<DT><STRONG>Mãsurãtori sintetice vs. mãsurãtori în condiþii
``reale''.</STRONG></DT>
<DD>Cînd mãsurãm un sistem, cu ce fel de date de intrare
trebuie sã facem rulãrile?  Care sunt datele ``cele mai tipice''?
Putem distinge la marginile unui spectru larg teste complet sintetice
care exerseazã un numãr foarte mic de parametri, ºi teste extrem de
complexe, cu programe sau date ``reale'', folosite în medii
industriale.
</DD>
</DL>

<P>
Înainte de a plonja în concret sã menþionãm ºi faptul cã
interpretarea rezultatelor testelor este adesea foarte dificilã.
Dupã cum vom vedea în partea a doua a acestui articol, mai multe
fenomene pot da naºtere unor efecte similare, iar atunci cînd putem
avea de-a face cu interferenþa mai multor fenomene este foarte greu
de depistat cauza realã a unor rezultate.

<P>

<H1><A NAME="SECTION02000000000000000000">
Mãsurãtori directe</A>
</H1>

<P>

<H1><A NAME="SECTION02010000000000000000">
O procedurã pentru mãsurarea timpului în Unix</A>
</H1>

<P>
Dupã ce am vorbit despre tot felul de metode, care mai de care mai
sofisticate, voi ilustra în acest articol o metodã foarte simplã de
auto-instrumentare a unui program, care poate fi folositã pentru a
mãsura destul de precis chiar evenimente foarte scurte.

<P>
Mãsurarea timpului este o treabã a sistemului de operare, aºa cã
avem nevoie de un oarecare suport din partea acestuia.  Voi folosi
pentru exemplificare sistemul de operare Unix; programele din acest
text au fost testate pe mai multe sisteme, incluzînd Linux, SunOs,
Solaris ºi Digital Unix.  Metodologia poate fi probabil însã
folositã ºi pe sisteme din familia Windows, în mãsura în care
contabilizarea timpului pentru programe se face într-un fel
asemãnãtor (acest subiect îmi este, din pãcate, strãin).

<P>

<H2><A NAME="SECTION02011000000000000000">
Funcþiile <TT>setitimer</TT> ºi <TT>getitimer</TT></A>
</H2>

<P>
Nucleul unui sistem Unix menþine pentru fiecare proces trei contoare
independente, numite ``ceasuri de interval'' (interval timers).
Utilizatorul are la dispoziþie douã funcþii de bibliotecã pentru a
citi ºi scrie aceste ceasuri; scrierea se face cu <TT>setitimer()</TT>
iar citirea cu <TT>getitimer()</TT>.

<P>
Timpul însuºi este reprezentat într-o structurã care se numeºte
<TT>struct timeval</TT>.  Pe sistemele citate anterior structura aceasta
este foarte simplã:

<P>
<PRE>
struct timeval {
   long  tv_sec;        /* secunde */
   long  tv_usec;       /* microsecunde */
};
</PRE>

<P>
Un ``itimer'' (interval timer) are douã astfel de structuri
înauntru:

<P>
<PRE>
struct  itimerval {
   struct  timeval it_interval; /* timer interval */
   struct  timeval it_value;    /* current value */
};
</PRE>

<P>

<OL>
<LI>o structurã numitã <TT>it_interval</TT>, care conþine perioada
cu care ceasul trebuie sã ``batã''.

<P>
</LI>
<LI>o structurã numitã <TT>it_value</TT> care aratã cît timp mai
trebuie sã treacã înainte de urmãtoarea bãtaie a ceasului.
</LI>
</OL>

<P>
Cînd un astfel de ceas ``expirã'', nucleul trimite procesului în
cauzã un semnal.  Din fericire pe noi nu ne vor interesa semnalele:
vom folosi aceste ceasuri într-un mod mai simplu, pentru a mãsura
durata unor evenimente: setãm valoarea curentã a lui <TT>it_value</TT>, executãm codul de mãsurat, ºi apoi citim <TT>it_value</TT> din nou; fãcînd diferenþa vom afla cît a durat
execuþia.

<P>

<H2><A NAME="SECTION02012000000000000000">
Timp real ºi timp virtual</A>
</H2>

<P>
Unix este un sistem de operare multitasking: mai multe procese se
pot executa ``simultan''.  De obicei nu avem la dispoziþie tot
atîtea procesoare cît procese de executat, aºa cã modul în care
mai multe programe îºi ``împart'' calculatorul este prin <EM>time-sharing</EM>: o bucãþicã de timp se executã unul, apoi programul
este suspendat ºi se executã un al doilea, etc.

<P>
Nucleul oferã deci douã feluri de timere pentru procese (de fapt
trei, dar numai douã ne intereseazã pe noi acum): unul care
mãsoarã timpul real scurs (numit ºi timpul ceasului de pe perete:
``wall-clock time'') ºi unul care mãsoarã timpul ``virtual'': numai
timpul cît procesul mãsurat a fost în execuþie.

<P>
Noi vom folosi ambele timere, în funcþie de ceea ce vrem sã mãsurãm.

<P>

<H2><A NAME="SECTION02013000000000000000">
Mãsurarea timpului</A>
</H2>

<P>
Vom scrie trei funcþii de bazã care manipuleazã aceste timere;
iatã declaraþiile lor în fiºierul <TT>etime.h</TT>:

<P>
<PRE>
/* fisierul etime.h */

#ifndef _ETIME_H
#define _ETIME_H

void init_etime(void);  /* initializeaza ceasurile */
double get_etime(void); /* calculeaza timpul virtual scurs de la
                           initializarea ceasurilor, in secunde */
double get_ewtime(void);/* timpul real scurs de la initializarea
                           ceasurilor */
#endif
</PRE>

<P>
Aceste funcþii sunt relativ simplu de scris, dacã citim cu atenþie
explicaþiile din manual ale funcþiilor <TT>getitimer</TT> ºi <TT>setitimer</TT>.  Am presupus cã nici unul dintre programele mãsurate nu
se va executa mai mult de o zi, ºi de aceea am pus lungimea
intervalului de mãsurat la 24 * 60 * 60 = 86400 secunde.  Iatã
codul:

<P>
<PRE>
/* fisierul etime.c: manipulare de timere */

#include "etime.h"
#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;

/* memoreaza timpul virtual ramas */
static struct itimerval init_virtual; 

/* timpul real ramas */
static struct itimerval init_real;

#define MAX_ETIME 86400   /* o zi = un interval foarte mare. */

void init_etime(void)
{
    init_virtual.it_interval.tv_sec = 0;
    init_virtual.it_interval.tv_usec = 0;
    init_virtual.it_value.tv_sec = MAX_ETIME;
    init_virtual.it_value.tv_usec = 0;
    setitimer(ITIMER_VIRTUAL, &amp;init_virtual, NULL);
    /* ultimul argument al lui setitimer citeste valoarea
       timerului inainte de a fi modificat; nu ne intereseaza,
       deci folosim NULL */

    init_real.it_interval.tv_sec = 0;
    init_real.it_interval.tv_usec = 0;
    init_real.it_value.tv_sec = MAX_ETIME;
    init_real.it_value.tv_usec = 0;
    setitimer(ITIMER_REAL, &amp;init_real, NULL);
}

double get_etime(void) 
        /* elapsed time: timp scurs */
{
    struct itimerval curent;

    getitimer(ITIMER_VIRTUAL, &amp;curent);

    /* cite secunde au trecut de cind am setat init_virtual? */
    return (double)((init_virtual.it_value.tv_sec -
                     curent.it_value.tv_sec) +
                    (init_virtual.it_value.tv_usec -
                     curent.it_value.tv_usec) * 1e-6);
    /* 1e-6 = marimea unei microsecunde in secunde. */
}

double get_ewtime(void) 
        /* elapsed wall time: timp scurs real */
{
    struct itimerval curent;

    getitimer(ITIMER_REAL, &amp;curent);
    return (double) ((init_real.it_value.tv_sec - curent.it_value.tv_sec) +
                     (init_real.it_value.tv_usec - curent.it_value.tv_usec)*1e-6);
}
</PRE>

<P>
Deºi sunt multe litere, ce se întîmplã ar trebui sã fie evident.
Observaþi cã ceasurile numãrã ``în jos'' (descresc de la valoarea
iniþialã spre 0), ºi de aceea scad valoarea curentã din cea
iniþialã ºi nu invers.

<P>

<H2><A NAME="SECTION02014000000000000000">
Mãsurarea rezoluþiei ceasului</A>
</H2>

<P>
Buun.  Avem deci o metodã pentru a mãsura cît timp a trecut.
Primul lucru pe care o sã-l facem este sã vedem ce <EM>rezoluþie</EM>
are timerul însuºi.  Cu alte cuvinte: cu ce frecvenþã bate ceasul?
Nu ne putem aºtepta ca valoarea timer-ului sã fie ajustatã foarte
frecvent, pentru cã aceasta ar lua foarte mulþi cicli din execuþia
programelor însele.

<P>
Pentru a mãsura rezoluþia ceasului ne vom folosi de faptul cã <B>ceasul se miºcã relativ încet</B>.  Mult mai încet decît durata
executãrii unei funcþii sau a unui apel de sistem.  Cu alte cuvinte,
pot executa de multe ori funcþia <TT>get_etime</TT> între douã
bãtãi ale ceasului.  Acest lucru este fundamental pentru buna
funcþionare a programelor de mãsurare pe care le scriem, ºi îl vom
verifica puþin mai tîrziu.  În orice caz, ºtim din folclor (sau,
dacã nu, din alte articole din PC Report) cã un apel de sistem pe o
maºinã modernã dureazã de ordinul zecilor de microsecunde, pe
cînd rezoluþia ceasului este în zona milisecundelor (de sute de ori
mai micã).

<P>
Vom scrie deci un program foarte simplu care nu face decît sã
citeascã ceasul în mod repetat pînã sesizeazã o schimbare.  Din
cauzã cã citirile vor fi mult mai dese decît ticãirile ceasului,
suntem siguri cã vom vedea cu cît se schimbã ceasul la fiecare
bãtaie.  Funcþia <TT>delta()</TT> calculeazã rezoluþia ceasului:

<P>
<PRE>
/* functia delta(): masuratoarea rezolutiei ceasului SO */

double delta(void)
{ 
    double curent, inainte, 
           mindelta = 10;       /* valoare ridicol de mare */
    int repetam = 3;   /* masuram de mai multe ori, ca sa fim siguri */

    inainte = get_etime();
    while (repetam) {
        curent = get_etime();
        if ((curent - inainte) &gt; 1e-6) {
            repetam--;
            if ((curent - inainte) &lt; mindelta)
                /* avem o estimare mai buna pentru rezolutie */
                mindelta = curent - inainte;
            inainte = curent;
        }
    }
    return mindelta;
}
</PRE>

<P>
(Observaþi metoda de a compara valori <TT>double</TT>).  Încercaþi-o:

<P>
<PRE>
/* exemplu: masurarea delta() */

#include &lt;stdio.h&gt;
#include "etime.h"

double delta(void);

int main(void)
{
    init_etime();
    printf("Rezolutia ceasului este %2.3fms\n", delta()*1000);
    return 0;
}
</PRE>

<P>

<H2><A NAME="SECTION02015000000000000000">
Mãsurarea unor evenimente foarte scurte</A>
</H2>

<P>
Ce ne facem însã cu intervalele foarte scurte?  Cum poþi sã
mãsori un eveniment care dureazã o microsecundã dacã ai un ceas
care are ca unitate de mãsurã de 10ms?  Din fericire nu e prea greu:
un calculator e foarte bun la a repeta aceeaºi operaþiune de
milioane de ori.  Ce trebuie sã facem este sã executãm operaþia de
mãsurat de -- sã zicem -- un milion de ori, ºi sã împãrþim
rezultatul mãsurãtorii la un milion.

<P>
De fapt trebuie sã fim ceva mai grijulii, din douã motive:

<P>

<UL>
<LI>Mãsurarea unei operaþiuni de o secundã ar dura prea mult în
acest fel, de aceea vom face calculatorul sã mãsoare atîta timp
cît îi trebuie pentru a fi garanta cã este suficient de riguros.
Dacã o mãsurãtoare ia în jur de o secundã, atunci ea nu mai
trebuie repetatã de loc.

<P>
</LI>
<LI>Trebuie sã fim atenþi cînd mãsurãm timpul <EM>virtual</EM>,
(pentru cã în interiorul unei secunde procesul ar putea fi
întrerupt de mai multe ori din cauza time-sharing) ºi cînd timpul
<EM>real</EM> (pentru cã asta vrem de fapt sã aflãm).  Trebuie sã
cronometrãm numai ``timpul efectiv de joc''.
</LI>
</UL>

<P>
Acestea fiind zise, vom purcede la a scrie o funcþie genericã numitã
<TT>ftime</TT> care are trei argumente:

<P>

<UL>
<LI>Un pointer spre o altã funcþie, a cãrei duratã trebuie
mãsuratã;

<P>
</LI>
<LI>Precizia cerutã, în procente.  Eroarea mãsurãtorii va fi
limitatã de aceastã valoare;

<P>
</LI>
<LI>Un boolean care spune dacã mãsurãm timp virtual (0) sau real
(1).
</LI>
</UL>

<P>
Pentru a limita eroarea, trebuie sã facem un pic de aritmeticã.  Sã
presupunem cã vrem ca eroarea sã fie sub 1 procent.  Atunci dacã
ceasul bate cu perioada de X, trebuie sã mãsurãm numai durate de
cel puþin 101X.  De ce?  Orice mãsurãtoare este eronatã cu cel
mult +/-X, deci eroarea va fi sub 1 procent.

<P>
Mai general, dacã vrem o eroare mãrginitã de <IMG
 WIDTH="13" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\epsilon$"> procente
ºi rezoluþia ceasului este <IMG
 WIDTH="21" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$\Delta$"> atunci trebuie sã rulãm testul
timp de <!-- MATH
 $(1 + \epsilon) \Delta / \epsilon$
 -->
<IMG
 WIDTH="87" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$(1 + \epsilon) \Delta / \epsilon$">.  Formula nu e prea greu de
demonstrat riguros, dar datoritã formatului PC Report formulele
matematice sunt ceva mai greu de tehnoredactat.  Voi adãuga
demonstraþia ca anexã în varianta articolului care se gãseºte în
pagina mea de web.

<P>
<PRE>
/* functia ftime: masuratoarea duratei unei alte functii */

#include "etime.h"

/* puneti functia delta() aici */

double ftime(void (*de_masurat)(void), double epsilon, int timp_real)
{
    double durata;        /* cit timp trebuie executat testul */
    unsigned long repetitii;
    double inceput, sfirsit;
    static double Delta;
    static int initializat = 0;
    double (*masoara)(void);

    masoara = timp_real ? get_ewtime : get_etime;
 
    if (!initializat) {
        /* prima oara calculam Delta */
        initializat = 1;
        Delta = delta();
    }

    durata = (1 + epsilon) * Delta / epsilon;

    for (repetitii = 1; ; repetitii *= 2) {
        int i;
        inceput = masoara();
        for (i=repetitii; i &gt; 0; i--)
            de_masurat();
        sfirsit = masoara();
        if (sfirsit - inceput &gt;= durata) break;
    }
    return ((sfirsit - inceput) / (double)repetitii);
}
</PRE>

<P>
Funcþia este destul de simplã: va dubla numãrul de repetiþii al
executãrii funcþiei de mãsurat pînã cînd în total repetiþiile
depãºesc suficient durata necesarã pentru a mãrgini eroarea.
Dacã vã îngrijoreazã numãrul mare de execuþii al buclei,
observaþi cã numãrul de execuþii al funcþiei de mãsurat descrie
o serie geometricã (se executã de 1, 2, 4, 8, etc. ori), deci
numãrul total de execuþii nu va depãºi niciodatã 2*<TT>durata</TT>,
unde <TT>durata</TT> este durata necesarã pentru a limita eroarea (ºi
asta e uºor de demonstrat).  Pentru calculatorul meu <IMG
 WIDTH="21" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$\Delta$"> este
10ms, deci pentru o eroare de 1% <TT>durata</TT> este 1s.  Durata
mãsurãtorii nu va depãºi deci 2 secunde (decît dacã funcþia de
mãsurat dureazã mai mult).

<P>
ªtiu cã vã grãbiþi sã încercaþi codul, aºa cã daþi-i
drumul:

<P>
<PRE>
/* prima masuratoare */
#include &lt;stdio.h&gt;
#include "etime.h"

/* puneti aici delta() si ftime() */

void f(void)
{
   /* scrieti aici codul de masurat, ce vreti */
}

int main(void)
{
    init_etime();
    printf("Durata executarii lui f este %2.2fsec\n", ftime(f, 0.01, 0));
    return 0;
}
</PRE>

<P>

<H2><A NAME="SECTION02016000000000000000">
Surse de eroare</A>
</H2>

<P>
Din pãcate am vãzut (din fugã) cã un sistem care se auto-mãsoarã
este supus la perturbaþii (un fel de principii de incertitudine a
la Heisenberg).  Nici programul nostru nu este scutit de astfel de
probleme.  Nu putem face foarte mult pentru a le corecta, dar este
foarte bine sã le avem în vedere.  Iatã unele posibile
interferenþe:

<P>
<DL>
<DT><STRONG>Codul suplimentar:</STRONG></DT>
<DD>observaþi cã ceea ce mãsurãm este tot
codul executat între atribuirea lui <TT>inceput</TT> ºi atribuirea lui
<TT>sfirsit</TT>, din funcþia <TT>ftime()</TT>.  Asta înseamnã, pe
lîngã corpul funcþiei <TT>de_masurat</TT> ºi ceva din ciclul <TT>for</TT>, plus codul care cheamã funcþia ºi executã întoarcerea.  De
asemenea, vom vedea cã uneori va trebui sã înghesuim în corpul
funcþiei de mãsurat cod suplimentar, pe care de fapt nu l-am vrea
mãsurat (de pildã pentru cã funcþia de mãsurat nu poate avea
argumente aºa cum am scris-o).  Aceste erori sunt însã mãrunte;
eroarea relativã depinde, desigur, de cît de mult dureazã funcþia
de mãsurat însãºi.

<P>
</DD>
<DT><STRONG>Execuþia în interiorul nucleului:</STRONG></DT>
<DD>o problemã mult mai gravã
este faptul cã contabilizarea timpului de cãtre nucleu nu este
întotdeauna foarte precisã.  Nucleul trebuie sã execute tot felul
de funcþii pe care utilizatorul nu le-a chemat niciodatã (de pildã
funcþia care comutã de la un proces la altul).  Timpul acestor
funcþii este atribuit pînã la urmã tot unor procese utilizator.

<P>
Sau sã luãm un alt caz: apariþia unui pachet pe reþea.  Nucleul
trebuie sã citeascã pachetul ºi probabil sã-l trimitã pe o altã
interfaþã, sau sã-l livreze unui proces.  Dar din momentul
apariþiei pachetului pînã la livrare nu este încã evident cui îi
este destinat acesta (poate unei alte maºini).  Ori timpul de
procesare al pachetului trebuie contabilizat ºi el undeva.  În
general toate întreruperile (de disc, de la tastaturã, etc.) suferã
de problema asta.

<P>
Din aceastã cauzã, mãsurãtorile vor fi mai precise dacã maºina
nu este deloc încãrcatã (nu executã prea multe procese) ºi nu
este conectatã la reþea.  Cît de mare este eroarea vã invit sã
experimentaþi fãcînd mãsurãtori pe douã maºini: una aglomeratã
ºi una liberã.

<P>
</DD>
<DT><STRONG>Efecte de cache:</STRONG></DT>
<DD>Un alt tip de interferenþã, foarte
spectaculos, este interferenþa în cache a codului care mãsoarã cu
cel mãsurat.  Vom vedea în partea a doua a articolului, cînd vom
mãsura parametrii cache-ului, cã datele ºi codul îºi împart
cache-ul numit L2; din cauza asta pentru anumite plasamente ale
datelor am putea avea conflicte între date ºi codul însuºi,
conflicte care ar putea sã disparã în alte configuraþii!  Astfel
de efecte sunt extrem de dificil de controlat ºi mãrginit.

<P>
Conflicte de cache pot fi ºi între sistemul de operare ºi programul
de mãsurat etc.  O cutie a Pandorei, ce mai.
</DD>
</DL>

<P>

<H1><A NAME="SECTION02020000000000000000">
Mãsurãtori de performanþã</A>
</H1>

<P>
Hai sã exersãm acum procedurile de mai sus pe niºte operaþiuni
interesante.  Vom mãsura pentru început cea mai scurtã duratã din
calculator: frecvenþa de tact a microprocesorului!  Aceasta este
efectiv uriaºã: un procesor la 333Mhz are un ceas de 3ns, de 3
milioane de ori mai micã decît rezoluþia Delta (10ms) a ceasului!

<P>

<H2><A NAME="SECTION02021000000000000000">
Frecvenþa ceasului procesorului</A>
</H2>

<P>
Cum putem sã mãsurãm o duratã atît de scurtã?  În primul rînd,
cum putem scrie un program atît de scurt?  Nici nu putem.  Dar vom
face acelaºi truc: vom repeta aceeaºi instrucþiune foarte scurtã
de multe ori.

<P>
Ce instrucþiune dureazã exact un ciclu de ceas?  Practic, pe toate
procesoarele RISC sau CISC o adunare de numere întregi dureazã exact
un ciclu de ceas.

<P>
Va trebui sã fim atenþi însã cînd scriem codul la urmãtoarele
aspecte:

<P>

<OL>
<LI>Procedura cu adunãrile va trebui sã fie compilatã <EM>cu
optimizãri</EM> de cãtre compilator.  Codul în asamblare rezultat nu
trebuie sã conþinã nici un fel de instrucþiuni în plus în afarã
de adunãri, pentru cã altfel nu mãsurãm ce trebuie;

<P>
</LI>
<LI>Din cauza asta nu putem folosi de fapt o buclã: instrucþiunile
de incrementare ºi test iau la fel de mult ca adunãrile însele.  Va
trebui sã scriem cu mîna o mulþime de adunãri;

<P>
</LI>
<LI>Procesoarele moderne superscalare pot executa mai multe adunãri
simultan; pentru a evita acest lucru vom face ca fiecare adunare sã
foloseascã rezultatul celei anterioare (asta se numeºte o <EM>dependenþã</EM>; dependenþele în programe sunt unul dintre obstacolele
majore împotriva creºterii performanþei.  De data asta vor fi în
folosul nostru);

<P>
</LI>
<LI>Codul nu trebuie sã fie optimizabil în aºa fel încît sã
fie simplificat prea tare (<EM>dead-code ellimination</EM>).  De pildã,
dacã facem numai adunãri, dar nu facem nimic cu rezultatul, un
compilator deºtept s-ar putea prinde ºi ar putea elimina toate
adunãrile din program.
</LI>
</OL>

<P>
<PRE>
/* masurarea ceasului microprocesorului */

int ax;  /* niste variabile globale pentru a impiedica optimizari */
int bx;
int cx;

/* niste macrouri simpatice pentru a genera 100 de repetitii */
#define DOI(x) x x
#define PATRU(x) DOI(x) DOI(x)
#define CINCI(x) x PATRU(x)
#define DOUASCINCI(x) CINCI(CINCI(x))
#define OSUTA(x) PATRU(DOUASCINCI(x))

void add_test(void)
{
    register int a = ax;
    register int b = bx;
    register int c = cx;

    OSUTA(a += b; a += c;)      /* doua adunari dependente! */

    ax = a+b+c;     /* pentru ca scriem intr-o variabila globala
                       compilatorul nu va scoate nici o adunare
                       din program */
}

void add_dummy(void)
{
    register int a = ax;
    register int b = bx;
    register int c = cx;
    ax = a+b+c;
}

double mhz(double epsilon)
{
    double secs;

    secs = ftime(add_test, epsilon, 0) - ftime(add_dummy, epsilon, 0);
    return (200.0 / secs) / 1e6; /* add_test are 200 instr.
                                    mai mult decit add_dummy */
}
</PRE>

<P>
Am fost foarte atent sã compensez diferenþa între costul celor 200
de instrucþiuni de adunare ºi instrucþiunile suplimentare,
calculînd durata unei proceduri <TT>add_dummy</TT>, care conþine numai
codul parazit ºi scãzînd cele douã valori.  Am testat codul ãsta
pe o maºinã rapidã: un Pentium II la 266Mhz astfel:

<P>
<PRE>
#include &lt;stdio.h&gt;
#include "etime.h"

/* puneti aici ftime(), delta(), mhz() si prietenii lor */

int main(void)
{
    init_etime();
    printf("Frecventa ceasului este %gMhz\n", mhz(0.02));
    return 0;
}
</PRE>

<P>
Cu o eroare toleratã de 2% am ob'tinut r'aspunsul: 266.3MHz.  Destul
de bine, nu?

<P>

<H2><A NAME="SECTION02022000000000000000">
Costul unui apel de procedurã</A>
</H2>

<P>
Asta este deja o treaba foarte simplã de calculat.  Pur ºi simplu
folosim programul de mai sus, numit ``prima mãsurãtoare'', fãrã a
pune nimic în corpul funcþiei <TT>f</TT>.  Pe sistemul meu timpul a
ieºit 33.9ns, adicã aproximativ 9 cicli de procesor.

<P>

<H2><A NAME="SECTION02023000000000000000">
Durata unui apel de sistem simplu</A>
</H2>

<P>
Este interesant de mãsurat care este durata executãrii unui apel de
sistem (un serviciu elementar oferit de nucleu).  Mãsurarea timpului
însãºi foloseºte funcþia <TT>getitimer()</TT> care la rîndul ei
foloseºte un apel de sistem.

<P>
Trebuie sã fim însã foarte atenþi sã mãsurãm apeluri de sistem
<EM>idempotente</EM>, adicã a cãror execuþie repetatã va da mereu
aceleaºi rezultate.  De exemplu, probabil cã nu putem mãsura durata
citirii dintr-un fiºier folosind metoda noastrã, pentru cã numai
prima citire va accesa discul; a doua va lua datele din cache.
Aceasta este o limitare importantã a testelor repetitive, ca cel pe
care l-am scris.

<P>
De asemenea, pentru cã nu este foarte clar cui îi atribuie nucleul
timpul petrecut în timpul unui apel de sistem, vom mãsura timpul
<B>real</B>.  Dacã apelul nu este blocant, avem ºanse ca în timpul
testului sã nu fie executat nici un alt proces.  Aceastã
mãsurãtoare e musai sa fie executatã pe o maºinã ne-încãrcatã,
pentru cã altfel rezultatele vor fi puternic distorsionate de
celelalte procese.

<P>
Oricum, pentru un apel de sistem foarte simplu, cum e
<TT>getpid()</TT> (pentru multe alte detalii privitoare la acesta
vedeþi ºi <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#linux">articolul</a>
meu din PC Report ianuarie 1998, ``Anatomia unui apel de sistem'')
putem rula urmãtorul cod:

<P>
<PRE>
/* masurarea unui apel de sistem */

/* nu uitati sa includeti get_etime(), etc... */

#include &lt;unistd.h&gt;

int main(void)
{
    init_etime();
    printf("Un apel de sistem dureaza %fs\n", ftime(getpid, 0.02, 1));
    /* o sa obtineti un warning la compilare din cauza ca
       getpid intoarce de fapt un intreg; nu-i problema. */
    return 0;
}
</PRE>

<P>
Pe aceeaºi maºinã, rulînd Linux 2.0.30, am obþinut un timp de
2.00 microsecunde pentru un apel de sistem.  Am avut deci dreptate: un
apel de sistem e mult mai scurt decît rezoluþia ceasului.

<P>

<H2><A NAME="SECTION02024000000000000000">
Durata comutãrii de procese</A>
</H2>

<P>
În fine, încheiem aceastã parte a articolului cu o mãsurãtoare a
duratei comutãrii între douã procese.

<P>
Vom scrie douã procese care ºtim cã se blocheazã reciproc, în
aºa fel încît execuþia se paseazã de la unul la celãlalt.  Din
nou, mãsurãm timpul real.

<P>
Programul acesta cere cîteva cunoºtinþe elementare despre Unix; unele
dintre funcþiile componente le-am explicat mai demult, de exemplu în
<a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#shell">articolul</a>
``Shell-ul'' din PC Report iunie 1997.

<P>
Ideea este simplã: deschid douã þevi ºi fac douã procese: unul
citeºte din una ºi scrie în cealaltã cîte un caracter ºi
viceversa.  Cînd un proces încearcã sã citeascã dintr-o þeavã
goalã se blocheazã; în acest fel la fiecare citire/scriere se
produce ºi o comutare de procese.  Mãsurãtoarea se face numai de
cãtre procesul pãrinte.

<P>
<PRE>
/* masurarea timpului de comutare intre procese */

#include &lt;unistd.h&gt;

int p[2], r[2];
char c;

void t(void)
{
    write(r[1], &amp;c, 1);
    read(p[0], &amp;c, 1);
}

double forktest(void)
{
    int copil;

    if (pipe(p) &lt; 0 || pipe(r) &lt; 0) exit(1);
    copil = fork();
    if (copil) {
        double rv = ftime(t, 0.01, 1);
        kill(copil, 9);
        return rv;
    }
    else {
        while (1) {
            read(r[0], &amp;c, 1);
            write(p[1], &amp;c, 1);
        }
        return 0;
    }
}

int main(void)
{
    init_etime();
    printf("Comutarea intre 2 procese dureaza %gus\n", 1e6*forktest());
    return 0;
}
</PRE>

<P>
Pe maºina mea rezultatul afiºat a fost: 17.8528us.  Asta include
evident ºi costul a patru apeluri de sistem (cîte un <TT>read</TT> ºi
un <TT>write</TT> în fiecare din procese) ºi douã comutãri
(dus-întors).  Asta înseamnã cã o comutare de fapt dureazã cam 17
- 4*2 / 2 = 4.5 microsecunde.  Asta este o performanþã excelentã
pentru un sistem de operare, fiind ºi una dintre explicaþiile
succesului Linux.

<P>

<H1><A NAME="SECTION02030000000000000000">
Încheiere temporarã</A>
</H1>

<P>
Nu pot decît sã vã invit sã exersaþi mãsurãtorile pe tot felul
de alte probleme.  De exemplu, este mult mai greu sã mãsuraþi timpul
de creare al unui proces, din cauza ne-idempotenþei.  Mãsuraþi apoi
tot felul de alte lucruri, ca timpul de acces la disc, timpul de
transfer în reþea, etc.  Vedeþi ce iese.  În partea a doua vom
continua explorãrile utilizãrilor mãsurãtorilor pe niºte cazuri
mult mai complicate.

<P>

<H1><A NAME="SECTION03000000000000000000">
Mãsurãtori indirecte</A>
</H1>

<P>
În numãrul anterior din PC Report (septembrie 1998) am vãzut cum
putem mãsura intervale de timp folosind instrumentele puse la
dispoziþie de cãtre sistemul de operare; de asemenea am folosit
aceste instrumente pentru a ne face o idee despre durata unora dintre
activitãþile fundamentale, cum ar fi tactul procesorului, durata
unui apel de procedurã, durata unui apel de sistem, etc.  Codul
procedurilor din acel articol este disponibil ºi din pagina de web a
autorului, pentru cei care nu au cumpãrat numãrul anterior al
revistei, sau pentru cei care sunt prea leneºi ca sã tasteze.

<P>
În acest articol vom continua sã folosim mãsurãtorile de timp, dar
de data aceasta în scopuri indirecte.  Activitãþi de acest gen sunt
foarte des întîlnite în proiectarea sistemelor de calcul:
mãsurarea directã a unor parametri este adesea imposibilã, ºi ca
atare proiectanþii trebuie sã mãsoare fenomene diferite, iar apoi
printr-un raþionament de la efecte spre cauze sã deducã motivele
cãrora rezultatele li se datoreazã.

<P>
Cu cît sistemele în cauzã sunt mai complicate, cu atît mai dificil
de interpretat devin rezultatele.  Dacã un efect poate fi produs de
cauze multiple, din care unele nu sunt sub controlul direct al
experimentatorului, atunci devine foarte greu de explicat cu
exactitate în ce mãsura rezultatul este o interferenþã a
pãrþilor componente ºi ce contribuþie are fiecare dintre ele.

<P>
Chiar ºi acest articol, care mãsoarã un sistem relativ simplu ºi
aflat în întregime (aproape) la dispoziþia experimentatorului, va
avea pe alocuri dificultãþi în a explica unele dintre fenomene.
Pentru cã informaþiile pe care le voi extrage din mãsurãtori sunt
în mare parte nepublicate de cãtre fabricanþi, nici nu avem o
metodã directã de a le verifica; este posibil ca erori de
interpretare sã se fi strecurat în raþionamentele mele.  Cititorii
care le vor decela sunt invitaþi sã le comunice autorului.

<P>

<H1><A NAME="SECTION03010000000000000000">
Mãsurarea parametrilor cache-urilor microprocesorului</A>
</H1>

<P>

<H2><A NAME="SECTION03011000000000000000">
O digresiune</A>
</H2>

<P>
O figurã marcantã în galeria celebritãþilor proiectanþilor de
sisteme este Mahadev Satyanarayanan<A NAME="tex2html1"
  HREF="#foot151"><SUP>1</SUP></A>.  Domnului
Satyanarayanan îi este atribuit un citat care afirmã cã în
proiectarea sistemelor existã doar douã unelte fundamentale:

<P>

<UL>
<LI>Cache-urile;
</LI>
<LI>Un nivel suplimentar de indirectare.
</LI>
</UL>

<P>
Aserþiunea este cel puþin spectaculoasã ºi este rezultatul
distilãrii experienþei de zeci de ani de proiectare a unor sisteme
complexe.  Eu personal nu sunt capabil sã argumentez pro sau contra,
dar îmi sprijin inserþia acestui citat pe autoritatea
incontestabilã a domnului Satyanarayanan.

<P>
Despre cache-uri am publicat un <a href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#cache">articol</a> amplu în PC Report din martie
1997<A NAME="tex2html2"
  HREF="#foot154"><SUP>2</SUP></A>; cu toate acestea, sunt departe de a fi spus totul despre
ele (chiar în textul de faþã ne vom întîlni cu multe lucruri
noi).  Pentru cã de fapt restul articolului va fi consacrat în
întregime cache-ului asociat microprocesorului, o sã spun doar
cîteva cuvinte despre noþiunea de indirectare, din dorinþa de
completitudine.

<P>
Indirectarea este oferitã de cãtre ``referinþe'' (pointeri): în
loc de a vorbi despre o valoare vorbeºti despre <EM>locul</EM> unde se
aflã acea valoare.  Noþiunea de variabilã este un exemplu de
indirectare: cînd vorbesc despre X nu spun ce valoare are X, dar am
la dispoziþie o metodã pentru a afla aceastã valoare atunci cînd
am nevoie.  Un nume dat unui obiect este o indirectare pentru acel
obiect.  Numele simbolice din Internet sunt indirectãri pentru adrese
reale ale calculatoarelor, un callback este o indirectare pentru o
funcþie care trebuie chematã, un numãr de inod este un nivel de
indirectare pentru un fiºier pe disc în Unix, etc.

<P>

<H2><A NAME="SECTION03012000000000000000">
Cache-uri: o recapitulare sumarã</A>
</H2>

<P>
Sã revenim acum la cache-uri.  Dacã vreþi un studiu detaliat al
arhitecturii cache-urilor de microprocesor atunci trebuie sã citiþi
capitolul 5 din cartea ``Computer Architecture: A Quantitative
Approach'', ediþia a IIa, Morgan Kaufmann, 1995, de David Patterson,
de la universitatea Berkeley ºi John Hennessy, de la universitatea
Stanford<A NAME="tex2html3"
  HREF="#foot157"><SUP>3</SUP></A>.  Aceastã carte (ºi versiunea ei oarecum
simplificatã ``Computer Organization and Design: The
Hardware/Software Interface'', de aceeaºi autori, 1998) este baza
majoritãþii cursurilor de arhitectura calculatoarelor din Statele
Unite.  Capitolul 5 numai are 100 de pagini ºi rezumã circa 1600 de
articole de cercetare publicate numai între 1989 ºi 1995.

<P>
Pentru concreteþe voi studia cache-ul ataºat procesorului maºinii
aflate pe biroul meu, un Pentium II la 266Mhz, vechi de un an (poate
între timp detaliile arhitecturale s-au schimbat).

<P>
ªtim cã programul ºi datele pe care acesta le prelucreazã se aflã
în mod normal în memoria calculatorului (iar atunci cînd
calculatorul este stins, pe disc).  O memorie DRAM tipicã pentru un
calculator modern are un timp de acces de ordinul a 50 de nanosecunde;
asta înseamnã cã din clipa în care procesorul vrea sã ia un
cuvînt din memorie pînã la livrarea lui trec 50 de nanosecunde.

<P>
Procesorul meu însã (pe lîngã faptul cã este o maºinã
superscalarã, deci poate executa mai multe instrucþiuni deodatã)
poate executa o instrucþiune în fiecare ciclu de ceas; la 266Mhz
asta înseamnã ceva mai puþin de 4 nanosecunde pentru o
instrucþiune.

<P>
Discrepanþa între aceºti timpi este foarte mare.  Soluþia de a
folosi memorii mult mai rapide, SRAM, nu este practicã pentru cã
SRAMul este de cîteva zeci de ori mai scump decît DRAMul, deci
preþul calculatorului ar creºte prea mult.

<P>
Din fericire procesorul tinde sã re-foloseascã fiecare dintre
instrucþiunile executate ºi dintre datele prelucrate de mai multe
ori în intervale scurte de timp; aceastã proprietate (observatã
empiric) a programelor se numeºte ``localitate'', ºi este cea care
permite ingenioasa soluþie a cache-urilor: construim o memorie
intermediarã numitã ``cache'' (de la ``ascuns''), cu timp mic de
acces, dar de capacitate micã.  Atunci cînd procesorul vrea sã
prelucreze date le aduce în cache.  Prima oarã o sã aºtepte, dar a
doua oarã timpul de acces va fi redus simþitor.  Cînd cache-ul se
umple procesorul eliminã dintre datele care probabil nu vor mai fi
folosite în curînd.

<P>
Asta e ideea de bazã, ºi este extrem de practicã.  Noi înºine,
oamenii, tindem sã repetãm materia înaintea unui examen, pentru a
împrospãta cunoºtinþele din ``cache'' (memoria de scurtã duratã
ºi capacitate micã), folosind aceeaºi observaþie despre localitate
(ºi anume cã putem uita totul de îndatã ce examenul a trecut).

<P>
O încercare de acces care gãseºte datele în cache se numeºte
``loviturã'' (hit); un rateu în englezã se cheamã ``miss''.
Evident, un rateu este întotdeauna mai costisitor (ca timp) decît o
nimerealã.

<P>
Dacã datele cerute nu sunt în cache, atunci de obicei procesorul
este blocat (<EM>stalled</EM>) pînã cînd se face transferul din
memoria lentã.

<P>
Pentru cã în cache se pot afla simultan doar o parte din octeþii
din memorie, fiecare cuvînt din cache este însoþit de o
``etichetã'' (<EM>tag</EM>) care aratã de unde vine acel cuvînt.

<P>

<H2><A NAME="SECTION03013000000000000000">
Dimensiunea cache-ului</A>
</H2>

<P>
În primul nostru experiment vom încerca sã mãsurãm cît de mare
este cache-ul asociat procesorului.

<P>
Cum facem asta?  Simplu: citim din memorie date aflate una lîngã
cealaltã.  Dacã datele încap toate în cache, durata unei citiri
<EM>repetate</EM> va fi în medie micã.  Dacã datele nu încap însã,
de fiecare cînd citim o datã nouã una veche va trebui sã fie
scoasã ºi cea nouã adusã din memorie.  În felul acesta, de
îndatã ce citim mai multe date decît încap în cache, trebuie sã
observãm o încetinire a vitezei de execuþie.

<P>
Am scris deci urmãtorul program:

<P>
<PRE>
/* Masurarea ratei de transfer din memorie (cache) */

#include "ftime.h"       /* procedurile pentru masurat */
#define MAXTRANSFER (4 * 1024 * 1024) /* 4 Mb */

typedef int unitate;     /* unitatea de transferat: 4 octeti */

union {
   char array[MAXTRANSFER];
   unitate aliniament;
} de_transferat;

int TRANSFER;            /* citi octeti transferam */
register dummy;

#define UNROLL 64

#define ACCES(adresa)  a += *(adresa);
#define ACCES4(adresa) \
  ACCES(adresa+0) ACCES(adresa+1) \
  ACCES(adresa+2) ACCES(adresa+3)
#define ACCES16(adresa) \
  ACCES4(adresa+0) ACCES4(adresa+4) \
  ACCES4(adresa+8) ACCES4(adresa+12)
#define ACCES64(adresa) \
  ACCES16(adresa+0) ACCES16(adresa+16) \
  ACCES16(adresa+32) ACCES16(adresa+48)

void citire(void)
{
    register int i;
    register unitate a;
    register int *b = (int*)de_transferat.array;

    for (i = TRANSFER / sizeof(unitate); i &gt;= 0; i -= UNROLL) {
        ACCES64(b)
        b += UNROLL;
    }
    dummy = a;
}

void citire_ajustare(void)
{
    register int i;
    register unitate a;
    register unitate *b = (unitate*)de_transferat.array;

    for (i = TRANSFER / sizeof(unitate); i &gt;= 0; i -= UNROLL) {
        b += UNROLL;
    }
    dummy = a;
}

int main(void)
{
     int i;
     double Mhz, durata_ciclu;

     init_etime();
     Mhz = mhz(0.02);
     durata_ciclu = 1.0 / Mhz / 1e6;
     printf("Frecventa ceasului este %gMhz\n", Mhz);

     for (i=0; i &lt; MAXTRANSFER; i++)
        de_transferat.array[i] = 0;

     for (TRANSFER=512; TRANSFER &lt; MAXTRANSFER; TRANSFER &lt;&lt;= 1) {
          double t = ftime(citire, 0.01, 0) - ftime(citire_ajustare, 0.01, 0);
          printf("Cantitate %d, rata %2.2fMb/s, %2.2fcicli/cuvint\n", 
                 TRANSFER, 
                 (double)TRANSFER / t / (1024*1024), 
                 t / durata_ciclu / TRANSFER);
     } 
     return 0;
}
</PRE>

<P>
Ce se întîmplã trebuie sã fie destul de clar pentru cei care au
citit prima parte a articolului.  Cu toate acestea trebuie sã fim
atenþi la anumite subtilitãþi.

<P>
Folosim funcþiile <TT>mhz(), init_etime(), ftime()</TT>, dezvoltate
data trecutã.  Facem mãsurãtoarea citind cuvinte adiacente
dintr-un vector foarte mare.  Pentru cã citim cîte un întreg
odatã, care are probabil 4 octeþi, trebuie sã luãm niºte mãsuri
de precauþie.  Multe calculatoare nu permit citirea datelor
ne-aliniate: orice cuvînt de 4 octeþi trebuie sã fie accesat la o
adresã multiplu de 4.  Acesta este ºi scopul acelei <TT>union</TT> din
programul de mai sus: vectorul de caractere numit <TT>array</TT> va fi
aliniat în acelaºi fel cu întregul numit <TT>aliniament</TT>, pe care
compilatorul de C garanteazã sã-l punã la o adresã multiplu de 4.
Pentru Pentium aliniamentul nu conteazã de fapt, dar codul de mai sus
funcþioneazã ºi pentru alte procesoare.

<P>
O altã tehnicã foarte interesantã ºi demnã de reþinut este <EM>desfãºurarea buclei</EM> (loop unrolling).  În loc sã repetãm de un
numãr de ori o citire din memorie repetãm de 64 de ori mai puþin 64
de citiri din memorie.

<P>
De ce facem asta?  Pentru cã în felul acesta facem de 64 de ori mai
puþine incrementãri ale contorului buclei, ºi facem de 64 de ori
mai puþine teste de terminare a buclei.  Din cauza asta
mãsurãtoarea este mai precisã.  Tehnica aceasta este folositã cu
succes ºi de cãtre compilatoarele care optimizeazã.  Pe lîngã
faptul cã numãrul de instrucþiuni utile executate creºte, o buclã
cu un corp mai lung oferã mai multe oportunitãþi pentru
``scheduling'', dînd posibilitatea procesorului sã execute mai multe
instrucþiuni simultane mai des.

<P>
Variabila <TT>dummy</TT> este folositã pentru a împiedica compilatorul
sã optimizeze prea tare codul (întreaga buclã ar deveni inutilã
altfel).

<P>
Esenþialã este execuþia buclei <TT>for</TT> care iniþializeazã toatã
matricea <TT>de_transferat.array</TT> cu 0: dacã nu facem treaba asta
sistemul de operare nici mãcar nu va aloca pentru noi memoria
respectivã ºi orice citire din acea memorie va da automat un rezultat
0, fãrã ca memoria sã fie cititã de fapt.  (Mi-au ieºit peri albi
pînã am înþeles de ce mãsurãtorile care nu iniþializau matricea
dãdeau rezultate aberante.)

<P>
Iatã ºi rezultatele mãsurãtorii:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="RIGHT">Octeþi</TD>
<TD ALIGN="CENTER" COLSPAN=1>MB/s</TD>
<TD ALIGN="CENTER">Cicli/cuvînt</TD>
</TR>
<TR><TD ALIGN="RIGHT">512</TD>
<TD ALIGN="RIGHT">961.50</TD>
<TD ALIGN="CENTER">1.06</TD>
</TR>
<TR><TD ALIGN="RIGHT">1024</TD>
<TD ALIGN="RIGHT">972.92</TD>
<TD ALIGN="CENTER">1.05</TD>
</TR>
<TR><TD ALIGN="RIGHT">2048</TD>
<TD ALIGN="RIGHT">934.09</TD>
<TD ALIGN="CENTER">1.09</TD>
</TR>
<TR><TD ALIGN="RIGHT">4096</TD>
<TD ALIGN="RIGHT">958.68</TD>
<TD ALIGN="CENTER">1.06</TD>
</TR>
<TR><TD ALIGN="RIGHT">8192</TD>
<TD ALIGN="RIGHT">971.47</TD>
<TD ALIGN="CENTER">1.05</TD>
</TR>
<TR><TD ALIGN="RIGHT">16384</TD>
<TD ALIGN="RIGHT">933.42</TD>
<TD ALIGN="CENTER">1.09</TD>
</TR>
<TR><TD ALIGN="RIGHT">32768</TD>
<TD ALIGN="RIGHT">474.40</TD>
<TD ALIGN="CENTER">2.15</TD>
</TR>
<TR><TD ALIGN="RIGHT">65536</TD>
<TD ALIGN="RIGHT">474.23</TD>
<TD ALIGN="CENTER">2.15</TD>
</TR>
<TR><TD ALIGN="RIGHT">131072</TD>
<TD ALIGN="RIGHT">474.15</TD>
<TD ALIGN="CENTER">2.15</TD>
</TR>
<TR><TD ALIGN="RIGHT">262144</TD>
<TD ALIGN="RIGHT">426.70</TD>
<TD ALIGN="CENTER">2.39</TD>
</TR>
<TR><TD ALIGN="RIGHT">524288</TD>
<TD ALIGN="RIGHT">316.05</TD>
<TD ALIGN="CENTER">3.23</TD>
</TR>
<TR><TD ALIGN="RIGHT">1048576</TD>
<TD ALIGN="RIGHT">228.57</TD>
<TD ALIGN="CENTER">4.47</TD>
</TR>
<TR><TD ALIGN="RIGHT">2097152</TD>
<TD ALIGN="RIGHT">228.57</TD>
<TD ALIGN="CENTER">4.47</TD>
</TR>
<TR><TD ALIGN="RIGHT">4194304</TD>
<TD ALIGN="RIGHT">224.56</TD>
<TD ALIGN="CENTER">4.55</TD>
</TR>
</TABLE>
</DIV>

<P>
Observãm imediat un rezultat foarte interesant: viteza de transfer
are 3 paliere, la 1Gb/sec, jumãtate de Gb/s ºi un sfert de Gb/sec.
De ce cele 3 valori diferite?

<P>
Din cauzã cã viteza procesoarelor creºte -- datoritã avansului
tehnologiei -- mult mai repede decît viteza de rãspuns a memoriei,
calculatoarele moderne au de fapt 2 nivele de cache, unul mai mic ºi
mai rapid, numit L1, de obicei din SRAM, ºi unul mai mare ºi ceva
mai lent (L2).  La procesorul Pentium II cache-ul L1 este pe acelaºi
integrat cu procesorul, iar cache-ul L2 este în acelaºi soclu.
Cache-ul L2 este de de obicei DRAM lent, dar are un bus extrem de lat
ºi scurt, deci poate susþine o ratã de transfer relativ mare
comparativ cu memoria de bazã.

<P>
Mãsurãtorile de mai sus indicã un cache L1 de 16Kb ºi un cache L2
de 512Kb.

<P>
Rata de transfer nu descreºte subit la paliere ci se degradeazã pe
mãsurã ce ocupãm mai mult din cache pentru cã programul însuºi
ºi sistemul de operare folosesc pãrþi din cache, care concureazã
pentru spaþiu în cache cu matricea <TT>array</TT>.  Efectul este însã
destul de pronunþat.

<P>

<H2><A NAME="SECTION03014000000000000000">
<EM>Write back</EM> sau <EM>write through</EM>?</A>
</H2>

<P>
Atunci cînd procesorul scrie date, ce se întîmplã cu cache-ul?  La
întrebarea asta atît de simplã existã o multitudine de rãspunsuri
posibile.

<P>
Prima alegere pe care o are de fãcut un designer este între a
pãstra valoarea scrisã numai în cache (asta se numeºte <EM>write-back</EM>) sau de a propaga simultan valoarea scrisã în nivelul
urmãtor al ierarhiei de memorie (<EM>write-through</EM>).

<P>
Avantajul metodei din urmã este cã în fiecare clipã ºtim cã ceea
ce se gãseºte în cache la o anumitã adresã este o copie fidelã a
ceea ce se gãseºte în memorie (copiile sunt <EM>coerente</EM>).  Asta
simplificã oarecum lucrurile cînd avem de-a face cu mai multe
microprocesoare care acceseazã aceeaºi memorie; de asemenea avem
certitudinea cã în cazul cînd anumite cuvinte sunt scoase din cache
pentru a face loc altora valoarea lor nu mai trebuie salvatã în
nivelul inferior.

<P>
Pe de altã parte write-through nu poate scrie mai repede decît poate
absorbi nivelul urmãtor din ierarhia de memorii (e clar: pe o
ºosea nu pot intra mai multe maºini decît ies decît pentru foarte
puþin timp).

<P>
Am rescris testul anterior astfel:

<P>
<PRE>
#define ACCES(a) (*(a) = 0);

....

void atinge(void) {
    int i, a;
    for (i=0; i &lt; TRANSFER/sizeof(unitate); i++)
        a += de_transferat.array[i];
    dummy = 0;
}

int main(void)
{ 
     for (...) { /* ca mai sus */
          atinge(); 
          .... /* ca mai sus */
     } 
}
</PRE>

<P>
Am schimbat macro-ul <TT>ACCES</TT> pentru a scrie în loc de a citi.
În plus am scris o funcþie micã, numitã <TT>atinge()</TT>, care
citeºte fiecare cuvînt din array înainte de a face mãsurãtoarea.
Vom vedea în secþiunea urmãtoare de ce vrem sã atingem fiecare
cuvînt înainte de a mãsura.

<P>
Iatã ºi rezultatele:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="RIGHT">Octeþi</TD>
<TD ALIGN="CENTER" COLSPAN=1>MB/s</TD>
<TD ALIGN="CENTER" COLSPAN=1>Cicli/cuvînt</TD>
</TR>
<TR><TD ALIGN="RIGHT">512</TD>
<TD ALIGN="RIGHT">849.79</TD>
<TD ALIGN="RIGHT">1.20</TD>
</TR>
<TR><TD ALIGN="RIGHT">1024</TD>
<TD ALIGN="RIGHT">873.34</TD>
<TD ALIGN="RIGHT">1.17</TD>
</TR>
<TR><TD ALIGN="RIGHT">2048</TD>
<TD ALIGN="RIGHT">856.00</TD>
<TD ALIGN="RIGHT">1.19</TD>
</TR>
<TR><TD ALIGN="RIGHT">4096</TD>
<TD ALIGN="RIGHT">861.86</TD>
<TD ALIGN="RIGHT">1.18</TD>
</TR>
<TR><TD ALIGN="RIGHT">8192</TD>
<TD ALIGN="RIGHT">857.57</TD>
<TD ALIGN="RIGHT">1.19</TD>
</TR>
<TR><TD ALIGN="RIGHT">16384</TD>
<TD ALIGN="RIGHT">855.45</TD>
<TD ALIGN="RIGHT">1.19</TD>
</TR>
<TR><TD ALIGN="RIGHT">32768</TD>
<TD ALIGN="RIGHT">237.11</TD>
<TD ALIGN="RIGHT">4.31</TD>
</TR>
<TR><TD ALIGN="RIGHT">65536</TD>
<TD ALIGN="RIGHT">237.07</TD>
<TD ALIGN="RIGHT">4.31</TD>
</TR>
<TR><TD ALIGN="RIGHT">131072</TD>
<TD ALIGN="RIGHT">237.05</TD>
<TD ALIGN="RIGHT">4.31</TD>
</TR>
<TR><TD ALIGN="RIGHT">262144</TD>
<TD ALIGN="RIGHT">213.34</TD>
<TD ALIGN="RIGHT">4.79</TD>
</TR>
<TR><TD ALIGN="RIGHT">524288</TD>
<TD ALIGN="RIGHT">158.02</TD>
<TD ALIGN="RIGHT">6.46</TD>
</TR>
<TR><TD ALIGN="RIGHT">1048576</TD>
<TD ALIGN="RIGHT">88.88</TD>
<TD ALIGN="RIGHT">11.50</TD>
</TR>
<TR><TD ALIGN="RIGHT">2097152</TD>
<TD ALIGN="RIGHT">76.19</TD>
<TD ALIGN="RIGHT">13.41</TD>
</TR>
<TR><TD ALIGN="RIGHT">4194304</TD>
<TD ALIGN="RIGHT">75.29</TD>
<TD ALIGN="RIGHT">13.57</TD>
</TR>
</TABLE>
</DIV>

<P>
Din nou avem trei paliere dar, exceptîndu-l pe primul, performanþa
este substanþial mai micã.  Cu toate acestea putem afirma cã cele
douã nivele sunt write-back.  De ce?  Dacã L1, de pildã, era
write-through, am fi avut exact aceeaºi ratã de transfer pentru tot
domeniul 512 octeþi -- 512 Kb.

<P>
De ce e rata de scriere mai micã decît cea de citire?  Sunt mai
multe posibile motive la mijloc:

<P>

<UL>
<LI>Pentru cã datele sunt modificate, atunci cînd o valoare este
scoasã din cache pentru a aduce o alta ea trebuie ºi salvatã în
nivelul urmãtor din ierarhia de memorie.  Cu alte cuvinte, cînd
scriu octetul cu numãrul 32768, octetul cu numãrul 0 trebuie salvat
din cache-ul L1 în L2.  Scrierea va implica deci douã acþiuni: o
scriere din L1 în L2 în paralel cu o scriere din microprocesor în
L1;

<P>
</LI>
<LI>În general citirea se poate implementa mai rapid.  De ce?
Atunci cînd vreau sã citesc de la adresa X din memorie, trebuie
fãcute urmãtoarele operaþii:

<P>

<OL>
<LI>Din adresa X se extrage posibila adresã a octetului din cache;
</LI>
<LI>Adresa octetului care se aflã în cache în acel loc (tag-ul)
este comparatã cu X;
</LI>
<LI>Dacã în cache se aflã într-adevãr octetul de la adresa X
octetul este transferat spre microprocesor.  Altfel este iniþiatã o
citire din nivelul urmãtor al ierarhiei.
</LI>
</OL>

<P>
Diferenþa între citire ºi scriere este cã la citire paºii 2 ºi 3
de mai sus pot fi iniþiaþi simultan.  Pentru scriere însã paºii 2
ºi 3 trebuie efectuaþi strict unul dupã altul.

<P>
</LI>
<LI>Statistic s-a constatat cã în general citirile din memorie
sunt cam de 4 ori mai frecvente decît scrierile (de exemplu codul
programului însuºi este de obicei imutabil; este doar citit de
microprocesor ºi niciodatã modificat).  Din cauza asta proiectanþii
optimizeazã procesorul pentru a face citirile mai rapid.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION03015000000000000000">
<EM>Write allocate on write miss</EM>?</A>
</H2>

<P>
O altã alegere pe care o pot face proiectanþii este dacã atunci
cînd se scrie într-un cuvînt care <EM>nu</EM> se aflã în cache
cuvîntul trebuie adus în cache sau scrierea trebuie fãcutã direct
în nivelul urmãtor.  Dacã cuvîntul este totuºi adus, cache-ul se
cheamã ``write-allocate on write miss'', din motive evidente.  Altfel
cache-ul se numeºte ``write-around''.  În general, un cache
write-through este ºi write-around ºi invers, un cache write-back
este write-allocate.

<P>
Pentru a verifica ipoteza este suficient sã scoatem din programul
anterior apelul funcþiei <TT>atinge()</TT>; mãsurãtorile ne confirmã
cã Pentium are un cache write-allocate pentru cã performanþa este
foarte asemãnãtoare.

<P>

<H2><A NAME="SECTION03016000000000000000">
I-cache ºi D-cache</A>
</H2>

<P>
O întrebare la care este mult mai greu de rãspuns este dacã existã
unul sau douã cache-uri separate pentru program ºi date.  Modul de
acces la instrucþiuni este foarte diferit de modul de acces la date,
aºa cã are sens ca douã cache-uri diferite sã se ocupe de cele
douã zone diferite.  În plus, în general, datele ºi codul sunt
puse în memorie în zone complet diferite.

<P>
Pentru a putea rãspunde la aceastã întrebare ar trebui sã scriem
un program care se auto-modificã ºi care poate controla propria sa
aºezare în memorie; treaba este posibilã dar relativ încîlcitã,
aºa cã o lãsãm ca un exerciþiu pentru cititorul cu înclinaþii
de hacker. 

<P>
O cãutare pe serverul de web de la Intel ne va indica faptul cã
existã douã cache-uri L1, ambele de 16K, unul pentru cod ºi unul
pentru date.  Numele tradiþionale sunt I-cache (instruction-cache)
ºi D-cache (data-cache).

<P>
L2 este însã un cache <EM>unificat</EM>: 512K pentru ambele foloase.

<P>

<H2><A NAME="SECTION03017000000000000000">
Asociativitatea cache-ului</A>
</H2>

<P>
Gradul de asociativitate al unui cache aratã cît de uºor poate fi
localizat un cuvînt în cache.  Cele mai simple cache-uri (numite
<EM>direct-mapped</EM>) cautã un cuvînt într-un mod foarte simplu:
ignorã primii biþi din adresã ºi indexeazã în cache cu adresa
obþinutã.  Dacã mãrimea cache-ului este M, atunci toate
cuvintele de memorie aflate la o adresã de forma kM + o, cu k
întreg, se vor afla în acelaºi loc în cache, la adresa o
(desigur, nu toate simultan; cel mult unul dintre ele la un moment
dat).  Cache-urile directe sunt foarte simplu de construit, sunt mici
(ca circuite hardware) ºi foarte rapide.

<P>
Varianta alternativã este ca un cuvînt din memorie sã se poatã
afla într-unul din mai multe locuri din cache.  Dacã avem un cache
de mãrime  <EM>asociativ pe n cãi</EM><A NAME="tex2html4"
HREF="#foot213"><SUP>4</SUP></A> atunci existã n locuri în care un
cuvînt de la o adresã se poate afla.  ªi anume cuvîntul de la adresa X
se poate afla la oricare din adresele multiple de X mod (M/n).

<P>
De exemplu pentru M=16 (ridicol de mic), n=4, cuvîntul de la
adresa 1 din memorie se poate afla în cache în oricare din adresele
1, 5, 9 ºi 13.

<P>
Un cache asociativ este mult mai flexibil decît unul direct.  De
exemplu, în cache-ul asociativ de mai sus, se pot afla simultan
cuvintele din memorie de la adresele 1 ºi 17, pe cînd într-un cache
direct cu aceeaºi capacitate M=16 nu.

<P>
Cache-ul extrem, pentru care n=M, se numeºte <EM>complet
asociativ</EM> (fully associative).  Cu cît gradul de asociativitate
(n) creºte, cu atît complexitatea circuitului creºte.  Cu
tehnologia curentã este complet ne-practic de implementat în
hardware un cache complet asociativ mai mare de 256 de cuvinte.

<P>
Din aceastã raþiune la Pentium II cache-ul L1 este asociativ pe 4
cãi, iar L2 este direct.  Cum am aflat asta?  Am scris un mic test
care încearcã sã-l ghiceascã pe n.  Ne-am bazat exact pe
observaþia de mai sus.

<P>
Pentru cache-ul ipotetic de mai sus, cu M=16, am putea face
urmãtoarele teste:

<P>

<UL>
<LI>Cît de repede putem citi octeþii 1 ºi 17?
</LI>
<LI>Cît de repede putem citi octeþii 1, 17, 17+16=33, 17+32=49?
</LI>
<LI>etc.
</LI>
</UL>

<P>
Dacã primul test indicã o ratã de transfer la fel de mare ca
transferul unor date consecutive, atunci ºtim cã n &gt;= 2, pentru cã
1 ºi 17 încap simultan înauntru.  Dacã viteza este substanþial
mai micã ºtim însã cã n = 2.

<P>
Dacã n &gt;= 2, al doilea test ne va spune dacã n &gt;= 4 în exact
acelaºi fel.  Aþi prins ideea?

<P>
<PRE>
/* masurarea asociativitatii cache-ului L1 */

#define L1 (16 * 1024)   /* tocmai am masurat astea */
#define L2 (512 * 1024)

int ASOC;
int BLOC;

void asociativitate(void)
{
    register int i;
    register unitate a;
    register unitate *b = (unitate*)de_transferat.array;
    for (i=ASOC; i &gt; 0; i--) {
        ACCES64(b);
        b += BLOC;
    }
    dummy = a;
}
 
 
void asociativitate_ajustare(void)
{
    register int i;
    register unitate a;
    register unitate *b = (unitate*)de_transferat.array;
    for (i=ASOC; i &gt; 0; i--) {
        b += BLOC;
    }
    dummy = a;
}

int main(void)
{
     int i;
     double Mhz, durata_ciclu;

     init_etime();
     Mhz = mhz(0.02);
     durata_ciclu = 1.0 / Mhz / 1e6;
     printf("Frecventa ceasului este %gMhz\n", Mhz);

     BLOC = L1;
     for (i=1; i &lt;= 16; i &lt;&lt;= 1) {
         double t;

         ASOC = i;
         t = ftime(asociativitate, 0.01, 0) 
             - ftime(asociativitate_ajustare, 0.01, 0);
         printf("Distanta %d, %2.2cicli/cuvint\n", 
                ASOC, t / durata_ciclu / ASOC / UNROLL);
     } 
     return 0;
}
</PRE>

<P>
Testele mãsoarã cuvinte aflate la <TT>BLOC</TT> octeþi unul de altul
în RAM, cuvinte despre care ºtim cã se vor bate pe aceeaºi linie
din cache.  Fãcînd pe <TT>BLOC = L1</TT> mãsurãm asociativitatea lui
L1 (ºi similar pentru L2).  Încercãm felurite asociativitãþi,
toate puteri ale lui 2.  Ne oprim la 16 în programul de mai sus, dar
dacã asta nu e suficient putem continua testele.

<P>
Rezultatele numerice pentru L1 sunt urmãtoarele:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="RIGHT">Distanþa</TD>
<TD ALIGN="CENTER" COLSPAN=1>cicli/cuvînt</TD>
</TR>
<TR><TD ALIGN="RIGHT">1</TD>
<TD ALIGN="RIGHT">1.12</TD>
</TR>
<TR><TD ALIGN="RIGHT">2</TD>
<TD ALIGN="RIGHT">1.10</TD>
</TR>
<TR><TD ALIGN="RIGHT">4</TD>
<TD ALIGN="RIGHT">1.47</TD>
</TR>
<TR><TD ALIGN="RIGHT">8</TD>
<TD ALIGN="RIGHT">2.14</TD>
</TR>
<TR><TD ALIGN="RIGHT">16</TD>
<TD ALIGN="RIGHT">2.12</TD>
</TR>
</TABLE>
</DIV>

<P>
Asta ne confirmã într-adevãr cã avînd un asociativitatea
cache-ului L1 este 4.

<P>
Cum putem mãsura asociativitatea cache-ului L2 fãrã a fi
încurcaþi de faptul cã L1 este asociativ el însuºi?  Trebuie sã
controlãm accesele în aºa fel încît rateurile sã se producã ºi
în L1 ºi în L2, deºi L1 va încerca sã pãstreze cît mai multe
date.  

<P>
Din moment ce ºtim deja asociativitatea lui L1 am scris un program
care încarcã toate cele 4 linii unde se poate afla o adresã în L1,
dupã care referã o altã linie care se bate cu prima pentru o linie
în L2.  Rezultatul aratã cam aºa:

<P>
<PRE>
/* masurarea asociativitatii cache-ului L2 */

void asociativitate_L2(void)
{
    register int i;
    register unitate a;
    register unitate *b = (unitate*)de_transferat.array;
    for (i=ASOC; i &gt; 0; i--) {
        ACCES16(b);
        ACCES16(b+L1);
        ACCES16(b+L1+L1);
        ACCES16(b+L1+L1+L1);
        b+=L2;
    }
    dummy = a;
}
 
 
void asociativitate_L2_ajustare(void)
{
    register int i;
    register unitate a;
    register unitate *b = (unitate*)de_transferat.array;
    for (i=ASOC; i &gt; 0; i--) {
        b += L2;
    }
    dummy = a;
}

int main() { /* etc. */ }
</PRE>

<P>
A trebuit sã mãresc MAXTRANSFER la 17Mb ca sã nu ies din marginile
array-ului (cînd <TT>ASOC = 8</TT>, 8 cuvinte la 512Kb distanþa
înseamnã 16Mb).  Mãsurãtorile au arãtat cã pentru L2 gradul de
asociativitate este 1, deci cu alte cuvinte L2 este direct-mapped.

<P>

<H2><A NAME="SECTION03018000000000000000">
Cache-ul victimã</A>
</H2>

<P>
Cache-urile asociative costã foarte mult; cu cît creºte gradul de
asociativitate cu atît complexitatea hardware este mai mare, dar cu
atît performanþele pe o gamã largã de programe vor fi mai bune.
Proiectanþii de cache-uri au gãsit o soluþie ingenioasã care
rezolvã cazuri patologice de acces la memorie cu un cost minim.
Ideea este de a adãuga unui cache asociativ pe <IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.png"
 ALT="$n$"> cãi un cache
extrem de mic (pînã în 10 cuvinte, poate chiar unul singur), dar
complet asociativ.  Atunci cînd un cuvînt este evacuat din cache-ul
primar el va fi pus în acest ``depozit'' în speranþa cã va fi
folosit din nou în curînd.  Acest minuscul cache se numeºte, din
motive, sper evidente, cache-victimã.  Simulãrile aratã cã pentru
o gamã largã de programe cache-ul victimã este extrem de eficace
în a reduce rateurile care nu pot fi evitate de gradul de
asociativitate.  Faþã de costul redus al hardware-ului beneficiile
sale sunt remarcabile.

<P>
Pentium II este un procesor foarte modern, deci este destul de
plauzibil sã fie echipat cu un cache-victimã pentru L1.  Cum putem
sã determinãm dacã e adevãrat ºi sã mãsurãm capacitatea sa?

<P>
Simplu: ne bazãm chiar pe observaþia precedentã, cum cã acest
cache este folosit pentru a þine informaþiile care scapã din
memoria asociativã.  Atunci vom concepe un test care face din ce în
ce mai multe cuvinte sã se batã pentru cache-ul victimã, pînã
cînd vom observa o degradare a performanþei.

<P>
De data asta nu avem voie sã atingem mai multe cuvinte consecutive;
trebuie sã citim exact 5, 6, 7, etc. cuvinte care se bat pe aceeaºi
linie, iar atunci cînd observãm o degradare a performanþei putem
trage concluzia cã am depãºit capacitatea victimei.

<P>
<PRE>
Testul pentru cache-ul victima:
         __________   
        |__________|  ^ 
        |__________|  | grad de asociativitate
        |__________|  v
        |__________|  ^ bataie pentru victima
        |__________|  v
</PRE>

<P>
Primul test pe care l-am fãcut, cu 5 cuvinte, a arãtat deja o
descreºtere substanþialã a ratei de transfer, deci am tras
concluzia ca Pentium de fapt nu are cache victimã.

<P>
<PRE>
/* Masurarea cache-ului victima */
void victima(void)
{
    register unitate a;
    register unitate *b = (unitate*)de_transferat.array;
    ACCES(b);
    ACCES(b+L1);
    ACCES(b+L1+L1);
    ACCES(b+L1+L1+L1);
    ACCES(b+L1+L1+L1+L1);
    dummy = a;
}
 
void victima_ajustare(void)
{
    register unitate a;
    register unitate *b = (unitate*)de_transferat.array;
    dummy = a;
}

int main(void)
{
    /* etc. */
    t = ftime(victima, 0.01, 0) - ftime(victima_ajustare, 0.01, 0);
    printf("%2.2fcicli/cuvint\n", t / durata_ciclu / 5);
}
</PRE>

<P>

<H2><A NAME="SECTION03019000000000000000">
Mãrimea liniei din cache</A>
</H2>

<P>
Din motive de economie ºi localitate octeþii din cache nu sunt
independenþi, ci sunt grupaþi în <EM>blocuri</EM> sau <EM>linii</EM>.
Astfel, dacã unul dintre octeþii dintr-un bloc este referit de
cãtre procesor, toþi ceilalþi octeþi din linie sunt ºi ei aduºi
în cache.  Economia care se obþine în acest fel este de etichete de
adresa (tags): toþi octeþii dintr-o linie au aceeaºi etichetã.

<P>
(La scriere lucrurile pot varia: unele procesoare pot suporta
modificarea ºi salvarea numai unora dintre octeþii dintr-o linie).

<P>
Cum putem mãsura mãrimea liniei?  În ceea ce priveºte L2 nu am
reuºit sã concep un test suficient de discriminator, mai ales pentru
cã probabil linia din L2 este mai micã decît cea din L1, deci
nu pot sã evit interferenþele!  Cititorul care concepe un test este
rugat sã mi-l aducã la cunoºtinþã.

<P>
Mãrimea liniei din L1 poate fi determinatã dupã cum aratã
urmãtoarea figurã:

<P>

<P>
<PRE>
Determinarea marimii liniei de cache L1:
                     _ ...
                    |_| ^
                    |_| | ASOC (grad de asociativitate
                    |_| |           incluzind victima)
       _............|_|.v.
      |_|..............
      &lt;---LINIE-------&gt;
       ^
       | Se bate octetul asta cu cei ``verticali'' pentru o linie?
       Daca da, atunci marimea liniei este cel putin LINIE, altfel
       marimea este mai mica.
</PRE>

<P>
Testul acesta trebuie fãcut cu grijã, pentru cã dacã o linie este
mai mare decît bus-ul pe care se transportã datele nu toþi octeþii
dintr-o linie vor veni deodatã.  De exemplu dacã linia din L1 are 16
octeþi (128 de biþi) ºi dacã transferul între L2 ºi L1 se face
pe cîte 64 de biþi, o linie trebuie adusã de fapt în doi paºi.

<P>
Mãsurãtoarea pe care am pus-o la cale se desfãºoarã astfel: pun
un cuvînt în cache, si dupã aia accesez alte 4 cuvinte.  Dacã
linia octetului cu pricina concureazã cu liniile celorlalþi 4 am o
idee despre lungimea liniei.

<P>
Iatã ºi programul:

<P>
<PRE>
int LINIE;
 
void linie(void)
{
    register unitate *b = (unitate*)de_transferat.array;
    register unitate a;
    ACCES(b);
    ACCES(b+LINIE);
    ACCES(b+LINIE+L1);
    ACCES(b+LINIE+L1+L1);
    ACCES(b+LINIE+L1+L1+L1);
    dummy = a;
}


void linie_ajustare(void)
{
    register unitate a = 0;
    dummy = a;
}

int main(void)
{
     /* init etc. */
     for (LINIE=20; LINIE &gt;= 1; LINIE-=1) {
         double t;
 
         t = ftime(linie, 0.01, 0) - ftime(linie_ajustare, 0.01, 0);
         printf("Linie %d, %2.2fciclii/cuvint\n",
                LINIE, t / durata_ciclu / 5);
     }
}
</PRE>

<P>
Iatã rezultatele:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="RIGHT">Linie</TD>
<TD ALIGN="CENTER" COLSPAN=1>cicli/cuvînt</TD>
<TD ALIGN="RIGHT">Linie</TD>
<TD ALIGN="CENTER" COLSPAN=1>cicli/cuvînt</TD>
</TR>
<TR><TD ALIGN="RIGHT">20</TD>
<TD ALIGN="RIGHT">2.29</TD>
<TD ALIGN="RIGHT">10</TD>
<TD ALIGN="RIGHT">2.32</TD>
</TR>
<TR><TD ALIGN="RIGHT">19</TD>
<TD ALIGN="RIGHT">2.26</TD>
<TD ALIGN="RIGHT">9</TD>
<TD ALIGN="RIGHT">2.32</TD>
</TR>
<TR><TD ALIGN="RIGHT">18</TD>
<TD ALIGN="RIGHT">2.29</TD>
<TD ALIGN="RIGHT">8</TD>
<TD ALIGN="RIGHT">3.44</TD>
</TR>
<TR><TD ALIGN="RIGHT">17</TD>
<TD ALIGN="RIGHT">2.32</TD>
<TD ALIGN="RIGHT">7</TD>
<TD ALIGN="RIGHT">4.44</TD>
</TR>
<TR><TD ALIGN="RIGHT">16</TD>
<TD ALIGN="RIGHT">2.57</TD>
<TD ALIGN="RIGHT">6</TD>
<TD ALIGN="RIGHT">3.27</TD>
</TR>
<TR><TD ALIGN="RIGHT">15</TD>
<TD ALIGN="RIGHT">2.57</TD>
<TD ALIGN="RIGHT">5</TD>
<TD ALIGN="RIGHT">3.22</TD>
</TR>
<TR><TD ALIGN="RIGHT">14</TD>
<TD ALIGN="RIGHT">2.29</TD>
<TD ALIGN="RIGHT">4</TD>
<TD ALIGN="RIGHT">3.36</TD>
</TR>
<TR><TD ALIGN="RIGHT">13</TD>
<TD ALIGN="RIGHT">2.32</TD>
<TD ALIGN="RIGHT">3</TD>
<TD ALIGN="RIGHT">3.39</TD>
</TR>
<TR><TD ALIGN="RIGHT">12</TD>
<TD ALIGN="RIGHT">2.29</TD>
<TD ALIGN="RIGHT">2</TD>
<TD ALIGN="RIGHT">3.36</TD>
</TR>
<TR><TD ALIGN="RIGHT">11</TD>
<TD ALIGN="RIGHT">2.35</TD>
<TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="RIGHT">&nbsp;</TD>
</TR>
</TABLE>
</DIV>

<P>
Valorile obþinute sugereazã dimensiunea liniei de 8* <TT>sizeof(unitate)</TT> = 32 de octeþi = 128 de biþi.  Valorile sunt
relativ mari pentru cã execut numai 5 instrucþiuni de citire în
întreaga buclã, deci nu amortizez suficient costul buclei (ca mai
înainte prin ``unrolling'').

<P>

<H2><A NAME="SECTION030110000000000000000">
Cache-uri blocante</A>
</H2>

<P>
Închei acest articol cu o provocare pentru cititor.  Mãsurãtori
fãcute de mine indicã faptul cã cache-ul Pentium nu este blocant.
Va invit sã verificaþi aceastã aserþiune.

<P>
Procesoarele moderne pot lansa în execuþie mai multe instrucþiuni,
care adesea opereazã asupra unor date diferite.  În acest caz ar fi
detrimental performanþei ca în momentul în care o instrucþiune dã
un rateu în cache toate celelalte sã fie forþate sã aºtepte.  Un
cache ne-blocant permite execuþia altor instrucþiuni în timp ce
serveºte din memoria lentã rateul uneia.  În felul acesta se poate
întîmpla ca datele cerute de douã instrucþiuni sã soseascã în
ordine inversã cererilor!

<P>
Cache-urile ne-blocante sunt niºte dispozitive hardware extrem de
sofisticate.  Dar atunci cînd ai 15 milioane de tranzistori la
dispoziþie (cît conþine Pentium II) nu te dai în lãturi de la
nimic pentru o creºtere a performanþei în execuþie.

<P>

<H1><A NAME="SECTION03020000000000000000">
Concluzii</A>
</H1>

<P>
Calculatoarele sunt niºte sisteme din ce în ce mai complicate;
miniaturizarea ºi tehnologiile înalte au permis realizarea fizicã a
unor sisteme extrem de sofisticate.  Balanþa dintre pãrþile
componente este în continuã schimbare: dacã în urmã cu 20 de ani
viteza de acces a memoriilor ºi viteza de calcul a procesoarelor erau
relativ egale, în ziua de azi procesoarele evolueazã cu o ratã de
creºtere a performanþei de 55% pe an, fa't'a de memorii care cresc
cu numai 7% 'in aceea'si perioad'a.  Designerii sunt deci for'ta'ti
sã inventeze tot felul de noi dispozitive care sã creascã
performanþa întregului sistem (care tinde sã fie la fel de lent ca
cea mai lentã componentã).  

<P>
Din cauza asta mãsurarea performanþei unui sistem este crucialã
pentru a înþelege ce îmbunãtãþiri trebuie aduse.  Adesea
mãsurãtorile se pot face numai indirect, ºi sunt influenþate de o
multitudine de parametri independenþi.  Proiectarea unor mãsurãtori
interesante ºi interpretarea rezultatelor devin adevãrate
meºteºuguri.

<P>
Una peste alta, arhitecþii calculatoarelor nu vor rãmîne prea
curînd ºomeri.

<P>
A-propos, ce meserie v-aþi ales?

<P>

<P>

<H1><A NAME="SECTION03030000000000000000">
Derivarea duratei de execuþie</A>
</H1>

<P>
Pentru început vom calcula valoarea minimã ºi maximã a timpului
real de execuþie în funcþie de valoarea timpului mãsurat ºi de
precizia ceasului.

<P>
Sã facem urmãtoarele notaþii:

<UL>
<LI><IMG
 WIDTH="21" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$\Delta$">: rezoluþia ceasului sistemului de operare;
</LI>
<LI><IMG
 WIDTH="23" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$T_s$">: timpul de pornire al mãsurãtorii, cum e raportat de
<code>get_etime()</code>;
</LI>
<LI><IMG
 WIDTH="25" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$T_f$">: timpul final al mãsurãtorii, raportat de
<code>get_etime()</code>;
</LI>
<LI><IMG
 WIDTH="19" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img19.png"
 ALT="$T$">: timpul mãsurat de execuþie;
</LI>
<LI><IMG
 WIDTH="19" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img20.png"
 ALT="$t_s$">: timpul real de pornire (``timp absolut'': Newtonian);
</LI>
<LI><IMG
 WIDTH="21" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img21.png"
 ALT="$t_f$">: timpul real final;
</LI>
<LI><IMG
 WIDTH="12" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.png"
 ALT="$t$">: timpul real de execuþie;
</LI>
</UL>

<P>
ªtim cã urmãtoarele relaþii sunt adevãrate:
<P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{eqnarray*}
T_s \leq &t_s& < T_s + \Delta \\
T_f \leq &t_f& < T_f + \Delta
\end{eqnarray*}
 -->
<IMG
 WIDTH="157" HEIGHT="61" BORDER="0"
 SRC="img23.png"
 ALT="\begin{eqnarray*}
T_s \leq &amp;t_s&amp; &lt; T_s + \Delta \\
T_f \leq &amp;t_f&amp; &lt; T_f + \Delta
\end{eqnarray*}">
<BR CLEAR="ALL"></DIV><P></P>
<BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>

<P>
Atunci:
<P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{eqnarray*}
t = t_f - t_s &<& T_f + \Delta - T_s = T + \Delta \\
t = t_f - t_s &>& T_f - (T_s + \Delta) = T - \Delta
\end{eqnarray*}
 -->
<IMG
 WIDTH="303" HEIGHT="61" BORDER="0"
 SRC="img24.png"
 ALT="\begin{eqnarray*}
t = t_f - t_s &amp;&lt;&amp; T_f + \Delta - T_s = T + \Delta \\
t = t_f - t_s &amp;&gt;&amp; T_f - (T_s + \Delta) = T - \Delta
\end{eqnarray*}">
<BR CLEAR="ALL"></DIV><P></P>
<BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>

<P>
Deci avem:

<P>
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
T - \Delta < t < T + \Delta
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="tT"></A><IMG
 WIDTH="149" HEIGHT="31" BORDER="0"
 SRC="img25.png"
 ALT="\begin{displaymath}
T - \Delta &lt; t &lt; T + \Delta
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(1)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
Acum vom demonstra urmãtoarea relaþie între <IMG
 WIDTH="19" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img19.png"
 ALT="$T$">, <IMG
 WIDTH="21" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$\Delta$"> ºi
eroarea maximã relativã doritã <IMG
 WIDTH="13" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\epsilon$">: <!-- MATH
 $T \geq
\frac{1+\epsilon}{\epsilon} \Delta$
 -->
<IMG
 WIDTH="83" HEIGHT="41" ALIGN="MIDDLE" BORDER="0"
 SRC="img26.png"
 ALT="$T \geq
\frac{1+\epsilon}{\epsilon} \Delta$">.

<P>
Fie <IMG
 WIDTH="16" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="$k$"> un întreg pozitiv astfel încît <IMG
 WIDTH="66" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.png"
 ALT="$T = k \Delta$">; putem
presupune fãrã a pierde din generalitate cã avem <IMG
 WIDTH="48" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img28.png"
 ALT="$k \neq 1$">.
Din <A HREF="masuri-html.html#tT">1</A> avem

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
T - \Delta < t < T + \Delta \Leftrightarrow \\
- \Delta < t - T < \Delta.
\end{displaymath}
 -->

<IMG
 WIDTH="317" HEIGHT="31" BORDER="0"
 SRC="img29.png"
 ALT="\begin{displaymath}
T - \Delta &lt; t &lt; T + \Delta \Leftrightarrow \\
- \Delta &lt; t - T &lt; \Delta.
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
Împãrþind prin <IMG
 WIDTH="66" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.png"
 ALT="$T = k \Delta$"> avem:

<P>
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
- \frac{1}{k} < \frac{t - T}{T} < \frac{1}{k}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="eq1"></A><IMG
 WIDTH="128" HEIGHT="45" BORDER="0"
 SRC="img30.png"
 ALT="\begin{displaymath}
- \frac{1}{k} &lt; \frac{t - T}{T} &lt; \frac{1}{k}
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(2)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
Termenul din mijloc este chiar eroarea relativã pe care vrem s-o
mãrginim.  Acum exprimãm eroarea relativã ca funcþie de raportul
<!-- MATH
 $r = \frac{t-T}{T}$
 -->
<IMG
 WIDTH="67" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$r = \frac{t-T}{T}$">:

<P>
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\frac{t-T}{t} =  \frac{(t-T)/T}{t/T} = \frac{r}{1 - r}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="eq2"></A><IMG
 WIDTH="209" HEIGHT="51" BORDER="0"
 SRC="img32.png"
 ALT="\begin{displaymath}
\frac{t-T}{t} = \frac{(t-T)/T}{t/T} = \frac{r}{1 - r}
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(3)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
Din ecuaþiile <A HREF="masuri-html.html#eq1">2</A> and <A HREF="masuri-html.html#eq2">3</A> obþinem:
<P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{eqnarray*}
\frac{t-T}{t} & < & \frac{1/k}{1 - 1/k} = \frac{1}{k-1} \\
\frac{t-T}{t} & > & \frac{-1/k}{1 - 1/k} = -\frac{1}{k - 1}.
\end{eqnarray*}
 -->
<IMG
 WIDTH="232" HEIGHT="98" BORDER="0"
 SRC="img33.png"
 ALT="\begin{eqnarray*}
\frac{t-T}{t} &amp; &lt; &amp; \frac{1/k}{1 - 1/k} = \frac{1}{k-1} \\
\frac{t-T}{t} &amp; &gt; &amp; \frac{-1/k}{1 - 1/k} = -\frac{1}{k - 1}.
\end{eqnarray*}">
<BR CLEAR="ALL"></DIV><P></P>
<BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>

<P>
sau 

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
\left|\frac{t-T}{t}\right| < \frac{1}{k-1}.
\end{displaymath}
 -->

<IMG
 WIDTH="123" HEIGHT="48" BORDER="0"
 SRC="img34.png"
 ALT="\begin{displaymath}
\left\vert\frac{t-T}{t}\right\vert &lt; \frac{1}{k-1}.
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
Pentru cã vrem ca eroarea relativã sã fie mãrginitã de
<IMG
 WIDTH="13" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\epsilon$">, trebuie sã avem:
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
\frac{1}{k-1} \leq \epsilon \Leftrightarrow
k \geq \frac{1+\epsilon}{\epsilon} \Leftrightarrow
T \geq \frac{1 + \epsilon}{\epsilon} \Delta.
\end{displaymath}
 -->

<IMG
 WIDTH="295" HEIGHT="46" BORDER="0"
 SRC="img35.png"
 ALT="\begin{displaymath}
\frac{1}{k-1} \leq \epsilon \Leftrightarrow
k \geq \frac{1+\...
...} \Leftrightarrow
T \geq \frac{1 + \epsilon}{\epsilon} \Delta.
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
QED.

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot151">... Satyanarayanan</A><A NAME="foot151"
 HREF="masuri-html.html#tex2html1"><SUP>1</SUP></A>
<DD>Cea mai cunoscutã
realizare a sa este sistemul de fiºiere distribuit numit Andrew File
System, iniþial dezvoltat la universitatea Carnegie Mellon,
actualmente vîndut de compania Transarc, o filialã IBM.  Un derivat
AFS numit Episode este sistemul de fiºiere de bazã din mediul de
calcul distribuit (DCE: Distributed Computing Environment) al
organizaþiei OSF (Open Software Foundation).

<DT><A NAME="foot154">...
1997</A><A NAME="foot154"
 HREF="masuri-html.html#tex2html2"><SUP>2</SUP></A>
<DD>Textul articolului este disponibil în pagina de web a
autorului.

<DT><A NAME="foot157">...
Stanford</A><A NAME="foot157"
 HREF="masuri-html.html#tex2html3"><SUP>3</SUP></A>
<DD>Berkeley ºi Stanford sunt clasate între primele 4
universitãþi din Statele Unite în privinþa cercetãrii în
domeniul calculatoarelor.

<DT><A NAME="foot213">... cãi</EM></A><A NAME="foot213"
 HREF="masuri-html.html#tex2html4"><SUP>4</SUP></A>
<DD>Întotdeauna <IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.png"
 ALT="$n$">
divide pe <IMG
 WIDTH="25" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$M$">.

</DL>
<BR><HR>

</BODY>
</HTML>
