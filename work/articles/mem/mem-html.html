<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Alocarea memoriei în nucleul sistemului de operare</TITLE>
<META NAME="description" CONTENT="Alocarea memoriei în nucleul sistemului de operare">
<META NAME="keywords" CONTENT="mem-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Alocarea memoriei în nucleul sistemului de operare</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- mihaib+ at cs.cmu.edu 
<BR><TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>17 decembrie 1998</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>alocarea memoriei: feluriþi algoritmi
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>programare în C, structuri de date
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>alocator, memorie, colectare de deºeuri,
performanþã, nucleu
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html39"
  HREF="mem-html.html">Alocarea memoriei</A>
<LI><A NAME="tex2html40"
  HREF="#SECTION00030000000000000000">Limbaje ºi alocarea de memorie</A>
<UL>
<LI><A NAME="tex2html41"
  HREF="#SECTION00031000000000000000">Alocarea în limbajul C</A>
</UL>
<BR>
<LI><A NAME="tex2html42"
  HREF="#SECTION00040000000000000000">Caracteristici ale alocatoarelor</A>
<UL>
<LI><A NAME="tex2html43"
  HREF="#SECTION00041000000000000000">Timp pe operaþie (cazul cel mai defavorabil)</A>
<LI><A NAME="tex2html44"
  HREF="#SECTION00042000000000000000">Timp amortizat</A>
<LI><A NAME="tex2html45"
  HREF="#SECTION00043000000000000000">Fragmentare</A>
<LI><A NAME="tex2html46"
  HREF="#SECTION00044000000000000000">Grad de utilizare</A>
<LI><A NAME="tex2html47"
  HREF="#SECTION00045000000000000000">Simplitate</A>
<LI><A NAME="tex2html48"
  HREF="#SECTION00046000000000000000">Concurenþã</A>
</UL>
<BR>
<LI><A NAME="tex2html49"
  HREF="#SECTION00050000000000000000">Alocarea staticã</A>
<LI><A NAME="tex2html50"
  HREF="#SECTION00060000000000000000">Consumatori de memorie</A>
<UL>
<LI><A NAME="tex2html51"
  HREF="#SECTION00061000000000000000">Programele utilizatorilor</A>
<LI><A NAME="tex2html52"
  HREF="#SECTION00062000000000000000">Nucleul: alocarea de memorie</A>
<LI><A NAME="tex2html53"
  HREF="#SECTION00063000000000000000">Nucleul: alocarea de spaþiu pe disc</A>
</UL>
<BR>
<LI><A NAME="tex2html54"
  HREF="#SECTION00070000000000000000">Un alocator dinamic foarte simplu</A>
<LI><A NAME="tex2html55"
  HREF="#SECTION00080000000000000000">Alocatorul cu hartã de resurse</A>
<LI><A NAME="tex2html56"
  HREF="#SECTION00090000000000000000">Alocatorul cu puteri ale lui 2</A>
<LI><A NAME="tex2html57"
  HREF="#SECTION000100000000000000000">Alocatorul Karels-McKusick</A>
<LI><A NAME="tex2html58"
  HREF="#SECTION000110000000000000000">Alocatorul ``slab''</A>
<LI><A NAME="tex2html59"
  HREF="#SECTION000120000000000000000">Concluzii</A>
</UL>
<!--End of Table of Contents-->
<BR>
<BR>

<P>
``640 de kiloocteþi trebuie sã fie îndeajuns pentru oricine''.
Aceasta este probabil cea mai faimoasã gafã a lui Bill Gates,
pronunþatã cîndva pe la începutul anilor '80.  Enunþul este cu
atît mai amuzant cu cît compania lui Gates, Microsoft, produce
niºte programe uriaºe, pentru care resursele calculatoarelor
contemporane, care au evoluat într-o ratã greu de imaginat, nu sunt
suficiente.

<P>
Dacã lucrurile ar fi stat aºa, atunci articolul de faþã nu ar mai
fi fost scris.  Dar rata de creºtere a programelor este comparabilã
cu cea a capacitãþilor memoriilor; pe de altã parte <EM>datele</EM>
prelucrate de programe devin din ce în ce mai mari; audio, video,
multimedia sunt mari consumatoare de spaþiu.

<P>
Dacã lucrurile ar fi stat aºa cum prevedea Gates, atunci sistemele
de operare însele ar fi dispãrut, sau ar fi arãtat substanþial
diferit de cele din ziua de azi; aceasta este tot o ironie, pentru cã
Microsoft îºi menþine dominaþia în arena mondialã a software-ului
prin monopolul pe care îl are asupra sistemelor de operare pentru
calculatoare personale.  De ce spun cã sistemele de operare ar fi
dispãrut?  Pentru cã rolul principal al unui sistem de operare este
cel de management al resurselor unui calculator, în particular de
management al memoriei.  Dacã resursele ar fi prezente din
abundenþã, atunci necesitatea unui manager ar fi mult mai puþin
stringentã.

<P>

<H1><A NAME="SECTION00020000000000000000">
Alocarea memoriei</A>
</H1>

<P>
Ce este de fapt alocarea memoriei?  Calculatorul posedã din
fabricaþie o anumitã cantitate de memorie (RAM).  În memorie vor fi
încãrcate mai multe programe ºi datele prelucrate de ele: nucleul
sistemului de operare, datele acestuia, programele utilizatorilor ºi
datele asupra cãrora acestea opereazã, datele citite de la
dispozitivele periferice, pachetele de date care vin ºi merg în
reþeaua în care calculatorul este conectat, bibliotecile încãrcate
dinamic, etc.  O singurã bucatã mare de memorie (RAM-ul) trebuie
împãrþitã între toate aceste entitãþi lacome, în aºa fel
încît sã nu se incomodeze unele pe altele.  Entitatea care
gestioneazã memoria, þine contabilitatea zonelor ocupate ºi a celor
libere, care satisface cererile pentru noi zone ºi care
re-utilizeazã zonele eliberate este alocatorul de memorie.

<P>
Alocarea memoriei este de obicei o treabã ierarhicã; la baza
ierarhiei se aflã sistemul de operare, care are la dispoziþie
întregul RAM.  Sistemul de operare dã feluritelor programe ale
utilizatorilor porþiuni de memorie.  La rîndul lor, fiecare din
programe gestioneazã bucãþica primitã de la nucleu pentru nevoile
sale interne.

<P>
În acest text ne vom concentra asupra alocatorului de memorie din
nucleele sistemelor de operare de tip Unix, dar vom privi superficial
ºi asupra unor alte alocatoare.  Un tratament excelent al subiectului
puteþi gãsi în capitolul 12 din cartea ``Unix Internals'', de Uresh
Vahalia, publicatã în anul 1996 de editura Prentice Hall.  Am
folosit unele dintre prezentãrile din acea carte în scrierea acestui
articol.

<P>

<H1><A NAME="SECTION00030000000000000000">
Limbaje ºi alocarea de memorie</A>
</H1>

<P>
O clasificare a limbajelor din punctul de vedere al alocãrii memoriei
le împarte în trei categorii:

<P>

<OL>
<LI>Limbaje care nu pot aloca dinamic memorie.  Din aceastã
categorie fac parte cele mai ancestrale limbaje: Cobol, Fortran.  În
aceste limbaje (cel puþin în versiunile lor iniþiale), utilizatorul
nu poate aloca dinamic memorie de loc în momentul execuþiei
programului; toatã memoria necesarã trebuie sã fie alocatã
înainte ca programul sã porneascã în execuþie.

<P>
</LI>
<LI>Limbaje cu alocare ºi dealocare explicitã.  Limbaje ca Pascal,
C ºi C++ îi permit utilizatorului sã cearã pe parcursul execuþiei
noi zone de memorie ºi sã returneze memoria folositã.  Utilizatorul
apeleazã pentru acest scop niºte <EM>funcþii de bibliotecã</EM>.
Aceste funcþii au fost implementate de cel care a scris compilatorul
pentru limbajul respectiv.  Aceste funcþii cer de la sistemul de
operare o bucatã mare de memorie pe care apoi o împart dupã
necesitãþi; atunci cînd toatã bucata este consumatã cer o alta de
la nucleu.  În Pascal funcþiile cu pricina sunt <TT>new</TT> ºi <TT>free</TT>, în C <TT>malloc</TT> ºi <TT>free</TT> iar în C++ <TT>new</TT> ºi
<TT>delete</TT>.  Ca funcþionare sunt extrem de similare; funcþiile din
Pascal ºi C++ folosesc tipul obiectelor alocate pentru a deduce
cîtã memorie este necesarã (de exemplu programatorul zice: ``vreau
memorie pentru un vector de 10 întregi''); programatorii în C
trebuie sã indice explicit de cîtã memorie au nevoie (ex.: ``dã-mi
ºi mie 40 de octeþi'').

<P>
</LI>
<LI>Limbaje cu colectoare de gunoaie (<EM>garbage collection</EM>).
Lisp ºi Java folosesc un mecanism extrem de interesant, prin care
utilizatorul nu specificã niciodatã cînd vrea sã elibereze o zonã
de memorie (adicã <TT>free()</TT> nu existã); compilatorul ºi un
sistem de funcþii care se executã simultan cu programul (runtime
system) deduc singure care dintre zone sunt nenecesare ºi le
recupereazã.  Lisp-ul aparent este un limbaj în care nu existã nici
mãcar alocare dinamicã (o funcþie de gen <TT>new</TT>); în realitate
în Lisp fiecare obiect nou creat este automat alocat într-o zonã de
memorie nouã, fãrã ca utilizatorul sã trebuiascã sã specifice
asta (de exemplu cînd utilizatorul concateneazã douã liste, atunci
sistemul alocã automat spaþiu pentru lista rezultat).

<P>
Din anumite puncte de vedere, tehnica colectãrii de gunoaie este cea
mai preferabilã.  Principalul ei avantaj este cã scuteºte
utilizatorul de pericolul de a folosi zone de memorie nealocate,
prevenind astfel apariþia unor bug-uri extrem de greu de depanat.
Avantajele ei nu se opresc aici: împreunã cu o disciplinã de tipuri
strictã, colectarea deºeurilor face demonstrarea automatã a
corectitudinii programelor o sarcinã mult mai simplã: un demonstrator
de teoreme va fi întotdeauna sigur cã o zonã de memorie folositã
nu este dealocatã.

<P>
Pe de altã parte, colectarea de gunoaie are anumite dezavantaje: este
impredictibilã ca timp consumat (adicã nu e clar în ce moment al
execuþiei programului se va petrece), ºi este <EM>conservativã</EM>.
Întrebarea dacã o anumitã zonã de memorie va mai fi sau nu
folositã de un program în viitor este în general o chestiune <EM>nedecidabilã</EM>; asta înseamnã cã nu se poate scrie nici un algoritm
care sã rãspundã la o astfel de întrebare, chiar dacã are
informaþii complete despre programul analizat ºi despre datele lui
de intrare.  Din cauza aceasta este posibil ca un program cu colectare
automatã sã pãstreze alocate zone de memorie care sunt în
realitate inutile, pentru cã sistemul nu are cum sã demonstreze
acest lucru.
</LI>
</OL>

<P>
În acest articol vom vorbi mai ales despre sisteme de tipul
intermediar, cu alocare ºi dealocare explicitã.  Motivele sunt
multiple.  În primul rînd majoritatea alocatoarelor din nucleele
sistemelor de operare comerciale sunt de acest tip<A NAME="tex2html1"
  HREF="#foot67"><SUP>1</SUP></A>.  În al doilea rînd, chiar implementarea unui alocator
cu colector va folosi idei de genul celor prezente în alocatoarele
explicite.  ªi în al treilea rînd, colectarea gunoaielor este un
subiect ceva mai dificil.

<P>

<H2><A NAME="SECTION00031000000000000000">
Alocarea în limbajul C</A>
</H2>

<P>
Nucleele sistemelor de operare comerciale sunt toate scrise în C,
inclusiv alocatoarele de memorie din biblioteci; din cauza aceasta vom
privi mai îndeaproape funcþiile acestui limbaj.

<P>
Programatorul în C are la dispoziþie funcþiile <TT>malloc</TT> ºi
prietenii ei (<TT>calloc, realloc</TT>) pentru a aloca memorie, ºi
funcþia <TT>free</TT> pentru a o elibera.  <TT>calloc</TT> ºi <TT>realloc</TT> pot fi scrise folosind <TT>malloc</TT>, aºa cã nu le vom da
prea mare atenþie.  Prototipurile acestor funcþii se aflã în
fiºierul header <TT>&lt;stdlib.h&gt;</TT> din biblioteca standard C, prezentã
pe orice sistem.

<P>
Funcþia <TT>malloc</TT> are un singur argument: numãrul de octeþi care
trebuie alocaþi.  Rezultatul funcþiei este un pointer generic (<TT>void*</TT>) spre zona alocatã.  Dacã <TT>malloc</TT> nu gãseºte destulã
memorie, atunci rezultatul apelului ei este pointerul cu valoarea 0
(<TT>NULL</TT>).

<P>
Funcþia <TT>free()</TT> are tot un singur argument, ºi nici un
rezultat.  Argumentul ei este un pointer obþinut de la un <TT>malloc</TT> anterior; efectul executãrii ei este eliberarea zonei de
memorie aflatã în acel loc.

<P>
Biblioteca în care sunt implementate <TT>malloc</TT> ºi <TT>free</TT>
menþine o pleiadã de structuri de date indicînd unde se aflã
zonele libere ºi unde cele ocupate.  Observaþi de pildã cã <TT>free</TT> nu primeºte nici un fel de informaþii despre cît de mare este
zona dealocatã; biblioteca trebuie deci sã ºtie acest lucru.

<P>
În cazul sistemului de operare Unix aceste funcþii de bibliotecã
sunt implementate folosind un apel de sistem<A NAME="tex2html2"
  HREF="#foot85"><SUP>2</SUP></A> numit <TT>sbrk</TT>.  Figura&nbsp;<A HREF="mem-html.html#malloc">1</A>
ilustreazã relaþia dintre aceste funcþii.  Apelul de sistem are la
ca argument cantitatea cerutã de memorie (pozitivã sau negativã);
efectul executãrii apelului este adãugarea <EM>la sfîrºitul
segmentului de date</EM> al programului a unei cantitãþi de memorie
egale cu cea cerutã.

<P>
În mod normal <TT>malloc</TT> executã un <TT>sbrk</TT> la început pentru
a obþine o cantitate mare de memorie, ºi apoi la fiecare apel
returneazã utilizatorului cîte o bucãþicã din bucata mare.  Dacã
dupã o vreme întreaga bucatã mare devine ocupatã, atunci <TT>malloc</TT> executã un nou <TT>sbrk</TT>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="malloc"></A><A NAME="228"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Funcþiile pentru alocarea memoriei.  <TT>malloc/free</TT> sunt funcþii de bibliotecã folosite de utilizator.  Ele
obþin memorie de la nucleul sistemului de operare folosind funcþia
<TT>sbrk</TT>.</CAPTION>
<TR><TD><IMG
 WIDTH="179" HEIGHT="160" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=4cm\epsffile{malloc.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H1><A NAME="SECTION00040000000000000000">
Caracteristici ale alocatoarelor</A>
</H1>

<P>
Existã o sumedenie de feluri de alocatoare diferite; în ceea ce
priveºte colectoarele ºi în ziua de azi se desfãºoarã cercetãri
care îmbunãtãþesc performanþa.  Iatã aici cîteva criterii dupã
care putem evalua calitatea unui alocator.

<P>

<H2><A NAME="SECTION00041000000000000000">
Timp pe operaþie (cazul cel mai defavorabil)</A>
</H2>

<P>
Prima caracteristicã este complexitatea unei operaþii de
alocare/dealocare.  În mod normal un alocator trebuie sã execute un
numãr constant de operaþii pentru fiecare funcþiune.  Dar vom vedea
mai jos cã adesea în cel mai rãu caz alocatoarele trebuie sã
execute o sumedenie de instrucþiuni pentru a rãspunde la o singurã
cerere.  De exemplu alocatorul cu hartã de resurse, prezentat mai
jos, ar putea sã aibã nevoie sã parcurgã întreaga listã de
blocuri de memorie neocupate pentru a gãsi unul de mãsura
potrivitã.  Asta înseamnã cã, cu cît e mai multã memorie
disponibilã, cu atît execuþia unui apel de alocare/dealocare poate
fi mai costisitoare (pentru cã lista va fi mai lungã).

<P>

<H2><A NAME="SECTION00042000000000000000">
Timp amortizat</A>
</H2>

<P>
O mãsurã interesantã a costului unei alocãri este <EM>timpul
amortizat</EM> pentru o operaþie de alocare.  De exemplu dacã cele mai
multe operaþii de alocare dureazã 1ms, dar la fiecare 500 de
operaþii costul execuþiei este de 200ms, atunci costul amortizat
este de (499*1 + 1*200)/500 = 1.39ms pe operaþie (costul în cazul
cel mai rãu ar fi 200).

<P>
Sistemele cu colectare de gunoaie au de obicei un timp amortizat mic
pentru fiecare operaþie, dar din cînd în cînd (atunci cînd
colectorul porneºte în execuþie), anumite operaþii dureazã foarte
mult.  Acesta este cazul sistemelor LISP obiºnuite.

<P>
Pentru cã nucleul unui sistem de operare trebuie sã facã faþã
unor cereri extrem de severe, în general alocatoarele din nuclee
trebuie sã aibã cazul cel mai defavorabil relativ mic.  Exista
alocatoare care primesc niºte indicaþii despre urgenþa operaþiei:
dacã cel care are nevoie de memorie nu se grãbeºte, algoritmul
îºi poate permite sã petreacã mai mult timp; altfel trebuie sã
rãspundã cît se poate de repede.

<P>
De exemplu nucleul trebuie sã primeascã pachete de date din reþea;
atunci cînd un pachet îºi face apariþia, nucleul nu poate sã
aºtepte prea mult pentru a gãsi un loc în care sã-l depoziteze,
pentru cã nu are unde sã punã pachetul între timp.  Dacã nucleul
nu reuºeºte sã obþinã un buffer pentru o stoca pachetul, atunci
de obicei pachetul este pur ºi simplu pierdut (asta se numeºte <EM>buffer overrun</EM>).  Cel care a transmis pachetul iniþial va trebui
sã trimitã o copie.

<P>

<H2><A NAME="SECTION00043000000000000000">
Fragmentare</A>
</H2>

<P>
Alocatoarele se mai confruntã cu o problemã neplãcutã: aproape
niciodatã nu pot folosi întreaga memorie disponibilã, pentru cã
mici fragmente ``se pierd'' fãrã a putea fi folosite.

<P>
Aceste pierderi apar din cauzã cã consumatorii de memorie doresc
bucãþi de memorie de mãrimi variate, care sunt greu de pus cap la
cap în memoria disponibilã.  În funcþie de interfaþa
alocatorului, existã douã tipuri de pierderi.  Pentru cã pierderile
apar din cauza împãrþirii spaþiului disponibil în fragmente,
aceastã problemã se numeºte <EM>fragmentare</EM>.  Existã douã
feluri de fragmentare: internã ºi externã.

<P>

<H3><A NAME="SECTION00043100000000000000">
Fragmentarea externã</A>
</H3>

<P>
Tabela&nbsp;<A HREF="#fragmentare">1</A> aratã un posibil scenariu de cereri de
alocare/dealocare ºi evoluþia memoriei în timp.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="220"></A>
<TABLE>
<CAPTION><STRONG>Table 1:</STRONG>
Fragmentarea externã apare datoritã
gãurilor apãrute între zone de memorie ºi care sunt prea mici
pentru a fi folosite.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">
timp </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">   cerere </FONT></TD>
<TD ALIGN="CENTER" COLSPAN=5><FONT SIZE="-1"> starea memoriei</FONT></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
     </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">          </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 0 </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 10 </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 15 </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 25 </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 35 </FONT></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
0    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">          </FONT></TD>
<TD ALIGN="CENTER" COLSPAN=5><FONT SIZE="-1"> liber</FONT></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
1 </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> x = aloca(10) </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXXXXXX </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> </FONT></TD>
<TD></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
2 </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> y = aloca(5)  </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXXXXXX </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXX </FONT></TD>
<TD></TD>
<TD></TD>
<TD></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
3 </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> z = aloca(10) </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXXXXXX </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXX </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXXXXXXX </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> </FONT></TD>
<TD></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
4 </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> dealoca(y)    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXXXXXX </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXXXXXXX </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> </FONT></TD>
<TD></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
5 </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> w = aloca(10) </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXXXXXX </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXXXXXXX </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> XXXXXXXXX </FONT></TD>
<TD></TD>
<TD></TD>
</TR>
</TABLE></DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Fenomenul se petrece la momentul 4: dealocãm un bloc de memorie de 5
octeþi cuprins între alte douã blocuri.  Dupã aceea alocãm unul
de zece; cei cinci octeþi nu sunt suficienþi, aºa cã în acel loc
rãmîne o ``gaurã''.  Astfel de gãuri apar din ce în ce mai multe,
ºi scad în dimensiune (de exemplu dacã am aloca apoi 3 octeþi în
gaura de 5 am rãmîne cu o gaurã de 2 octeþi).  Dupã o vreme
gãurile practic nu mai pot fi folosite, dar consumã în total o
sumedenie de spaþiu.  Acest gen de fragmentare se numeºte ``extern''
pentru cã risipa apare între blocurile alocate.

<P>
Se demonstreazã cã atunci cînd avem de-a face cu alocãri de
blocuri de mãrimi diferite, fragmentarea externã este inevitabilã.
Singurul mod în care putem repara ceva este de a muta blocuri dintr-o
parte într-alta, <EM>compactînd</EM> spaþiul liber.  Dar aceasta este
o operaþie extrem de costisitoare ca timp, care în anumite
condiþii este imposibilã (de exemplu atunci cînd muþi ceva din
memorie trebuie sã corectezi valorile tuturor pointerilor din program
care puncteazã la acel obiect; pentru un limbaj ca C acest lucru este
imposibil).  LISP ºi Java folosesc uneori compactarea spaþiului
ocupat.  

<P>
Tot compactare fac ºi programele care defragmenteazã discurile
pentru a creºte performanþa accesului la fiºiere.  

<P>

<H3><A NAME="SECTION00043200000000000000">
Fragmentarea internã</A>
</H3>

<P>
Acest tip de alocare este folosit adesea pentru alocarea spaþiului pe
discurile magnetice, ºi pentru alocarea memoriei virtuale pentru
procese.

<P>
Singurul mod în care putem evita fragmentarea externã este de a
aloca toate obiectele de exact aceeaºi mãrime.  În acest caz orice
``gaurã'' între douã obiecte poate fi folositã pentru un alt
obiect.  Cînd consumatorul vrea 10 sau 50 de octeþi, tot 100 îi dai
(de exemplu).  Asta duce la risipã în interiorul fiecãrui ``bloc''
alocat; aceasta este fragmentarea internã.

<P>
Structurile de date ºi algoritmii pentru alocarea blocurilor de
mãrimi egale sunt mult mai simple ºi omogene (se pot chiar
implementa parþial în hardware).  Din cauza asta practic toate
sistemele de operare moderne alocã memoria virtualã în termeni de
<EM>pagini</EM>, care au în jur de 4 kiloocteþi fiecare.

<P>

<H2><A NAME="SECTION00044000000000000000">
Grad de utilizare</A>
</H2>

<P>
Pe lîngã faptul cã spaþiul se fragmenteazã, alocatorul însuºi
menþine propriile structuri de date pentru gestiune.  Aceste
structuri ocupã loc adiþional, reducînd utilizarea efectivã a
memoriei.  De pildã, nucleele au o tabelã a paginilor din RAM, în
care memoreazã cum este utilizatã fiecare paginã.  Pentru fiecare
paginã din RAM nucleul menþine la Pentium 4 octeþi suplimentari;
asta înseamnã o risipã de 1 la mie.

<P>

<H2><A NAME="SECTION00045000000000000000">
Simplitate</A>
</H2>

<P>
Interfaþa <TT>malloc/free</TT> este foarte simplã; aproape cã nu se
poate concepe ceva mai simplu.  Alte alocatoare pot avea interacþiuni
mai complicate: de exemplu ar putea permite dealocarea doar a unui
fragment dintr-o zonã alocatã anterior, ar putea cere ca <TT>free</TT>
sã indice explicit cîtã memorie trebuie dealocatã, ar putea avea
tot felul de argumente suplimentare referitoare la urgenþa alocãrii,
etc.

<P>

<H2><A NAME="SECTION00046000000000000000">
Concurenþã</A>
</H2>

<P>
În fine, o ultimã dimensiune dupã care putem compara alocatoarele
de memorie este gradul de acces concurent pe care îl permit.  Pe un
calculator cu mai multe procesoare este imaginabil cã douã
procesoare vor simultan sã aloce/dealoce memorie.  Pentru a preveni
haosul, trebuie puse anumite restricþii asupra ordinii de execuþie.
Zona de cod care alocã/dealocã este de obicei o <EM>regiune
criticã</EM>, în sensul cã nu poate fi executatã de mai multe
procesoare simultan<A NAME="tex2html5"
  HREF="#foot128"><SUP>3</SUP></A>.  Un alocator bine scris va
permite un grad mai ridicat de concurenþã, pentru a exploata mai
bine resursele computaþionale.

<P>

<H1><A NAME="SECTION00050000000000000000">
Alocarea staticã</A>
</H1>

<P>
Începînd cu aceastã secþiune, voi trece în revistã felurite
tipuri de alocatoare folosite în practicã.  În mijlocul acestei
discuþii voi insera o secþiune despre constrîngerile puse asupra
alocatoarelor.  Discuþia este departe de a fi exhaustivã; este mai
curînd ilustrativã.

<P>
Sã începem cu cel mai simplu tip de alocator, cel care...nu
existã.  În acest caz trebuie sã alocãm toate zonele de la
scrierea programului.  Metoda aceasta era folositã în versiunile
vechi de Unix, ºi este în continuare folositã pentru anumite
sisteme de fiºiere (sistemul de fiºiere din Unix, UFS, prealocã
pentru fiecare fiºier cîte un inod pe disc la momentul formatãrii
discului; numãrul acesta nu se poate apoi schimba).  În Pascal
matricile pot fi alocate numai static (adicã dimensiunile lor trebuie
sã fie cunoscute la compilare).

<P>
Marele avantaj al metodei este simplitatea.  Existã însã douã mari
dezavantaje: 

<P>

<UL>
<LI>Risipa.  Pentru cã nu ºtim dinainte cîtã memorie o sã
folosim, trebuie sã alocãm în mod conservativ mai multã decît
orice valoare posibilã.  Asta înseamnã risipã pentru majoritatea
cazurilor.  

<P>
</LI>
<LI>Depãºirea.  Chiar dacã alocãm un milion de obiecte,
programul care are nevoie de un milion unu o sã eºueze.
</LI>
</UL>

<P>

<H1><A NAME="SECTION00060000000000000000">
Consumatori de memorie</A>
</H1>

<P>
Fiecare consumator de memorie are idiosincraziile lui; contextul în
care memoria este folositã impune anumite constrîngeri asupra
implementãrii alocatorului.

<P>

<H2><A NAME="SECTION00061000000000000000">
Programele utilizatorilor</A>
</H2>

<P>
Cel mai comun consumator de memorie sunt programele utilizatorilor.
Acestea pun ºi cele mai puþine restricþii asupra alocatorului; cele
mai multe programe ale utilizatorilor nu au constrîngeri severe de
vitezã sau spaþiu, ºi ca atare pot implementa scheme foarte
complicate, cu cost mediu mai ridicat dar care au alte trãsãturi
dezirabile.

<P>

<H3><A NAME="SECTION00061100000000000000">
Niºte recomandãri</A>
</H3>

<P>
Înainte de a trece la celelalte tipuri de alocatoare, permiteþi-mi sã
fac niºte recomandãri de stil în ceea ce priveºte alocarea memoriei.
Recomandãrile sunt inspirate de indicaþiile proiectului GNU, care
produce software de foarte bunã calitate (despre proiectul GNU am
scris pe larg într-un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#open">articol</a>
din PC Report consacrat fenomenului Free Software).

<P>

<UL>
<LI>Verificaþi întotdeauna rezultatul întors de funcþiile gen
<TT>malloc</TT>.  O eroare tipicã este de a nu compara rezultatul cu 0.
Cel mai recomandabil este sã folosiþi o funcþie-``înveliº'' (<EM>wrapper</EM>); numele tradiþional al unui wrapper pentru <TT>malloc</TT>
este <TT>xmalloc</TT>, de la ``checked malloc'':

<P>
<PRE>
/* xmalloc este un wrapper pentru malloc care verifica
   rezultatele si opreste executia programului in caz
   de terminare a memoriei disponibile */

void * xmalloc(size_t size)
{
        void * r = malloc(size);
        if (!r) {
                fprintf(stderr, "Memoria virtuala este consumata\n");
                exit(1);
        }
        return r;
}
</PRE>

<P>
</LI>
<LI>Nu scrieþi niciodatã într-un buffer de o anumitã mãrime
lucruri care nu încap.  Anumite funcþii de bibliotecã, cum ar fi
<TT>fgets</TT> citesc de la un periferic un ºir de caractere într-un
buffer.  Ori, nu existã nici o limitã pentru lungimea ºirului
tastat de utilizator; oricît de mare ar fi buffer-ul, utilizatorul
poate tasta un ºir mai lung.  Majoritatea bug-urilor faimoase din
Unix sunt de acest tip; celebrul ``Internet Worm'' din 1988, care a
pus în genunchi cîteva zeci de mii de calculatoare, se baza în
propagarea sa pe un astfel de bug în programul <TT>finger</TT>, care
este folosit pentru a identifica utilizatori pe maºini aflate la
distanþã.  Folosiþi întotdeauna funcþii care limiteazã numãrul
de caractere citite, cum ar fi <TT>fgets</TT>.

<P>
</LI>
<LI>Nu folosiþi niciodatã alocarea staticã.  Corectitudinea
programelor este mai importantã decît viteza lor de execuþie.  De
fiecare datã cînd vreþi sã scrieþi ceva într-un buffer
ne-încãpãtor, realocaþi buffer-ul fãcîndu-l mai mare.

<P>
Funcþia de bibliotecã <TT>realloc</TT> face chiar acest lucru: are ca
argument un pointer ºi o nouã dimensiune.  Rezultatul este un nou
buffer, care are dimensiunea indicatã, ºi care conþine tot vechiul
conþinut al buffer-ului iniþial.

<P>
</LI>
<LI>Dacã folosiþi <TT>realloc</TT> pentru a creºte în mod repetat
un buffer, trebuie sã aveþi grijã sã nu plãtiþi un cost
amortizat prea mare pentru asta.  Costul unui <TT>realloc</TT> este
proporþional cu mãrimea buffer-ului realocat, pentru cã fiecare
octet trebuie copiat.  Din cauza asta se recomandã ca, de fiecare
datã cînd realocaþi un buffer, sã-i dublaþi lungimea, cum aratã
ºi exemplul urmãtor<A NAME="tex2html6"
  HREF="#foot221"><SUP>4</SUP></A>
<P>
<PRE>
/* Folosirea lui `realloc' pentru a mari un buffer pe masura
   datelor pe care trebuie sa le contina */

#include &lt;stdlib.h&gt;

#define DUBLEAZA 1

char *buf = 0;  /* bufferul */
int marime = 0; /* marimea curenta */
int ramas = 0;  /* spatiu liber ramas in buffer */
FILE *f = blabla; /* un fisier oarecare */

while (1) {
        int c = fgetc(f);   /* citim date dintr-un fisier intr-un buffer */
        if (c == EOF) break;
        if (!ramas) {       /* buffer-ul e plin: trebuie realocat */

                /* avem doua variante de realocare */
#if DUBLEAZA
                int marimenoua = marime ? (marime * 2) : 1;
#else
                int marimenoua = marime + 1;
#endif

                buf = realloc(buf, marimenoua);
                if (!buf) exit(1);   /* eroare fatala */
                ramas = marimenoua - marime;
                marime = marimenoua;
        }
        buf[marime - ramas] = c;
        ramas--;
}
</PRE>

<P>
O simplã analizã aratã cã dacã dublãm lungimea buffer-ului,
costul plãtit pentru a stoca k caractere este 1 + 2 + 4 + ...+
2<sup>lk</sup>, unde <!-- MATH
 $lk = \lfloor \log_2 k \rfloor$
 -->
<IMG
 WIDTH="102" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.png"
 ALT="$lk = \lfloor \log_2 k \rfloor$">.  (Plãtim un cost de 1
pentru realloc(2), 2 pentru realloc(4), etc.).  Asta este o serie
geometricã, a cãrei sumã este &lt; 2k.

<P>
Pe de altã parte, dacã mãrim buffer-ul cu o unitate la fiecare pas,
plãtim 1+2+3+...+(k-1) = k<sup>2</sup>.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION00062000000000000000">
Nucleul: alocarea de memorie</A>
</H2>

<P>
Un alt alocator se aflã în nucleul sistemului de operare.  Aºa cum
am spus deja, acest alocator gestioneazã atît spaþiul folosit în
structurile de date interne nucleului, cît ºi spaþiu necesar
proceselor care se executã.  Interacþiunea dintre variatele
alocatoare este înfãþiºatã în figura&nbsp;<A HREF="mem-html.html#interactiune">2</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="interactiune"></A><A NAME="222"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Interacþiunea dintre feluritele
alocatoare de memorie din nucleu.  Alocatorul de pagini gestioneazã
întreaga memorie fizicã a maºinii.  El genereazã spaþiu atît
pentru procese (unitatea de bazã fiind pagina), cît ºi memorie
pentru alocatorul intern al nucleului.  Sãgeþile indicã schimb de
spaþiu de memorie între componente.</CAPTION>
<TR><TD><IMG
 WIDTH="576" HEIGHT="404" BORDER="0"
 SRC="img7.png"
 ALT="\begin{figure}\begin{verbatim}Memoria RAM
^
\vert
___v_____________
\ver...
...uffere pentru retea, inoduri, tabela de procese, etc.)\end{verbatim}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Subiectul acestui articol este cutiuþa etichetatã ``alocatorul
intern al nucleului'', deºi multe din principiile indicate se aplicã
ºi celorlalte entitãþi.  Aceste alocatoare sunt mult mai
constrînse decît alocatoarele din spaþiul utilizatorului; în
particular trebuie sã aibã timpi de rãspuns foarte mici, pentru cã
pot fi chemate de pãrþi critice din nucleu.

<P>
Cele trei alocatoare interacþioneazã permanent: cînd nucleul nu mai
are destule zone pentru propriile lui date cere noi pagini de la
alocatorul de pagini.  Cînd procesele utilizatorilor mor, paginile
lor sunt preluate de alocatorul de pagini.  Cînd alocatorul de pagini
are puþine resurse disponibile, el poate cere alocatorului intern sã
returneze din memoria pe care nu o foloseºte în acel moment, etc..

<P>

<H2><A NAME="SECTION00063000000000000000">
Nucleul: alocarea de spaþiu pe disc</A>
</H2>

<P>
Un ultim mare subsistem al nucleului care se ocupã de alocarea
spaþiului este sistemul care alocã spaþiu pe disc, atît pentru
fiºiere, cît ºi pentru memoria virtualã (memoria proceselor care
sunt oprite din execuþie este uneori salvatã pe disc pentru a
permite executarea altora; aceastã tehnologie se numeºte ``memorie
virtualã'').

<P>
Alocatoarele de spaþiu pe disc au alte atribute foarte specifice; de
pildã alocatoarele care trebuie sã parcurgã o listã întreagã
pentru a gãsi spaþiul necesar sunt complet nepractice, pentru cã
accesele la disc dureazã extrem de mult (milisecunde, ceea ce
înseamnã milioane de cicli de procesor).  Despre funcþionarea
acestor alocatoare am vorbit pe scurt în alte articole din PC Report,
consacrate sistemelor de fiºiere.

<P>

<H1><A NAME="SECTION00070000000000000000">
Un alocator dinamic foarte simplu</A>
</H1>

<P>
Voi ilustra aici în scop pur didactic implementarea unui alocator
extrem de ineficient ºi risipitor, dar totodatã complet.  Aceasta
este schema de bazã de funcþionare a tuturor alocatoarelor din
nucleu; variaþiunile constau în îmbunãtãþiri.  Acest alocator
implementeazã funcþia <TT>free()</TT> fãrã a face nimic!  Memoria
eliberatã este pur ºi simplu pierdutã.  Alocatorul extrage zonele
de memorie dintr-o memorie mare alocatã static iniþial, care are 16
megaocteþi.  Puteþi folosi acest alocator în programele
dumneavoastrã! 

<P>
<PRE>
/* implementarea unui alocator dinamic foarte simplu; functia
   free() nu face absolut nimic. */

typedef unsigned int size_t;

#define MARIME_MEMORIE 16 * 1024 * 1024
char memorie[MARIME_MEMORIE];

int memorie_consumata = 0;

void * malloc(size_t marime)
{
        if (MARIME_MEMORIE &lt; marime + memorie_consumata)
                return 0;
        memorie_consumata += marime;
        return (void*) &amp;memorie[memorie_consumata - marime];
}

void free(void *)
{}
</PRE>

<P>
Acest alocator este extrem de rapid; probabil cã nici nu poate fi
scris un alocator mai rapid.  Preþul plãtit este o enormã risipã
de memorie: tot ce este dealocat se pierde complet.

<P>
Oricum, aceste funcþii ilustreazã cãrãmizile de bazã cu care un
alocator din nucleu trebuie sã opereze.  Alocatorul de pagini
manipuleazã memoria fizicã a maºinii ca un vector enorm de octeþi,
din care extrage porþiuni aºa cum facem noi cu vectorul numit <TT>memorie</TT>.

<P>

<H1><A NAME="SECTION00080000000000000000">
Alocatorul cu hartã de resurse</A>
</H1>

<P>
Acesta este probabil cel mai simplu tip de alocator care
implementeazã ºi funcþia <TT>free</TT>.  Acest alocator menþine un
vector de structuri care descriu fiecare bloc liber.
Figura&nbsp;<A HREF="mem-html.html#harta">3</A> aratã o posibilã reprezentare a situaþiei la un
moment dat:

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="harta"></A><A NAME="236"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
Alocatorul cu hartã de resurse are o
``hartã'' care indicã fiecare regiune liberã ºi ocupatã.</CAPTION>
<TR><TD><IMG
 WIDTH="384" HEIGHT="158" BORDER="0"
 SRC="img8.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8.5cm\epsffile{harta.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Avem o micã problemã, pentru cã alocatorul are nevoie el însuºi
de spaþiu pentru a reprezenta tabela cu resurse.  Putem face însã
niºte mici trucuri pentru a compacta reprezentarea:

<P>

<UL>
<LI>Cînd <TT>malloc</TT> gãseºte un bloc, foloseºte primii&nbsp;4
octeþi<A NAME="tex2html9"
  HREF="#foot175"><SUP>5</SUP></A> pentru a memora
lungimea sa ºi returneazã adresa urmãtorului octet.  Aceastã
lungime este folositã de <TT>free</TT> pentru a ºti cît de mult
trebuie dealocat.

<P>
<PRE>
        Forma unui bloc de memorie ocupat: fiecare bloc este
        precedat de 4 octe'ti care con'tin lungimea blocului.

        --------------------------------------------
        |  lungimea  |                             |
        --------------------------------------------
                      ^ 
                      \ adresa returnat'a de malloc
</PRE>

<P>
</LI>
<LI>Putem memora informaþia despre blocurile libere în chiar
spaþiul ocupat de blocurile libere!  Astfel, putem þine blocurile
libere într-o listã înlãnþuitã, ca în figura&nbsp;<A HREF="mem-html.html#lista">4</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="lista"></A><A NAME="242"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4:</STRONG>
Putem implementa alocatorul cu hartã de memorie
menþinînd în fiecare bloc liber informaþie despre lungimea proprie
(L) ºi adresa urmãtorului bloc liber (N).</CAPTION>
<TR><TD><IMG
 WIDTH="361" HEIGHT="140" BORDER="0"
 SRC="img9.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{lista.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Cînd alocatorul vrea sã gãseascã un bloc liber pleacã de la
adresa primului bloc liber ºi parcurge lista de blocuri libere pînã
gãseºte unul de dimensiune corespunzãtoare.

<P>
</LI>
</UL>

<P>
Acest alocator este relativ simplu, dar foarte ineficient.  Din cauza
fragmentãrii complexitatea operaþiilor este mare (dupã o vreme
lista de blocuri libere devine populatã cu o sumedenie de blocuri
mici, a cãror traversare este costisitoare ºi inutilã).  Schema
este de asemenea uºor risipitoare: 4 octeþi sunt memoraþi în plus
pentru fiecare bloc ocupat, iar faptul cã un bloc liber trebuie sã
conþinã douã valori impune o lungime minimã de 8 octeþi pentru un
bloc.

<P>
Eliberarea unui bloc îl insereazã la începutul listei de blocuri
libere.  Dacã vrem sã reducem fragmentarea, la eliberare putem sã
comasãm un bloc cu vecinul urmãtor, în caz cã acesta este liber
ºi el.  Dacã vrem sã putem comasa ºi cu vecinul anterior, atunci
în fiecare bloc memorãm ºi în ultimii 4 octeþi lungimea sa; în
acest fel, atunci cînd eliberãm un bloc, putem ºti exact unde
începe cel de dinainte.  În orice caz, eliberarea cere un numãr
constant de instrucþiuni (care nu depinde de numãrul de zone deja
alocate).

<P>

<H1><A NAME="SECTION00090000000000000000">
Alocatorul cu puteri ale lui 2</A>
</H1>

<P>
Problema alocatorului de mai sus constã în faptul cã trebuie sã
<EM>caute</EM> un bloc de dimensiune potrivitã.  Pentru a remedia acest
lucru putem folosi o altã reprezentare: pãstrãm o serie de liste de
blocuri, toate blocurile de pe fiecare listã avînd o anumitã
dimensiune.  Atunci cînd vrem un anumit bloc, returnãm un bloc de
dimensiunea imediat superioarã.  Cele mai folosite dimensiuni sunt
puteri ale lui 2, ca în figura&nbsp;<A HREF="mem-html.html#put2">5</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="put2"></A><A NAME="248"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5:</STRONG>
Structurile de date ale alocatorului cu puteri
ale lui 2: cîte o listã de blocuri libere pentru fiecare dimensiune
de bloc.  Fiecare bloc ocupat are informaþii despre propria sa
lungime.</CAPTION>
<TR><TD><IMG
 WIDTH="429" HEIGHT="135" BORDER="0"
 SRC="img10.png"
 ALT="\begin{figure}\centerline{\epsfxsize=9.5cm\epsffile{put2.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Acest alocator suferã de fragmentare internã, pentru cã alocã
întotdeauna mai mult decît i se cere.

<P>
Alocarea ºi dealocarea cer timp constant pe operaþiune (calculul
listei plus extragerea primului bloc din listã).  Putem reprezenta
listele de blocuri libere exact ca în schema cu harta de resurse;
comasarea este practic imposibil a (am putea comasa numai vecini de
dimensiuni egale, ca sã obþinem rezultate de mãrime tot puteri ale
lui doi).  Pentru toate blocurile mai mici de o anumitã limitã ºi
mai mari de o alta, putem avea niºte liste separate, în care facem
cãutare exhaustivã.  Dacã vrem sã avem liste cu toate dimensiunile
posibile de blocuri sunt suficiente 32 de liste, ceea ce e o valoare
rezonabilã.

<P>
În momentul în care o listã doritã este complet depopulatã, putem
scoate un bloc mai mare de pe lista imediat superioarã, pe care îl
putem sparge în douã bucãþi mai mici.

<P>
În interiorul nucleului existã multe structuri de date care au ca
dimensiuni exact puteri ale lui 2; pentru astfel de cereri se
iroseºte o cantitate enormã de memorie, pentru cã fiecare bloc
alocat trebuie sã conþinã ºi cei 4 octeþi suplimentari.  Astfel,
dacã vrem sã alocam 256 de octeþi, trebuie de fapt 260, care
înseamnã ca folosim un bloc de 512; risipa este de aproape 100%!

<P>
Alte dezavantaje ale metodei: în general blocurile mici nu se pot
grupa laolaltã pentru a forma blocuri mari, ºi sistemul de paginare
nu poate obþine pagini nefolosite înapoi în caz de nevoie.

<P>

<H1><A NAME="SECTION000100000000000000000">
Alocatorul Karels-McKusick</A>
</H1>

<P>
În 1988 Kirk McKusick ºi Michael Karels au construit o variantã
îmbunãtãþitã a alocatorului cu puteri ale lui 2, cere este
folositã acum în 4.4BSD Unix ºi Digital Unix.  Metoda lor eliminã
risipa pentru cazul blocurilor care au dimensiuni exact puteri ale
lui&nbsp;2.

<P>
Listele de blocuri libere sunt înlãnþuite exact ca în alocatorul
cu puteri ale lui 2.  Diferenþa principalã constã în modul în
care blocurile ocupate îºi reprezintã lungimea; trucul folosit este
foarte ingenios: alocatorul menþine un vector mare de numere, cîte
unul pentru fiecare paginã.  Elementul 5 din vector reprezintã
mãrimea blocurilor din pagina 5.  Figura&nbsp;<A HREF="mem-html.html#karels">6</A> aratã un
exemplu de structuri de date ale alocatorului.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="karels"></A><A NAME="254"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 6:</STRONG>
Vectorul care reprezintã mãrimea blocurilor
pentru fiecare paginã în alocatorul Karels-McKusick.  Pagina 0 este
divizatã în blocuri de cîte 32 de octeþi, pagina 1 în blocuri de
cîte 512, etc.  Paginile încã nefolosite sunt înlãnþuite într-o
lista.</CAPTION>
<TR><TD><IMG
 WIDTH="316" HEIGHT="149" BORDER="0"
 SRC="img11.png"
 ALT="\begin{figure}\centerline{\epsfxsize=7cm\epsffile{karels.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
O altã optimizare fãcutã de alocatorul acesta este modul în care
se calculeazã rotunjirea în sus a unei valori la cea mai micã
putere a lui 2; calculul este fãcut cu un macro care conþine o
expresie de genul:

<P>
<PRE>
#define LISTA(marime) \
 (marime) &gt; 128 \
        ? (marime) &gt; 256 ? 4 : 3 \
        : (marime) &gt; 64 \
                ? 2 \
                : (marime) &gt; 32 ? 1 : 0
</PRE>

<P>
Avantajul unei astfel de expresii în locul unei bucle este cã,
atunci cînd mãrimea este cunoscutã la compilare, întreaga expresie
devine o constantã care poate fi calculatã de compilator, deci codul
executat devine mult mai rapid.

<P>
Acest alocator este mai eficient decît cel cu puteri ale lui 2, ºi
risipeºte mult mai puþinã memorie, pentru cã toate cererile egale
cu o putere a lui doi sunt satisfãcute cu un buffer de mãrime
potrivitã.  Celelalte dezavantaje rãmîn însã prezente.

<P>

<H1><A NAME="SECTION000110000000000000000">
Alocatorul ``slab''</A>
</H1>

<P>
O schemã mult mai sofisticatã de alocare, inspiratã din limbajele
orientate pe obiecte a fost introdusã de Sun în sistemul de operare
Solaris 2.4 ºi este acum implementatã ºi în Linux.  ``Slab''
înseamnã în englezã ``lespede''; acest alocator are zone de
memorie diferite pentru obiecte diferite, pe care le putem vedea ca
niºte mozaicuri de forme diferite; de aici ºi numele.  Acest
alocator trateazã cu multã atenþie o serie de aspecte importante
pentru performanþã care sunt complet ignorate de alte alocatoare:

<P>

<UL>
<LI>Alocatorul încearcã atunci cînd cautã noi zone sã nu
atingã prea multe locaþii de memorie, pentru a nu polua cache-ul
microprocesorului cu date care nu sunt utile; se spune cã alocatorul
are o ``urmã'' micã (<EM>small footprint</EM>);

<P>
</LI>
<LI>Alocatorul încearcã sã aloce obiectele în memorie în aºa
fel încît douã obiecte diferite sã nu pice în aceeaºi linie din
cache-ul de date; asta maximizeazã utilizarea cache-ului cînd
obiectele sunt folosite simultan.  De exemplu obiectul care
reprezintã în nucleu un fiºier are cîteva cîmpuri care sunt
foarte des folosite, aflate sã zicem la începutul structurii, ºi
alte cîteva cîmpuri care sunt extrem de rar folosite.  Sã
presupunem cã obiectul ``fiºier'' are 256 de octeþi; în acest caz
toate cîmpurile des folosite din toate fiºierele se vor afla la
adrese multiplu de 256.  Din cauza asta ele se vor lupta pentru un set
restrîns de linii din cache, în vreme ce celelalte linii vor fi
prost utilizate.  Alocatorul slab va încerca sã aloce fiecare
obiect la o adresã care nu e multiplu de aceeaºi valoare.

<P>
</LI>
<LI>Alocatorul încearcã sã reducã numãrul de operaþii de
iniþializare asupra noilor obiecte alocate.  De exemplu multe obiecte
din nucleu care pot fi folosite de mai multe procese au un cîmp care
indicã numãrul de utilizatori (de pildã un fiºier memoreazã
numãrul de procese care au deschis fiºierul).  Cînd acest numãr
ajunge 0, înseamnã cã obiectul nu mai este utilizat, ºi el poate
fi dealocat.  Asta înseamnã cã avem certitudinea cã orice fiºier
dealocat va avea valoarea 0 în acel cîmp.  Atunci cînd alocãm un
nou fiºier, dacã folosim vechea zonã de memorie, ºtim deci cã nu
mai trebuie sã iniþializãm acest cîmp, pentru cã are deja
valoarea corectã!  Practic nucleul menþine un cache cu obiecte de
curînd dealocate, pe care le foloseºte atunci cînd i se cer noi
alocãri.
</LI>
</UL>

<P>
Alocatorul slab constã de fapt într-o rutinã centralã (numitã
<TT>kmem_cache_create</TT>) care creazã alocatoare pentru fiecare
obiect.  Rutina asta primeºte ca parametri numele obiectului,
mãrimea unui obiect, constrîngerile de aliniere (de ex. toate
obiectele trebuie sã fie la o adresã multiplu de 16) ºi pointeri
spre o funcþie constructor ºi o funcþie destructor.

<P>
Iatã un exemplu de utilizare:

<P>
<PRE>
alocator_de_fisiere = kmem_cache_create("fisier", sizeof(struct fisier),
                                        8, constructor_fisier,
                                        destructor_fisier);

alocator_de_inoduri = kmem_cache_create("inod", sizeof(struct inod),
                                        4, constructor_inod,
                                        destructor_inod);

struct fisier * fs = kmem_cache_alloc(alocator_de_fisiere, FLAGS);
struct inod * in = kmem_cache_alloc(alocator_de_inoduri, FLAGS);
</PRE>

<P>
Funcþia <TT>kmem_cache_create</TT> creazã deci alocatoare pentru
felurite obiecte.  Fiecare alocator este apoi folosit pentru a
construi obiecte de acel tip.

<P>
Fiecare alocator are propria lui zonã de memorie, în care menþine
numai obiecte de acel tip; va exista astfel o zonã de pagini în care
se alocã numai fiºiere, o zonã în care se alocã numai inoduri,
etc.  În acest fel toate obiectele dintr-o zonã au aceeaºi
dimensiune!

<P>
Fiecare alocator menþine de asemenea o listã cu obiectele care au
fost de curînd dealocate, ºi le refoloseºte atunci cînd i se cer
noi obiecte.  Pentru cã obiectele au fost dealocate, ele nu mai
trebuie sa fie iniþializate din nou.

<P>
Atunci cînd un alocator epuizeazã toatã memoria pe care o are la
dispoziþie, el cere de la alocatorul de pagini o nouã paginã pe care
o umple cu obiecte noi.  Pentru cã aceste obiecte nu au fost
niciodatã iniþializate, alocatorul cheamã funcþia constructor care
a fost indicatã pentru fiecare nou obiect.  Observaþi cã acest
constructor este chemat numai prima oarã cînd pagina este
obþinutã; dupã ce un obiect a fost dealocat constructorul nu mai
este chemat din nou.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="slab"></A><A NAME="260"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 7:</STRONG>
Alocatorul ``slab''.  Fiecare obiect are propriul
lui alocator, care menþine în pagini obiectele alocate ºi libere.
În fiecare paginã primul obiect alocat începe la altã adresã,
pentru a încãrca uniform liniile din cache-ul microprocesorului.
Fiecare paginã mai posedã anumite structuri de date folosite la
întreþinere (cum ar fi o listã dublu înlãnþuitã a tuturor
paginilor pentru un anumit obiect).</CAPTION>
<TR><TD><IMG
 WIDTH="497" HEIGHT="318" BORDER="0"
 SRC="img12.png"
 ALT="\begin{figure}\centerline{\epsfxsize=11cm\epsffile{slab.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Fiecare alocator foloseºte propriile lui pagini într-un mod similar
cu alocatorul cu puteri ale lui doi.  La sfîrºitul fiecãrei pagini
alocatorul rezervã o zonã pentru o structurã de date care descrie
ocupaþia acelei pagini.  Primul obiect în paginã este plasat la o
distanþã aleatoare de marginea pagini; acest plasament are efectul
de a pune obiecte din pagini diferite la adrese diferite în cache,
exact cum am indicat mai sus.

<P>
Alocatorul slab poate returna sistemului de paginare paginile în care
toate obiectele sunt nefolosite.  Alocatorul are o ``urmã'' micã,
pentru cã majoritatea cererilor acceseazã o singurã paginã.  Acest
tip de alocator risipeºte ceva resurse datoritã modului de plasare
în paginã ºi pentru cã are o zonã diferitã pentru fiecare tip de
obiect.  Performanþa lui este însã excelentã, ºi rãmîne unul
din cele mai puternice alocatoare implementate.

<P>

<H1><A NAME="SECTION000120000000000000000">
Concluzii</A>
</H1>

<P>
Alocarea memoriei este un subiect foarte generos, care suscitã în
continuare interes cercetãtorilor.  Gestiunea memoriei este un din
funcþiile principale ale unui sistem de operare.  Nucleul unui sistem
de operare gestioneazã întreaga memorie fizicã a unui calculator;
el oferã memorie atît sieºi (nucleului), pentru funcþionarea sa,
cît ºi proceselor executate de utilizatori.  Procesele
utilizatorilor gestioneazã la rîndul lor bucãþelele primite de la
nucleu.

<P>
Dacã subiectul vã intereseazã mai aveþi multe de aflat în
domeniu.  Dacã nu, sper sã-i alocaþi mãcar 2-3 neuroni în memoria
dumneavoastrã.  Alegeþi un algoritm în acest scop.

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot67">... tip</A><A NAME="foot67"
 HREF="mem-html.html#tex2html1"><SUP>1</SUP></A>
<DD>Cu toate
acestea, sistemele Mach ºi Digital Unix (fost OSF/1), care este bazat
pe Mach, au o formã primitivã de colector chiar în interiorul
nucleului.

<DT><A NAME="foot85">... sistem</A><A NAME="foot85"
 HREF="mem-html.html#tex2html2"><SUP>2</SUP></A>
<DD>Apelurile de
sistem sunt funcþii puse la dispoziþia programelor de cãtre nucleul
sistemului de operare.

<DT><A NAME="foot128">... simultan</A><A NAME="foot128"
HREF="mem-html.html#tex2html5"><SUP>3</SUP></A> <DD>Explicaþii mai
ample despre conceptul de regiune criticã am dat într-o serie de
articole (<a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#nucleu">(1)</a>,
<a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#linux">(2)</a>,
mai vechi din PC Report despre sistemele de operare; copiile
articolelor sunt disponibile din pagina mea de web.

<DT><A NAME="foot221">... ator</A><A NAME="foot221"
 HREF="mem-html.html#tex2html6"><SUP>4</SUP></A>
<DD>Anumite implementãri mai vechi de C nu
vor executa corect acest program, pentru cã ºtiu ce sã facã atunci
cînd funcþia <TT>realloc</TT> primeºte un argument 0, prima oarã
cînd e chematã.  Conform standardului C însã, acest program este
corect.

<DT><A NAME="foot175">... ti</A><A NAME="foot175"
 HREF="mem-html.html#tex2html9"><SUP>5</SUP></A>
<DD>Valoarea 4 este plauzibilã pentru maºini pe 32 de
biþi; lungimea ar putea avea nevoie de mai mulþi biþi pe maºini
care suportã mai mult de 4Go de spaþiu de adrese.

</DL>
<BR><HR>

</BODY>
</HTML>
