<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Verificarea automatã a programelor</TITLE>
<META NAME="description" CONTENT="Verificarea automatã a programelor">
<META NAME="keywords" CONTENT="metacompilare-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Verificarea automatã a programelor</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>octombrie 2001</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html23"
  HREF="metacompilare-html.html">Bug-uri în Linux</A>
<LI><A NAME="tex2html24"
  HREF="#SECTION00030000000000000000">Testare ºi verificare</A>
<LI><A NAME="tex2html25"
  HREF="#SECTION00040000000000000000">Proiectul ``Meta-Compilation'' (MC)</A>
<LI><A NAME="tex2html26"
  HREF="#SECTION00050000000000000000">Inferenþa automatã a regulilor de testat</A>
<LI><A NAME="tex2html27"
  HREF="#SECTION00060000000000000000">Concluzii</A>
<LI><A NAME="tex2html28"
  HREF="#SECTION00070000000000000000">Alte surse de informaþie</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Pe data de 8 august 2000 pe lista de e-mail numitã ``Linux kernel'',
care este folositã de cãtre cei care meºteresc la nucleul
sistemului de operare Linux pentru a comunica între ei, a apãrut un
mesaj care descria o serie de potenþiale probleme (bug-uri) din
nucleu, trimis de Dawson Engler, un proaspãt profesor la
universitatea Stanford.  Pe aceastã listã se vehiculeazã adesea
rapoarte de defecþiuni, aºa cã unul în plus nu pare ceva deosebit.
Mesajul cu pricina însã conþinea nu una, douã, sau chiar zece
erori, ci peste 160!  ªi mai interesant, toate aceste potenþiale
erori au fost descoperite automat, folosind un program care studiazã
codul ºi cautã inadvertenþe.  În final nu toate rapoartele s-au
dovedit a fi defecþiuni, dar multe dintre ele erau într-adevãr
bug-uri importante.

<P>
Acest mesaj de poºtã electronicã este probabil cea mai
``vizibilã'' aplicare a unei tehnologii încã relativ imature, dar
care face progrese remarcabile, numitã <EM>verificare formalã</EM>.
Verificarea formalã este folositã pe scarã relativ largã, dar mai
ales de cãtre proiectanþii de hardware; multe din circuitele
procesoarelor moderne au fost certificate ca fiind corecte folosind
verificarea formalã.  O cercetare febrilã se desfãºoarã pentru a
adapta metodele dezvoltate pentru hardware ºi la analiza programelor;
software-ul are însã o naturã substanþial diferitã de a
hardware-ului, ºi probabil va fi nevoie de inventarea unor tehnici
noi.

<P>
În acest articol voi descrie pe scurt metodele folosite de echipa de
la Stanford condusã de Dawson Engler pentru a descoperi erori în
programe, ºi unele din rezultatele lor foarte interesante despre
natura erorilor în nucleul Linux.

<P>

<H1><A NAME="SECTION00020000000000000000">
Bug-uri în Linux</A>
</H1>

<P>
Un aforism spune cã orice program are cel puþin un bug ºi este cu
cel puþin o linie prea lung.  Aplicînd aceastã regulã în mod
repetat putem deduce cã orice program poate fi optimizat pînã este
redus la o singurã linie de cod, care este eronatã.

<P>
Chiar dacã sistemul de operare Linux este lãudat pentru robusteþea
sa deosebitã, nu este scutit de imperfecþiuni.  Profitînd de
disponibilitatea surselor C ale programului, cercetãtorii de la
Stanford au testat o nouã metodologie pentru a descoperi bug-uri pe
21 de versiuni diferite ale nucleului, începînd de la versiunea 1.0,
din ianuarie 1994, pînã la versiunea 2.4.7, din primãvara acestui
an.  Trebuie menþionat dintru început cã sistemul de la Stanford nu
descoperã toate bug-urile, ci numai anumite tipuri de bug-uri,
relativ simple; voi discuta metodologia folositã ceva mai încolo.
Vom considera cã bug-urile descoperite de acest sistem sunt
reprezentative pentru toate bug-urile în general, cel puþin în
anumite aspecte ale distribuþiilor statistice.  E de reþiunt deci
cã rezultatele pe care le prezint în continuare se referã la un
subset al tuturor bug-urilor, care poate nu este reprezentativ.

<P>
Codul Linux e structurat din mai multe pãrþi relativ independente;
putem factoriza codul însã în douã mari clase: nucleul
propriu-zis, ºi driverele.  Driverele sunt mici programe care fac
parte din nucleu ºi care interfaþeazã nucleul cu dispozitivele
periferice.  Datoritã popularitãþii PC-ului, existã literalmente
mii de periferice diferite, fiecare avînd nevoie de un driver
separat<A NAME="tex2html3"
  HREF="#foot56"><SUP>1</SUP></A>.  Ca atare, majoritatea
codului Linux se aflã în drivere.  Cantitatea de cod din drivere
variazã între 50 ºi 70 la sutã din întregul sistem.

<P>
Între versiunile 1.0 ºi 2.4.1 codul sistemului Linux a crescut de
aproximativ 16 ori, de la 105 mii de linii de cod la 1,6
milioane<A NAME="tex2html4"
  HREF="#foot57"><SUP>2</SUP></A>  Cel mai mult au crescut driverele, datoritã
faptului cã din ce în ce mai mulþi fabricanþi de hardware au
publicat informaþii despre periferice sau chiar au contribuit cu cod.
Alte subsisteme care au crescut sensibil între timp sunt sistemele de
fiºiere ºi codul pentru protocoalele de reþea.

<P>
În total, în cele 21 de versiuni de nucleu sistemul de la Stanford a
detectat peste 1000 de bug-uri distincte.  (Unele dintre bug-uri se
manifestã în mai multe versiuni diferite de nucleu.)  Numãrul de
bug-uri este practic direct proporþional cu mãrimea codului: nucleele
mai mari aveau mai multe erori.

<P>
Bug-urile sunt însã departe de a fi uniform distribuite.  Dupã cum
ne aºteptãm, cele mai multe bug-uri sunt în drivere, pentru cã
driverele ocupã atît de mult din cod.  Putem normaliza numãrul de
bug-uri în douã feluri: împãrþim la numãrul de linii, pentru a
vedea la cîte linii avem un bug, sau putem împãrþi la numãrul de
locuri în care acelaºi tip de bug s-ar fi putut manifesta.  De
exemplu, dacã un bug care constã în lipsa verificãrii unui cod de
eroare dupã apelul unei funcþii care poate eºua, densitatea de
bug-uri este numãrul de locuri în care nu verificãm eroarea
împãrþit la numãrul de locuri în care apelãm funcþii care pot
returna erori.

<P>
Chiar dacã normalizãm numãrul de bug-uri, driverele stau însã
destul de rãu: densitatea de bug-uri în drivere este între 3 ºi 7
ori mai mare decît în nucleul propriu-zis.  Driverele sunt folosite
doar de cei care au perifericele corespunzãtoare, spre deosebire de
nucleu, care e folosit practic de toatã lumea.  Ca atare, driverele
sunt mai puþin testate, deci este de aºteptãt sã aibã mai multe
bug-uri.

<P>
Înþelepciunea popularã spune cã cu cît un program e mai
``bãtrîn'', cu atît are mai puþine bug-uri; acest lucru este
verificat ºi de datele despre Linux: fiºierele cele mai vechi au
cele mai puþine bug-uri.  La nivel de funcþie, funcþiile mai lungi
tind sã aibã o densitate mai mare de bug-uri, ceea ce confirmã
regula cã programul trebuie spart în bucãþele mici ºi
independente, pentru a stãvili complexitatea.

<P>
Dacã facem un grafic al distribuþiei erorilor în raport cu
fiºierele în care apar, graficul este foarte neuniform: cele mai
multe fiºiere au cam 1 bug, pe cînd cîteva fiºiere sunt
responsabile pentru majoritatea bug-urilor.  Foarte adesea,
programatorii au copiat un fragment de program eronat în mai multe
locuri, multiplicînd apariþia unui singur bug.

<P>
Privind la versiuni succesive ale sistemului de operare, se poate
observa în care versiune apare un bug ºi în care dispare.  Folosind
aceste date, se poate calcula durata medie de viaþã a unui bug în
cod.  În pofida numãrului mare de persoane care contribuie la Linux,
durata medie de viaþã este relativ ridicatã: un bug
supravieþuieºte cam un an ºi opt luni înainte de a fi corectat.

<P>
O ultimã statisticã pe care o voi prezenta comparã densitatea de
bug-uri din Linux cu cea dintr-un alt sistem de operare dezvoltat
open-source: OpenBSD.  Programatorii sistemului OpenBSD sunt foarte
mîndri de faptul cã periodic inspecteazã manual întregul cod, cu
scopul de a detecta erori (în englezã aceastã procedurã se
numeºte <EM>code audit</EM>).  Ca atare, ei spun cã OpenBSD este cel
mai sigur sistem de operare.  În mod surprinzãtor, densitatea de
bug-uri în Linux este mai micã, fiind undeva între 1,2 ºi 6 ori
(cercetãtorii au calculat cîte un raport pentru fiecare tip de bug
pe care l-au analizat, de aceea prezintã mai multe numere diferite).
Acest lucru demonstreazã cã într-adevãr o comunitate mai mare de
programatori este mai eficace în a detecta probleme (Linux este mai
popular decît OpenBSD) .

<P>

<H1><A NAME="SECTION00030000000000000000">
Testare ºi verificare</A>
</H1>

<P>
Care este metodologia prin care aceste bug-uri au fost depistate?  Cum
au putut cercetãtorii sã gãseascã probleme în bucãþi de cod pe
care nici mãcar nu le pot executa (de exemplu, este limpede cã nu
pot rula toate driverele, pentru cã nu au la-ndemînã toate
perifericele posibile)?

<P>
Existã douã metode diferite de a depana un program: metode dinamice
ºi metode statice.

<P>
Testarea este o metodã dinamicã: programul este pornit, i se dau
niºte date de intrare, ºi comportarea lui este observatã; eventual
se poate folosi un debugger pentru a urmãri evoluþia programului în
timp ºi pentru a-i putea inspecta mãruntaiele.  Testarea este
relativ uºor de înþeles ºi folosit, dar are mai multe probleme,
mai ales în contextul depanãrii unui sistem de operare:

<P>

<UL>
<LI>Unele bug-uri se vor manifesta numai pentru anumite date de
intrare; ca atare, reuºita unui test nu garanteazã cã programul
este corect;
</LI>
<LI>Am menþionat deja cã driverele pentru perifericele care nu
sunt instalate pe un sistem nu pot fi executate;
</LI>
<LI>În general, sistemul de operare nu opereazã asupra unui simplu
se de date, ci manipuleazã programe, pachete de date care circulã
în reþea, întreruperi de la hardware ºi alte evenimente care sunt
greu de controlat ºi reprodus.
</LI>
</UL>

<P>
Ca atare, grupul de la Stanford foloseºte metode statice.  Metodele
statice constau în analiza unui program înainte de a fi lansat în
execuþie, independent de datele de intrare.  Cea mai familiarã
dintre aceste metode este chiar compilarea: un compilator modern
verificã tot felul de proprietãþi ale programului, ºi rejecteazã
programele care nu respectã criteriile de corectitudine.  Alteori
compilatorul poate da avertismente asupra unor construcþii care pot
genera probleme la execuþie, cum ar fi de pildã variabile
neiniþializate.

<P>
Metodele statice sunt extrem de puternice: ele pot raþiona despre
comportarea unui program <EM>oricare</EM> ar fi datele sale de intrare.
Compilatoarele de astãzi efectueazã analize extrem de sofisticate
asupra codului, pe care apoi îl optimizeazã.  Multe dintre
optimizãri pot fi aplicate numai în anumite condiþii; de exemplu, o
atribuire poate fi eliminatã dacã rezultatul ei nu mai este folosit
în restul programului.  Pentru a demonstra cã atribuirea este
inutilã, compilatorul analizeazã codul ºi demonstreazã cã, orice
cãrare prin program va urma execuþia, rezultatul atribuirii nu mai
este folosit.

<P>
În general astfel de demonstraþii nu pot fi fãcute: teoria
calculabilitãþii aratã cã chestiuni de genul acesta sunt <EM>nedecidabile</EM>.  De aceea, compilatoarele sunt conservatoare: aplicã
optimizãri numai cînd sunt absolut sigure cã sunt corecte, ºi
cîteodatã nu aplicã optimizãri corecte pentru cã nu pot demonstra
legalitatea lor.  Cît de greu este de demonstrat o proprietate,
depinde de mulþi factori, dar în primul rînd de limbajul de
programare care este compilat.  La ora actualã se desfãºoarã o
cercetare extrem de febrilã în domeniul limbajelor de programare,
scopul cãreia este proiectarea unor limbaje mai restrictive.  În
astfel de limbaje anumite tipuri de erori devin imposibile; limbajele
trebuie sã rãmînã însã suficient de flexibile pentru a exprima
în mod natural calcule arbitrar de complicate.

<P>

<H1><A NAME="SECTION00040000000000000000">
Proiectul ``Meta-Compilation'' (MC)</A>
</H1>

<P>
Pentru cã limbajul C în care este scris nucleul de Linux este un
limbaj relativ primitiv, cercetãtorii de la Stanford au fãcut un
compromis: au extins compilatorul de C cu informaþii specifice
nucleului Linux.  Aceastã metodologie dã ºi numele proiectului:
meta-compilare.

<P>
Un exemplu va clarifica cel mai bine tehnica folositã.

<P>
Pentru a preveni accesele concurente la unele structuri de date
importante, nucleele folosesc <EM>regiuni critice</EM>.  Intrarea unui
program într-o regiune criticã este permisã numai dupã
achiziþionarea unei încuietori (lock).  Un singur program poate
obþine o încuietoare, care-i permite accesul în regiunea criticã;
la terminarea regiunii critice, programul elibereazã încuietoarea.
Dacã un program acceseazã încuietoarea cînd un altul este în
regiunea criticã, este blocat pînã cînd posesorul încuietorii
iese din regiune ºi elibereazã încuietoarea.

<P>
De exemplu, funcþiile <TT>lock_kernel()</TT> ºi <TT>unlock_kernel()</TT>
încuie ºi respectiv descuie anumite porþiuni din nucleu.  Aceste
operaþii sunt implementate în douã funcþii obiºnuite.  Dar felul
în care aceste funcþii sunt folosite este foarte specific: de
exemplu, de fiecare datã cînd se foloseºte <TT>lock</TT>, trebuie sã
urmeze eventual <TT>unlock</TT> (altfel nimeni nu mai poate intra în
regiunea criticã, ºi calculatorul probabil se va bloca).  De
asemenea, nimeni nu poate face de douã ori la rînd <TT>lock</TT>,
fãrã a face între timp ºi un <TT>unlock</TT>: a doua oarã programul
s-ar bloca din cauzã cã se aflã deja în regiunea criticã.

<P>
Metacompilarea exploateazã acest gen de informaþie, care nu þine de
limbajul de programare, ci de <EM>aplicaþia</EM> care este programatã.
Proiectul MC le permite programatorilor sã scrie extensii ale
compilatorului care încorporeazã astfel de informaþii.

<P>
MC foloseºte compilatorul de C numit gcc (Gnu C Compiler), care este
compilatorul folosit în mod tradiþional pentru a compila nucleul
Linux; acest compilator este disponibil, ca ºi Linux, cu codul sãu
sursã.  Cercetãtorii de la Stanford au definit un limbaj foarte
simplu, pe care l-au numit Metal.  Compilatorul extins cu Metal
poartã numele de xgcc (eXtended gcc).  Iatã un exemplu de program
complet scris în Metal, care verificã folosirea corectã a
instrucþiunilor de încuiere:

<P>
<PRE>
{ #include "linux-includes.h" }

// descriem un automat finit: state machine
sm verifica_lock {
   // Pattern-uri de cautat in cod
   pat incuie = { lock_kernel(); }
   pat descuie = { unlock_kernel(); }

   // stari; prima stare e starea initiala
   descuiat: incuie ==&gt; incuiat
           | descuie ==&gt; { err("descuiere dubla"); }
           ;

   incuiat: descuie ==&gt; descuiat
          | incuie ==&gt; { err("incuiere dubla"); }
            // acest pattern indica sfirsitul functiei
          | $end_of_path$ ==&gt; { err("functia se termina incuiata"); }
          ;
}
</PRE>

<P>
Programele Metal sunt compilate ºi transformate în programe C ºi
apoi executabile, care sunt apoi legate dinamic de compilatorul gcc.
Cînd xgcc este executat pentru a compila nucleul, extensiile scrise
în Metal sunt executate una cîte una.  Fiecare extensie analizeazã
fiecare funcþie compilatã ºi o verificã.

<P>
Programele Metal descriu <EM>automate finite</EM>.  Programul de mai sus
descrie automatul din figura&nbsp;<A HREF="metacompilare-html.html#automat">1</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="automat"></A><A NAME="154"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
<I>Automatul finit care testeazã folosirea
corectã a instrucþiunilor de încuiere ºi descuiere.  Douã
încuieri succesive, douã descuieri succesive, sau terminarea
procedurii în starea ``încuiat'' cauzeazã o eroare.</I></CAPTION>
<TR><TD><IMG
 WIDTH="360" HEIGHT="234" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{automat.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Acest automat finit este executat în mod abstract de cãtre
compilator pe program, pe fiecare procedurã în mod separat.  În mod
conceptual, compilatorul executã fiecare cãrare posibilã din
procedurã ºi face tranziþiile indicate de automat cînd
întîlneºte pattern-urile indicate.  Dacã vreuna din cãrãri
cauzeazã intrarea în starea de eroare, xgcc genereazã un mesaj de
eroare.

<P>
Observaþi cã acest automat ignorã cele mai multe operaþiuni din
program, ºi este interesat numai de apelurile funcþiilor <TT>lock_kernel()</TT> ºi <TT>unlock_kernel()</TT>.  

<P>
Sã ilustrãm funcþionarea automatului pe o procedurã fictivã, al
cãrei schelet este urmãtorul:

<P>
<PRE>
f() {
   lock_kernel();
   ...
   p = malloc(10);
   if (!p)
       return OUT_OF_MEMORY;
   ...
   unlock_kernel();
   return OK;
}
</PRE>

<P>
Aceastã procedurã obþine încuietoarea dupã care încearcã sã
aloce 10 octeþi.  Dacã alocarea eºueazã, returneazã un cod de
eroare.  Altfel procedura face tot felul de calcule, descuie nucleul,
ºi returneazã un cod OK.

<P>
Execuþia poate urma douã cãrãri prin aceastã procedurã,
ilustrate în figura&nbsp;<A HREF="metacompilare-html.html#carari">2</A>: amîndouã intrã pe la început,
dar una iese în caz de eroare din procedurã, pe cînd a doua descuie
lacãtul înainte de a ieºi.  Cu litere cursive în
figura&nbsp;<A HREF="metacompilare-html.html#carari">2</A> am indicat starea curentã a automatului finit
cînd parcurge cãrãrile respective.  Observaþi cã pe cãrarea
roºie automatul ajunge la sfîrºitul procedurii ºi se aflã în
starea ``încuiat''; ultima regulã din programul Metal va semnaliza
în acest caz o eroare.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="carari"></A><A NAME="161"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
<I>Traiectoriile posibile ale programului printr-o
procedurã.  Cãrarea indicatã cu roºu va fi semnalatã ca o eroare
de programul Metal, pentru cã execuþia procedurii se terminã
într-o stare încuiatã.</I></CAPTION>
<TR><TD><IMG
 WIDTH="360" HEIGHT="452" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{carari.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
În realitate xgcc nu parcurge toate cãrãrile posibile, ci
calculeazã simultan toate stãrile în care se poate afla automatul
în fiecare punct din program folosind o metodã numitã <EM>interpretare abstractã</EM>.  Sper sã pot consacra un articol special
interpretãrii abstracte ºi altor tehnici de verificare formalã,
aºa cã nu voi mai discuta aici despre ea.

<P>
Toate analizele descrise în Metal sunt strict intraprocedurale,
adicã analizeazã fiecare funcþie separat<A NAME="tex2html7"
  HREF="#foot92"><SUP>3</SUP></A>.  

<P>
Aceasta este ºi una dintre limitãrile cele mai mari ale acestei
scheme.  Vom ilustra falibilitatea ei printr-un alt exemplu.  Sã
presupunem cã funcþia <TT>f()</TT> de mai sus este apelatã în
urmãtorul fragment de cod:

<P>
<PRE>
   ...
   eroare = f();
   if (eroare == OUT_OF_MEMORY)
        unlock_kernel();
   ...
</PRE>

<P>
Atunci de fapt codul funcþiei <TT>f</TT> nu era eronat, pentru cã
pînã la urmã ambele cãrãri duc la o descuiere.

<P>
Astfel, analizele descrise în Metal sunt <EM>incomplete</EM>, ºi pot
genera alarme false, numite <EM>falsuri pozitive</EM>.  (Un fals negativ
este o eroare realã care nu este semnalatã).  xgcc poate fi folosit
cu succes dacã cei care programeazã folosesc o disciplinã ºi un
stil de programare consistent.  De exemplu, în general programatorii
vor considera codul funcþie <TT>f</TT> de mai sus ca fiind defectuos,
pentru cã este asimetric: uneori descuiem în <TT>f()</TT>, alteori în
apelantul lui <TT>f</TT>.

<P>
În proiecte atît de mari ca Linux, disciplina în programare este
absolut esenþialã.  Contributorilor le este bine-cunoscutã
atitudinea cvasi-dictatorialã a lui Linus Torvalds în aceastã
privinþã: el va rejecta programe perfect funcþionale dacã nu este
mulþumit cu stilul de programare.  Cu siguranþã cã aceastã
disciplinã de fier contribuie în mod substanþial la calitatea
ridicatã a nucleului Linux.

<P>
Cele aproximativ 1000 de bug-uri menþionate mai sus au fost detectate
folosind 8 programe Metal, toate în jurul a 100 de linii de cod
fiecare.  Alte extensii scrise pentru xgcc au avut rezultate mixte:
deºi generau  erori, multe dintre ele erau falsuri pozitive.
Din pãcate, fiecare mesaj trebuie sã fie inspectat manual pentru a
decide dacã este o eroare adevãratã sau nu.  Ca atare, extensiile
Metal sunt utile mai ales dacã genereazã relativ puþine alarme
false, altfel efortul necesar pentru verificarea mesajelor devine
repede prohibitiv.

<P>

<H1><A NAME="SECTION00050000000000000000">
Inferenþa automatã a regulilor de testat</A>
</H1>

<P>
În mod interesant, nici unul dintre programatorii de la Stanford din
proiectul MC nu este expert în nucleul Linux.  Ca atare, pentru a
valida mesajele xgcc, ei trebuia sa scruteze codul pentru a înþelege
ce se întîmplã de fapt.  Din aceastã activitate le-a venit o idee
foarte interesantã, care este subiectul unuia din cele mai recent
articole pe care le-au scris, ºi care vor fi prezentate în luna
octombrie la conferinþa ``Symposium on Operating System Priciples''.

<P>
xgcc este atît de bun pe cît sunt extensiile scrise.  Dacã ºtii ce
fel de bug sã cauþi, îl poþi gãsi (de exemplu, trebuie sã ºtii
cã <TT>lock</TT>/<TT>unlock</TT> se folosesc împreunã în felul
indicat).  Cînd cercetãtorii de la Stanford validau erorile, cãutau
exemple similare în cod, pentru a vedea cum trebuie fãcute de fapt
lucrurile.

<P>
De aici s-a nãscut ideea lor cea mai interesantã: avem la
dispoziþie aproape douã milioane de linii de cod.  De ce sã nu
folosim acest cod pentru a extrage automat regulile de programare?
De exemplu, dacã în cod funcþiile <TT>lock</TT> ºi <TT>unlock</TT> apar
mereu împreunã, ºi în ordinea asta, înseamnã cã asta e o
regulã care trebuie respectatã.

<P>
Bine, dar dacã în program sunt bug-uri?  Atunci regula va fi
încãlcatã.  Pentru a infera reguli, vom cãuta în program
construcþii care apar foarte frecvent, chiar dacã nu apar
întotdeauna.  Dacã în 999 de cazuri din 1000 <TT>lock</TT> este urmat
de <TT>unlock</TT>, dar în 1 la mie nu, considerãm cã am dat peste o
regulã importantã.

<P>
A fost fãcutã o listã de tipuri de reguli care trebuie cãutate în
cod (de exemplu, <TT>&lt;A&gt;</TT> este mereu urmat de <TT>&lt;B&gt;</TT>, unde
<TT>&lt;A&gt;</TT> ºi <TT>&lt;B&gt;</TT> trebuie descoperite), ºi apoi codul a fost
analizat exhaustiv pentru a obþine posibile reguli (de exemplu,
<TT>&lt;A&gt;</TT> este <TT>lock()</TT> ºi <TT>&lt;B&gt;</TT> este <TT>unlock()</TT>).  Fiecare
regulã a fost apoi analizatã statistic, ºi regulile au fost apoi
sortate în raport cu deviaþia de la distribuþia uniformã.  Apoi
regulile cele mai promiþãtoare au fost transformate în programe
Metal.

<P>
Ingeniozitatea cercetãtorilor însã nu s-a oprit aici.  Dacã suntem
nefamiliari cu nucleul, tot nu ºtim dacã regulile acestea trebuie
sau nu sã fie respectate.  Analizînd regulile, cercetãtorii au
observat cã folosirea unei anumite construcþii în cod implicã
faptul cã programatorul are o anumitã <EM>credinþã</EM> despre cum
trebuie sã arate codul.  De exemplu, dacã un programator comparã un
pointer cu zero, înseamnã cã programatorul se aºteaptã cã acel
pointer sã poatã avea valoarea zero.

<P>
Cercetãtorii au definit apoi niºte reguli simple care aratã cum se
propagã credinþele prin program ºi care dintre credinþe sunt
contradictorii.  Voi ilustra din nou acest lucru cu un exemplu simplu:

<P>
<PRE>
  char* p = f();
  b = *p;     /* credinta: p nu poate fi zero */
  ...
  if (p == 0) /* credinta: p poate fi zero */
     ...
</PRE>

<P>
În acest fragment de program, pointerul <TT>p</TT> este dereferenþiat
(se citeºte valoarea la care puncteazã).  Asta înseamnã cã
programatorul nu se aºteaptã ca în acest punct valoarea pointerului
sã fie zero.  Dar, ceva mai departe în program, pointerul este
comparat cu zero.  Programatorul nu ar fi fãcut aceastã comparaþie
dacã nu s-ar fi aºteptat sã reuºeascã ciþeodatã.  Aceste douã
credinþe (cã <TT>p</TT> nu poate fi zero, respectiv cã <TT>p</TT> poate
fi zero) sunt contradictorii.  Una dintre ele trebuie sã fie o
eroare!

<P>
Folosind aceastã metodã au fost construite noi teste care au
descoperit alte cîteva sute de bug-uri în Linux.

<P>

<H1><A NAME="SECTION00060000000000000000">
Concluzii</A>
</H1>

<P>
În acest articol am prezentat proiectul numit Meta-compilare, care
augumenteazã compilatorul cu informaþii specifice programului
compilat.  Compilatorul foloseºte aceste informaþii pentru a detecta
posibile erori în program.  Tipul proprietãþilor care se pot
verifica folosind aceastã schemã este destul de restrîns: fiecare
procedurã din programul de analizat este redusã la un automat finit
a cãrui traiectorie este urmãritã pentru a vedea dacã trece prin
stãri de eroare.  Am vãzut de asemenea o schemã ingenioasã prin
care codul este analizat pentru a extrage reguli de stil de programare
în mod automat; cazuri în care regulile de stil sunt încãlcate
sunt potenþiale erori de programare.  Aceste exemple constituie o
aplicare a tehnicilor de verificare formalã pentru analiza automatã
a programelor.

<P>

<H1><A NAME="SECTION00070000000000000000">
Alte surse de informaþie</A>
</H1>

<P>

<UL>
<LI>Articolul meu despre depanare din PC Report din iunie 1999 
conþine consideraþii despre metodele statice ºi dinamice:
<TT><A NAME="tex2html8"
  HREF="http://www.cs.cmu.edu/~mihaib/articles/articles.html#ddd">http://www.cs.cmu.edu/~mihaib/articles/articles.html#ddd</A></TT>.

<P>
</LI>
<LI>Am vorbit despre teoria calculabilitãþii în articolul meu din
PC Report din decembrie 1999:
<TT><A NAME="tex2html9"
  HREF="http://www.cs.cmu.edu/~mihaib/articles/articles.html#complex">http://www.cs.cmu.edu/~mihaib/articles/articles.html#complex</A></TT>.

<P>
</LI>
<LI>Am descris pe scurt automatele finite în articolul meu din PC
Report din aprilie 2000:
<TT><A NAME="tex2html10"
  HREF="http://www.cs.cmu.edu/~mihaib/articles/articles.html#regex">http://www.cs.cmu.edu/~mihaib/articles/articles.html#regex</A></TT>.

<P>
</LI>
<LI>Pagina de web a proiectului MC de la Stanford:
<TT><A NAME="tex2html11"
  HREF="http://hands.stanford.edu/linux">http://hands.stanford.edu/linux</A></TT>.

<P>
</LI>
<LI>Pagina de web a lui Dawson Engler, liderul proiectului MC:
<TT><A NAME="tex2html12"
  HREF="http://www.stanford.edu/~engler">http://www.stanford.edu/~engler</A></TT>.  Aici puteþi gãsi toate
articolele publicate de acest grup despre Metacompilation pe care se
bazeazã prezentarea din acest articol.

<P>
</LI>
<LI>O paginã cu legãturi spre publicaþii care sintetizeazã starea
curentã a metodelor de verificare formalã:
<TT><A NAME="tex2html13"
  HREF="http://www.cerc.utexas.edu/~jay/fv_surveys">http://www.cerc.utexas.edu/~jay/fv_surveys</A></TT>
<P>
</LI>
<LI>O biblioteca virtualã cu informaþii despre verificare
formalã: <TT><A NAME="tex2html14"
  HREF="http://www.afm.sbu.ac.uk">http://www.afm.sbu.ac.uk</A></TT>
<P>
</LI>
<LI>O excelentã introducere în metodologia verificãrii formale
pentru hardware: C.-J. H. Seger, ``An Introduction to Formal Hardware
Verification'', Technical Report 92-13, UBC, Department of Computer
Science, Vancouver, B.C., Canada, June 1992, 
<BR><TT><A NAME="tex2html15"
  HREF="http://www.cerc.utexas.edu/~jay/fv_surveys/Seger.ps">http://www.cerc.utexas.edu/~jay/fv_surveys/Seger.ps</A></TT>
</LI>
</UL>

<P>
<BR><HR><H4>Note</H4>
<DL>
<DT><A NAME="foot56">...
separat</A><A NAME="foot56"
 HREF="metacompilare-html.html#tex2html3"><SUP>1</SUP></A>
<DD>Desigur, dacã douã periferice sunt compatibile
între ele, pot folosi acelaºi driver, dar compatibilitatea pare sã
fie mai curînd excepþia decît regula.

<DT><A NAME="foot57">...
milioane</A><A NAME="foot57"
 HREF="metacompilare-html.html#tex2html4"><SUP>2</SUP></A>
<DD>Linux este cel mai portabil sistem de operare,
rulînd pe zeci de procesoare diferite.  Informaþiile din textul de
faþã sunt însã specifice versiunii de Linux pentru procesoarele
x86, de pe PC-uri.

<DT><A NAME="foot92">... separat</A><A NAME="foot92"
 HREF="metacompilare-html.html#tex2html7"><SUP>3</SUP></A>
<DD>Autorii au
introdus ºi un mecanism rudimentar prin care se pot efectua unele
analize interprocedurale, facînd douã treceri asupra programului,
în prima trecere colectînd informaþii despre toate procedurile
vizitate.

</DL>
<BR><HR>

</BODY>
</HTML>
