<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>``Micro'' sau ``macro''?</TITLE>
<META NAME="description" CONTENT="``Micro'' sau ``macro''?">
<META NAME="keywords" CONTENT="micron-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">``Micro'' sau ``macro''?</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> <TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>12 iunie 1997</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Nucleele monolitice par sã fie preferate în
sistemele de operare.
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>Cunoºtinþe de bazã despre sisteme de
operare.
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>monolit, micronucleu, apel de sistem, proces,
domeniu protejat.
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html47"
  HREF="micron-html.html">Serviciile oferite de nucleu: apeluri de sistem</A>
<UL>
<LI><A NAME="tex2html48"
  HREF="#SECTION00021000000000000000">Structura unui apel de sistem</A>
<LI><A NAME="tex2html49"
  HREF="#SECTION00022000000000000000">Comutarea proceselor</A>
</UL>
<BR>
<LI><A NAME="tex2html50"
  HREF="#SECTION00030000000000000000">Plasarea serviciilor</A>
<UL>
<LI><A NAME="tex2html51"
  HREF="#SECTION00031000000000000000">Biblioteci</A>
<LI><A NAME="tex2html52"
  HREF="#SECTION00032000000000000000">Nucleu</A>
<LI><A NAME="tex2html53"
  HREF="#SECTION00033000000000000000">Server(e)</A>
<LI><A NAME="tex2html54"
  HREF="#SECTION00034000000000000000">Resurse fãrã servere (serverless); Memoria distribuitã
partajatã</A>
<LI><A NAME="tex2html55"
  HREF="#SECTION00035000000000000000">Semantica operaþiilor</A>
</UL>
<BR>
<LI><A NAME="tex2html56"
  HREF="#SECTION00040000000000000000">Promisiunile micro-nucleelor</A>
<UL>
<LI><A NAME="tex2html57"
  HREF="#SECTION00041000000000000000">RPC</A>
</UL>
<BR>
<LI><A NAME="tex2html58"
  HREF="#SECTION00050000000000000000">Problema micro-nucleelor</A>
<LI><A NAME="tex2html59"
  HREF="#SECTION00060000000000000000">În loc de concluzie: arhitectura NT</A>
<UL>
<LI><A NAME="tex2html60"
  HREF="#SECTION00061000000000000000">Local procedure call (LPC)</A>
<LI><A NAME="tex2html61"
  HREF="#SECTION00062000000000000000">Memoria partajatã</A>
<LI><A NAME="tex2html62"
  HREF="#SECTION00063000000000000000">Prealocarea resurselor</A>
</UL>
<BR>
<LI><A NAME="tex2html63"
  HREF="#SECTION00070000000000000000">Concluzii</A>
</UL>
<!--End of Table of Contents-->
<BR>
<BR>

<P>
De la apariþia ideii de micro-nucleu aceasta a suscitat un enorm
entuziasm printre cercetãtori ºi industriaºi.  Tehnica promitea sã
rezolve elegant o mulþime de probleme din proiectarea sistemelor de
operare, ºi sã permitã scrierea de sisteme distribuite cu mare
uºurinþã.  În mod paradoxal însã, la aceastã datã toate
sistemele de operare de uz general au mai curînd o arhitecturã
monoliticã.  Chiar ºi despre Windows NT, un cal pe care multã lume
serioasã pariazã ca învingãtor în cursa sistemelor de operare, se
rîde adesea: ``a plecat ca un micro-nucleu, dar s-a umflat pînã a
ajuns mai mare ca un macro-nucleu''.

<P>
Acest articol îºi propune sã explice care este motivaþia acestei
spectaculoase rezistenþe a tehnologiei tradiþionale.  Pentru cei
nerãbdãtori concluzia se poate rezuma într-un rînd: costul
serviciilor este prea mare (mult prea mare) într-un sistem de operare
micro-nucleu.

<P>
Am spus mai sus ``sisteme de operare de uz general''.  Toate
consideraþiile arhitecturale pe care le prezint sunt valabile pentru
majoritatea sistemelor de operare existente la zi.  Consideraþiile
despre eficienþã, care sunt cruciale în supravieþuirea comercialã
a unui sistem, sunt însã semnificative numai pentru sistemele de
operare pentru calculatoare obiºnuite.  Prin contrast, sistemele de
operare specializate (de exemplu sistemele de timp real pentru
controlul proceselor, sau pentru maºini electronice de jocuri) sunt
într-adevãr micro-nuclee, ºi îºi fac foarte bine treaba lor.
Cheia este însã aceasta: treaba lor este într-adevãr foarte
specializatã; o maºinã SEGA de jocuri electronice nu are nici disc,
nici reþea, nici periferice prea multe, aºa cã sistemul de operare
este special scris.  Atenþia noastrã se apleacã mai ales asupra
sistemelor tip Unix/Windows (3.1/NT/95)/VMS, care sunt concepute sã
permitã rularea unei varietãþi nelimitate de aplicaþii ºi
partajarea resurselor între programe care nu ºtiu unul despre
celãlalt, adesea în medii ``deschise'' (reþele).

<P>
O sã procedez pe parcursul acestui articol indirect: voi atinge tot felul 
de probleme care aparent nu au mare legãturã cu subiectul central, dupã 
care, în final, într-o secþiune sumarã voi arãta cum consecinþele 
faptelor pe care le-am tot înºiruit, ºi pe care le socotesc nu lipsite 
de interes în sine, se adunã întru concluzia indicatã mai sus, care
promite dominaþia sistemelor monolitice.

<P>

<H1><A NAME="SECTION00020000000000000000">
Serviciile oferite de nucleu: apeluri de sistem</A>
</H1>

<P>
În aceastã secþiune voi face o scurtã recapitulare a modului de
funcþionare al nucleului, pentru a înþelege de unde izvorãsc toate
problemele.  Pentru cã am vorbit aiurea despre aceste lucruri mai pe
larg, aici voi fi oarecum succint.  Cititorul interesat poate gãsi o
descriere a funcþionãrii unui nucleu de sistem de operare în <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#nucleu">articolul</a>
meu publicat în serial în PC Report în septembrie/octombrie 1996<A
NAME="tex2html1" HREF="#foot53"><SUP>1</SUP></A>.

<P>
Nucleul unui sistem de operare se poate asemui cu o <EM>bibliotecã</EM>
de funcþii care sunt puse la dispoziþia proceselor utilizatorilor.
Practic întreg accesul la perifericele conectate este mediat de
nucleu, din motive de reutilizare a codului, eficienþã ºi, mai
ales, securitate<A NAME="tex2html2"
  HREF="#foot55"><SUP>2</SUP></A>.

<P>
Pentru utilizatorul normal acest lucru se manifestã prin prezenþa
unei colecþii de funcþii gata fãcute, cu care el poate manipula
perifericele (terminal, disc, fiºiere, reþea, etc.).  Un exemplu
tipic este funcþia <TT>write()</TT> din Unix, prin care se pot trimite
date spre un periferic.  Funcþiile puse la dispoziþie de cãtre
nucleu se numesc <EM>apeluri de sistem (system calls)</EM>.

<P>
O altã funcþie importantã a nucleului, vizibilã utilizatorului
prin apeluri de sistem pentru crearea, distrugerea ºi manipularea
proceselor, este cea de management al proceselor.  Un proces este un
program care se executã.  Nucleul permite mai multor programe
independente sã fie ``încãrcate'' în memorie, puse în execuþie,
oprite ºi terminate.  O funcþie care este mai rar sub controlul
utilizatorului este cea de ``planificare'' (scheduling) a proceselor:
oprirea proceselor care s-au executat prea mult ºi pornirea celor
care tînjesc dupã puþinã activitate.

<P>
Nucleul implementeazã de asemenea noþiunea de <EM>spaþiu de
adrese</EM>, folosind <EM>sistemul de memorie virtualã</EM>.  În
arhitecturile ``clasice'' fiecare proces are impresia cã posedã în
întregime memoria calculatorului.  Acest truc este realizat folosind
translatarea adreselor (address mapping): pentru fiecare proces
nucleul menþine o listã a zonelor de memorie care-i sunt vizibile,
iar orice referinþã la memorie a unui proces este re-calculatã ºi
tradusã într-o referinþã într-una din zonele care i-au fost
alocate.  Astfel, adresa 5 (``adresã virtualã'') va indica o locaþie
diferitã de memorie în RAM (``adresã fizicã'') pentru fiecare
proces.

<P>
Vom vedea un pic mai jos cã sistemul de memorie virtualã permite
cîteodatã vizibilitate a unei zone de memorie mai multor procese,
pentru uºurarea comunicãrii între ele.

<P>
Nucleul însuºi este protejat folosind memoria virtualã.  Pentru a
putea apela serviciile nucleului, el trebuie sã fie cumva vizibil
proceselor.  Dar zona de memorie în care se aflã nucleul devine
accesibilã numai atunci cînd procesele invocã serviciile nucleului,
fiind invizibilã sau inaccesibilã în mod normal.

<P>

<H2><A NAME="SECTION00021000000000000000">
Structura unui apel de sistem</A>
</H2>

<P>
Sã vedem cum poate un proces ordinar beneficia de serviciile
nucleului, pãstrînd totuºi nucleul inaccesibil.  (Nucleul posedã o
grãmadã de structuri de date, despre toate procesele, aºa încît
citirea lor ar putea reprezenta o periculoasã scurgere de
informaþii.  Cu atît mai mult scrierea în zona de memorie fizicã
în care se aflã nucleul trebuie sã fie prohibitã în mod normal).

<P>
Atîta vreme cît un proces se executã el foloseºte Unitatea
Centralã într-un mod neprivilegiat (user mode).  Procesul ``vede''
din memoria fizicã numai porþiunea care i-a fost alocatã de nucleu,
cam ca în figura&nbsp;<A HREF="micron-html.html#user-mode">1</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="user-mode"></A><A NAME="234"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
Traducerea adreselor în modul utilizator.</CAPTION>
<TR><TD>
<PRE>
       memorie                      memorie
       virtuala                     fizica
       proces curent
       ________________________     ____________
       |           |           \    | memorie  |
       |  proces 1 |            \   | proces k |
       |           |             \__|__________|
       |___________|____________    | memorie  |
       |inaccesibil|            \   | fizica   |
       |           |             \  | proces 1 |
       -------------              \_|__________|
                                    |          |
                                    |__________|
                                    |          |
                                    |  nucleu  |
                                    ------------
</PRE>
</TD></TR>
</TABLE>
</DIV><P></P>

<P>
Sã presupunem cã procesul vrea sã cheme un apel de sistem (<TT>write()</TT>, ca sã fim concreþi).  (Un scenariu asemãnãtor este
valabil pentru cazul survenirii unei întreruperi sau executãrii unei
operaþii ilegale.)  Pentru acest scop procesul cheamã o funcþie de
bibliotecã oferitã de fabricanþii sistemului, care <EM>împacheteazã</EM> argumentele în niºte regiºtri, iar într-un
registru convenit (de pildã AX) codul apelului de sistem (<TT>write()</TT> sã zicem cã are codul 3), dupã care executã o
instrucþiune specialã a microprocesorului.

<P>
Aceastã instrucþiune are un efect dramatic: cauzeazã trecerea
procesorului în mod privilegiat (kernel-mode), dupã care sare la o
rutinã specialã.  Aceastã rutinã în primul rînd transformã
modul în care se face translatarea adreselor, ``aducînd'' nucleul
în spaþiul de adrese al procesului curent.  (Aceastã ``aducere'' se
poate face automat prin faptul cã zonele de memorie ale nucleului pot
fi accesibile numai în modul privilegiat; depinde de caracteristicile
unitãþii de management a memoriei ºi procesorului prin ce detalii
anume se obþine vizibilitatea.)  Cert este cã subit imaginea aratã
ca în figura&nbsp;<A HREF="micron-html.html#kernel-mode">2</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="kernel-mode"></A><A NAME="235"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
Traducerea adreselor în modul nucleu.</CAPTION>
<TR><TD>
<PRE>
       memorie                       memorie
       virtual'a                     fizic'a
       proces curent
       ________________________     ------------
       |           |           \    | memorie  |
       |  proces 1 |            \   | proces k |
       |           |             \__|__________|
       |___________|____________    | memorie  |
       |  nucleu   |   \        \   | fizica   |
       |___________|    \        \  | proces 1 |
                    \    \        \_|__________|
                     \    \         |          |
                      \    \________|__________|
                       \            |  nucleu  |
                        \___________|__________|
</PRE></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Deodatã toate structurile de date ºi codul nucleului au devenit vizibile.  
Apoi rutina specialã (care tocmai se executã) se uitã în regiºtri 
conveniþi pentru a depista apelul fãcut (în exemplul nostru gãseºte 
în AX un 3).  Apoi în funcþie de acesta cheamã una sau alta din
procedurile de tratare din codul nucleului (de-multiplexeazã apelul,
de obicei folosind o tabelã care pentru fiecare apel conþine o
adresã în nucleu: <TT>call syscall[AX]</TT>).

<P>
Mai departe, procedura de tratare a apelului de sistem, care este
specificã pentru apelul nostru (<TT>write</TT>) cautã în locurile
convenite argumentele (de obicei tot în regiºtri), verificã
validitatea lor ºi începe executarea apelului.

<P>
Un apel de sistem de genul lui <TT>write()</TT> roagã nucleul sã
transfere date spre un periferic.  În cazul lui <TT>write</TT> datele
sunt indicate prin adresa virtualã a unui buffer ºi mãrimea lui:
<TT>write(periferic, buffer, marime)</TT>.  În mod normal nucleul
trebuie sã <EM>copieze</EM> conþinutul întregului buffer în
interiorul nucleului pentru prelucrare.  De ce?  Pentru cã acest
proces va fi suspendat acum, în aºteptarea terminãrii executãrii
apelului de sistem (în general interacþiunea cu perifericele este
foarte lentã ºi cauzeazã suspendarea proceselor).  Ori dacã acest
proces este suspendat, un altul va fi pornit.  Dar acest lucru va
schimba modul în care este translatat spaþiul de adrese virtuale,
deci adresa virtualã a buffer-ului indicat nu va mai avea aceeaºi
semnificaþie pentru nucleu!

<P>
Fãcînd tot felul de trucuri uneori nucleul reuºeºte sã evite
copierea datelor<A NAME="tex2html5"
  HREF="#foot236"><SUP>3</SUP></A>.  Pentru anumite operaþii însã copierea datelor
în interiorul nucleului nu poate fi evitatã: de exemplu cînd datele
trebuie sã plece în reþea ele trebuie împachetate ºi sparte în
bucãþi mai mici, sau atunci cînd merg spre disc trebuie re-aliniate
ºi mutate în cache.  De asemenea, cînd datele se duc spre un alt
proces (de pildã printr-un <TT>pipe</TT> în Unix) ele trebuie din nou
copiate în interiorul nucleului, pentru a lãsa procesul care face
<TT>write</TT> sã continue sã foloseascã buffer-ul fãrã a modifica
datele deja trimise (dupã scrierea într-o ``þeavã'' (pipe)
procesul care face scrierea de obicei îºi continuã execuþia, dar
datele sunt pãstrate pînã cînd un proces de la celãlalt capãt al
``þevii'' le citeºte.  Pãstrarea se face în nucleu).

<P>

<H2><A NAME="SECTION00022000000000000000">
Comutarea proceselor</A>
</H2>

<P>
Sã ne uitãm acum ºi la operaþiile care însoþesc comutarea
execuþiei de la un proces la altul, pentru cã acest cost este foarte
important în micro-nuclee.

<P>
Comutarea proceselor implicã salvarea stãrii procesului curent ºi
încãrcarea stãrii procesului care urmeazã pentru execuþie.
Pentru cã cea mai mare parte din stare este conþinutã în tabele
aflate în memorie, schimbarea se poate face relativ simplu
încãrcînd valoarea unui pointer spre noua cãsuþã din tabelã
care se va folosi (pentru a comuta de la procesul 3 la procesul 5
nucleul va pune în pointerul spre cãsuþa din tabel cu datele
procesului curent valoarea 5 în locul lui 3).

<P>
În general însã trebuie luate în calcul mai multe operaþii.
Anume trebuie fãcute urmãtoarele operaþiuni, nici una foarte
complicatã:

<P>
<DL COMPACT>
<DT></DT>
<DD><B>Faza 1: salvarea stãrii:</B>
</DD>
<DT>1.</DT>
<DD>Salvarea regiºtrilor curenþi;
</DD>
<DT>2.</DT>
<DD>Salvarea stãrii coprocesorului matematic;
</DD>
<DT>3.</DT>
<DD>Salvarea regiºtrilor de depanare, dacã procesul curent era
depanat;
</DD>
<DT>4.</DT>
<DD>Salvarea regiºtrilor ºi stãrii unitãþii de management a
memoriei; salvarea tabelei de translatare a adreselor a procesului
curent (tabela de translatare indicã modul în care se interpreteazã
adresele virtuale pentru procesul curent);
</DD>
<DT>5.</DT>
<DD>Modificarea contoarelor ºi ceasurilor de execuþie pentru a
reflecta timpul consumat de procesul care se opreºte;

<P>
<B>Faza 2: comutarea:</B>
</DD>
<DT>6.</DT>
<DD>Rularea algoritmului de planificare (scheduling), care parcurge
cozile de procese gata de execuþie în ordinea prioritãþilor,
alegînd pe cel mai urgent;
</DD>
<DT>7.</DT>
<DD>Golirea cache-urilor de translatare a adreselor -- Translation
Lookaside Buffer<A NAME="tex2html6"
  HREF="#foot93"><SUP>4</SUP></A>  TLB este un
cache care reþine felul în care se traduc adresele virtuale cele mai
des folosite pentru procesul curent; din moment ce semnificaþia
adresei virtuale 5 pentru noul proces va fi alta, vechea ei asociere
trebuie ºtearsã ºi din TLB.

<P>
<B>Faza 3: încãrcarea noului proces:</B>
</DD>
<DT>8.</DT>
<DD>Încãrcarea tuturor regiºtrilor salvaþi (de paºii 1-3), cu
valorile lor pentru noul proces;
</DD>
<DT>9.</DT>
<DD>Încãrcarea tabelei de translatare a adreselor a noului proces
ºi a regiºtrilor unitãþii de management a memoriei.  În acest fel
noul spaþiu de adrese virtuale devine vizibil ºi cel vechi
invizibil;
</DD>
<DT>10.</DT>
<DD>Pentru cã în timp ce noul proces ``dormea'' s-au putut
întîmpla evenimente interesante pentru el (de exemplu, în Unix i-a
fost trimis un semnal), acum este momentul de a lua acþiuni speciale
(în cazul semnalelor Unix se construiesc cadre pe stivã pentru
procedurile de tratare a semnalelor, sau procesul este omorît);
</DD>
<DT>11.</DT>
<DD>Schimbarea pointerilor spre a puncta spre noul proces.
</DD>
</DL>

<P>
Dupã cum vedeþi sunt totuºi o sumedenie de operaþii de fãcut.
Nuclee foarte sofisticate pot avea operaþiile de comutare a
proceselor chiar mai complicate decît cele descrise aici.

<P>
Sã observãm cã în comutarea proceselor mai existã cel puþin un
cost ascuns, implicat de operaþia de schimbarea <EM>localitãþii</EM>
de adresare: pentru cã începem rularea unui nou proces, care va
folosi un spaþiu de adrese complet diferit, cache-ul
microprocesorului va genera foarte multe rateuri pentru început,
fiind încãrcat cu date din spaþiul vechiului proces.  De asemenea,
TLB a fost golit (în pasul 7 mai sus), deci pentru a-l umple din nou
cu traducerea adreselor în noul proces, va trebui sã fie consultatã
tabela de traducere a adreselor pentru noul proces, operaþie
costisitoare, deoarece implicã accese suplimentare la memorie.

<P>
Un alt posibil cost va fi plãtit pînã noul proces îºi aduce de pe
memoria secundarã (disc) paginile de memorie din setul de lucru
(working set); datoritã faptului cã paginile de memorie îndelung
ne-folosite sunt de obicei scoase afarã pe disc, s-ar putea ca
procesul care tocmai porneºte sã trebuiascã sã ºi le ia de acolo.
Aducerea unei pagini este o operaþie extrem de costisitoare, care
implicã pe lîngã accesul la disc ºi oprirea procesului care cere
pagina pînã la venirea acesteia, ceea ce înseamnã încã o
comutare de procese!

<P>

<H1><A NAME="SECTION00030000000000000000">
Plasarea serviciilor</A>
</H1>

<P>
Existã în mod logic trei locuri unde poate fi implementat un
serviciu:

<P>

<OL>
<LI>În spaþiul procesului care îl foloseºte, ca o bibliotecã de
funcþii;
</LI>
<LI>În interiorul nucleului, accesat printr-un apel de sistem;
</LI>
<LI>În gestiunea unui proces separat, numit ``server''.
</LI>
</OL>

<P>
(Un al patrulea loc, mai puþin uzual, va fi de asemenea discutat.)

<P>
Figura&nbsp;<A HREF="micron-html.html#plasament">3</A> aratã cele trei variante.  Le vom analiza pe
fiecare pe scurt.  Pentru un serviciu dat, foarte adesea proiectantul
sistemului are la dispoziþie toate cele 3 posibilitãþii.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="plasament"></A><A NAME="237"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3:</STRONG>
Plasamentul serviciilor.</CAPTION>
<TR><TD>
<PRE>
  ------------           ------------          -----------------------
  |  proces  |           |          |          |  proces  |  proces  |
  |          |           |          |          | (client) | (server) |
  |          |           |          |          |          |          |
  |          |           |  proces  |          |          |          |
  ----|-------           |          |          |          |          |
  |          |           |          |          |          |          |
  |biblioteca|           |          |          |          |          |
  ============           ====|=======          =====|===========|=====
  |          |           |          |          |     \__________/    |
  | nucleu   |           | nucleu   |          | nucleu              |
  ------------           ------------          -----------------------
   varianta 1             varianta 2                  varianta 3
</PRE>
</TD></TR>
</TABLE>
</DIV><P></P>

<P>
Modul dominant în care sunt plasate serviciile (adicã locul
majoritãþii serviciilor) dã ºi clasificarea unui sistem în
taxonomia sistemelor de operare.  Practic fiecare sistem de operare va
avea servicii în toate cele trei pãrþi, astfel încît diferenþa
este mai curînd una de grad decît de naturã.  Astfel, sistemele
care aleg varianta 2 pentru majoritatea serviciilor se numesc
monolitice, pentru cã tind sã aibã un nucleu foarte mare, cu o
grãmadã de cod.

<P>
Sistemele care opteazã pentru varianta 3 se numesc prin contrast
``micro-nuclee'', pentru cã nucleul avînd puþine servicii devine
foarte mic.

<P>
În fine, sisteme în care majoritatea serviciilor sunt plasate în
spaþiul proceselor însele, în funcþii de bibliotecã, sunt relativ
puþin rãspîndite.  Vom vedea însã niºte candidaþi puþin mai
jos.

<P>

<H2><A NAME="SECTION00031000000000000000">
Biblioteci</A>
</H2>

<P>
Cu servicii plasate în biblioteci este obiºnuit orice programator
care a folosit un limbaj de genul C sau Pascal.  O bibliotecã este o
colecþie de funcþii gata scrise, la care programele utilizatorilor
se pot ``lega'', ºi pe care le pot folosi.  Legarea (linking) la
funcþiile din biblioteci se poate face fie atunci cînd programul
este creat (la sfîrºitul compilãrii), ºi atunci se numeºte
``legare staticã'' (static linking), fie abia dupã ce programul a
fost pornit în execuþie, fiind atunci numitã legare dinamicã
(dynamic linking).  Cert este cã se face doar odatã, aºa încît
costul legãrii se ``amortizeazã'' cînd funcþiile din bibliotecã
sunt folosite intens.

<P>
``Costul'' unui astfel de serviciu este extrem de scãzut; cel mai
scãzut posibil probabil, pentru cã implementarea unui apel de
funcþie în termenii microprocesorului este foarte ieftinã.  Trebuie
însã sã observãm cã natura codului din bibliotecile partajate
care se încarcã dinamic<A NAME="tex2html8"
  HREF="#foot238"><SUP>5</SUP></A> îl face cîteodatã mai ineficient decît codul obiºnuit, cu
factori cuprinºi între 1% 'si 30%.

<P>
Sã vedem niºte exemple concrete faimoase de servicii plasate în
biblioteci.

<P>

<H3><A NAME="SECTION00031100000000000000">
Cazul MS-DOS</A>
</H3>

<P>
Într-un anumit sens sistemul de operare MS-DOS este o mare
bibliotecã de funcþii pe care procesele le pot chema; este adevãrat
cã chemarea funcþiilor se face nu plasînd pe stivã argumente, ci
în regiºtri, ºi apelînd apoi o ``întrerupere software'' (de
exemplu, dacã îmi aduc aminte bine, toate funcþiile pentru
operaþiuni grafice sunt chemate punînd în registrul AX codul
funcþiei ºi executînd INT 10h).  Aceastã întrerupere software
este un rudimentar apel de sistem, care de fapt este un apel indirect
de funcþie din ``nucleu''.

<P>
Datoritã faptului cã MS-DOS nu oferã memorie virtualã, apelul de
sistem este mult mai simplu decît cel descris mai sus în prima
secþiune a articolului, ºi este practic la fel de eficient ca un
apel de procedurã.

<P>
Viteza MS-DOS este explicaþia popularitãþii sale enorme, pe care
s-a clãdit averea Microsoft ºi a fabricanþilor de jocuri.  Din
pãcate (sau din fericire), viteza de execuþie a apelurilor de sistem
nu este singurul criteriu de merit; faptul cã nu oferã multitasking
(mai multe procese simultan, ceea ce implicã ºi memorie virtualã
pentru izolarea lor) ºi cã lucrul cu perifericele este foarte
ineficient, au dus la moartea acestui sistem de operare.

<P>

<H3><A NAME="SECTION00031200000000000000">
Cazul C</A>
</H3>

<P>
Limbajele de programare de nivel înalt posedã adesea funcþii de
bibliotecã pentru a fi independente de arhitectura calculatorului.
În Pascal astfel de funcþii sunt <TT>write</TT> ºi <TT>new</TT>.  O sã
ne aruncãm privirea asupra unei instanþe în limbajul C.

<P>
Limbajul ANSI C pune la dispoziþia utilizatorilor o serie de funcþii
de bibliotecã pentru manipularea de ``stream''-uri (nu îmi vine în
minte nici o traducere rezonabilã).  Un ``stream'' este un cîrnat de
octeþi; tipul stream este în C notat cu <TT>FILE</TT>.  Operaþiile pe
stream-uri au numele prefixate cu litera <TT>f</TT>: <TT>fopen(),
fclose(), fprintf(), fscanf(), fflush(), fputc(), fgetc(), fseek(),
fputs()</TT>, etc.  C transformã toate perifericele în stream-uri;
astfel se pot folosi aceleaºi funcþii pentru terminale, fiºiere,
ºi alte minuni, depinzînd de sistemul de operare.

<P>
Dupã ce un stream este creat (cu <TT>fopen()</TT>) sau moºtenit, (ca
<TT>stdio</TT>), pot fi trimise date spre el cu <TT>fputc(), fputs()</TT>
sau <TT>fprintf()</TT>.  <TT>fputc(caracter, stream)</TT> trimite un
caracter spre stream-ul indicat, oricãrui periferic i-ar fi acesta
asociat.  ``Trimiterea'' se realizeazã de obicei prin invocarea unui
apel de sistem pentru transmis date; la sistemul de operare Unix
folosind apelul <TT>write()</TT>.

<P>
<TT>puts(sir, stream)</TT> trimite un ºir de mai multe caractere.
Funcþia <TT>fprintf()</TT>, (a cãrei binecunoscutã variantã <TT>printf()</TT> este o abreviere) face douã operaþii: <EM>formateazã</EM>
ºi transmite datele (de exemplu <TT>fprintf(stdio, "%d", x);</TT>
transformã întîi valoarea lui <TT>x</TT> într-un ºir de caractere,
dupã care trimite acest ºir spre stream).

<P>
Pe lîngã acest gen de servicii de conversie, biblioteca de operaþii
cu stream-uri mai face un serviciu de ``buffer''-ing: strînge
caracterele trimise spre stream-uri laolaltã ºi le trimite în
grãmezi.  De ce?  Am vãzut cã un apel de sistem este o operaþie
relativ costisitoare.  Din cauza asta, în loc sã invoce nucleul
pentru fiecare caracter, mai multe caractere sunt strînse laolaltã
ºi pasate cu un singur apel de sistem.  Asta implicã imediat o
creºtere de eficienþã.

<P>
Ca sã verific aceastã aserþiune am compilat urmãtoarele douã
programe:

<P>
<PRE>
/* streams */                          /* system call */
int main(void)                         int main(void)
{                                      {
  unsigned long i;                       unsigned long i;

  for (i=0l; i &lt; 1000000; i++)           for (i=0l; i &lt; 1000000; i++)
    putchar('0');                          write(1, "0", 1);
  return 0;                              return 0;
}                                      }
</PRE>

<P>
Varianta din stînga scrie de un milion de ori caracterul 0 folosind
stream-uri.  Stream-ul strînge (în implementarea de bibliotecã pe
care o am eu) cîte 1024 de caractere pe care le trimite<A NAME="tex2html9"
  HREF="#foot239"><SUP>6</SUP></A>; asta înseamnã
cã face 1 000 000/1024 = 977 de apeluri de sistem <TT>write()</TT>.

<P>
Varianta din dreapta pur ºi simplu scrie un milion de caractere
fãcînd un milion de apeluri de sistem, unul pentru fiecare caracter.
Iatã timpii cronometraþi<A NAME="tex2html10"
  HREF="#foot240"><SUP>7</SUP></A> pe o maºinã Linux 486/33Mhz:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">streams</TD>
<TD ALIGN="LEFT">apel de sistem</TD>
<TD ALIGN="LEFT">raport</TD>
</TR>
<TR><TD ALIGN="LEFT">4.66 sec</TD>
<TD ALIGN="LEFT">87.08 sec [sic!]</TD>
<TD ALIGN="LEFT">1:18</TD>
</TR>
</TABLE>
</DIV>

<P>
Pot, fireºte, estima aproximativ durata unui apel de sistem.  Astfel
am durata a 1 000 000 - 977 apeluri de sistem <TT>write()</TT> spre un
periferic nul, de aproximativ 82.5 secunde (scãzînd dispare
diferenþa dintre timpii de legare).  Asta înseamnã un timp de 82
microsecunde pentru un apel de sistem <TT>write</TT>.  Prin contrast,
apelul unei funcþii dureazã sub 1 microsecundã pe aceeaºi
maºinã, dar este mai greu de estimat precis.

<P>

<H3><A NAME="SECTION00031300000000000000">
Cazul NT</A>
</H3>

<P>
Sistemul Windows NT de la Microsoft este aparent un sistem
micro-nucleu, dar vom mai avea un cuvînt de spus asupra acestei
categorisiri.  Oricum, proiectanþii lui Windows NT au sesizat ºi ei
importanþa plasãrii serviciilor frecvente în biblioteci legate
direct la codul proceselor, ºi au încercat din rãsputeri sã
foloseascã aceastã tehnicã pentru eficienþã.  Iatã o
ilustraþie:

<P>
La NT 3.5 gestiunea ecranului era fãcutã de un proces separat, un
``server''; la NT 4.0 gestiunea ecranului a fost mutatã în
interiorul nucleului.  Important este acum pentru noi cã existã o
entitate exterioarã proceselor utilizatorilor care gestioneazã în
întregime ecranul.  Cînd ai de desenat un punct, o linie, un
caracter sau un ``bitmap'', trebuie sã discuþi cu aceastã entitate.
Transmiterea unui mesaj spre un alt proces (la 3.5) sau un apel de
sistem (la 4.0) costã, iar cînd vrei sã trasezi zeci de mii de
elemente (aplicaþiile Windows sunt în mod normal risipitoare în
graficã) costul se înmulþeºte cu acest factor.  Din cauza asta,
proiectanþii lui NT au aplicat tehnica mutãrii serviciilor grafice
în bibliotecile utilizatorului.

<P>
Pe lîngã faptul cã au aplicat tehnica ``buffer''-ului, de a
strînge cît mai multe operaþii la un loc înainte de a le trimite
serverului de ecran, au ajuns la adevãrate ``exagerãri'': de pildã
culoarea curentã este menþinutã atît de serverul ecranului cît
ºi de bibliotecã; atunci cînd utilizatorul cheamã o funcþie
pentru a afla valoarea culorii, biblioteca rãspunde direct, fãrã a
interoga serverul, economisind o comunicaþie.

<P>
Atunci cînd utilizatorul schimbã culoarea curentã, biblioteca nu
transmite modificarea spre server decît în momentul în care
utilizatorul face ºi o desenare; în acest fel se mai economiseºte
un mesaj, fãrã ca vreun efect vizual sã arate schimbarea.

<P>

<H3><A NAME="SECTION00031400000000000000">
Cazul exokernel</A>
</H3>

<P>
PC Report din Septembrie 1996 a gãzduit un articol despre un nou
prototip de arhitecturã a sistemului de operare, ``exokernel'' -ul.
Exokernel-ul este o idee împinsã la extrem, încarnatã într-un
prototip de sistem de operare numit ExOS, dezvoltat la MIT.  Ideea
este de a elimina aproape complet nucleul (mai mult chiar decît în
cazul sistemelor micro-nucleu), mutînd absolut toate funcþiile
acestuia, (mai puþin o oarecare funcþie de arbitrare a accesului la
resurse de nivel foarte jos, cum ar fi pagini de memorie) în
biblioteci gigantice legate de procesele utilizatorilor.  În acest
caz toate operaþiile se pot executa la întreaga vitezã a
microprocesorului, evitînd costisitoarele apeluri de sistem.  (De
aici ºi numele: kernel (nucleu) ``exterior'': la purtãtor.)

<P>
Ideea este foarte tentantã, sîanumite aplicaþii dezvoltate special
pentru exokernel au într-adevãr viteze uluitoare.  Anumite probleme
rãmîn însã foarte greu de rezolvat în contextul exokernel-ului.
Una dintre ele, extrem de spinoasã, este tratatã sumar în
secþiunea consacratã semanticii operaþiilor, aflatã puþin mai
jos.

<P>

<H2><A NAME="SECTION00032000000000000000">
Nucleu</A>
</H2>

<P>
Al doilea loc unde poate fi plasat un serviciu este în nucleu.
Sistemele de operare monolitice pun în nucleu mai toate serviciile
care au o utilizare frecventã.

<P>
Sisteme monolitice tipice sunt (ºi veþi recunoaºte toate sistemele
dominante pe piaþã): Windows 3.1, Windows 95, Unix, VMS,
JavaOS<A NAME="tex2html11"
  HREF="#foot144"><SUP>8</SUP></A>.
Windows NT este considerat în continuare un sistem micro-nucleu,
deºi conþine în nucleu servicii care la Unix (un monolit tipic)
sunt înafara nucleului, cum ar fi sistemul de ferestre sau serverul
de fiºiere.  Dupã cum vedeþi, graniþele sunt difuze între
categorii...

<P>
Sistemele monolitice sunt comercial cele mai rãspîndite.

<P>
Pentru ilustraþie, sã vedem care sunt categoriile de servicii
oferite de un sistem Unix tipic:

<P>
<DL COMPACT>
<DT>*</DT>
<DD>Operaþii cu procese (creare, distrugere, etc.);
</DD>
<DT>*</DT>
<DD>Depanarea ºi mãsurarea (profiling) proceselor;
</DD>
<DT>*</DT>
<DD>Planificarea ºi execuþia proceselor;
</DD>
<DT>*</DT>
<DD>Accounting ºi tarifare dupã consumul resurselor;
</DD>
<DT>&nbsp;</DT>
<DD>Operaþii cu fiºiere;
</DD>
<DT>*</DT>
<DD>Comunicaþie inter-proces: þevi (pipes), semnale, memorie
partajatã, semafoare, mesaje;
</DD>
<DT>&nbsp;</DT>
<DD>Protocoale de comunicaþie în reþea (TCP/IP);
</DD>
<DT>*</DT>
<DD>Gestiunea memoriei virtuale;
</DD>
<DT>*</DT>
<DD>Alocarea ºi eliberarea memoriei;
</DD>
<DT>&nbsp;</DT>
<DD>Timere ºi alarme;
</DD>
<DT>*</DT>
<DD>Mecanisme de protecþie ºi securitate;
</DD>
<DT>&nbsp;</DT>
<DD>Legarea dinamicã;
</DD>
<DT>&nbsp;</DT>
<DD>Managementul perifericelor.
</DD>
</DL>

<P>
Am marcat cu asterisc serviciile care în orice implementare a unui
sistem de operare, fie ea monolit sau micro-nucleu, trebuie sã fie
oferite de nucleu.  (Cum se descurcã exokernel-ul fãrã ele, mie
personal nu îmi este foarte clar.)

<P>
Sistemele monolitice sunt destul de greu de scris ºi relativ
inflexibile: o schimbare a serviciilor oferite se poate face în mod
tradiþional doar oprind sistemul ºi recompilînd o imagine a
nucleului<A NAME="tex2html12"
  HREF="#foot147"><SUP>9</SUP></A>.  Existã însã o cantitate considerabilã de
experienþã în folosirea ºi manipularea acestor sisteme.

<P>
Cea mai dezirabilã trãsãturã a acestor sisteme (comparate cu
bibliotecile) este separaþia netã între spaþiul de adrese al
nucleului ºi cel al proceselor utilizator.  Aceasta permite nucleului
sã aibã un control foarte strîns<A NAME="tex2html13"
  HREF="#foot148"><SUP>10</SUP></A>asupra operaþiilor care pot fi efectuate de procese, ºi îi permite
sã forþeze cu uºurinþã respectarea politicilor de folosire a
resurselor.

<P>

<H2><A NAME="SECTION00033000000000000000">
Server(e)</A>
</H2>

<P>
În fine, putem lua o resursã partajatã ºi o putem depune în
braþele unui proces, care sã aibã grijã de ea; procesul care ne
``serveºte'' cu aceastã resursã se va numi ``server''.  Nucleul
trebuie sã punã la dispoziþia proceselor o metodã eficace prin
care sã comunice între ele; de îndatã ce au aceastã metodã la
dispoziþie, procesele care au nevoie de resursa deþinutã de server
devin ``clienþii'' lui, trimiþîndu-i un mesaj cu cererea lor.
Serverul le rãspunde clienþilor cu datele cerute.

<P>
Marele avantaj al acestei formule este cã teoretic se poate aplica
ºi în cazul în care clientul ºi serverul sunt pe maºini diferite
ºi comunicã printr-o reþea.  Într-adevãr, majoritatea
covîrºitoare a aplicaþiilor din reþea folosesc aceastã
arhitecturã.

<P>
De aici apar însã ºi problemele, dupã cum vom vedea într-o
secþiune ulterioarã consacratã în mod special sistemelor
micro-nucleu, care tind sã exploateze tehnologia client-server.

<P>
Pentru a ilustra diferenþa de performanþã, pe acelaºi calculator
pe care am fãcut mãsurãtorile anterioare, un nucleu experimental
extrem de simplu (PicOS -- implementat de autor), fãrã memorie
virtualã, cu procese integral rezidente în RAM, permite schimbarea a
circa 5000 de mesaje/sec între douã procese pe aceeaºi maºinã.
Asta înseamnã deja 200 de microsecunde pentru un mesaj, adicã 400
pentru un apel complet cerere/rãspuns.  Comparaþi cu performanþa
unui apel de sistem ºi cu a unui apel de procedurã.

<P>
Vom petrece restul rîndurilor din aceastã secþiune chiorîndu-ne la
cîteva exemple reale de folosire a serverelor pentru gestiunea
resurselor.

<P>

<H3><A NAME="SECTION00033100000000000000">
Servere în Unix</A>
</H3>

<P>
În Unix cele mai faimoase servere care ruleazã ca procese sunt:

<P>

<UL>
<LI>pentru accesul fiºierelor la distanþã (NFS: Network File
System), care în mod normal ruleazã ca o combinaþie proces/nucleu;
</LI>
<LI>``super-serverul'' inetd, care porneºte la cerere alte cîteva
sute de servere; lista acestora se poate gãsi într-un fiºier <TT>/etc/services</TT> pe o maºinã Unix; printre ele: servere pentru acces
la distanþã (telnet, rlogin, rsh, rexec, ssh, kerberos), poºtã
electronicã (smtp, uucp), transfer de fiºiere (ftp), etc., etc.;
</LI>
<LI>serverul de www (world wide web);
</LI>
<LI>serverul de nume (named);
</LI>
<LI>serverul de raportare a erorilor (syslogd, klogd);
</LI>
<LI>serverul de ferestre (X).
</LI>
</UL>

<P>

<H3><A NAME="SECTION00033200000000000000">
Windows NT</A>
</H3>

<P>
Windows NT are o arhitecturã în care serverele ocupã un loc
central; probabil din aceastã cauzã este asimilat cu un
micro-nucleu, deºi cele douã noþiuni sunt oarecum independente,
dupã cum se poate vedea din exemplele citate.  Ideea de bazã a lui
NT a fost ``furatã'' de arhitectul lui ºef, David Cutler (la rîndul
lui ``furat'' de la Digital de cãtre Microsoft) de la sistemul de
operare Mach, un prototip de cercetare micro-nucleu construit la
Universitatea Carnegie Mellon ºi acum dezvoltat la Universitatea din
Utah.

<P>
Ideea, extrem de elegantã, este de a construi un mediu foarte bogat
în proprietãþi pe care sã se poatã apoi construi servere
independente care sã emuleze sisteme de operare distincte.  Astfel,
pe o maºinã NT pot rula simultan aplicaþii Windows 95, MS-DOS, OS/2
ºi Unix, fiecare avînd impresia cã foloseºte sistemul de operare
respectiv, dar discutînd de fapt cu un server, ca în
figura&nbsp;<A HREF="micron-html.html#NT">4</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="NT"></A><A NAME="241"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 4:</STRONG>
Arhitectura lui Windows NT.</CAPTION>
<TR><TD>
<PRE>
            | server  | proces   |  server   | server  | proces |
            | Windows | Windows  | securitate| Unix    | Unix   |
            |         |          |           |         |        |
            |         |          |           |         |        |
            ===|=|==========|====================|=|========|====
            |   \ \_________/      |grafica|____/   \_______/   |
  Nucleu    |    \_________________| Win95 |                    |
   (4.0)    |                      |_______|                    |
            |                                                   |
</PRE>
</TD></TR>
</TABLE>
</DIV><P></P>

<P>
În mod normal un server lucreazã astfel: un thread<A NAME="tex2html15"
  HREF="#foot163"><SUP>11</SUP></A> aºteaptã blocat sã vinã cereri de
operaþii de la clienþi.  Cînd vine o cerere, acest thread creazã
un nou thread, cãruia îi paseazã mesajul cu operaþia cerutã,
dupã care se duce din nou la culcare, aºteptînd noi mesaje.
Thread-ul fiu decodificã mesajul, executã operaþia, rãspunde ºi
moare.

<P>
În acest fel server-ul poate executa simultan mai multe cereri.  Pe
de altã parte, dacã nu existã cereri, server-ul nu consumã aproape
nici un fel de resurse, pentru cã are un singur thread, care doarme.

<P>

<H2><A NAME="SECTION00034000000000000000">
Resurse fãrã servere (serverless); Memoria distribuitã
partajatã</A>
</H2>

<P>
Sã notãm în treacãt cã toate cele trei soluþii citate dau
fiecare resursã pe seama cuiva: o bibliotecã, un nucleu, un proces.
Existã ºi o soluþie ``democraticã'', în care nimeni nu posedã un
obiect; acest stil de proiectare se numeºte ``fãrã servere''
(serverless).  Din pãcate algoritmii folosiþi pentru acest fel de
probleme sunt în general puþin robuºti ºi extrem de complicaþi,
ºi trãdeazã adesea tocmai cauza pentru care erau creaþi: evitarea
unei ``gîtuituri'' (bottleneck) în accesul la resursã,
reprezentatã de serverul care o gestioneazã.

<P>
Sã notãm totuºi o aplicaþie a acestui gen de algoritmi în
sistemele de calcul paralele ºi distribuite, mai ales a celor care
implementeazã ceea ce se numeºte <EM>memorie distribuitã
partajatã (Distributed Shared Memory, DSM)</EM>.  Ideea centralã este de
a avea pentru toate calculatoarele dintr-o reþea un singur spaþiu de
adrese uriaº, în care toate scriu ºi citesc, dar care nu este
memorat fizic în vreun loc fixat, ci ale cãrui ``locaþii'' se
``plimbã'' dupã necesitãþi între maºinile care le folosesc.

<P>
Existã ºi sisteme de fiºiere implementate dupã aceastã schemã,
dar progresele comerciale sunt (încã) slãbuþe.  Nici noi nu o sã
le consacrãm deci prea mare importanþã în acest articol, care iar
a început sã ia proporþii mai mari decît cele anticipate iniþial
de autor.

<P>

<H2><A NAME="SECTION00035000000000000000">
Semantica operaþiilor</A>
</H2>

<P>
``Unde sã plasãm un serviciu, în care din cele trei posturi?''
Aparent rãspunsul la aceastã întrebare depinde doar de
consideraþii de eficienþã ºi esteticã, precum ºi de
extravaganþa design-erului.  Dar lucrurile nu stau chiar aºa!

<P>
Vom vedea cã anumite însuºiri ale unui serviciu depind esenþial de
plasarea sa, ºi cã fiecare din cele trei scheme are proprietãþi
speciale, care nu pot fi simulate nicicum în întregime de celelalte.
(Vom ignora asemenea consideraþii elementare cum ar fi cã nu putem
plasa servicii de creare a proceselor într-o bibliotecã, pentru cã
atunci cine creazã procesul în care se aflã biblioteca?)

<P>
Lista de diferenþe care urmeazã nu este în nici un caz exhaustivã,
ci doar vrea sã ilustreze prin exemple problema.

<P>

<H3><A NAME="SECTION00035100000000000000">
Diferenþe semantice bibliotecã-nucleu</A>
</H3>

<P>
Deosebirea dintre bibliotecã ºi nucleu este cu siguranþã
familiarã oricãrui programator în C care frustrat a încercat
sã-ºi depaneze programele punînd <TT>printf()</TT>-uri pe ici-colo,
dar care nu dãdeau nici un efect!

<P>
Explicaþia este simplã: <TT>printf()</TT> scrie, dupã cum am vãzut,
într-un buffer, care este golit numai în anumite circumstanþe.
Dacã o eroare survine înainte ca apelul de sistem <TT>write()</TT> sã
fie executat ºi procesul moare, conþinutul din buffer este definitiv
pierdut!  (Soluþia este, fireºte, sã forþãm golirea buffer-ului
folosind funcþia <TT>fflush()</TT>.)

<P>
Aºa ceva nu se va întîmpla dacã folosim direct <TT>write()</TT>,
pentru cã odatã apelul de sistem executat, datele au fost copiate de
nucleu ºi vor ajunge pînã la urmã la perifericul-destinaþie.

<P>
Diferenþa esenþialã între cele douã cazuri este de duratã de
viaþã a informaþiei: dacã informaþia este într-o bibliotecã,
localã unui proces, atunci ea nu poate supravieþui morþii
procesului<A NAME="tex2html16"
  HREF="#foot173"><SUP>12</SUP></A>.

<P>
Nucleul în schimb supravieþuieºte tuturor proceselor (teoretic),
deci poate menþine în siguranþã informaþiile globale pentru
întregul sistem.

<P>
Un alt exemplu faimos este implementarea protocoalelor de reþea în
biblioteci, care pune infernale dificultãþi (de altfel acesta este
unul dintre motivele atacurilor la exokernel, care, vã amintiþi,
este o bibliotecã mare): de exemplu standardul TCP/IP impune ca dupã
închiderea unei conexiuni de reþea, unul din capete sã reþinã
identificatorul conexiunii pentru o vreme nefolosit (``30 de secunde''
scrie la carte), în aºa fel încît sã nu fie însuºit de o altã
conexiune (în acel caz, pachete întîrziate ale conexiunii precedente
care mai rãtãcesc pe reþea ar putea fi incorect primite pe
conexiunea nouã).  Puteþi vedea în Unix lista tuturor conexiunilor
cu comanda <TT>netstat</TT>.  Cele care sunt în starea <TT>TIME_WAIT</TT>
sunt conexiuni de acest gen: terminate, dar memorate.  Pe un server de
web trebuie sã fie o mulþime de astfel de conexiuni la un moment
dat<A NAME="tex2html17"
  HREF="#foot242"><SUP>13</SUP></A>.

<P>
Ei bine, pe un proces care are protocoalele de comunicaþie
implementate în biblioteci îl vor trece toate sudorile sã menþinã
identificatorul conexiunii dupã moartea procesului.

<P>

<H3><A NAME="SECTION00035200000000000000">
Diferenþe semantice nucleu-server</A>
</H3>

<P>
O deosebire de acelaºi gen de semanticã (semnificaþie) de acelaºi
gen a serviciilor subzistã între serviciile oferite de nucleu ºi
cele oferite de servere aflate la distanþã: în mod normal pe o
maºinã ori merge nucleul ºi procesele, ori, dacã nucleul nu merge,
nu merge nimic.  Cu alte cuvinte, dacã procesele pot cere servicii de
la nucleu sunt sigure cã gestionarul lor este sãnãtos.  Acest lucru
nu mai este adevãrat în cazul proceselor care cer servicii de la
distanþã: cînd scuipi niºte informaþie în reþea ºi nu
primeºti rãspuns este greu de zis dacã informaþia a ajuns ºi
rãspunsul nu, sau informaþia s-a pierdut, sau a ajuns ºi serverul a
murit înainte sau dupã ce a primit-o.  De aici ºi complexitatea
enormã a protocoalelor de reþea ºi a algoritmilor distribuiþi.

<P>
O altã diferenþa greu de mascat între soluþia unei probleme cu
nucleu ºi soluþia cu servere este în încredere.  Un nucleu ºtie
cã toate procesele care ruleazã pe maºina lui au fost create de el
ºi sunt ``legitime''.  Pe de altã parte cînd un server primeºte o
cerere de la distanþã (sau chiar pe aceeaºi maºinã), el nu are la
dispoziþie mijloacele nucleului de verificare.  Un mecanism complet
diferit trebuie inventat pentru a asigura serverul de identitatea
clienþilor, un lucru nenecesar pentru un serviciu plasat în nucleu.

<P>

<H1><A NAME="SECTION00040000000000000000">
Promisiunile micro-nucleelor</A>
</H1>

<P>
Iatã care sunt unele din avantajele (reale sau fictive) ale
arhitecturii micro-nucleu; unele din aceste merite sunt atributabile
arhitecturii client-server, altele arhitecturii de micro-nucleu, dar
am vãzut cã a doua o implicã pe prima.

<P>
<DL>
<DT><STRONG>Modularitate</STRONG></DT>
<DD>Într-un nucleu monolitic diferitele pãrþi
comunicã foarte adesea folosind variabile globale, ceea ce ridicã
probleme dificile privitoare la corectitudinea codului.  Mai ales pe
multiprocesoare, unde mai multe programe pot acþiona simultan asupra
aceleiaºi structuri de date, se pot ivi tot felul de comportamente
ciudate.  Prin contrast, în soluþia cu servere, un server
gestioneazã o cantitate redusã de resurse, iar interacþiunea cu
alte programe se face prin interfeþe foarte bine precizate (mesaje).
E clar, micro-nucleele încurajeazã modularitatea.

<P>
</DD>
<DT><STRONG>Scalabilitate</STRONG></DT>
<DD>Vrei un serviciu mai puternic: mai adaugi niºte
servere sau niºte clienþi, înlocuieºti serverele cu altele mai
performante.  O maºinã este prea încãrcatã: muþi din servere pe
alta.  Toate acestea sunt aspecte ale creºterii incrementale a unui
sistem, sau creºtere în raport cu resursele ºi necesitãþile
disponibile.

<P>
</DD>
<DT><STRONG>Distribuire facilã</STRONG></DT>
<DD>Dacã primitiva ta de bazã este <TT>trimite_mesaj()</TT>, atunci eºti încurajat sã dezvolþi soluþii
pentru programe în care nu conteazã unde se aflã server-ul.
Mediile de calcul distribuit (DCE: Distributed Computing Environment
al lui OSF: Open Software Foundation) sunt un exemplu de standard de
scriere a unei aplicaþii independent de numãrul de calculatoare pe
care se executã.

<P>
</DD>
<DT><STRONG>Adaptabilitate (customizability)</STRONG></DT>
<DD>Nucleul nu poate fi schimbat
decît în micã mãsurã, cu mare grijã, ºi arar fãrã a opri
sistemul.  Pe de altã parte, serverele sunt simple procese, care pot
fi create ºi omorîte dinamic, fãrã a avea nevoie de privilegii
administrative extraordinare.  Cu alte cuvinte fiecare utilizator al
unui micro-nucleu ar putea sã-ºi construiascã mediul care îi
convine; cine nu foloseºte fiºiere nu porneºte nici un server de
fiºiere, ºi are mai multe resurse pentru alte ocupaþii.

<P>
</DD>
<DT><STRONG>Dimensiune redusã</STRONG></DT>
<DD>Vîrful de lance al creatorilor de
micro-nuclee este: plãteºti numai pentru ce foloseºti.  Nu ai
nevoie de ceva: nu primeºti.  Un nucleu monolit conþine toate
serviciile, fie cã le vrei, fie cã nu.

<P>
</DD>
<DT><STRONG>Comunicaþie puternicã inter-proces</STRONG></DT>
<DD>Aceasta este o condiþie
necesarã pentru viabilitatea unui micro-nucleu.  Comunicaþia trebuie
sã fie eficientã, pentru cã fiecare serviciu implicã cel puþin un
schimb de douã mesaje (cerere/rãspuns), ºi flexibilã pentru a
permite transmiterea unei variate game de mesaje (de la un numãr, la
un fiºier de megaocteþi cu imagini).
</DD>
</DL>

<P>

<H2><A NAME="SECTION00041000000000000000">
RPC</A>
</H2>

<P>
Orice discuþie serioasã despre arhitectura client-server trebuie sã
atingã mãcar în trecere subiectul apelului procedurilor la
distanþã (remote procedure calls).  Subiectul este fascinant ºi
meritã o tratare mult mai amplã.

<P>
Observaþi cã în cazul folosirii serverelor nu numai cã am mutat un
serviciu într-un proces separat, dar am schimbat ºi <EM>natura</EM>
modului în care serviciul este invocat: înainte era printr-un apel
de funcþie (sau de sistem), dar acum este prin <EM>trimiterea</EM> unui
mesaj.  E aceeaºi diferenþã de perspectivã ca între o procedurã
ºi un fiºier; pentru un programator paradigma mesajului este mai
incomodã.

<P>
Din cauza asta a fost inventatã împachetarea mesajelor în
proceduri.  Practic programatorul cheamã o procedurã (dintr-o
bibliotecã), care procedurã construieºte mesajul, îl trimite,
aºteaptã rãspunsul ºi se întoarce în mod uzual.  În acest fel
programatorul opereazã din nou cu conceptul familiar de procedurã.

<P>
O astfel de procedurã chematã la distanþã se numeºte în englezã
``remote procedure call'', prescurtat RPC.  Un pachet RPC face multe
lucruri: dintr-o specificare de nivel înalt a procedurii oferite de
server<A NAME="tex2html18"
  HREF="#foot188"><SUP>14</SUP></A> el construieºte
automat funcþiile pentru client ºi server.  Funcþiile acestea, care
manipuleazã mesajul se numesc în englezã <EM>stub</EM>.  Misiunea lor
este de a împacheta argumentele procedurii într-un mesaj (operaþie
numitã <EM>marshalling</EM>), de a trimite mesajul ºi a despacheta
valorile la recepþia unui mesaj.  Funcþionarea este prezentatã
schematic în figura&nbsp;<A HREF="micron-html.html#RPC">5</A>.  Procedurile stub sunt generate de
compilatoare speciale din simpla descriere a interfeþei lor (tipul
argumentelor ºi al rezultatelor).

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="RPC"></A><A NAME="243"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 5:</STRONG>
Operaþiile într-un RPC.</CAPTION>
<TR><TD>
<PRE>
------------           ------------        1. clientul cheama stub-ul
|  client  |           |  server  |        2. 'impachetarea (marshalling)
|          |           |          |        3. stub-ul client trimite mesaj
| 11^  |1  |           |   _6_    |        4. despachetarea (demarshalling)
|===|==v===|           |=5|===|7==|        5. apelul procedurii 'in server
|   |  2\__|____3_>>>__|__/4  |   |        6. execu'tia procedurii 'in server
|  10\_____|___________|_____/ 8  |        7. procedura serverului se 'intoarce
|          |    9 <<<  |          |        8. stub 'impacheteaz'a rezultatele
| stub     |           |     stub |        9. rezultatele transmise clientului
------------           ------------       10. stub-ul client despacheteaz'a
                                          11. stub-ul client se 'intoarce
</PRE>
</TD></TR>
</TABLE>
</DIV><P></P>

<P>
O altã problemã rezolvatã de un pachet RPC este de a <EM>localiza</EM>
serverele care oferã servicii.  Cînd un client porneºte el ºtie
doar cã undeva ar trebui sã se afle un server care exportã
serviciile care îl intereseazã.  Operaþia de descoperire a
server-ului se numeºte tot ``legare'', dar în englezã foloseºte
termenul <EM>binding</EM>, care este un sinonim parþial pentru
``linking'' (corespunzînd acestei faze din compilarea tradiþionalã).

<P>
O calitate a unui pachet RPC bun este cã permite invocarea de
proceduri pe maºini diferite arhitectural de cea pe care se aflã
clientul.  Pentru asta procedurile stub de împachetare trebuie sã
foloseascã un standard comun de reprezentare a datelor, astfel
încît calculatoare care folosesc reprezentãri diferite (ex.
big/little endian) diferite sã se înþeleagã totuºi între ele.

<P>
Existã o mulþime de probleme cu RPC, care scad oarecum din meritele
metodei; în principal o serie de diferenþe între semantica unui
apel de procedurã obiºnuitã ºi al unei proceduri distante sunt
aproape de nedepãºit.  De exemplu cum trimiþi un pointer la
distanþã ºi la ce-i foloseºte server-ului, care are alt spaþiu de
adrese?

<P>

<H1><A NAME="SECTION00050000000000000000">
Problema micro-nucleelor</A>
</H1>

<P>
Din cît am divagat, probabil cã problema sare-n ochi: într-un
micro-nucleu costul unui serviciu este prea ridicat.  Asta pentru cã
transmiterea unui mesaj implicã:

<P>

<OL>
<LI>Apeluri de sistem pentru trimitere ºi recepþie de mesaje,
atît de partea clientului cît ºi a serverului;
</LI>
<LI>Cel puþin o comutare de procese;
</LI>
<LI>Pentru RPC împachetarea ºi despachetarea argumentelor;
</LI>
<LI>Copierea argumentelor din spaþiul de adrese al clientului, în
nucleu, eventual prin reþea, ºi apoi în spaþiul serverului;
</LI>
<LI>Crearea unui thread în server pentru a trata cererea;
</LI>
<LI>Dacã mesajul trece prin reþea este posibil sã fie copiat de
mai multe ori: de pildã din nucleu pe placa de reþea ºi invers la
recepþie;
</LI>
<LI>Copierea rãspunsului pe traseul invers server --&gt;
client.
</LI>
</OL>

<P>
O altã observaþie interesantã este cã în general în micro-nuclee
tendinþa este de a fragmenta un serviciu oferit de un nucleu monolit
în <EM>mai multe</EM> servicii oferite de servere diferite.  De
exemplu, apelul <TT>open(fisier)</TT> din Unix de obicei devine un
apel pentru a traduce numele de fiºier într-un identificator unic,
executat de serverul de directoare (sau, mai rãu, traducerea fiecãrei
pãrþi din ``cãrare'' (path) independent, printr-un apel separat al
unui alt server!), ºi apoi ``deschiderea'' fiºierului la serverul de
fiºiere propriu-zis (figura&nbsp;<A
HREF="micron-html.html#userv">6</A> ilustreazã acest fapt).  În acest
caz, ceea ce iniþial era un singur apel de sistem poate deveni o suitã
de zeci de mesaje schimbate cu mai multe servere!

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="userv"></A><A NAME="244"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 6:</STRONG>
Deschiderea fiºierului <TT>/usr/bin/bash</TT>
într-un sistem distribuit.</CAPTION>
<TR><TD>
<PRE>
              1         __________                          Mesaje schimbate
        /---------->>--|          | server-ul          1. unde e serverul usr?
        | /--------<<--|__________| directorului /     2. la adresa xx
        | |   2     
------------       3    __________
|  client  |____/--->>-|          | server-ul (xx)     3. unde e `bin'?
|          |--------<<-|__________| directorului /usr  4. la adresa yy
|          |____   4              
|          |--\ \     5 __________ 
------------   \ \-->>-|          | server-ul (yy)     5. unde e `bash'?
        | |     \---<<-|__________| directorului /bin  6. la zz, cod ww
        | |           6            
        | |             __________
        | \__7__/--->>-|          | server-ul (zz)     7. scoate `ww'!
        \-----------<<-|__________| de fisiere         8. uite-l! (date) 
             8         
</PRE>
</TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H1><A NAME="SECTION00060000000000000000">
În loc de concluzie: arhitectura NT</A>
</H1>

<P>
Vom încheia acest articol urmãrind cîteva din trucurile fãcute de
proiectanþii sistemului Windows NT în lupta cu microsecundele.
Trebuie spus din capul locului cã pentru a pãstra compatibilitatea
cu atîtea sisteme existente (Windows 95, OS/2, etc.) ei nu aveau de
ales între prea multe variante arhitecturale, ºi cã soluþia cu
serverele din figura&nbsp;<A HREF="micron-html.html#NT">4</A> este cea mai flexibilã.

<P>

<H2><A NAME="SECTION00061000000000000000">
Local procedure call (LPC)</A>
</H2>

<P>
Un pachet RPC face o grãmadã de operaþii de care nu este nevoie în
cazul în care clientul ºi serverul sunt pe aceeaºi maºinã.  De
exemplu conversia datelor într-un format standard ºi înapoi este
curatã sinucidere, din moment ce procesorul este acelaºi.  Pe de
altã parte o cantitate impresionantã de mesaje în NT tind sã fie
între programe locale; de exemplu tot ce þine de afiºare pe ecran
se plimbã între unul din serverele de emulare ºi serverul Windows
95, care singur are în mînã gestiunea ecranului.  Din cauza asta
între NT 3.54 ºi NT 4.0 serverul de ecran a coborît în nucleu, cum
apare ºi în figura&nbsp;<A HREF="micron-html.html#NT">4</A>.

<P>
Mai apar ºi alte mesaje locale, de exemplu între un program Unix ºi
serverul de emulare Unix.

<P>
Proiectanþii NT au optimizat în mod special acest gen de comunicare,
numind-o ``apel de procedurã localã'' (Local Procedure Call, LPC).
Cînd apelul unei funcþii dintr-un server este pe aceeaºi maºinã,
majoritatea operaþiilor costisitoare sunt pur ºi simplu evitate.
Din pãcate nici atîta nu este suficient pentru a atinge performanþa
necesarã.  Iatã alte douã trucuri care sunt folosite cu succes în
cazul NT, pentru servere locale.

<P>

<H2><A NAME="SECTION00062000000000000000">
Memoria partajatã</A>
</H2>

<P>
Dacã se eliminã operaþiile care <EM>transformã</EM> datele
(marshalling), atunci cel mai mare cost nu este dat nici de apelul de
sistem, nici de comutarea proceselor, ci de <EM>copierea</EM>
argumentelor mari.  Foarte adesea serverele de fiºiere sunt
implementate folosind RPC; operaþii tipice vor transfera cantitãþi
mari de date din/spre fiºier.  Copierea datelor din client în nucleu
ºi apoi în server pentru un <TT>write()</TT> (sau invers la citirea
unui fiºier) este o risipã majorã (overhead) fãrã nici un
beneficiu real.

<P>
Proiectanþii lui Windows NT au folosit un mod special de transmitere
a datelor între un client ºi un server, care foloseºte mecanismul
de memorie virtualã oferit de nucleu.  Astfel, clientul alocã o
zonã de memorie partajatã (pagini din RAM care sunt vizibile în mai
multe spaþii virtuale) ºi trimite server-ului doar o descriere a
zonei partajate.  De pildã pentru un <TT>write()</TT> clientul alocã
zona (printr-un apel special de sistem), scrie datele în zonã, face
un LPC <TT>write()</TT> la server, dînd descrierea zonei partajate.
Serverul poate accesa acum direct memoria comunã cu clientul.  Nici
un octet nu a fost mutat în bufferele din nucleu ºi înapoi!
Singura operaþie este modificarea tabelelor de translatare a
adreselor pentru a face zona vizibilã ºi în server.  Zona
partajatã este fãcutã vizibilã în spaþiul server-ului în timp
ce server-ul executã apelul, dupã care devine din nou invizibilã
pentru server.

<P>
Aceeaºi tehnologie, a memoriei partajate, este folositã ºi în
anumite implementãri ale serverelor de ferestre X Windows, în care
clienþii locali pot da direct zone de memorie, ºi nu conþinutul
lor.

<P>

<H2><A NAME="SECTION00063000000000000000">
Prealocarea resurselor</A>
</H2>

<P>
Amintiþi-va, din secþiunea dedicatã serviciilor oferite de servere,
cum funcþioneazã un server în NT: face ``pui'' (thread-uri) pentru
fiecare nouã cerere, care mor dupã execuþia cererii.  Aceastã
creare de thread-uri pentru fiecare serviciu este de asemenea o sursã
importantã de ineficienþã.  De aceea Windows NT mai încalcã
încã odatã regulile bunelor maniere ºi face o optimizare
specialã.  Proiectanþii spun cã aceastã optimizare este atît de
urîtã încît nici nu este accesibilã utilizatorului obiºnuit; ea
este folositã numai între serverele de emulare ºi modulul grafic.

<P>
Pe scurt între un client foarte activ ºi un server se stabileºte o
cale extrem de rapidã de comunicare la cererea clientului.  Astfel
server-ul alocã un thread special pentru acel client, care va executa
numai cererile acestui client.  Mai existã o zonã partajatã
alocatã permanent pentru uzul celor doi, ºi o pereche de
``evenimente'' (event pair).  Perechea de evenimente este de fapt un
întrerupãtor prin care clientul ºi thread-ul alocat din server
îºi semnaleazã reciproc (mai exact îi semnaleazã planificatorului
din nucleu) cînd au nevoie de serviciile celuilalt.

<P>
Acest mecanism simplificã multe operaþii: thread-ul nu mai este
creat/distrus, tabela de pagini pentru memoria partajatã nu mai este
modificatã (pentru cã zona partajatã va fi folositã pentru
totdeauna de douã thread-uri fixate), planificatorul (scheduler-ul)
nu mai are de fãcut nici o decizie de alegere, pentru cã va rula
server-ul în cuanta de timp neconsumatã a client-ului.

<P>

<H1><A NAME="SECTION00070000000000000000">
Concluzii</A>
</H1>

<P>
Plasarea serviciilor în mîinile unor procese face gestiunea mult mai
simplã, dar este un factor mare de ineficienþã datoritã <EM>graniþelor
numeroase de trecut între sisteme autonome (procese ºi nucleu)</EM>.
Diferenþa este semnificativã ºi forþeazã programatorii de sistem la
tot felul de soluþii extravagante optimizate pentru cazuri
particulare.

<P>
Windows NT, care este considerat sistemul de operare al viitoarei
decade, a constatat pe propria piele dezavantajele arhitecturilor
micro-nucleu, cãpãtînd caracteristici accentuate de monolit, ºi
folosind tehnici extreme pentru a recupera eficienþa.

<P>
Una peste alta, în ziua de astãzi în sisteme de operare viaþa nu
este prea simplã pentru programatori!

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot53">...
1996</A><A NAME="foot53"
 HREF="micron-html.html#tex2html1"><SUP>1</SUP></A>
<DD>Pentru cei care nu au cumpãrat revista, articolele la
care fac referinþã sunt disponibile în postscript din pagina mea de
web.

<DT><A NAME="foot55">... securitate</A><A NAME="foot55"
 HREF="micron-html.html#tex2html2"><SUP>2</SUP></A>
<DD>Se înregistreazã fireºte ºi tendinþe de
a permite accesul proceselor direct la periferice, cum ar fi de
exemplu în tehnologia Unet, în care procesele pot scrie direct pe
placa de reþea; deocamdatã sistemele comerciale însã nu au mers
atît de departe.

<DT><A NAME="foot236">... datelor</A><A NAME="foot236"
 HREF="micron-html.html#tex2html5"><SUP>3</SUP></A>
<DD>De pildã nucleul poate reþine adresa <EM>fizicã</EM> a buffer-ului, ºi poate marca în tabelele interne acea
zonã ca fiind ``tabu'' (pentru a nu fi modificatã de algoritmii de
paginare, care refolosesc memoria fizicã) pînã conþinutul ei a
fost prelucrat.

<DT><A NAME="foot93">... Buffer</A><A NAME="foot93"
HREF="micron-html.html#tex2html6"><SUP>4</SUP></A> <DD>vedeþi ºi <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#cache">articolul</a>
meu despre cache-uri din PC Report din martie 1997 pentru o discuþie a
TLB.

<DT><A NAME="foot238">... dinamic</A><A NAME="foot238"
 HREF="micron-html.html#tex2html8"><SUP>5</SUP></A>
<DD>Este vorba de faptul cã acest cod
este ``independent de poziþie'' (<EM>position independent code</EM>;
PIC).

<DT><A NAME="foot239">... trimite</A><A NAME="foot239"
 HREF="micron-html.html#tex2html9"><SUP>6</SUP></A>
<DD>Am
verificat acest lucru folosind comanda <TT>strace</TT>.

<DT><A NAME="foot240">... ti</A><A NAME="foot240"
 HREF="micron-html.html#tex2html10"><SUP>7</SUP></A>
<DD>Timpii au fost cronometraþi cu
comanda <TT>time program &gt;/dev/null</TT>, cu ieºirea trimisã la
perifericul null, care face operaþiile instantaneu, deci nu intervine
în mãsurãtoare.

<DT><A NAME="foot144">...
JavaOS</A><A NAME="foot144"
 HREF="micron-html.html#tex2html11"><SUP>8</SUP></A>
<DD>Informaþiile mele în legãturã cu JavaOS nu sunt
foarte ample, dar cred cã poate fi categorisit ca monolitic.

<DT><A NAME="foot147">...
nucleului</A><A NAME="foot147"
 HREF="micron-html.html#tex2html12"><SUP>9</SUP></A>
<DD>Sistemele moderne Unix pot încãrca dinamic unele
porþiuni de nucleu.

<DT><A NAME="foot148">... ns</A><A NAME="foot148"
 HREF="micron-html.html#tex2html13"><SUP>10</SUP></A>
<DD>Cel puþin teoretic;
faptul cã se raporteazã mereu noi bug-uri în securitatea sistemelor
Unix nu zguduie de loc încrederea adepþilor în aceastã tezã.

<DT><A NAME="foot163">... thread</A><A NAME="foot163"
HREF="micron-html.html#tex2html15"><SUP>11</SUP></A> <DD>Dacã noþiunea
nu vã este familiarã, puteþi asimila un thread cu un proces; o
descriere amplã a conceptului ºi o implementare a unui pachet de
thread-uri am <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#threads">publicat</a>
în PC Report din ianuarie 1997.  De altfel în Unix-ul tradiþional,
ne-existînd thread-uri, se folosesc chiar procese pentru servere.

<DT><A NAME="foot173">...
procesului</A><A NAME="foot173"
 HREF="micron-html.html#tex2html16"><SUP>12</SUP></A>
<DD>Fireºte, o bibliotecã partajatã poate servi de
repozitoriu de informaþie

<DT><A NAME="foot242">...
dat</A><A NAME="foot242"
 HREF="micron-html.html#tex2html17"><SUP>13</SUP></A>
<DD>Dacã nu aveþi la îndemînã un server de web, creaþi
o conexiune cu <TT>telnet localhost</TT>, vedeþi ambele capete cu <TT>netstat</TT>, închideþi conexiunea cu <TT>exit</TT> ºi apoi vedeþi
informaþia rãmasã din nou cu <TT>netstat</TT>.

<DT><A NAME="foot188">...
server</A><A NAME="foot188"
 HREF="micron-html.html#tex2html18"><SUP>14</SUP></A>
<DD>Într-un limbaj de descriere a interfeþei,
``interface definition language'', prescurtat IDL.

</DL>
<BR><HR>

</BODY>
</HTML>
