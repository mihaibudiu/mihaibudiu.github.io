<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Nucleul</TITLE>
<META NAME="description" CONTENT="Nucleul">
<META NAME="keywords" CONTENT="nucleu-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Nucleul</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- budiu@cs.cornell.edu</STRONG></P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html19"
  HREF="nucleu-html.html">Ce se dã ºi ce se cere</A>
<LI><A NAME="tex2html20"
  HREF="#SECTION00030000000000000000">Maºina</A>
<LI><A NAME="tex2html21"
  HREF="#SECTION00040000000000000000">Nucleul ca bibliotecã de funcþii</A>
<LI><A NAME="tex2html22"
  HREF="#SECTION00050000000000000000">Nucleul ca interpretor</A>
<LI><A NAME="tex2html23"
  HREF="#SECTION00060000000000000000">Procesele - time-sharing</A>
<LI><A NAME="tex2html24"
  HREF="#SECTION00070000000000000000">Memoria virtualã</A>
<LI><A NAME="tex2html25"
  HREF="#SECTION00080000000000000000">Securitatea</A>
<LI><A NAME="tex2html26"
  HREF="#SECTION00090000000000000000">Modul nucleu ºi modul utilizator</A>
<LI><A NAME="tex2html27"
  HREF="#SECTION000100000000000000000">Natura nucleului</A>
<LI><A NAME="tex2html28"
  HREF="#SECTION000110000000000000000">Tabela de procese</A>
<LI><A NAME="tex2html29"
  HREF="#SECTION000120000000000000000">Apelurile de sistem</A>
<LI><A NAME="tex2html30"
  HREF="#SECTION000130000000000000000">Reentranþa</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION000140000000000000000">Erorile</A>
<LI><A NAME="tex2html32"
  HREF="#SECTION000150000000000000000">Comunicaþia inter-proces</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION000160000000000000000">Micro-nuclee ºi monoliþi</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION000170000000000000000">Ce a mai rãmas</A>
</UL>
<!--End of Table of Contents-->
<P>
<DL>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>nucleu, întrerupere, controler, time-sharing,
securitate, proces
</DD>
<DT><STRONG>Nivelul tehnic:</STRONG></DT>
<DD>programator cu 1-2 ani de experienþã
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>un limbaj de asamblare
</DD>
</DL>

<P>
Cea mai importantã parte a unui sistem de operare, cea care
se regãseºte în oricare implementare, de la MS-DOS la VMS, este
<EM>nucleul</EM>.  Acest articol încearcã sã explice pe scurt ce, cum,
cînd ºi de ce face un nucleu.

<P>
Ca sã vã convingeþi de importanþa nucleului încercaþi
sã faceþi urmãtorul experiment cu PC-ul dumneavoastrã
(presupunînd cã folosiþi MS-DOS): ºtergeþi <TT>msdos.sys</TT> de pe
hard-disc (unul din fiºierele care conþine nucleul sistemului) ºi
apoi încercaþi sã folosiþi calculatorul fãrã dischete de boot.
Dacã aþi reuºit, nu mai citiþi articolul ãsta.  Mai bine scrieþi
unul.

<P>
Vom folosi pe alocuri pentru ilustraþii exemple din MS-DOS,
Windows ºi UNIX, însã conceptele discutate încearcã sã fie
independente de aceste sisteme de operare.

<P>
Anumiþi termeni sunt atît de consacraþi în englezã
încît traducerea lor ar suna caraghios, ºi nu ar face articolul
mai lizibil.  Vom amesteca tacit astfel de barbarisme frecvent în
text.

<P>

<H1><A NAME="SECTION00020000000000000000">
Ce se dã ºi ce se cere</A>
</H1>

<P>
Un sistem de operare este în general compus dintr-o sumã de
componente relativ independente, dar care toate concurã spre un singur
scop: a face viaþa utilizatorului mai uºoarã.  A explica ce este un
nucleu nu este foarte simplu atîta vreme cît nu este clar:

<P>

<UL>
<LI>ce funcþii importante oferã sistemul de operare;
</LI>
<LI>ce poate face un calculator dacã nucleul nu existã.
</LI>
</UL>

<P>
Din cauza asta trebuie sa aruncãm întîi o privire asupra a
ceea ce ºtie sã facã un calculator fãrã a avea un nucleu, ºi
asupra a ceea ce nucleul adaugã.

<P>

<H1><A NAME="SECTION00030000000000000000">
Maºina</A>
</H1>

<P>
Sã luãm un calculator tipic.  Ce poate el sã facã fãrã
nici un fel de programe?  În primul rînd microprocesorul -- sau mai
precis Unitatea Centralã (UC), care nu este întotdeauna un
microprocesor -- ºtie sã <EM>interpreteze</EM> programe.  Cum face
asta?  Are un pointer, numit Program Counter (PC), spre o adresã a
memoriei, de unde citeºte cîte un numãr.  Acesta este interpretat
drept codul unei instrucþiuni, care este executatã.  PC-ul este
modificat ºi apoi UC o ia de la capãt cu cititul numãrului.

<P>
Ce fel de instrucþiuni ale UC existã?  De transfer de date
între memorie ºi regiºtri, pentru felurite operaþii
aritmetice/logice, instrucþiuni pentru controlul execuþiei
programului (<TT>if</TT>, <TT>goto</TT>, etc).  Coprocesorul matematic ºi
cu instrucþiunile lui îl includem tot în UC; o aproximaþie bunã
pentru nevoile noastre.

<P>
Calculatoarele moderne sunt echipate ºi cu o unitate de
management al memoriei, UMM.  Cîteodatã ea este parte din
microprocesor, ca la Intel, cîteodatã un circuit separat, ca la
Motorola.  Rolul ei este urmãtorul: de fiecare data cînd cineva (de
exemplu UC) intenþioneazã sa acceseze o locaþie de memorie
indicînd o adresã, aceastã adresã este verificatã ºi
transformatã dupã un set de reguli (care este sub controlul UC).
Rezultatul transformãrii adresei este o altã adresã de memorie sau
o eroare (excepþie) dacã ceva nu e în regulã.

<P>
Pe lînga UMM mai existã o parte activã într-un calculator,
de data asta mult mai greu de descris, pentru ca are o natura extrem
de eterogenã.  În general apelativul aplicat este ``dispozitive
periferice''.  Cu riscul de a fi prea generali ºi de a nu respecta
adevãrul întotdeauna, putem sã le descriem astfel: perifericele
sunt dispozitive care permit comunicarea cu ``lumea exterioarã''.  La
nivelul cel mai de jos întruparea lor este ``controlerul'', care este
un fel de microprocesor foarte specializat.  Controlerele primesc mici
programe de executat de la UC, în limbajele lor specifice (fiecare
controler are comenzile lui), ºi apoi le executã.  Execuþia se
soldeazã cu un transfer de date dinspre/spre memorie.  Unele
controlere pot transfera singure date, altele doar pun datele la
dispoziþia UC.

<P>
Instrucþiunile înþelese de controlere sunt de nivel extrem
de scãzut.  De exemplu, pentru a scrie un ºir de octeþi pe disc,
trebuie trimis controlerului de disc un program care specificã locul
precis pe disc (partiþie, cilindru, cap, sector, adresã), codul
operaþiei (scriere), adresa în memorie unde se aflã octeþii,
numãrul lor.  Dupã terminare trebuie aflat dacã totul a mers cum
trebuie: poziþia pe disc la care s-a ajuns (dacã suntem în alt loc
decît ne aºteptam e bucluc), dacã datele s-au scris, dacã nu de ce
nu (eroare tranzitorie, disc protejat, time-out); dacã nu a mers bine
trebuie încercat (dacã are sens) de mai multe ori, sau trebuie
resetat controlerul, sau trebuie trimis capul hard-disc-ului la
începutul discului (recalibrare), ca sa fim siguri unde se aflã --
poate nu s-a miºcat cum trebuia -- sau cine mai ºtie ce se poate
întîmpla.

<P>
Metoda universal folositã actualmente, prin care controlerul
atrage atenþia UC cã s-a petrecut ceva interesant (de exemplu s-a
terminat transferul, sau s-a produs o eroare, sau s-a întîmplat ceva
``în lumea de-afarã'' -- de exemplu s-a apãsat o tastã) este <EM>întreruperea</EM>.  Grosier descris, o întrerupere se soldeazã pentru
UC cu încãrcarea PC-ului cu o valoare anumitã, care depinde de
natura întreruperii.  Asta înseamnã de fapt un salt la o anume
adresã, salt care se petrece fãrã a fi consecinþa executãrii
programului curent, ci a ceva care s-a întîmplat ``înafarã''.  Ca
sa rãmînem în cadrul exemplului de mai sus, dupã ce a programat
controlerul de hard-disc sã scrie ce are de scris, UC face altceva.
Cînd controlerul a terminat operaþia (cu bine sau nu) genereazã o
întrerupere pentru a atrage atenþia asupra sa.  UC ºtie cã trebuie
sã se ocupe de controler.

<P>
Întreruperi pot fi generate nu numai de periferice, ci ºi de
UMM, sau chiar de UC însãºi: de exemplu cînd cineva încearcã sã
împartã la 0 se poate produce o întrerupere generatã de chiar UC.
UC poate inhiba generarea de întreruperi (prin executarea unor
instrucþiuni speciale) dacã doreºte, dar de obicei o face pentru
perioade foarte scurte.  

<P>
Uneori avem de a face cu un controler special numai pentru
întreruperi, care are grijã ca o întrerupere ignoratã la un moment
dat sã fie livratã mai tîrziu, cînd UC permite.  Asta pentru cã
întreruperile semnificã evenimente importante, care nu pot fi
trecute cu vederea.

<P>
Ei bine, cam atît poate face un calculator!  Dupã cum
vedeþi nu este prea simplu de folosit un calculator gol-goluþ:
lucrurile pe care ºtie sã le facã sunt mult prea simple, ºi este
poate nevoie de mii de instrucþiuni numai pentru a scrie un numãr pe
ecran.  Aici intrã nucleul în joc.

<P>

<H1><A NAME="SECTION00040000000000000000">
Nucleul ca bibliotecã de funcþii</A>
</H1>

<P>
Una din primele utilizãri la care se gîndeºte cineva cînd
este întrebat despre nucleu, este drept colecþie de funcþii care
sunt necesare marii majoritãþi a programelor.  Cele mai evidente
sunt funcþiile pentru intrare-ieºire; utilizatorul în loc sã dea
zeci de comenzi controlerului, sã aºtepte întreruperea, sã
verifice rezultatele, eventual sã încerce din nou, sã trateze
erorile, cheamã o funcþie din nucleu (printr-un <EM>apel de sistem</EM>
- un fel de apel de procedurã mai simandicos), procedurã care de
exemplu ar putea avea numele mnemonic <TT>write_file</TT>, cu niºte
argumente simple: un nume de fiºier ºi un array.

<P>
De altfel în cazul sistemului de operare MS-DOS nucleul --
grosso modo -- la cam atîta se rezumã: la a oferi niºte funcþii
foarte utile.  La MS-DOS nucleul este format din mai multe componente:
una se cheamã BIOS, (Basic Input-Output System) ºi este o suitã de
funcþii înscrise în memorii nevolatile.  De exemplu pe plãcile
video VGA se aflã cîte un BIOS care oferã funcþii pentru a face un
punct, o linie, a trece în modul text/grafic, a schimba rezoluþia, a
ºterge ecranul, etc.  Acestea sunt, logic vorbind, pãrþi ale
nucleului.  MS-DOS mai oferã (ca mai toate sistemele de operare)
funcþii pentru accesul discului.  Astfel, în loc de a avea de a face
cu un obiect foarte complicat, care are capete, cilindri, ºamd., avem
o structurã de directoare, care permite fiºierelor sã aibã nume,
ºi sã creascã fãrã sã se calce pe picioare între ele.  Funcþii
de genul ``adaugã un octet la sfîrºitul fiºierului cutare'' sunt
tot pãrþi din nucleu.  La MS-DOS, alte pãrþi ale nucleului (afarã
de BIOS) se citesc de pe disc la ``încãlþarea'' sistemului
(``boot''-are), din fiºierele <TT>msdos.sys</TT> ºi <TT>io.sys</TT>.

<P>

<H1><A NAME="SECTION00050000000000000000">
Nucleul ca interpretor</A>
</H1>

<P>
Deja am început sã ne facem o impresie (favorabilã) despre
natura nucleului.  Cu ce poate fi el asemuit cel mai tare?  Din punct
de vedere al utilizatorului, nucleul este un <EM>interpretor</EM>, pentru
cã oferã niºte noi instrucþiuni spre uzul tuturor (apelurile de
sistem sunt aceste instrucþiuni).  Utilizatorul foloseºte aceste
``instrucþiuni'' ca ºi cum ele i-ar fi oferite de cãtre maºina
însãºi; de fapt ele sunt interpretate: sunt obþinute prin
executarea funcþiilor din nucleu, care sunt scrise în termenii
instrucþiunilor de bazã ale maºinii.

<P>
Aproximaþia aceasta, a nucleului cu un interpretor, poate fi
dusã la limitã, cu niºte consecinþe foarte interesante.  În 1952
a fost creat limbajul BASIC (nu dispreþuiþi, vã rog, venerabilul,
chiar dacã uºor senil), tocmai pentru acest scop: pentru a þine loc
de nucleu al sistemului de operare, oferind <EM>numai</EM> instrucþiuni
de nivel mai ridicat decît cele ale UC, UMM, etc.

<P>
O altã tentativã interesantã, care se bucurã de ceva mai
mult succes, este de a folosi un limbaj mult mai puternic pe post de
nucleu, ºi anume LISP.  LISP-ul este tot un limbaj interpretat (în
esenþã), mult mai expresiv decît BASIC-ul, care poate folosi pe
post de sistem de operare (aþi auzit de ``maºinile LISP''?).

<P>
În toate aceste cazuri nucleul transformã de fapt
calculatorul într-o unealtã mult mai uºor de folosit: într-o <EM>maºinã virtualã</EM>.

<P>

<H1><A NAME="SECTION00060000000000000000">
Procesele - time-sharing</A>
</H1>

<P>
Ei bine, este grozav sã poþi scrie ºi citi date de la
periferice printr-un simplu apel de sistem.  Dar cine face citirea?
``Programele'', o sã spuneþi.  Da, dar care programe?  Suntem
obiºnuiþi ca într-o sesiune de utilizare a calculatorului sã
jonglãm cu o sumedenie de programe <EM>diferite</EM>, fãrã sã ne dãm
prea bine seama.  Editoare de texte, compilatoare, programe de
gestiune, de poºtã electronicã, etc.

<P>
Una din foarte importantele funcþii ale nucleului unui sistem
de operare este de a permite fiºierelor (de exemplu <TT>bc.exe</TT>) sã
devinã programe care se executã (ºi care atunci capãtã denumirea
de <EM>procese</EM>).

<P>
Una din funcþiile auxiliare acestui scop este gestiunea
resurselor calculatorului (memorie, etc.) în aºa fel încît
simultan sau succesiv sã poatã exista <EM>mai multe</EM> procese distincte.
(N-a fost dintotdeauna aºa!  În anii cincizeci porneai un calculator
pentru a face o singurã treabã; dupã aceea trebuia sã-l stingi.
Am avansat ceva.)

<P>
MS-DOS oferã de pildã un apel de sistem numit <TT>system()</TT>, prin care un utilizator poate indica nucleului un fiºier,
al cãrui conþinut este un ºir de instrucþiuni pe care îl doreºte
executat.

<P>
E simplu sa foloseºti <TT>system()</TT>, dar nucleul are o
treabã foarte grea de fãcut.  El trebuie sã gãseascã pentru noul
proces un loc în memorie (poate le dã pe cele vechi afarã), sã
citeascã întregul fiºier (am vãzut cã asta nu e deloc simplu),
ºi apoi sã sarã la prima instrucþiune cititã.

<P>
Lucrurile se complicã ºi mai tare dacã programul nou citit
trebuie sã se execute în paralel cu altele (nu e grozav sã nu
trebuiascã sã aºtepþi pînã programul care tipãreºte la
imprimantã terminã de scos totul ca sã lucrezi cu programul de
scris texte?).  O astfel de coexistenþã a mai multor procese
simultan se numeºte ``multitasking'' în englezã.  Utilizatorii de
MS-DOS nu au vãzut aºa ceva, dar cei de Windows, da.

<P>
Metoda prin care nucleul implementeazã de obicei
multitasking-ul se numeºte, tot în englezã, ``time sharing''
(punere în comun a timpului) ºi este extrem de interesantã.  Sã ne
aplecãm asupra ei ºi sã vedem cum se poate ea obþine din
instrucþiunile primitive ale maºinii.

<P>
Ideea de bazã este simplã: toate calculatoarele au un
``ceas'' (un periferic) care genereazã periodic întreruperi.
Fiecare întrerupere cauzeazã, dupã cum am spus, întreruperea (cum
altfel?)  programului care tocmai se executã, memorarea PC-ului din
aceastã clipã, ºi saltul la o anumitã procedurã asociatã
întreruperii.  În mod normal toate aceste proceduri, care servesc la
tratarea întreruperilor, sunt tot parte a nucleului (numele lor
englezesc este ``interrupt handlers'').

<P>
Cum ziceam, vine întreruperea de ceas; tocmai se executa
programul nr.1.  Se sare la procedura de tratare a întreruperii din
nucleu, care se uitã sã vad;a cine se executa: programul nr.1.
``Aha!'' zice nucleul, ``pentru moment îi ajunge.'', dupã care pune
la loc sigur valoarea PC-ului (salvatã de întrerupere), ºi a
celorlalþi regiºtri.  Apoi ia din alt loc valoarea pe care o salvase
pentru PC-ul programului nr.2, ºi face un salt acolo.  ªi tot aºa.
Rezultatul este executarea interclasatã a instrucþiunilor celor
douã programe.

<P>
Lucrurile se petrec foarte frumos astfel; dacã programele nu
acceseazã nici o zonã de memorie sau fiºier sau periferic în
comun, fiecare are impresia cã este singurul care se executã pe acel
calculator.  Programele nu trebuie scrise într-un fel special pentru
a putea coexista, de aceea sarcina programatorului este mult mai
simplã.

<P>
Inversa operaþiei de creere a unui proces este ``moartea''.
Aceasta este realizatã de nucleu scoþînd procesul defunct de pe
lista proceselor care se vor executa ºi eliberînd memoria alocatã
lui (plus alte resurse, cum ar fi fiºiere, etc.).

<P>

<H1><A NAME="SECTION00070000000000000000">
Memoria virtualã</A>
</H1>

<P>
Poate am cerut prea mult de la programe mai sus, cînd am zis
cã ele nu trebuie sã acceseze nimic în comun.  Memoria este una
singurã (de obicei), ºi este cam greu sã scrii un program în aºa
fel încît sã se poatã împãca cu oricare altul.

<P>
Dar nucleul ne sare din nou în ajutor!  Orice sistem de
operare mai evoluat (categorie la care MS-DOS nu se ridicã cu toatã
bunãvoinþa în ziua de azi) transformã ºi accesul la memorie în
aºa fel încît procesele sã nu se poatã influenþa în moduri
nedorite.  Mecanismul pe care îl descriem (numit ``memorie
virtualã'') este extrem de util chiar ºi în cazul în care nu avem
multitasking.

<P>
Ideea este de a folosi UMM (care pentru asta a ºi fost
fãcutã) pentru a da impresia fiecãrui proces care se executã pe
maºinã cã toatã memoria este a lui, de la adresa 0 la adresa
infinit, dacã se poate, ºi a nimãnui altcuiva, chiar dacã
lucrurile nu stau de fapt de loc aºa.

<P>
Soluþia este de a înghesui mai multe procese simultan în
memoria disponibilã fizic, ºi de a traduce fiecare acces la adresa X
a unuia din procese la o altã adresã.

<P>
Cum ``un desen face cît o sutã de cuvinte'' hai sã vedem un
exemplu extrem de simplificat:

<P>
<PRE>
  procesul nr.1                 procesul nr.2
----------------------      -------------------------
|0                  N|      |0                     M|  adrese virtuale
----------------------      -------------------------

vvvvvvvvvvvvvvvvvvvvvv      vvvvvvvvvvvvvvvvvvvvvvvvv  UMM traduce

-----------------------------------------------------
|0                  N        N+1                 N+M|  adrese fizice
-----------------------------------------------------
</PRE>

<P>
Cînd procesul nr.1 face o referinþã la ceea ce el crede cã
este adresa 0, aceastã referinþa este trimisã de UMM chiar la
adresa 0 din memoria fizicã.  Pe de altã parte, adresa 0 a
procesului nr.2 este trimisã la adresa N+1 din memoria fizicã.

<P>
Reamintiþi-vã cã în realitate cele douã procese nu se
executã niciodatã simultan<A NAME="tex2html1"
  HREF="#foot147"><SUP>1</SUP></A>, ci pe rînd, cînd le sunã ceasul.
De fiecare datã cînd comutã de la un proces la altul (deci cînd
trateazã întreruperea de la ceas), nucleul trebuie sã schimbe ºi
felul în care UMM traduce adresele.  Acest lucru îl face UC
discutînd cu UMM cam în acelaºi fel în care discutã cu un
controler: îi transmite tot felul de parametri.

<P>
Mecanismul simplu al memoriei virtuale poate fi exploatat ºi
în feluri mult mai exotice.  De exemplu se pot executa în
time-sharing procese al cãror total de memorie necesarã depãºeºte
cantitatea existentã.  Cum?  Simplu: cînd un proces este înlocuit
cu altul, pãrþi din memoria ocupatã de el sunt mutate pe disc (de
exemplu într-un fiºier).  Cînd vine din nou la rînd, acele pãrþi
sunt aduse la loc în memoria fizicã.  (Discul, de obicei, este mult
mai mare decît memoria.)  Aceastã tehnicã se numeºte ``swapping''.

<P>
Ea este cu douã tãiºuri, pentru cã scrierea/citirea de pe
disc este mult mai lentã decît cea din memorie, ºi nu-þi poþi
permite ca la fiecare zecime de secundã sã te muþi la un alt
program, iar mutarea sã dureze 10 secunde.  Nucleul trebuie sã fie
zgîrcit în astfel de mutãri.

<P>
Deocamdatã atît despre memoria virtualã.

<P>

<H1><A NAME="SECTION00080000000000000000">
Securitatea</A>
</H1>

<P>
Izolarea proceselor în zone de memorie disjuncte face sarcina
programatorului mai uºoarã ºi calculatorul mai eficient: se pot
rula simultan programe ale unor utilizatori diferiþi, care nu se vor
incomoda unul pe altul nicicum.  Un program nu poate scrie/citi din
memoria altuia, pentru ca nici una din adresele pe care el le referã
nu este tradusã de UMM în vreo adresã a celuilalt.

<P>
Acesta e unul dintre aspectele <EM>securitãþii</EM> utilizãrii
calculatoarelor, ºi este iarãºi una din sarcinile nucleului.
Sisteme ca MS-DOS sau Windows, care sunt concepute pentru a permite
unui singur utilizator sã foloseascã la un moment dat calculatorul,
sunt mai laxe din punct de vedere al securitãþii oferite: în
definitiv îþi dai cu ciocanul peste propriile degete.  În realitate
lucrurile nu stau chiar aºa, o dovadã fiind proliferarea viruºilor,
care sunt procese care fac daune ºi se multiplicã modificînd
fiºiere; ele profitã de slãbiciunea sistemului în aceastã
privinþã.

<P>
Securitatea are multe aspecte, plecînd de la a asocia fiecare
proces cu un utilizator, un utilizator cu niºte drepturi, fiecare
obiect (fiºier, terminal, etc.) cu un utilizator, ºi de a verifica
dacã procesele acceseazã numai ceea ce trebuie ºi cînd trebuie.
Modelul interpretorului se aratã iarãºi util.

<P>
Operaþiile pe care le poate face un proces sunt împãrþite
în douã categorii: ``sigure'' ºi ``periculoase''.
Operaþiile sigure nu vor putea niciodatã cauza neplãceri altcuiva
decît procesului care le executã, aºa cã pot fi executate
oricînd.  Un exemplu este adunarea a douã numere.

<P>
Operaþiile nesigure ar putea fi folosite întotdeauna pentru
scopuri malefice de cãtre un proces.  Toate operaþiile de acces la
memorie intrã în aceastã categorie, precum ºi toate operaþiile de
comunicaþie cu perifericele (dacã oricine poate scrie pe disc poate
ºterge lucruri care nu-i aparþin).  Orice executare a unei operaþii
nesigure este atent supervizatã de cãtre nucleu.  Iatã în ce fel:

<P>

<UL>
<LI>operaþiile de acces la memorie trec întotdeauna (la nivel
hardware) prin UMM.  Dacã un acces este ilegal (de exemplu în figura
de mai sus procesul nr.1 acceseazã o adresa mai mare ca N), atunci se
declanºeazã o excepþie (``trap'').

<P>
</LI>
<LI>toate operaþiile de intrare-ieºire sunt ilegale.  Procesele nu au
voie sa facã aºa ceva niciodatã.  Orice încercare se soldeazã cu
o excepþie.
</LI>
</UL>

<P>

<H1><A NAME="SECTION00090000000000000000">
Modul nucleu ºi modul utilizator</A>
</H1>

<P>
Bine, dar nu putem trãi fãrã operaþii de acces la
periferice!  Nucleul însuºi are nevoie de aºa ceva.  Pentru a
rezolva aceastã dilemã, UC moderne au cel puþin douã moduri de
lucru: modul <EM>nucleu</EM> (kernel) ºi modul <EM>utilizator</EM> (user),
plus o pereche de instrucþiuni pentru a trece dintr-un mod în
celãlalt.  (Nefericitã supraîncãrcare a cuvîntului ``nucleu'',
dar nu o coincidenþã, dupã cum vom vedea.)  În modul nucleu orice
operaþie este permisã.  În modul utilizator operaþiile ilegale
declanºeazã excepþii.  Instrucþiunile de schimbare a modului sunt
ele însele ilegale, ca ºi cele de control al întreruperilor.  Ce
este o excepþie ºi cum o foloseºte nucleul pentru a implementa
securitatea?

<P>
O excepþie (trap) este de obicei un caz special de
întrerupere: un obiect cu care ne-am mai întîlnit.  ``Special''
pentru cã trap-ul nu este generat de un periferic, ci de UMM sau
chiar de UC.  În rest însã totul aratã ca o întrerupere
ordinarã: salvarea PC-ului, saltul la rutina de tratare.

<P>
Ca totul sã fie în regulã, mai trebuie aranjat ca orice
întrerupere sã cauzeze automat trecerea în mod nucleu a UC.

<P>
Sã asamblãm componentele:

<P>

<OL>
<LI>cînd calculatorul porneºte, UC este în modul nucleul.  Nucleul
este citit de pe disc;

<P>
</LI>
<LI>nucleul construieºte tabelele cu adresele procedurilor care
trateazã întreruperile (interrupt handlers) ºi trap-urile; face în
aºa fel încît întreruperile ºi trap-urile sã treacã UC automat
în mod nucleu;

<P>
</LI>
<LI>cînd nucleul vrea sã predea controlul unui proces, trece
maºina în mod utilizator ºi apoi pune PC-ul la adresa de unde se va
executa acel proces;

<P>
</LI>
<LI>procesul se executã; fie cã face ceva ilegal, fie cã vine
întreruperea de ceas (sau o alta), se trece în mod nucleu, ºi se
sare la procedura de tratare a întreruperii, care este parte din
nucleu;

<P>
</LI>
<LI>procedurile de tratare a trap-urilor investigheazã starea
procesului care tocmai se executa cînd trap-ul a fost generat.  Din
starea memoriei, PC-ul salvat, ºi natura trap-ului (acces ilegal la
memorie, instrucþiune de intrare/ieºire, etc.) handler-ul poate
deduce dacã acea operaþie a fost într-adevãr ilegalã.  Dacã da,
procesul respectiv este probabil ``omorît''.
</LI>
</OL>

<P>
Schema este foarte simplã, ºi are urmãtoarele consecinþe
(dacã sistemul este bine scris):

<P>

<UL>
<LI>un proces nu poate strica <EM>nimic</EM>, pentru cã la prima
tentativã controlul este preluat de nucleu;

<P>
</LI>
<LI>nucleul poate prelua <EM>întotdeauna</EM> controlul de la un
proces, la apariþia unei întreruperi.  Ceasul genereazã
întotdeauna întreruperi, mai devreme sau mai tîrziu.
</LI>
</UL>

<P>

<H1><A NAME="SECTION000100000000000000000">
Natura nucleului</A>
</H1>

<P>
Putem simboliza situaþia aºa cum o înþelegem acum astfel:

<P>
<PRE>
                    --------------------------
                    |                        |
                    |    proces(e)           |
                    |                        |
                    |----O1------            |
                    |           |            |
                    |   nucleu  |            |
                    |           |            |
                    -----O2--O3------O3-------
                    |                        |
                    |     hardware           |
                    --------------------------
</PRE>

<P>
Am desenat un singur proces, pentru cã impresia fiecãruia
este cã maºina îi aparþine în totalitate.

<P>
Asta s-ar citi cam aºa: procesele ruleazã ``deasupra''
nucleului dar ºi maºinii hardware, iar nucleul ruleazã deasupra
hardware-ului direct.  Ce înseamnã ``X deasupra lui Y''?  Înseamnã
cã X foloseºte instrucþiuni sau funcþii oferite de Y.

<P>
<DL>
<DT><STRONG>O1</STRONG></DT>
<DD>sunt apelurile de sistem -- instrucþiuni oferite de nucleu
proceselor.
</DD>
<DT><STRONG>O2</STRONG></DT>
<DD>sunt instrucþiunile nesigure -- acestea pot fi executate
numai de cãtre nucleu.  
</DD>
<DT><STRONG>O3</STRONG></DT>
<DD>sunt instrucþiunile sigure -- care pot fi executate direct
de cãtre procese, dar, fireºte, ºi de cãtre nucleu.
</DD>
</DL>

<P>
Nucleul nu foloseºte în aceastã schemã niciodatã
instrucþiuni oferite de procese (existã sisteme în care acest lucru
nu este adevãrat întotdeauna).

<P>
Vedeþi, noþiunea de ``nucleu'' nu este foarte corectã la
acest nivel, în care discutãm structura nucleului însuºi: în
realitate este vorba de o singurã UC, care este succesiv în mod
nucleu ºi utilizator.  În fiecare mod UC poate executa anumite
categorii de instrucþiuni.  ``Nucleul'' este o abstracþie: este o
porþiune de cod (ºi date), care este executatã din cînd în cînd:
atunci cînd utilizatorul o cere, sau atunci cînd este nevoie de
serviciile sale, de exemplu cînd vine o întrerupere.

<P>

<H1><A NAME="SECTION000110000000000000000">
Tabela de procese</A>
</H1>

<P>
Nucleul este deci o colecþie de proceduri, care se invocã
fie de cãtre utilizator, prin apeluri de sistem, fie prin
întreruperi sau trap-uri.  În acest sens este o entitate pasivã, al
cãrei singur sens este de a servi procesele utilizatorilor.

<P>
Putem însã privi nucleul ºi invers: ca pe un dispecer, care
îºi mutã atenþia de la un proces la altul, ºi îl ``ajutã'' sã
se execute.  Pentru acest scop el posedã o structurã de date care
descrie informaþiile de care are nevoie pentru a identifica fiecare
proces.  Este practic un array mare de tot de structuri identice, una
pentru fiecare proces.  Acest array se cheamã ``tabela de procese''.

<P>
Ce trebuie sã fie într-una din structuri?  Rãspunsul,
evident, depinde foarte mult de sistemul de care vorbim, dar putem
extrage un ``cel mai mare numitor comun''.  Sã aruncãm o privire
deci asupra unor posibile cîmpuri; iatã deci cum ºi-ar putea descrie
nucleul un proces:

<P>

<UL>
<LI>o descriere a stãrii procesului (poate fi executat oricînd,
aºteaptã un eveniment extern -- ex. apãsarea unei taste, e pe
moarte, etc.);

<P>
</LI>
<LI>o descriere a zonelor de memorie asociate procesului: cum trebuie
configuratã UMM cînd se executã acest proces, ce pãrþi din
memoria lui sunt pe disc, ce adrese are voie sã acceseze;

<P>
</LI>
<LI>adresa la care procesul a fost întrerupt - PC-ul salvat la ultima
întrerupere;

<P>
</LI>
<LI>informaþii despre drepturile asociate; utilizatorul în contul
cãruia ruleazã acest proces;

<P>
</LI>
<LI>timpi de rulare ºi resurse consumate de acest proces;

<P>
</LI>
<LI>structuri de date de nivel mai înalt: fiºiere deschise ºi starea
lor (poziþia, lungimea, drepturi, etc.);

<P>
</LI>
<LI>starea apelului de sistem în curs de execuþie;

<P>
</LI>
<LI>starea comunicaþiei cu procesele vecine.
</LI>
</UL>

<P>
Unele dintre cîmpuri sunt evidente, alte vor fi descifrate
în secþiunile care urmeazã.

<P>
Nucleul are tot timpul o variabilã globalã numitã <TT>procesul_curent</TT>, ºi care indicã dintre cîmpurile array-ului care
este cel folosit în clipa de faþã.  Acesta este procesul care
tocmai se executã.  Cînd un proces se întrerupe, informaþiile sunt
salvate în cãsuþa lui.  Cînd un proces se (re)porneºte
informaþiile sunt preluate din cãsuþa sa, iar variabila <TT>procesul_curent</TT> este pusã sã arate spre aceastã cãsuþã.

<P>
Despre nucleu se spune la un moment dat cã ``se executã în
contextul procesului X'' dacã variabila <TT>procesul_curent</TT> are
valoarea X în acel moment.  În general asta înseamnã cã procesul
X tocmai a fãcut un apel de sistem.

<P>

<H1><A NAME="SECTION000120000000000000000">
Apelurile de sistem</A>
</H1>

<P>
Ce este deci un apel de sistem?  Este o ``instrucþiune''
pusã la dispoziþia utilizatorului de cãtre nucleu.  Cum se
realizeazã concret?  De obicei printr-o instrucþiune ilegalã, sau o
instrucþiune specialã a UC, care este folositã în acest scop.  Hai
sã presupunem cã UC are o instrucþiune numitã <TT>sys_call</TT>,
care se comportã întocmai ca o instrucþiune ilegalã: genereazã un
trap.  Atunci un proces face un apel de sistem în felul urmãtor:

<P>

<OL>
<LI>pune într-un anumit loc convenit dinainte în memoria lui
personalã (de exemplu pe stivã, sau într-o anumitã variabilã)
informaþiile care descriu apelul de sistem:

<P>

<UL>
<LI>un cod al apelului (de ex. <TT>write_file</TT>);
</LI>
<LI>parametrii necesari (de ex. un pointer spre numele fiºierului, ºi
un pointer spre array-ul de scris).
</LI>
</UL>

<P>
</LI>
<LI>executã instrucþiunea <TT>sys_call</TT>.

<P>
Ce se întîmplã apoi?

<P>
</LI>
<LI><TT>sys_call</TT> genereazã un trap;

<P>
</LI>
<LI>UC trece in mod nucleu ºi începe sã execute procedura asociatã
acelui trap;

<P>
</LI>
<LI>procedura aceasta investigheazã (cãutînd în zona convenitã)
codul apelului; gãseºte <TT>write_file</TT>; sare la o procedurã din
nucleu care se ocupã de scrierea în fiºiere;

<P>
</LI>
<LI>procedura aceasta (pe care o putem numi abuziv tot <TT>write_file</TT>) se uitã tot în locul convenit dupã argumente; le
extrage;

<P>
</LI>
<LI>procedura încearcã sã se execute cu aceste argumente; se
calculeazã cilindru, sector, etc., ºi controlerul de disc este rugat
sã extragã informaþia cerutã;

<P>
</LI>
<LI>procesul curent este <EM>suspendat</EM> ºi marcat ca aºteptînd
completarea unui apel de sistem; informaþiile despre apelul de sistem
care tocmai se executã sunt salvate în cãsuþa din tabela de
procese asociatã lui;

<P>
</LI>
<LI>se marcheazã într-o structurã de date asociatã controlerului
faptul cã i s-a dat de lucru pentru acest proces;

<P>
</LI>
<LI>un alt proces este pus în execuþie, ca sã nu se piardã timpul
aºteptînd resurse lente;

<P>
</LI>
<LI>timpul trece....

<P>
</LI>
<LI>mai tîrziu, <EM>în contextul altui proces</EM> (pentru cã cel
despre care vorbeam este încã suspendat), controlerul de disc
genereazã o întrerupere;

<P>
</LI>
<LI>procedura asociatã întreruperii investigheazã informaþia
asociatã controlerului pe care o scrisese la pasul 9; vede pentru ce
proces a lucrat acesta;

<P>
</LI>
<LI>procedura asociatã întreruperii preia de la controler rezultatele
(codul de eroare, de exemplu) ºi le pune în cãsuþa procesului care
a fãcut cererea, la descrierea apelului de sistem în curs de
execuþie;

<P>
</LI>
<LI>procesul suspendat este marcat din nou gata pentru execuþie;

<P>
</LI>
<LI>cînd eventual este selectat pentru a fi rulat din nou acest
proces, rezultatele sunt copiate din tabela de procese într-un alt
loc convenit dinainte pentru a primi rãspunsul;

<P>
</LI>
<LI>se sare la adresa indicatã de PC-ul salvat al acestui proces,
continuîndu-se astfel execuþia lui.
</LI>
</OL>

<P>
Partea frumoasã este cã deºi procesul crede cã nu s-a
întîmplat nimic altceva decît cã i s-a executat o
procedurã-apel-de-sistem, în realitate între timp poate sute de
alte procese au rulat ºi au fãcut treabã.  Asta da, eficienþã!

<P>
Observaþi cã lucrul cerut de un proces se desfãºoarã în
douã etape:

<P>

<UL>
<LI>într-o primã etapã, între paºii 1 ºi 8, nucleul lucreazã
pentru acest proces în propriul lui context;

<P>
</LI>
<LI>paºii 12-16 se efectueazã în contextul <EM>altuia</EM>.  În
general întreruperile aduc de lucru nucleului pentru un anumit
proces, care este altul decît cel care a fost întrerupt.  Cu toate
acestea, ele se executã în contextul lui.
</LI>
</UL>

<P>

<H1><A NAME="SECTION000130000000000000000">
Reentranþa</A>
</H1>

<P>
Lucrurile se desfãºoarã ca ºi cum nucleul este o bucatã
de cod executabil <EM>comunã</EM> tuturor proceselor.  Cînd procesele
fac apeluri de sistem, de fapt UC executã cod din nucleu.  Codul din
nucleu este deosebit de codul ordinar al unui proces prin faptul cã
accesul la el se poate face numai prin niºte puncte foarte precis
controlate.  Nu se poate <EM>sãri</EM> la o adresã din nucleu; în
spaþiul de adrese al unui proces (practic) nu existã nici o adresã
care sã fie a nucleului.  Saltul la codul nucleului se face prin
trap-uri, care schimba nivelul UC de la ``utilizator'' la ``nucleu''
ºi modificã tabelele de translatare ale UMM în aºa fel încît
adresele din nucleu devin accesibile.

<P>
Pe de altã parte situaþia nu este simetricã, pentru cã
procedurile din nucleu au nevoie sã acceseze memoria unui proces: de
exemplu procedura <TT>write_file</TT> descrisã mai sus trebuie sã ia din
spaþiul de memorie al procesului datele de scris ºi sã le trimitã
la perifericul pe care se aflã fiºierul.  (Fireºte cã nucleul va
trebui sã fie atent ca nu cumva sã scoatã afarã pe disc tocmai
zona de memorie în care lucreazã controlerul în timp ce procesul
este suspendat.)

<P>
Schema este deci urmãtoarea: procesele se executã mai tot
timpul în mod utilizator, din cînd în cînd însã au nevoie de
serviciile nucleului (sau survine o întrerupere).  Atunci procesele
continuã sã se execute, dar în mod nucleu, iar codul care se
executã este parte din nucleu (gîndiþi-vã din nou la nucleu ca la
o bibliotecã de funcþii ºi va fi mai clar).

<P>
<PRE>
       ....suspendate.....   curent 
       |     |     |     |     |        cod procese
       |     |     |     |     |
       |     |     |     |     |&lt;-
       |     |     |     |     |
                  [ ]&lt;-                 cod nucleu comun proceselor
           -&gt;     [ ]     &lt;-
     -&gt;           [ ]                   &lt;- = PC
</PRE>

<P>
Nucleul este deci un fel special de cod, care se poate afla
``de mai multe ori'' în execuþie la un moment dat.  Mai exact, un
proces se executã, iar toate celelalte sunt <EM>oprite</EM>, iar
PC-urile lor puncteazã toate undeva prin codul nucleului.

<P>
Acest gen de cod, care se aflã simultan în corpul mai multor
procese se numeºte cod <EM>reentrant</EM>.  Codul reentrant este foarte
greu de scris, pentru cã nu se comportã deloc aºa cum suntem
obiºnuiþi cu programele ordinare.  De exemplu în codul reentrant
variabilele globale nu pot fi folosite decît cu foarte mare grijã.

<P>
O procedurã din nucleu nu poate folosi pur ºi simplu o
variabilã globalã pentru a pasa parametri o alteia pe care o
cheamã: dacã tocmai atunci survine o întrerupere care lucreazã ºi
ea tocmai cu acea variabilã?  Între douã instrucþiuni consecutive
s-ar fi putut executa alte cîteva mii, din cine ºtie ce parte a
nucleului, ca rezultat al apariþiei întreruperii!

<P>
Programele scrise de utilizator sunt complet izolate de
întreruperi (nu simt deloc efectele lor directe) datoritã nucleului,
ºi de aceea sunt mult mai uºor de scris.

<P>
Coexistenþa mai multor procese care se executã interclasat
mai are efecte foarte interesante.  Operaþii care sunt foarte clare
în contextele unor procese izolate devin foarte ºubrede cînd se
combinã.  Cel mai simplu exemplu: este relativ limpede ce înseamnã
cã un proces deschide un fiºier: nucleul pregãteºte niºte
structuri de date pentru accesul ulterior mai rapid la fiºier.  Este
de asemenea clar ce se întîmplã dacã un proces ºterge un fiºier:
zona de date de pe disc alocatã fiºierului trebuie sã disparã.
Dar ce se întîmplã dacã un proces deschide un fiºier ºi altul
îl ºterge?  Dacã primul a scris deja ceva ce se întîmplã cu
datele lui?  În ce va continua el sã scrie, ºamd.?  Rãspunsul la
astfel de întrebãri nu este deloc evident, ºi trebuie fãcutã o
convenþie care sã trateze aceste cazuri, întotdeauna în acelaºi
mod.  Este tot treaba nucleului sã extindã <EM>semantica</EM>
(semnificaþia) operaþiilor ºi pentru cazul cînd operaþiile se
combinã.

<P>

<H1><A NAME="SECTION000140000000000000000">
Erorile</A>
</H1>

<P>
Nucleele trebuie sã fie foarte fiabile.  Nucleul se executã
în mod nucleu, ºi are acces la toatã puterea maºinii: poate
comunica cu orice periferic, poate accesa orice zonã de memorie.
Nucleul trebuie sã fie foarte atent, pentru cã el se executã în
contextele feluritor procese: nu cumva un proces sã-l înºele
dîndu-i niºte argumente ciudate la un apel de sistem, care sã-l
facã sã o ia razna.  De exemplu un proces ar putea cere un <TT>write_file</TT>, dar da ca adresa a datelor o adresã care este înafara
memoriei alocate lui.  Nucleul nu trebuie sã încerce sã citeascã
de acolo, pentru cã privilegiile sale ar putea duce la o catastrofã.

<P>
Procedurile din nucleu care executã apelurile de sistem vor
verifica întotdeauna dacã procesul care a cerut ceva are dreptul sã
facã asta, ºi dacã argumentele date au sens.

<P>
Adesea nucleul are de a face cu erori: fie cereri imposibil de
executat, fie defecþiuni ale hardware-ului sau controlerelor.  Ce
trebuie sã facã în acest caz?  Nu poate pur ºi simplu opri
calculatorul în întregime zicînd ``eroare: nu e vîrîtã
discheta''.

<P>
Erorile cauzate de cereri ilegale sunt relativ uºor de
rezolvat, pentru cã nucleul raporteazã proceselor care le-au fãcut
cã ceva nu e în regulã cu argumentele.  Procesele se vor descurca
cu aceastã indicaþie de eroare.  Existã însã erori care nu sunt
vina proceselor, sau care nu pot fi atribuite cuiva anume: de pildã
apariþia unui pachet eronat pe o reþea. Aceste erori nu pot fi nici
ignorate, pentru cã ar putea avea consecinþe fatale.

<P>
Metoda folositã este ca fiecare funcþie sã verifice erorile
care ar fi putut apãrea la fiecare operaþie invocatã, sã încerce
sã le remedieze singurã dacã poate, sau dacã nu sã le raporteze
funcþiei care a chemat-o.

<P>
Nucleele au de aceea nevoie de o metodã de raportare a
erorilor: ``error logging''.  Cea mai simplã variantã este ca
erorile sã fie scrise într-un fiºier, unde administratorii de
sistem sã le poatã inspecta, pentru a remedia defecþiunile care nu
pot fi remediate de software.

<P>

<H1><A NAME="SECTION000150000000000000000">
Comunicaþia inter-proces</A>
</H1>

<P>
În fine, una din ultimele slujbe ale nucleului, dupã ce a
încercat sã izoleze cît mai bine procesele unele de altele, este de
a le permite sã comunice, dar în moduri foarte controlate, în aºa
fel încît sã unul sã nu poatã influenþa pe altul mai mult decît
este el dispus sã se lase influenþat.

<P>
Nucleele pun la dispoziþie apeluri de sistem pentru
transferul de date între procese.  Cele mai comune se folosesc de
fiºiere, dar pot exista metode mult mai exotice, ca zone de memorie
comunã mai multor procese sau mesaje.

<P>
Cîteodatã ca sarcinã a nucleului (de exemplu în BSD UNIX)
este ºi implementarea protocoalelor de comunicaþie între
calculatoare diferite.  Prin acestea mai multe nuclee pun la
dispoziþia proceselor un mijloc de comunicaþie inter-proces care
permite transmiterea datelor între procese aflate pe maºini
diferite.

<P>

<H1><A NAME="SECTION000160000000000000000">
Micro-nuclee ºi monoliþi</A>
</H1>

<P>
Existã douã tendinþe mari în lumea calculatoarelor: de a
pune cît mai mult în nucleu, sau de a pune cît mai puþin.  A doua
tehnologie dã naºtere micro-nucleelor.  Un micro-nucleu încearcã
sã conþinã cît mai puþine funcþii: management-ul proceselor,
foarte puþinã grijã de memorie, dar mecanisme puternice de
comunicaþie inter-proces.  

<P>
Funcþiile necesare tuturor utilizatorilor sunt atunci oferite
de procese speciale, numite <EM>servere</EM>.  De exemplu putem imagina
un nucleu care nu oferã nici un fel de operaþii pe fiºiere.  O
operaþie de genul <TT>write_file</TT> ar putea fi implementatã de un
server special pentru fiºiere, cãruia procesele doritoare (<EM>clienþii</EM>) îi trimit prin mesaje informaþiile necesare.

<P>
Cealaltã metodã, care este cea mai rãspînditã
actualmente, foloseºte nuclee <EM>monolitice</EM>.  Orice serviciu care
implicã un grad oarecare de pericol (ar putea fi folosit pentru a
influenþa alte procese) este oferit direct de nucleu.  Windows95 ºi
UNIX sunt sisteme tipice monolitice.  Exemple de micronuclee:
Windows&nbsp;NT, Mach, Chorus.

<P>
Sistemele de operare <EM>distribuite</EM> încearcã sã
transforme mai multe calculatoare într-o singurã maºinã virtualã;
utilizatorul nu ar trebui sã fie preocupat de locul în care
procesele lui se executã.  În tehnologia curentã (încã la
început) sistemele distribuite se bazeazã pe micro-nuclee care
oferã funcþii speciale.  Sistemele uzuale erau proiectate ca ºi cum
calculatorul pe care rula nucleul era singurul; mecanismele de
comunicaþie inter-proces pe alte maºini erau adãugiri care nu se
potriveau foarte bine cu felul în care nucleele lucreazã.  În
sistemele distribuite fiecare nucleu este proiectat de la început cu
ideea de a lucra într-o lume populatã de multe alte nuclee, cu care
poate colabora, dar în care nu poate avea întotdeauna încredere.

<P>
Un nucleu poate sã aibã încredere în procesele care
ruleazã pe maºina pe care el se aflã, pentru cã ele au luat
naºtere numai datoritã lui însuºi, ºi au obþinut toate resursele
prin operaþii aflate strict sub controlul sãu.  Aceasta nu mai este
adevãrat pentru procesele aflate pe alte maºini.

<P>

<H1><A NAME="SECTION000170000000000000000">
Ce a mai rãmas</A>
</H1>       

<P>
Un sistem de operare -- se spune -- trebuie sã ofere mult mai
mult decît serviciile nucleului.  Ce anume mai face parte dintr-un
sistem de operare, ºi nu este nucleu:

<P>

<UL>
<LI>biblioteci de funcþii care implementeazã apelurile de sistem
(<TT>clib</TT> la UNIX); utilizatorul final nu trebuie nici mãcar sã
ºtie cum se face un apel de sistem; din cauza asta el primeºte de la
fabricantul sistemului un set de funcþii gata compilate pe care le
poate lega (linkedita) direct la programele sale.  Aceste funcþii
sunt niºte ``wrappere'' -- ele ``îmbracã'' apelurile de sistem,
transformîndu-le în simple funcþii pentru utilizator.  De exemplu
ar putea exista funcþia:

<P>
<PRE>
int write_file(char * file, int * array, int len);
</PRE>

<P>
care nu face decît sã punã argumentele în locul convenit de nucleu
ºi sã invoce trap-ul pe care în secþiunea ``Apelurile de sistem''
l-am numit <TT>sys_call</TT>.

<P>
</LI>
<LI>un shell: un interpretor de comenzi care citeºte interactiv comenzi
de la tastaturã ºi le transformã în invocãri de procese.
COMMAND.COM este un asemenea program pentru DOS.

<P>
</LI>
<LI>compilatoare, linkeditoare, loadere -- programe folosite pentru
a genera fiºiere executabile, care pot fi transformate de nucleu în
procese.

<P>
</LI>
<LI>utilitare diverse - editoare de texte, programe de întreþinut ºi
reparat discurile, unelte pentru administraþie.  Cantitatea acestor
programe dominã întregul sistem în cazul UNIX-ului; la MS-DOS este
redusã la minimum.
</LI>
</UL>

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot147">... simultan</A><A NAME="foot147"
 HREF="nucleu-html.html#tex2html1"><SUP>1</SUP></A>
<DD>Dacã avem de-a face cu un
multiprocesor -- un calculator cu mai multe procesoare -- douã
procese se <EM>pot</EM> executa simultan, dar în esenþã funcþionarea
memoriei virtuale este aceeaºi

</DL>
<BR><HR>

</BODY>
</HTML>
