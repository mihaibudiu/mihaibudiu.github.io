<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Despre ``þevi'' Arhitectura Modernã a Procesoarelor (2)</TITLE>
<META NAME="description" CONTENT="Despre ``þevi'' Arhitectura Modernã a Procesoarelor (2)">
<META NAME="keywords" CONTENT="pipe-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Despre ``þevi'' 
<BR>
Arhitectura Modernã a Procesoarelor (2)</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>11 noiembrie 1998</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>pipelining
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare despre
arhitectura calculatoarelor, programare în limbaj de asamblare
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>pipeline, stall, forward, hazard
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html28"
  HREF="pipe-html.html">Tehnologie, paralelism ºi performanþã</A>
<LI><A NAME="tex2html29"
  HREF="#SECTION00030000000000000000">Banda de asamblare</A>
<UL>
<LI><A NAME="tex2html30"
  HREF="#SECTION00031000000000000000">Despre economia capitalistã</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION00032000000000000000">Cum rãmîne cu calculatoarele?</A>
<LI><A NAME="tex2html32"
  HREF="#SECTION00033000000000000000">Regiºtrii de separaþie</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION00034000000000000000">Influenþa asupra ceasului</A>
</UL>
<BR>
<LI><A NAME="tex2html34"
  HREF="#SECTION00040000000000000000">Dependenþe</A>
<UL>
<LI><A NAME="tex2html35"
  HREF="#SECTION00041000000000000000">Dependenþe structurale</A>
<LI><A NAME="tex2html36"
  HREF="#SECTION00042000000000000000">Dependenþe ale datelor</A>
<LI><A NAME="tex2html37"
  HREF="#SECTION00043000000000000000">Dependenþe ale controlului</A>
<LI><A NAME="tex2html38"
  HREF="#SECTION00044000000000000000">Excepþii</A>
</UL>
<BR>
<LI><A NAME="tex2html39"
  HREF="#SECTION00050000000000000000">Soluþii</A>
<UL>
<LI><A NAME="tex2html40"
  HREF="#SECTION00051000000000000000">Compilatoare grijulii</A>
<LI><A NAME="tex2html41"
  HREF="#SECTION00052000000000000000">Blocajul (stall)</A>
<LI><A NAME="tex2html42"
  HREF="#SECTION00053000000000000000">Înaintarea (forwarding)</A>
</UL>
<BR>
<LI><A NAME="tex2html43"
  HREF="#SECTION00060000000000000000">Variaþiuni ºi concluzii</A>
</UL>
<!--End of Table of Contents-->
<P>
Procesoarele RISC au apãrut, în prima jumãtate a anilor '80; era
începutul unei revoluþii în arhitectura calculatoarelor.  Ideea era
cã în loc de a oferi o sumedenie de operaþiuni exotice, este mai
eficace pentru un procesor sã ofere un set restrîns de operaþiuni,
pe care le poate executa cu foarte mare vitezã.  Primele procesoare
RISC conþineau între 25 de mii ºi 40 de mii de tranzistoare.

<P>
În ziua de astãzi Pentium II conþine 15 milioane de tranzistoare!
Vãzut dinafarã Pentium II nu este un RISC, dar arhitectura internã
este de acest tip.

<P>
Întrebarea este: ce s-a întîmplat cu toate tranzistoarele astea,
unde au fost ``înghiþite''?  Setul de instrucþiuni al unui procesor
modern este practic identic cu al unui procesor de acum 15 ani
(exceptînd ornamente de genul MMX), deci funcþionalitatea oferitã
este neschimbatã.  Atunci la ce treabã au fost înhãmaþi toþi
tranzistorii?  Rãspunsul este: pentru a creºte performanþa.

<P>
Acest articol prezintã una dintre tehnicile cele mai simple la
îndemîna unui proiectant pentru a creºte performanþa unui
microprocesor; practic toate procesoarele fabricate în ziua de azi o
folosesc.  Este vorba de tehnica ``benzii de asamblare'', numitã ºi
<EM>pipeline</EM>.  Vom vedea cã e vorba de o idee extrem de simplã ºi
eficace.  Vom vedea apoi cã proprietãþile unei benzi de asamblare
ridicã o grãmadã de noi probleme, ºi cã implementarea tehnicii
este extrem de complicatã, cerînd un suport arhitectural
substanþial.  Vom mai vedea ºi unele dintre metodele folosite pentru
a rezolva problemele ivite.

<P>

<H1><A NAME="SECTION00020000000000000000">
Tehnologie, paralelism ºi performanþã</A>
</H1>

<P>
Existã douã forþe motoare responsabile de creºterea spectaculoasã
a puterii de calcul a microprocesoarelor.  Una dintre aceste forþe
este tehnologia de fabricaþie ºi miniaturizarea.  Miniaturizarea
unui circuit integrat digital se mãsoarã în microni; distanþa care
se indicã este, grosolan vorbind, distanþa între douã sîrme
adiacente pe o suprafaþã a circuitului.  Tehnologia curentã
dominantã în acest an este undeva între 0.25 ºi 0.35 microni.
Pentru comparaþie, un fir de pãr omenesc are cam 25 de microni,
adicã de 100 de ori mai mult!

<P>
Scãderea dimensiunilor înseamnã cã distanþa dintre circuite
scade, deci semnalul electric poate parcurge mai multe dintre ele în
aceeaºi unitate de timp.  De asemenea înseamnã cã frecvenþa
ceasului poate fi crescutã.  Ceasul unui microprocesor este
echivalentul insului de la tobã de pe o galerã romanã din
antichitate: bate ritmul cu care se sincronizeazã toate pãrþile
componente (vîslaºii).  Frecvenþele atinse la ora actualã de
procesoarele comerciale sunt de 600Mhz: 600 de milioane de operaþii
pe secundã, pentru procesoarele Alpha 21264.

<P>
Atît despre tehnologie.  A doua metodã de creºtere a performanþei,
care este oarecum o consecinþã indirectã a miniaturizãrii, este
<EM>paralelismul</EM>.  Dacã ai mai mulþi vîslaºi barca merge mai
repede.  Cu cît vîslaºii sunt mai mici, cu atît poþi pune mai
mulþi în calã.  (Desigur, analogia nu e perfectã, pentru cã, spre
deosebire de galere, pentru un microprocesor un vîslaº mai mic face
la fel de multã treabã ca unul mare.)

<P>
Practic toate articolele din seria aceasta vor discuta numai despre
aceastã a doua metodã.  Vom vedea cã procesoarele moderne consacrã
o cantitate impresionantã de resurse pentru a stoarce o cît de micã
îmbunãtãþire a performanþei (acolo se duc cele 15 milioane de
tranzistoare ale lui Pentium).  În general o dublare a mãrimii
circuitului produce mult mai puþin decît o dublare a performanþei,
dar în ziua de azi ºi obþinerea cîtorva procente este o realizare
meritorie.

<P>
Introducem acum cititorului prima tehnicã de prelucrare paralelã,
numitã ``tehnica benzii de asamblare''.

<P>

<H1><A NAME="SECTION00030000000000000000">
Banda de asamblare</A>
</H1>

<P>

<H2><A NAME="SECTION00031000000000000000">
Despre economia capitalistã</A>
</H2>

<P>
Averea considerabilã a lui Henry Ford se datora, cel puþin în
parte, metodei sale inovatoare de a organiza munca la fabricile sale
de automobile: lucrãtorii stau aºezaþi de-a lungul unei benzi, iar
maºinile neterminate merg de la unul la altul.  Fiecare executã
asupra maºinii o singurã operaþiune, dupã care o paseazã mai
departe.  Asta e banda de asamblare.

<P>
Pentru a face mai evidente beneficiile tehnicii, îmi permit sã o
ilustrez cu încã un exemplu.  Sã presupunem cã vreþi sã
investiþi într-o spãlãtorie/uscãtorie (Nufãrul?).  Ce i-aþi
recomanda proprietarului: sã cumpere 10 maºini de spãlat care
centrifugheazã ºi usucã, sau, cu aceiaºi bani, 9 maºini care
spalã ºi 9 care usucã?  Presupunem cã un spãlatul ºi uscatul
dureazã la fel de mult (oricare maºinã am folosi), o jumãtate de
orã.

<P>
Rãspunsul este: cu cele 9 perechi de maºini eficienþa este cu 80%
mai mare!  Iatã de ce: sã presupunem cã avem un ºuvoi constant de
consumatori.  Atunci cu maºinile de spãlat putem face 10
încãrcãturi de rufe în fiecare orã.  Cu maºinile perechi însã
putem face 9 încãrcãturi la fiecare <EM>jumãtate de orã</EM>, aºa
cum aratã tabelul&nbsp;<A HREF="#spalatorie">1</A>:

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="173"></A>
<TABLE>
<CAPTION><STRONG>Table 1:</STRONG>
Funcþionarea celor douã modele de spãlãtorie presupunînd
cã existã suficient de multe rufe.  Varianta cu maºini de uscat ºi
spãlat separate produce de douã ori mai multe <EM>serii</EM> de rufe
spãlate în acelaºi timp.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">
 Ora       </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 0 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 1/2 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 1 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 1 1/2 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 2 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 2 1/2 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 3 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">   
1 maºinã </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> intrã 1 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> intrã 2 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> intrã 3 </FONT></TD>
<TD></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> intrã 4</FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 1 terminat </FONT></TD>
<TD></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1">  2 terminat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 3 terminat </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
2 maºini </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 1 la spãlat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 2 la spãlat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 3 la spãlat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 4 la spãlat
</FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 5 la spãlat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 6 la spãlat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 7 la spãlat</FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 1 la uscat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 2 la uscat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 3 la uscat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 4 la
uscat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 5 la uscat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 6 la uscat </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
 </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 1 terminat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 2 terminat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 3 terminat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 4
terminat </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1"> 5 terminat </FONT></TD>
</TR>
</TABLE></DIV>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>

<H2><A NAME="SECTION00032000000000000000">
Cum rãmîne cu calculatoarele?</A>
</H2>

<P>
Ei bine, exact aceeaºi idee poate fi aplicatã în cazul
construcþiei microprocesoarelor!  În acest caz banda de asamblare se
numeºte <EM>pipeline</EM>, sau conductã.  De aici ºi titlul
articolului de faþã.  Am oarecare dificultãþi în a alege o
traducere rezonabilã a termenului, aºa cã pe parcursul articolului
voi folosi variaþi termeni, incluzînd pe cel de ``þeavã''.

<P>
Cum se aplicã deci conceptul în cazul microprocesoarelor?  Care e
treaba unui microprocesor?  Sã execute, una cîte una,
instrucþiunile programelor scrise de utilizatori.  Dar execuþia unei
instrucþiuni se poate descrie ca o serie de paºi succesivi; ceva de
genul: adu instrucþiunea din memorie, uitã-te ce fel de
instrucþiune este (o operaþie aritmeticã/logicã, un apel de
procedurã, un salt, etc.), decide care date trebuie procesate (care
sunt regiºtrii<A NAME="tex2html2"
  HREF="#foot68"><SUP>1</SUP></A> care conþin acele date), extrage datele
din regiºtri, efectueazã operaþia asupra datelor, pune rezultatul
la loc unde trebuie, ºi o ia de la capãt cu instrucþiunea
urmãtoare.  În figura&nbsp;<A HREF="pipe-html.html#procesor">1</A> avem structura unui procesor
ipotetic pe care indicãm cinci stagii prin care o instrucþiune trece
în prelucrare.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="procesor"></A><A NAME="183"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Arhitectura internã a unui microprocesor
ipotetic.  <B>PC</B> este Program Counter, adresa instrucþiunii în
curs de execuþie din program.  <B>IR</B> este Instruction Register,
registrul în care instrucþiunea curentã este decodificatã pentru a
extrage comenzile asupra celorlalte unitãþi ale microprocesorului.
<B>Cache-urile</B>, în numãr de douã, sunt memoriile în care
procesorul þine datele, respectiv instrucþiunile.  <B>MUX</B> sunt
multiplexoare: circuite care au mai multe intrãri ºi o singurã
ieºire; ele aleg una dintre intrãri ºi o trimit la ieºire.
Informaþia despre care dintre intrãri este selectatã depinde de
instrucþiunea curentã, ºi este indicatã prin linia punctatã.  De
exemplu, ultimul multiplexor din dreapta, va alege linia de sus pentru
instrucþiuni care citesc din memorie ºi pun rezultatul într-un
registru, ºi va alege linia de jos pentru instrucþiuni care scriu o
valoare calculatã.  <B>ALU</B> este unitatea aritmeticã-logicã
(Arithmetic-Logical Unit).  Am etichetat unele dintre conexiuni cu
informaþii despre valoarea pe care o poartã.  Pentru fiecare
instrucþiune, unele dintre aceste sîrme vor purta informaþii utile
iar altele nu.  Încercaþi sã identificaþi pentru fiecare tip de
instrucþiune de fapt ce se întîmplã.</CAPTION>
<TR><TD><IMG
 WIDTH="632" HEIGHT="373" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=14cm\epsffile{procesor.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Ei bine, instrucþiunile joacã exact rolul rufelor: dacã avem în
procesor cîte un circuit independent pentru fiecare din aceste
numeroase sarcini, atunci putem pune aceste circuite sã lucreze
simultan pe instrucþiuni succesive.  Astfel, în timp ce
instrucþiunea 1 pune rezultatul la loc (stagiul de acces la memorie),
instrucþiunea 2 opereazã asupra propriilor date (stagiul de
execuþie), instrucþiunea 3 tocmai extrage datele (stagiul de
decodificare), iar instrucþiunea 4 tocmai este adusã din memorie
(stagiul de citire).

<P>
Observaþi cã -- aparent -- cîºtigul pe care l-am obþine
transformînd procesorul într-un pipeline, este <EM>pe gratis</EM>: ºi
un procesor obiºnuit are nevoie de toate aceste circuite, însã
atunci cînd folosea unul dintre ele, celelalte erau inutile.  Cã
lucrurile nu stau chiar aºa vom vedea în secþiunile urmãtoare.

<P>
Cartea ``canonicã'' pentru studiul arhitecturii calculatoarelor
moderne este Hennessy and Patterson ``Computer Architecture -- a
Quantitative Approach'', publicatã de editura Morgan Kaufmann în
ediþia a doua în 1995.  Aceastã carte este de fapt versiunea pentru
cursuri doctorale a unei alte cãrþi de aceiaºi autori.  Cartea este
excelent scrisã, iar capitolele 3 ºi 4 sunt dedicate în întregime
tehnicii de pipelining, în total 250 de pagini.  Dacã subiectul vã
intereseazã cu adevãrat, vã recomand sã obþineþi aceastã carte;
dacã nu, poate cã articolul acesta este suficient de ilustrativ.
Acest articol va discuta doar despre tehnicile elementare folosite în
pipelining; despre tehnicile avansate (multiple-issue, out-of-order
execution, etc.) voi scrie probabil un altul.  Desenele din acest
text, ºi diagrama procesorului ipotetic, sunt bazate pe prezentarea
din aceastã carte.

<P>

<H2><A NAME="SECTION00033000000000000000">
Regiºtrii de separaþie</A>
</H2>

<P>
Dacã un procesor este implementat ca un pipeline, atunci între
diferitele <EM>stagii</EM> ale þevii se aflã niºte ``tampoane'', care
izoleazã stagiile unul de altul.  Arhitectural vorbind, tampoanele
sunt de fapt tot niºte regiºtri, numiþi <EM>pipeline registers</EM>.
Fiecare din aceºti regiºtri este comandat de ceasul
microprocesorului, ºi încarcã în interior toate rezultatele
procesãrii obþinute din stagiul anterior: instrucþiunea,
rezultatele parþiale, informaþii de stare, etc.
Figura&nbsp;<A HREF="pipe-html.html#registri">2</A> aratã segmentarea procesorului de mai sus.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="registri"></A><A NAME="194"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Procesorul de mai sus împãrþit în
stagii.  Barele haºurate sunt regiºtrii de separaþie.  Observaþi
cã am mutat un multiplexor din stagiul de acces la memorie în
stagiul de citire, pentru cã altfel în cazul unui salt am fi avut
douã stagii care încearcã simultan sã scrie în registrul PC.  Cu
toate acestea, linia care controleazã multiplexorul vine în
continuare din stagiul de acces la memorie, unde instrucþiunile de
salt îºi terminã de calculat destinaþia.</CAPTION>
<TR><TD><IMG
 WIDTH="631" HEIGHT="258" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=14cm\epsffile{registri.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Vom vedea cã regiºtrii de separaþie au un rol important pentru
blocajul þevii în anumite circumstanþe.

<P>

<H2><A NAME="SECTION00034000000000000000">
Influenþa asupra ceasului</A>
</H2>

<P>
Ce cîºtigãm cu ajutorul þevilor?

<P>
Pãi, în primul rînd, fiecare din stagii este mai scurt decît
întregul, deci se poate executa mai repede decît dacã am executa
toate stagiile unul dupã altul.  Putem deci mãri frecvenþa
ceasului; este exact acelaºi fenomen ca la maºinile de spãlat de
mai sus (încãrcãturi la jumãtate de orã în loc de o orã).

<P>
În al doilea rînd, aºa cum am vãzut, acum toate stagiile sunt
folosite simultan, fiecare pentru altã instrucþiune.  Aceasta este o
sursã de paralelism, care implicã o altã creºtere a performanþei.

<P>
Observaþi cã succesul acestei metode se bazeazã pe faptul cã avem
de procesat un ºir de instrucþiuni extrem de lung, continuu.  Dacã
la spãlãtorie vin rufe din douã în douã ore, atunci nu
cîºtigãm nimic din faptul cã putem scoate o nouã serie la fiecare
jumãtate de orã.  

<P>
Observaþi cã dureazã o vreme de cînd prima instrucþiune intrã
în þeavã pînã cînd terminã execuþia: atîþia cicli de ceas
cîte stagii avem.  Latenþa (<EM>latency</EM>), sau durata propagãrii
unei instrucþiuni prin pipeline, este mai mare decît în cazul unui
procesor fãrã pipeline, pentru cã am adãugat durata stocãrii
datelor în regiºtrii de separaþie.  Pe de altã parte, observaþi
cã dupã ce prima instrucþiune iese din þeavã, a doua se terminã
în ciclul imediat urmãtor.  Deci rata de execuþie (<EM>throughput</EM>) este de o instrucþiune pe ciclu de ceas!  Distincþia
între <EM>latency</EM> ºi <EM>throughput</EM> este extrem de importantã.

<P>
Acest fenomen apare într-o formã exacerbatã în cazul reþelelor de
calculatoare, în care existã doi parametri independenþi: durata
propagãrii datelor între douã calculatoare, ºi viteza de
transmisiune a datelor.  Putem avea linii cu duratã de propagare
micã (de exemplu cu latenþa de 2ms), dar cu vitezã micã, cum ar fi
un modem de 14.4Kbps.  Putem avea însã o linie cu duratã de
propagare extrem de mare (500ms), dar cu o viteza foarte mare, cum ar
fi un canal de transmisiune prin satelit, de 2Mbps.  Interesant este
cã în cazul reþelelor de calculatoare produsul acestor cantitãþi
(latenþa * rata de transmisie) este cel mai important; cu cît
produsul este mai mare, cu atît susþinerea performanþei reþelei
este mai greu de obþinut.  Dar am divagat; sper sã revin asupra
acestei teme într-un alt articol.  Înapoi la þevile noastre.

<P>
Sã observãm cã viteza la care putem pune ceasul este limitatã de
<B>cel mai lent stagiu din þeavã</B>.  Asta pentru cã toþi
lucrãtorii trebuie sã lucreze cu ritmul celui mai încet dintre ei.
Din aceastã cauzã, o împãrþire a sarcinilor la 5 circuite nu
garanteazã o creºtere a vitezei de 5 ori.  Sã presupunem cã cele 5
stagii dureazã 3, 3, 3, 5, respectiv 3 nanosecunde, ºi cã
întîrzierea unui registru de separaþie este de 2 nanosecunde.
Atunci circuitul fãrã þeavã executã o instrucþiune la fiecare
3+3+3+5+3=17 nanosecunde, ºi asta dã ºi viteza ceasului.  Pe de
altã parte, circuitul din ``felii'' executã o instrucþiune la 5+2
nanosecunde (5 pentru stagiul cel mai lent, plus douã ns pentru
propagarea prin registru).  Iatã deci cum, deºi am împãrþit
sarcina la 5, din cauza imbalansului creºterea de vitezã obþinutã
este de numai 17/7 = 2.42 ori.

<P>

<H1><A NAME="SECTION00040000000000000000">
Dependenþe</A>
</H1>

<P>
Trebuie sã vã temperez ºi mai tare entuziasmul în ceea ce
priveºte pipeline-urile: mai existã o grãmadã de probleme pe care
le-am trecut cu vederea, dar care devin evidente de îndatã ce ne
aplecãm puþin asupra construcþiei.

<P>
Problema este cã, foarte adesea, nu putem executa mai multe
instrucþiuni consecutive chiar una dupã alta, pentru cã anumite
constrîngeri fac acest lucru imposibil.  Acest gen de interferenþã
între instrucþiuni consecutive se numeºte în englezã <EM>hazard</EM>.
Voi folosi în româna termenul ``dependenþe'', deºi acesta nu este
tocmai exact<A NAME="tex2html5"
  HREF="#foot175"><SUP>2</SUP></A>.  Despre ce
fel de dependenþe este vorba?

<P>

<H2><A NAME="SECTION00041000000000000000">
Dependenþe structurale</A>
</H2>

<P>
Prima problemã care poate apãrea provine din faptul cã una dintre
aserþiunile mele de mai sus poate fi falsã; anume aceasta: ``cînd
folosea unul dintre [stagii], celelalte erau inutile''.  Iatã un
exemplu în care acest lucru nu este adevãrat: un procesor trebuie
dupã fiecare instrucþiune sã incrementeze adresa de unde se ia
urmãtoarea instrucþiune (adresa este aflatã în registrul numit
``<EM>Program Counter</EM>'').  Pentru cã incrementarea este o
operaþiune aritmeticã, procesorul ar putea folosi pentru acest scop
unitatea aritmeticã-logicã (în figura noastrã am fi avut în loc
de ALU ºi circuitul de incrementare un singur circuit).  Aici avem
deci un conflict: o altã instrucþiune, aflatã în stagiul de calcul
ar putea dori sã foloseascã acea unitate în acelaºi timp pentru
cã trebuie sã adune douã numere.

<P>
Astfel de ``hazards'' sunt numite ``structurale'', pentru cã
structura procesorului nu permite executarea anumitor tipuri de
instrucþiuni simultan în stagii diferite.  În exemplul nostru,
instrucþiunile care nu folosesc unitatea aritmeticã (de pildã o
instrucþiune de salt absolut) nu cauzeazã nici un fel de conflicte.

<P>
Putem da ºi alte exemple de dependenþe structurale: mai multe
instrucþiuni vor sã acceseze simultan acelaºi registru, mai multe
instrucþiuni vor sã acceseze memoria (de pildã o instrucþiune care
vrea sã-ºi adune operanzii ºi tocmai îi citeºte ºi una care a
terminat ºi vrea sã scrie rezultatul), sau instrucþiuni a cãror
execuþie dureazã mai mulþi cicli de ceas.

<P>
Un exemplu de ultima speþã sunt de pildã operaþiile în virgulã
flotantã (adicã cu numere ``reale'', nu întregi) care dureazã
uneori zeci de cicli de ceas, iar procesorul de obicei are o singurã
unitate de calcul în virgulã flotantã.

<P>
Teoretic un hazard structural se poate oricînd evita duplicînd
unitãþile funcþionale care sunt în conflict; aceastã soluþie nu
este însã întotdeauna fezabilã.  De pildã, dacã o
împãrþire<A NAME="tex2html6"
  HREF="#foot98"><SUP>3</SUP></A>  dureazã 10
cicli, atunci ar trebui sã avem 10 împãrþitoare pentru a permite
execuþia a 10 împãrþiri succesive.

<P>
Tot pentru a evita dependenþele structurale procesoarele moderne au,
aºa cum arãtam în figurã, douã cache-uri L1<A NAME="tex2html7"
  HREF="#foot99"><SUP>4</SUP></A>  separate: unul pentru instrucþiuni (I-cache)
ºi unul pentru date (D-cache): în acest fel se poate citi o
instrucþiune simultan cu scrierea rezultatelor alteia.

<P>
Vom vedea un pic mai jos cum rezolvã un procesor astfel de
dependenþe.

<P>

<H2><A NAME="SECTION00042000000000000000">
Dependenþe ale datelor</A>
</H2>

<P>
O dependenþã mult mai subtilã este cea a datelor.  Sã presupunem
cã avem un program cu douã instrucþiuni consecutive: una care scrie
numãrul 2 în registrul 3, iar urmãtoarea care adaugã valoarea 5
acelui registru.

<P>
În tabelul&nbsp;<A HREF="#avans">2</A> vedem cum progreseazã aceste instrucþiuni
într-o þeavã ipoteticã care seamãnã cu cea descrisã mai sus.
Am mai pus niºte instrucþiuni noop, care nu fac nimic, în jur,
pentru a ilustra mai bine

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="176"></A>
<TABLE>
<CAPTION><STRONG>Table 2:</STRONG>
Avansul instrucþiunilor într-un pipeline ideal.  Am
prescurtat stagiile cu <B>C</B>: citire, <B>D</B>: decodificare, <B>E</B>: execuþie, <B>M</B>: memorie, <B>S</B>: scriere.  Aceastã execuþie
nu este posibilã (fãrã ajutor suplimentar), pentru cã la momentul
de timp 3 instrucþiunea de adunare vrea valoarea din R3, care va fi
scrisã în R3 de instrucþiunea de scriere abia la momentul 5.
Dependenþa este marcatã cu douã semne + în tabel.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="CENTER" COLSPAN=9>Ceasul</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Instrucþiunea</B></TD>
<TD ALIGN="CENTER">0</TD>
<TD ALIGN="CENTER">1</TD>
<TD ALIGN="CENTER">2</TD>
<TD ALIGN="CENTER">3</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="CENTER">5</TD>
<TD ALIGN="CENTER">6</TD>
<TD ALIGN="CENTER">7</TD>
<TD ALIGN="CENTER">8</TD>
</TR>
<TR><TD ALIGN="LEFT">noop</TD>
<TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">D</TD>
<TD ALIGN="CENTER">E</TD>
<TD ALIGN="CENTER">M</TD>
<TD ALIGN="CENTER">S</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">scrie 2 în R3</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">D</TD>
<TD ALIGN="CENTER">E</TD>
<TD ALIGN="CENTER">M</TD>
<TD ALIGN="CENTER">S<sup>+</sup></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">aduna 5 la R3</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">D<sup>+</sup></TD>
<TD ALIGN="CENTER">E</TD>
<TD ALIGN="CENTER">M</TD>
<TD ALIGN="CENTER">S</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">noop</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">D</TD>
<TD ALIGN="CENTER">E</TD>
<TD ALIGN="CENTER">M</TD>
<TD ALIGN="CENTER">S</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">noop</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">D</TD>
<TD ALIGN="CENTER">E</TD>
<TD ALIGN="CENTER">M</TD>
<TD ALIGN="CENTER">S</TD>
</TR>
</TABLE>
</DIV>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Diagrama din tabelul&nbsp;<A HREF="#avans">2</A> este tipicã pentru a descrie
evoluþia datelor într-un pipeline.  Programul este scris pe
verticalã, ceasul este marcat pe orizontalã.  Starea þevii poate fi
cititã pe verticalã, de sus în jos.  Cãsuþa de la instrucþiunea
1 ºi ceasul 3 aratã în care dintre fazele þevii se aflã acea
instrucþiune la momentul 3, în cazul nostru în stagiul de acces la
memorie (M).

<P>
Care e problema?  Problema este cã instrucþiunea de scriere pune
datele în registrul 3 abia cînd atinge ultimul stagiu din þeavã.
Pe de altã parte, instrucþiunea de acumulare citeºte valoarea
registrului 3 atunci cînd este în faza de decodificare.  Dar
datoritã suprapunerilor, decodificarea instrucþiunii de acumulare se
face la momentul 3, iar scrierea la momentul 5!  Din cauza
suprapunerii, în execuþie am inversat ordinea în timp în care se
petrec douã operaþiuni.  Dacã nu facem nimic, rezultatul final va
fi desigur greºit, pentru cã acumularea nu vede efectul scrierii.

<P>
Înainte de a vedea ce e de fãcut sã inspectãm o altã dificultate
care poate apãrea.

<P>

<H2><A NAME="SECTION00043000000000000000">
Dependenþe ale controlului</A>
</H2>

<P>
Un tip special de dependenþe este cauzat de instrucþiunile de salt.
O instrucþiune de salt indicã o întrerupere în fluxul normal al
programului.  Neplãcerea apare din faptul cã execuþia
instrucþiunii de salt se terminã destul de tîrziu, abia cînd
instrucþiunea a calculat adresa finalã de destinaþie.  Dar între
timp în þeavã au intrat o grãmadã de instrucþiuni, toate cele
care urmau imediat.  Evident, acestea nu trebuie executate (sau vor fi
executate dacã saltul este condiþionat de o condiþie care este
falsã). 

<P>
Astfel de dependenþe se numesc ``dependenþe de control'', din cauzã
cã sunt produse de modificãri în ``controlul'' (ordinea de
execuþie) a programului.

<P>
Voi consacra un articol întreg acestui tip de dependenþe, pentru cã
efectul lor este catastrofal asupra performanþei, ºi pentru cã sunt
extrem de greu de reparat fãrã a pierde toate avantajele unui
pipeline.  Impactul salturilor este extrem de important din douã
motive:

<P>

<UL>
<LI>Din raþiuni de performanþã, procesoarele moderne au þevi
foarte foarte lungi (peste zece stagii); astfel de procesoare se
numesc pompos ``superpipelined''.  Ori, cu cît þeava este mai
lungã, cu atît o golire ºi reîncãrcare a ei costã mai mult.
Þeava nu mai este capabilã în acest caz sã producã un rezultat la
fiecare ciclu de ceas, pentru cã, dupã o golire, timpul pînã la
urmãtorul rezultat este din nou egal cu latenþa, care este tot una
cu numãrul de stagii.

<P>
</LI>
<LI>Mai grav este faptul cã, statistic s-a observat cã, în medie,
<EM>una din 7 instrucþiuni executate este un salt</EM>.  Aceastã
densitate enormã de salturi în codul maºinã este cu adevãrat
îngrijorãtoare: dacã la fiecare 7 instrucþiuni trebuie sã golim
þeava, atunci performanþa se duce cu totul de rîpã.
</LI>
</UL>

<P>
Sã estimãm costul unei astfel de situaþii pentru procesorul nostru
de mai sus, cu întîrzieri de 3, 3, 3, 5, 3 nanosecunde.  Atunci
procesorul va executa 7 instrucþiuni fiecare la cîte un ciclu, dupã
care timp de 4 cicli va umple din nou þeava golitã de un salt.  Asta
înseamnã 7*6 + 4*6 = 66 cicli pentru 7 instrucþiuni, adicã 66/7 =
9.42ns/instrucþiune în medie.  Creºterea de performanþã a
procesorului faþã de modelul fãrã þeavã este acum de 17/9.42 =
1.8 ori.  ªi încã am presupus cã celelalte feluri de dependenþe
nu cauzeazã nici o întîrziere!

<P>

<H2><A NAME="SECTION00044000000000000000">
Excepþii</A>
</H2>

<P>
Mai avem de-a face cu o ultimã neplãcere, care este mult mai greu de
rezolvat decît cele indicate anterior, ºi despre care nici nu vom
vorbi prea mult în acest articol.

<P>
Cînd anumite condiþii excepþionale se ivesc, procesorul trebuie sã
întrerupã complet fluxul execuþiei, sã execute o rutinã
specialã, iar apoi uneori sã reia programul întrerupt din exact
acelaºi punct.  Evenimentele care cauzeazã aceastã întrerupere
intempestivã se numesc excepþii.  Existã multe feluri de excepþii,
iar tratamentul lor depinde de tip.  Exemple de excepþii:
împãrþirea prin zero, accesul la o paginã de memorie virtualã
care nu se aflã în memoria fizicã, indicaþia terminãrii unui
transfer de cãtre un dispozitiv periferic (ex. discul), întîlnirea
unui punct de oprire (<EM>breakpoint</EM>) pus de un program de
depanare, etc.

<P>
Problema cea mai mare nu este în asemenea cazuri oprirea programului
ºi saltul (care seamãnã teribil cu o instrucþiune obiºnuitã de
salt), ci repornirea.  În momentul apariþiei unei excepþii, în
þeavã se pot afla o sumedenie de instrucþiuni, cine ºtie de unde
de prin memorie (poate la una dintre ele s-a ajuns printr-un salt sau
chiar o altã excepþie), etc.

<P>
Dacã procesorul vrea sã poatã relua execuþia dupã o excepþie,
atunci trebuie sã posede o grãmadã de circuite care menþin foarte
multã informaþie despre întreaga stare a þevii, pentru a permite
repornirea.  Un astfel de pipeline se numeºte <EM>restartable</EM>, ºi
este extrem de complicat.

<P>

<H1><A NAME="SECTION00050000000000000000">
Soluþii</A>
</H1>

<P>
Concluzia care se desprinde este cã e mai uºor de zis decît de
fãcut un pipeline.  Dar lupta pentru supremaþie în performanþa se
dã pe viaþã ºi pe moarte între marile companii (nu e o metaforã:
cei mai mari concurenþi ai lui Intel, Cyrix ºi AMD au trebuit sã
fie cumpãraþi de alte mari companii, IBM, respectiv National
Semiconductors, pentru a supravieþui).

<P>
Ca atare trebuie gãsite soluþii.  În restul articolului vom
investiga niºte soluþii pentru problema dependenþelor (dar nu ºi
pentru cea a excepþiilor restartabile).

<P>

<H2><A NAME="SECTION00051000000000000000">
Compilatoare grijulii</A>
</H2>

<P>
O posibilã soluþie (care însã nu este folositã decît parþial)
este ca în software sã garantãm cã astfel de lucruri nu se pot
întîmpla.  Compilatorul care genereazã cod pentru un microprocesor
ar trebui sã ne asigure cã douã instrucþiuni care se vor afla
simultan în þeavã nu vor interfera una cu alta.  Compilatorul poate
obþine acest efect umplînd spaþiul dintre douã astfel de
instrucþiuni cu instrucþiuni care nu fac nimic (no-op: no
operation).

<P>
Din pãcate soluþia aceasta nu este viabilã.  Un motiv este cã ar
trebui ca compilatorul sã aibã cunoºtinþe intime despre
arhitectura internã a þevii (ca sã ºtie ce depinde de cine).  Dar
Pentium, Pentium Pro ºi Pentium II au arhitecturi interne complet
diferite, deºi implementeazã acelaºi set de instrucþiuni; ne-ar
trebui deci un compilator diferit pentru fiecare maºina; mai mult
decît atît, programele de pe una n-ar mai merge pe alta, din cauzã
ca altele ar fi dependenþele care trebuie evitate.

<P>
Pe de altã parte, compilatoarele moderne încearcã din rãsputeri
sã ajute hardware-ul, fãrã a garanta neapãrat generarea unui cod
lipsit complet de dependenþe.  Operaþiunea numitã <EM>code
scheduling</EM> (ordonarea codului) este extrem de importantã pentru a
mãri performanþa programelor.  Practic compilatoarele încearcã sã
aranjeze instrucþiunile codului în aºa fel încît instrucþiuni
care depind una de alta (cum sunt cele douã de mai sus) sunt cît mai
departe una de alta.  De exemplu, dacã dupã cele douã instrucþiuni
de mai sus vine o instrucþiune care incrementeazã registrul 2,
atunci ultimele douã instrucþiuni pot fi schimbate între ele fãrã
a modifica rezultatul programului, tocmai pentru cã sunt
independente.  Îmi propun sã discut într-un articol separat despre
tehnicile de creºtere a performanþei folosite de compilatoare, aºa
cã trec acum la prezentarea primei soluþii reale folosite pentru a
rezolva problema dependenþelor.

<P>

<H2><A NAME="SECTION00052000000000000000">
Blocajul (stall)</A>
</H2>

<P>
Dacã o instrucþiune nu poate progresa în þeavã din cauzã cã-i
lipsesc anumite resurse (în exemplul de mai sus, registrul 3 încã nu
are valoarea necesarã), atunci aceste instrucþiuni sunt pur ºi
simplu þinute pe loc în þeavã în aceleaºi stagii, în timp ce
cele care le preced sunt lãsate sã continue.  Oprirea unei
instrucþiuni se numeºte blocaj, sau <EM>stall</EM>.  În spatele
instrucþiunii care continuã se formeazã un gol, numit ``bulã'' (cu
b mic) (<EM>bubble</EM>).  Bula este de fapt o instrucþiune noop: no
operation, care nu are nici un efect.

<P>
Tabelul&nbsp;<A HREF="#bula">3</A> prezintã evoluþia programului de mai sus atunci
cînd apare o bulã.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="177"></A>
<TABLE>
<CAPTION><STRONG>Table 3:</STRONG>
Avansul instrucþiunilor într-un pipeline cu blocaj.
Steluþa indicã un blocaj: la momentul respectiv instrucþiunea
indicatã rãmîne în acelaºi stagiu.  Pentru cã starea þevii se
poate citi pe fiecare coloanã, observaþi cã la momentul de timp 4
numai stagiile <B>C, E, M</B> ºi <B>S</B> apar; asta înseamnã cã
stagiul <B>D</B> conþine o bulã.  La momentul urmãtor bula se
propagã în stagiul <B>E</B>, ºi o nouã bulã apare în stagiul <B>D</B>.  De îndatã ce instrucþiunea care scrie în R3 ajunge în
stagiul S, instrucþiunea urmãtoare poate continua, pentru cã a
obþinut rezultatul.  Observaþi cã acum dependenþa este rezolvatã,
pentru cã semnele + sunt în aceeaºi coloanã, deci rezultatul
este deja disponibil cînd este cerut.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="CENTER" COLSPAN=9>Ceasul</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Instrucþiunea</B></TD>
<TD ALIGN="CENTER">0</TD>
<TD ALIGN="CENTER">1</TD>
<TD ALIGN="CENTER">2</TD>
<TD ALIGN="CENTER">3</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="CENTER">5</TD>
<TD ALIGN="CENTER">6</TD>
<TD ALIGN="CENTER">7</TD>
<TD ALIGN="CENTER">8</TD>
</TR>
<TR><TD ALIGN="LEFT">noop</TD>
<TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">D</TD>
<TD ALIGN="CENTER">E</TD>
<TD ALIGN="CENTER">M</TD>
<TD ALIGN="CENTER">S</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">noop</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">D</TD>
<TD ALIGN="CENTER">E</TD>
<TD ALIGN="CENTER">M</TD>
<TD ALIGN="CENTER">S</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">scrie 2 în R3</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">D</TD>
<TD ALIGN="CENTER">E</TD>
<TD ALIGN="CENTER">M</TD>
<TD ALIGN="CENTER">S<sup>+</sup></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">aduna 5 la R3</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">C*</TD>
<TD ALIGN="CENTER">C*</TD>
<TD ALIGN="CENTER">D<sup>+</sup></TD>
<TD ALIGN="CENTER">E</TD>
<TD ALIGN="CENTER">M</TD>
</TR>
<TR><TD ALIGN="LEFT">noop</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">D</TD>
<TD ALIGN="CENTER">E</TD>
</TR>
</TABLE>
</DIV>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
De îndatã ce instrucþiunea care avea resursele cerute îºi
terminã execuþia, instrucþiunile de dupã ele, care aveau nevoie de
resurse, îºi pot continua execuþia în mod obiºnuit.  Blocarea
unei instrucþiuni în þeavã este relativ uºor de produs: registrul
de separaþie de dinaintea acelui stagiu nu mai citeºte valorile
produse de stagiul anterior, ci pãstreazã vechiul sãu conþinut.

<P>
Soluþia prin care compilatorul insereazã instrucþiuni inutile se
numeºte <EM>staticã</EM>, pentru cã programul apoi rãmîne
neschimbat.  Prin contrast, atunci cînd bulele sunt create de
microprocesorul însuºi atunci cînd programul se executã, tehnica
se numeºte <EM>dinamicã</EM>.  Observaþi cã ºi în acest caz
programul din memorie este neschimbat: bula apare doar în þeavã,
ºi apoi dispare.

<P>
Soluþia asta pare acceptabilã.  Care este costul pe care trebuie
sã-l plãtim?

<P>
În primul rînd trebuie hardware special pentru a detecta
dependenþele.  Asta înseamnã practic o serie de comparatoare: un
comparator comparã registrul în care scrie instrucþiunea care se
aflã în stagiul 4 cu regiºtrii citiþi de instrucþiunile din
stagiile 3, 2.  Un alt comparator se uitã sã vadã dacã tipurile de
instrucþiuni din aceste stagii într-adevãr folosesc regiºtri (de
pildã o instrucþiune de salt imediat nu foloseºte nici un registru.
Dacã, de pildã, instrucþiunea din stagiul 4 va scrie în registrul
consumat de instrucþiunea din stagiul 2, atunci stagiul 2 este
blocat, stagiile 3 ºi 4 avanseazã, iar în stagiul 3 se formeazã o
bulã.

<P>
Un al doilea preþ pe care-l plãtim pentru blocaj este scãderea
performanþei.  Din cauzã cã instrucþiunile nu avanseazã ºi
þeava proceseazã nimicuri, rata efectivã cu care instrucþiunile
sunt executate scade sub una pe ciclu.  Cît de mult scade, depinde de
o sumedenie de factori, începînd cu calitatea compilatorului ºi
terminînd cu capacitatea þevii de a evita blocajele prin urmãtorul
mijloc pe care-l analizãm, înaintarea.

<P>

<H2><A NAME="SECTION00053000000000000000">
Înaintarea (forwarding)</A>
</H2>

<P>
În lupta lor acerbã cu nanosecundele, proiectanþii de
microprocesoare au gãsit încã o soluþie pentru a rezolva
dependenþele.  În exemplul de mai sus, o instrucþiune aflatã în
stagiul de decodificare avea nevoie de niºte date pe care
instrucþiunea aflatã în stagiul de execuþie tocmai le calculase.
Cea din stagiul de decodificare însã trebuia sã aºtepte ca
rezultatul calculelor sã fie pus într-un registru, ceea ce se va
întîmpla abia mai tîrziu.  Ideea este atunci simplã: din moment ce
tot am deja rezultatul, de ce sã mai aºtept sã fie scris în
registru ºi apoi sã-l iau din nou?  Ce-ar fi dacã producãtorul ar
trimite rezultatul pe o scurtãturã direct la consumator?

<P>
Aceastã tehnicã se numeºte ``înaintare'' (<EM>forwarding</EM>),
deºi strict vorbind este o ``înapoiere'', pentru cã datele sunt
trimise înapoi în þeavã, de la producãtor la consumator.  Asta
permite instrucþiunii din stagiul de decodificare sã-ºi continue
execuþia netulburatã, fãrã a mai fi nevoie de introducerea unei
bule.  Înaintarea este ilustratã în figura&nbsp;<A HREF="pipe-html.html#inaintare">3</A>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="inaintare"></A><A NAME="200"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
Stagiul de execuþie împreunã cu cãrarea
de înaintare a datelor.  Stagiul de execuþie poate prelua o valoare
fie de la stagiul de decodificare, fie de la propria sa ieºire.  Noul
multiplexor introdus, în partea de jos a figurii, face aceastã
alegere.  Multiplexorul este comandat de un comparator care se uitã
sã vadã dacã una dintre instrucþiuni produce valoarea unui
registru de care cealaltã are nevoie.</CAPTION>
<TR><TD><IMG
 WIDTH="446" HEIGHT="413" BORDER="0"
 SRC="img5.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{inaintare.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Soluþia este clar preferabilã, pentru cã viteza de execuþie
rãmîne aceeaºi, o instrucþiune pe ciclu.  Costul plãtit este
însã în hardware: pe lîngã circuitele prezente în cazul
blocãrii, înaintarea are nevoie de o mulþime de trasee speciale ºi
circuite de selecþie (multiplexoare) pentru a trimite datele pe
scurtãturi.  Dar budgetul în tranzistoare al proiectanþilor este
atît de mare încît nu se dau în lãturi de la aºa ceva.

<P>
Procesoarele reale folosesc deci o mixturã a celor trei tehnici
prezentate anterior; nu orice se poate rezolva cu înaintare, aºa cã
blocajul este practic întotdeauna necesar.  (Un exemplu ar fi o
instrucþiune care terminã de calculat un rezultat abia în stagiul
4, dar care este consumat de instrucþiunea urmãtoare în stagiul 2.
În momentul în care a doua instrucþiune vrea valoarea, ea nici nu
existã, deci înaintarea nu este de nici un folos., deci trebuie
folosit un blocaj.)

<P>

<H1><A NAME="SECTION00060000000000000000">
Variaþiuni ºi concluzii</A>
</H1>

<P>
Încheiem aici incursiunea noastrã în arhitectura
procesoarelor-þeavã.  În comparaþie cu alte tehnici, pe care
sperãm cã le vom putea prezenta în articole ulterioare,
pipelining-ul este pînã la urmã o metodã destul de simplã ºi cu
o eficacitate imediatã.  În procesoarele moderne nu numai fazele de
execuþie ale unei instrucþiuni sunt ``pipelined'', ci ºi
operaþiile aritmetice; de pildã unele unitãþi aritmetice
calculeazã o înmulþire pe 32 de biþi în 5-6 cicli de ceas, dar
pentru cã înmulþitorul este pipelined, el poate accepta o nouã
pereche de operanzi la fiecare ciclu, ºi poate produce rezultate cu
aceeaºi frecvenþã.

<P>
Procesoarele moderne folosesc un întreg arsenal de alte tehnici,
extrem de sofisticate, dintre care enumerãm aici:

<P>
<DL>
<DT><STRONG>Superpipeline:</STRONG></DT>
<DD>am definit acest termen deja: indicã un
pipeline extrem de adînc, cîteodatã de peste 10 stagii.

<P>
</DD>
<DT><STRONG>Superscalar:</STRONG></DT>
<DD>procesoarele superscalare au la dispoziþie mai
multe pipelines paralele, ºi pot lansa în execuþie mai multe
instrucþiuni simultan.  Pentium II are de pildã douã þevi, numite
U ºi V.  Un astfel de procesor poate termina mai multe instrucþiuni
în fiecare ciclu de ceas!

<P>
</DD>
<DT><STRONG>VLIW:</STRONG></DT>
<DD>este un acronim de la <EM>Very Long Instruction Word</EM>,
adicã ``instrucþiuni foarte lungi''.  Astfel de procesoare au
instrucþiuni formate din mai multe instrucþiuni elementare (ex. o
adunare ºi o scãdere simultan).  Compilatorul are sarcina sã
grupeze instrucþiunile laolaltã în aºa fel încît sã poatã fi
executate simultan.  Diferenþa faþã de un superscalar este cã
superscalarul decide dinamic care instrucþiuni merg împreunã, pe
cînd la VLIW acest lucru se face la compilare.

<P>
</DD>
<DT><STRONG>Reordonare:</STRONG></DT>
<DD>procesoarele moderne sunt în stare sã execute
instrucþiunile în altã ordine decît cea în care sunt prezente în
program; asta se numeºte <EM>out of order execution</EM>.  Practic ele
realizeazã echivalentul operaþiei de <EM>scheduling</EM> pe care o fac
compilatoarele, dar o fac în mod dinamic.  Avantajul este cã dacã
trebuie sã blochezi o instrucþiune în þeavã dar cele de dupã ea
au toate resursele disponibile, poþi sã le laºi s-o ia înainte,
þinînd þeava ocupatã.

<P>
</DD>
<DT><STRONG>Execuþia speculativã:</STRONG></DT>
<DD>este o tehnicã folositã pentru a
micºora impactul ``hazardurilor'' de control (adicã dependenþele
produse de salturi).  Procesorul presupune cã saltul se face într-o
anumitã direcþie ºi încarcã în þeavã instrucþiunile de la
``destinaþie'' (asta se numeºte speculaþie -- <EM>speculation</EM>).  Dacã se dovedeºte cã a greºit în ghicirea
adresei de destinaþie a saltului, atunci pur ºi simplu ºterge tot
ce a încãrcat greºit în þeavã ºi începe execuþia de la
locul unde mergea în realitate saltul.

<P>
</DD>
<DT><STRONG>Prezicerea salturilor:</STRONG></DT>
<DD>am vãzut cã dependenþele de control
sunt foarte costisitoare, ºi forwarding nu ajutã în cazul lor
(pentru cã adresa destinaþie este calculatã relativ tîrziu, dar
este necesarã foarte devreme, în chiar primul stagiu, care aduce
instrucþiuni din memorie).  Pentru asta procesoarele moderne
încearcã sã ``ghiceascã'' în mod inteligent direcþia unui salt,
bazîndu-se pe execuþiile trecute ale acelui salt.  O cantitate
enormã de hardware este dedicatã acestui scop.

<P>
</DD>
</DL>

<P>
Dacã vrem sã rezumãm învãþãmintele acestui text într-o frazã
putem spune aºa: atunci cînd ai destulã mînã de lucru ºi multe
activitãþi de fãcut, e foarte economic sã organizezi munca într-o
bandã de asamblare; specializarea fiecãrui lucrãtor garanteazã
eficacitate sporitã în muncã, iar durata medie de producere a unui
rezultat este egalã cu lungimea activitãþii celui mai lent dintre
lucrãtori.  

<P>
Gata cu distracþia, acum la treabã.  Fiecare sã-ºi reia locul în
þeavã!

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot68">... strii</A><A NAME="foot68"
 HREF="pipe-html.html#tex2html2"><SUP>1</SUP></A>
<DD>Regiºtrii microprocesorului sunt o
minusculã memorie aflatã în interiorul procesorului, unde el
pãstreazã datele pe care intenþioneazã sã le proceseze în
viitorul foarte apropiat.

<DT><A NAME="foot175">... exact</A><A NAME="foot175"
 HREF="pipe-html.html#tex2html5"><SUP>2</SUP></A>
<DD>Pentru a fi precis, hazardurile sunt de mai
multe tipuri, iar unele hazarduri se numesc <EM>dependencies</EM>.
Oricum, aproximarea mea nu este complet nerezonabilã.

<DT><A NAME="foot98">... tire</A><A NAME="foot98"
 HREF="pipe-html.html#tex2html6"><SUP>3</SUP></A>
<DD>Presupunem cã circuitul care face împãrþirea
nu poate le însuºi fi implementat ca un pipeline.

<DT><A NAME="foot99">... L1</A><A NAME="foot99"
HREF="pipe-html.html#tex2html7"><SUP>4</SUP></A> <DD>Am scris cel
puþin trei articole <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#cache">(1)</a>
<a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#smp">(2)</a>
<a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#masuri">(3)</a>
despre cache-uri în PC Report; le puteþi accesa din pagina mea de web.

</DL>
<BR><HR>

</BODY>
</HTML>
