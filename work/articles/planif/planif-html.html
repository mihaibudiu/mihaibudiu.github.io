<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>O problemã de inteligenþã artificialã -- planificarea</TITLE>
<META NAME="description" CONTENT="O problemã de inteligenþã artificialã -- planificarea">
<META NAME="keywords" CONTENT="planif-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">O problemã de inteligenþã artificialã -- planificarea</H1>
<P ALIGN="CENTER"><STRONG>Raluca Budiu (ralucav+@cs.cmu.edu)</STRONG></P>
<P ALIGN="CENTER"><STRONG>aprilie 1996 ?</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>enunþarea problemei de planificare; un exemplu din
lumea blocurilor; un planificator în PROLOG
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>planificare, operator, cãutare.
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe minime legate de tipuri de
date ºi de cãutare; limbajul Prolog pentru program
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html10"
  HREF="planif-html.html">Introducere</A>
<LI><A NAME="tex2html11"
  HREF="#SECTION00030000000000000000">Ce înþelegem prin ``planificare''</A>
<LI><A NAME="tex2html12"
  HREF="#SECTION00040000000000000000">O problemã tipicã</A>
<LI><A NAME="tex2html13"
  HREF="#SECTION00050000000000000000">Reprezentarea stãrilor în lumea blocurilor</A>
<LI><A NAME="tex2html14"
  HREF="#SECTION00060000000000000000">Reprezentarea operatorilor în lumea blocurilor</A>
<LI><A NAME="tex2html15"
  HREF="#SECTION00070000000000000000">Planificarea - o problemã de cãutare</A>
<LI><A NAME="tex2html16"
  HREF="#SECTION00080000000000000000">Algoritm ºi implementare</A>
<LI><A NAME="tex2html17"
  HREF="#SECTION00090000000000000000">ANEXÃ</A>
</UL>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION00020000000000000000">
Introducere</A>
</H1>

<P>
În acest articol ne propunem sã prezentãm una din problemele
centrale ale inteligenþei artificiale -- planificarea, împreunã cu o
soluþie simplã (ºi parþialã) a ei, implementatã în limbajul
PROLOG.  Pentru înþelegerea articolului nu e necesarã cunoaºterea 
PROLOG-ului.  Doar studiul codului din anexã necesitã o
minimã familiarizare cu acest limbaj.

<P>

<H1><A NAME="SECTION00030000000000000000">
Ce înþelegem prin ``planificare''</A>
</H1>

<P>
Înainte de a da o definiþie planificãrii, aºa cum este ea
înþeleasã de inteligenþa artificialã, sã considerãm urmãtorul
exemplu.  Sã ne imaginãm ca o persoanã X, aflatã în Bucureºti,
vrea sã facã o cãlãtorie la Londra.  Ca sã îºi poatã atinge
acest þel, X trebuie sã ducã la îndeplinire cîteva acþiuni
prealabile: sã obþinã o vizã de la Ambasada Britanicã, sã-ºi
cumpere bilet de avion, sã-ºi facã bagajul, sã se ducã la
aeroport la data ºi ora precizatã pe bilet, sã ia avionul ºi,
finalmente, sã coboare la Londra.  Aceste etape preliminare care
trebuie satisfãcute pentru atingerea scopului final -- cãlãtoria de
la Bucureºti la Londra -- se numesc acþiuni, ºi ele constituie un
plan.  Construirea explicitã a unei succesiuni de astfel de acþiuni
în vederea unui þel final oarecare este o planificare.

<P>
Pînã acum nimic nu pare sã se lege de inteligenþa artificialã.
Sã presupunem însã cã X este un robot bucureºtean, ºi cã ne-ar place ca
acest robot, în momentul în care cineva îi comandã o cãlãtorie
la Londra (sau orice altceva), sã fie capabil sã-ºi planifice
singur (în sensul de mai sus) aceastã cãlãtorie, fãrã ca omul
sã trebuiascã sã-i precizeze explicit cã are nevoie de o vizã, de
bilet, º.a.m.d.

<P>
Planificarea în sensul inteligenþei artificiale (de altfel singurul
sens în care vom folosi acest cuvînt de-acum încolo) înseamnã
generarea unei secvenþe de acþiuni pentru un agent (de tipul unui
robot) care poate schimba mediul (lumea) în care evolueazã.  Scopul
planificãrii este atingerea unuia sau mai multor þeluri exprimate
explicit.

<P>
O remarcã despre terminologie -- termenii ``lume'' ºi mediu se
referã în acest articol la universul problemei de rezolvat.

<P>
În definiþia de mai sus, am folosit cuvintele ``agent care poate
schimba mediul în care evolueazã''.  Într-adevãr, dacã robotul X
din exemplul dat nu e în stare sã interacþioneze cu lumea
înconjurãtoare altfel decît prin comenzile primite (nu poate sã
meargã sau sã emitã la rîndul lui cereri), atunci nici o
speranþã sã obþinã viza sau sã cumpere biletul de avion, ºi cu
atît mai puþin sã se deplaseze la aeroport.  Pe de altã parte,
dacã robotul cu pricina ºtie sã efectueze doar douã acþiuni: sã
coase ºi sã taie, oricît de ``inteligent'' ar fi el, e foarte
puþin probabil sã gãseascã o combinaþie de tãieturi ºi
cusãturi (adicã un plan bazat pe aceste douã acþiuni) care sã-l
poarte la Londra.

<P>
Ca sã recapitulãm, informaþia de intrare într-o problemã de
planificare conþine:

<P>

<UL>
<LI>o stare iniþialã a lumii (mediului).  In exemplul nostru,
starea iniþialã este: X se aflã în Bucureºti, fãrã vizã
britanicã, fãrã bilet spre Londra ºi fãrã vreun bagaj fãcut.

<P>
</LI>
<LI>o mulþime de acþiuni (operatori) care pot fi folosite în
schimbarea lumii.  Despre aceste acþiuni n-am spus nimic în exemplul
de mai sus, decît cã ar fi bine sã fie altele decît ``a coase''
ºi ``a tãia''; ele se referã la activitãþile elementare pe care
robotul X ar trebui sã le poatã îndeplini.  Putem presupune, de
exemplu, cã X ºtie sã obþinã vizã, sã cînte la pian, sã
cumpere bilet de avion, sã facã bagaje, sã meargã dintr-un loc în
altul, sã ia avionul, sã gãteascã, sã coboare din avion (de
obicei, însã, operatorii sunt mult mai simpli, dupã cum veþi
vedea).

<P>
</LI>
<LI>o mulþime de scopuri.  În exemplul dat, scopul este unul
singur -- cãlãtoria la Londra.
</LI>
</UL>

<P>
Înainte de a da un exemplu complet de problemã de planificare,
trebuie sã spunem cã, pentru ca sã se poatã vorbi de o soluþie la
o astfel de problemã, lumea în care planul urmeazã a fi executat
trebuie sã fie cel puþin predictibilã, dacã nu chiar
deterministã.  Aceasta înseamnã, revenind la exemplul nostru, cã
nu luãm în considerare evenimente neaºteptate de tipul aeroportul e
închis, sau avionul se prãbuºeºte la cinci minute dupã decolare
sau avionul e deturnat de pe ruta spre Londra.  Este evident cã
aceastã ipotezã a unei lumi lipsite de neprevãzut este destul de
departe de realitate.

<P>

<H1><A NAME="SECTION00040000000000000000">
O problemã tipicã</A>
</H1>

<P>
În inteligenþa artificialã (ºi nu numai), se obiºnuieºte ca,
atunci cînd o problemã destul de complicatã se doreºte a fi
rezolvatã, sã se caute mai întîi soluþii ale ei pentru un caz
particular mai simplu.  Aºa ºi cu planificarea.  Ea a fost intensiv
studiatã pe un exemplu de-acum clasic, ºi anume în aºa-numita lume
a blocurilor.  Toate obiectele în acest univers sunt cuburi de
aceeaºi mãrime.  Ele pot fi aºezate pe o masã (una singurã în
universul problemei, consideratã infinitã) sau unul peste celãlalt.
Agentul care poate modifica aceastã lume este un robot cu un braþ,
cu care poate sã apuce un singur bloc la un moment dat.

<P>
Iatã un exemplu de stare iniþialã ºi de stare finalã (de atins)
în aceastã lume (Figura 1):

<P>

<PRE>
                              |                                      |
                             _|_                                    _|_
        |----|     |----|   /   \            |----|      |----|    /   \
        | b  |     |  d |  /     \           | c  |      |  d |   /     \
        |----|     |----|                    |----|      |----|
        | a  |     |  c |                    | a  |      |  b |
--------|----|-----|----|-----          -----|----|------|----|------
        Stare initiala                        Scop (Stare finala)

                           Figura 1.
</PRE>

<P>
Problema este cum putem reprezenta aceste configuraþii cu un limbaj
mai apropiat de cel pe care l-ar putea înþelege un calculator.
Dacã în locul robotului, cel cãruia ar trebui sã-i descriem aceste
stãri ar fi un om, ºi dacã am comunica cu acel om la telefon, de
pildã, atunci probabil cã i-am spune ceva de genul: ``starea
iniþialã e urmãtoarea: blocurile a ºi c sunt pe masã, blocul b
este deasupra lui a ºi blocul d este deasupra lui c.  Pe blocurile b
ºi d nu mai este nici un alt bloc.  Robotul nu þine nimic în
mînã. Starea finalã este etc.''.  Ca atare, nu e o idee rea sã
descriem o stare în lumea blocurilor ca pe o colecþie de ``fapte''
(adicã afirmaþii adevãrate în configuraþia respectivã).

<P>

<H1><A NAME="SECTION00050000000000000000">
Reprezentarea stãrilor în lumea blocurilor</A>
</H1>

<P>
Prin urmare, pentru a reprezenta o stare vom folosi urmãtoarele
literale:

<P>
<DL>
<DT><STRONG>LIBER (x):</STRONG></DT>
<DD>însemnînd cã deasupra blocului x nu se
gãseºte nici un alt bloc
</DD>
<DT><STRONG>IN-MINA (x):</STRONG></DT>
<DD>însemnînd ca braþul robotului þine blocul x
</DD>
<DT><STRONG>PE-MASA (x):</STRONG></DT>
<DD>cu semnificaþia cã blocul x se gãseºte pe
masã
</DD>
<DT><STRONG>MINA-LIBERA:</STRONG></DT>
<DD>însemnînd cã robotul nu are nimic în
mînã
</DD>
<DT><STRONG>PE (x, y):</STRONG></DT>
<DD>însemnînd cã blocul x este aºezat pe blocul y.
</DD>
</DL>

<P>
Orice configuraþie din lumea blocurilor poate fi descrisã ca o
mulþime sau o conjuncþie (<EM>ºi</EM> logic) de astfel de literale.
De exemplu, sã vedem cum se reprezintã cele douã stãri din figura
1:

<P>
Starea iniþialã:

<P>
<PRE>
        PE-MASA (a).
        PE (b, a).
        LIBER (b).
        PE-MASA (c).
        PE (d, c).
        LIBER (d).
        MINA-LIBERA.
</PRE>

<P>
Starea finalã:

<P>
<PRE>
        PE-MASA (a).
        PE (c, a).
        LIBER (c).
        PE-MASA (b).
        PE (d, b).
        LIBER (d).
        MINA-LIBERA.
</PRE>

<P>
Cu alte cuvinte, o stare se poate exprima printr-o colecþie de fapte
care sunt toate adevãrate în configuraþia corespunzãtoare ei.

<P>

<H1><A NAME="SECTION00060000000000000000">
Reprezentarea operatorilor în lumea blocurilor</A>
</H1>

<P>
Sã vedem acum care sunt acþiunile elementare pe care robotul le
poate duce la îndeplinire:

<P>
<DL>
<DT><STRONG>RIDICA (x):</STRONG></DT>
<DD>însemnînd cã braþul robotului apucã blocul
x de pe masã;
</DD>
<DT><STRONG>ASEAZA (x):</STRONG></DT>
<DD>însemnînd cã robotul pune blocul x pe masã;
</DD>
<DT><STRONG>PUNE-PE (x, y):</STRONG></DT>
<DD>însemnînd cã robotul pune blocul x peste
blocul y;
</DD>
<DT><STRONG>IA-DE-PE (x, y):</STRONG></DT>
<DD>însemnînd cã robotul ridicã blocul x de
pe blocul y.
</DD>
</DL>

<P>
Fiind datã o stare iniþialã, robotul poate sã o modifice folosind
una dintre acþiunile (operatorii) de mai sus.  În felul acesta, se
ajunge într-o nouã configuraþie de blocuri care poate sau nu sã
fie identicã cu cea finalã.  Dacã nu este, putem încerca sã
aplicãm din nou un operator, de data aceasta din noua stare în care
tocmai am ajuns, ºi aºa mai departe pînã cînd se atinge þelul
urmãrit.  În plus, dacã ajungem într-o situaþie în care scopul
devine de neatins (cu alte cuvinte, am ales o secvenþa proastã de
operatori), putem oricînd sã ne întoarcem la starea precedentã ºi
sã încercãm un alt operator.  (Unii dintre dumneavoastrã poate au
identificat deja în clipa aceasta planificarea cu o cãutare).  Deci
acþiunile oferã un mod de schimbare a lumii în care robotul
evolueazã.

<P>
Problema care se pune acum este sã gãsim un mod de a exprima tocmai
schimbãrile pe care fiecare dintre aceste acþiuni le poate induce
asupra asupra configuraþiei curente de blocuri.  Vom încerca sã
rezolvãm aceastã problemã bazîndu-ne pe urmãtoarele observaþii:

<P>

<OL>
<LI>o acþiune nu poate fi satisfãcutã oricînd.

<P>
Într-adevãr, nu putem folosi operatorul (acþiunea) IA-DE-PE
(c, a) în starea iniþialã din Figura 1, cãci blocul c nu se aflã
pe blocul a.  Deci, pentru ca un operator sã poatã fi aplicat
trebuie ca starea curentã sã satisfacã anumite condiþii, pe care
le vom numi <EM>precondiþii</EM> ale operatorului cu pricina.

<P>
</LI>
<LI>în general, douã acþiuni modificã starea curentã în
feluri diferite.

<P>
Dacã în starea iniþialã din Figura 1 aplicãm de pildã
acþiunea IA-DE-PE (b, a) , blocul a devine liber ; dacã însã
folosim operatorul IA-DE-PE (d, c), blocul c este liber ºi blocul a
este acoperit în continuare de b.  Deci, un operator poate fi descris
prin efectele (<EM>post-condiþiile</EM>) sale, adicã prin starea lumii
dupã ce el a fost aplicat.
</LI>
</OL>

<P>
Acestea fiind spuse, un operator este unic reprezentat prin douã
mulþimi -- mulþimea precondiþiilor sale ºi mulþimea
post-condiþiilor sale.  Am spus deunãzi cã post-condiþiile unui
operator sunt date de starea lumii dupã ce el a fost aplicat.  Dar,
în principiu, aceastã stare depinde de starea anterioarã aplicãrii
operatorului respectiv.  Într-adevãr, dacã în starea iniþialã
din Figura 1 folosim operatorul IA-DE-PE (b, a), atunci starea în
care ajungem devine cea din Figura 2:

<P>

<PRE>
                                                       PE-MASA (a).
                            |       |----|             PE-MASA (c).
                          /-|-\     | d  |             PE (d, c).
                |----|   /| b |\    |----|             LIBER (d).
                | a  |    |---|     | c  |             IN-MINA (b).
         -------|----|--------------|----|------       LIBER (a).

                        Figura 2.
</PRE>

<P>
În aceastã nouã stare, practic nu s-a schimbat faþã de
configuraþia iniþialã din Figura 1 decît ceea ce era legat de
blocurile a ºi b, precum ºi de braþul robotului.  În rest,
blocurile c ºi d ºi-au pãstrat configuraþia din starea
anterioarã.  Deci post-condiþiile unui operator cuprind, pe lîngã
o descriere a felului în care operatorul respectiv modificã lumea,
ºi faptele care au rãmas neschimbate în urma aplicãrii
operatorului respectiv.  Dar acestea din urmã pot fi foarte multe
(imaginaþi-vã cã în loc de patru blocuri, am folosi cincizeci sau
o mie).  Prin urmare nu este convenabil sã folosim în reprezentarea
unui operator întreaga listã a post-condiþiilor sale.  Ce este de
fãcut?

<P>
Ne vom folosi de un mic truc.  Am vãzut cã de fapt ceea ce este cu
adevãrat relevant pentru un operator este felul în care s-a schimbat
starea posterioarã aplicãrii operatorului faþã de starea
anterioarã aceluiaºi moment.  Aceastã schimbare este descrisã de
douã mulþimi: cea a condiþiilor (faptelor) care devin adevãrate
în noua stare ºi cea a condiþiilor care devin false dupã aplicarea
operatorului.  Putem scrie:

<P>
<PRE>
        STARE-POST = STARE-ANTE + COND-ADAUGATE - COND-STERSE,
</PRE>

<P>
unde:

<P>
<DL>
<DT><STRONG>STARE-POST</STRONG></DT>
<DD>este starea posterioarã aplicãrii unui operator,
</DD>
<DT><STRONG>STARE-ANTE</STRONG></DT>
<DD>este starea anterioarã aplicãrii aceluiaºi operator,
</DD>
<DT><STRONG>COND-ADAUGATE</STRONG></DT>
<DD>este mulþimea faptelor care devin adevãrate în urma
aplicãrii operatorului respectiv,
</DD>
<DT><STRONG>COND-STERSE</STRONG></DT>
<DD>este mulþimea faptelor care devin false în urma
aplicãrii operatorului în cauzã.
</DD>
</DL>

<P>
Ca sã conchidem, un operator poate fi reprezentat prin urmãtorul
triplet:

<P>

<UL>
<LI>mulþimea precondiþiilor care fac posibilã aplicarea lui;
</LI>
<LI>mulþimea condiþiilor care trebuie adãugate la starea
curentã dupã ce operatorul a fost aplicat;
</LI>
<LI>mulþimea condiþiilor care trebuie ºterse din starea
curentã pentru a obþine starea urmãtoare.
</LI>
</UL>

<P>
De exemplu, operatorul IA-DE-PE (x, y) poate fi descris astfel:

<P>
<PRE>
        IA-DE-PE (y, x)
        preconditii:
                LIBER (y).
                MINA-LIBERA.
                PE (y, x).
        postconditii de adaugat:
                IN-MINA (y).
                LIBER (x).
        postconditii de sters:
                LIBER (y).
                MINA-LIBERA.
                PE (y, x).
</PRE>

<P>

<H1><A NAME="SECTION00070000000000000000">
Planificarea - o problemã de cãutare</A>
</H1>

<P>
Scopul nostru este sã construim un planificator, adicã un program
capabil sã construiascã un plan pentru o scop  ºi o stare
iniþialã date, folosind niºte operatori dependenþi de problemã.
Cum putem face acest lucru?  Folosindu-ne de niºte algoritmi
informaþi de cãutare.  Vom încerca sã explicãm ce sunt aceºtia
ºi în ce fel îi putem folosi în lunga expunere care urmeazã. 

<P>
Planificarea este o problemã de cãutare într-un spaþiu al
stãrilor. Sã vedem ce înþelegem prin aceastã afirmaþie.  Am
vãzut cã în orice problemã de planificare existã o stare de
pornire (stare iniþialã) ºi un scop pe care dorim sã-l atingem.
Pentru ajunge în starea finalã care satisface scopul de atins,
putem folosi o mulþime de operatori.  Aplicarea unuia sau altuia
dintre aceºti operatori atrage dupã sine o modificare de stare.
Toate stãrile noi care pot fi generate din starea iniþialã
aplicînd oricare din operatorii ale cãror precondiþii sunt
îndeplinite formeazã mulþimea succesorilor (stãrilor succesoare)
stãrii iniþiale.  În acelaºi mod putem defini mulþimea
succesorilor unei stãri alta decît cea iniþialã.  Starea
iniþialã, împreunã cu toate stãrile care sunt succesoare unei
alte stãri formeazã un <EM>spaþiu de stãri</EM>.  Cu alte cuvinte, un
spaþiu de stãri este mulþimea tuturor stãrilor care pot fi
obþinute din starea iniþialã aplicînd orice secvenþa posibilã de
operatori.  (Reamintim cã un operator poate fi aplicat numai dacã
precondiþiile sale sunt îndeplinite).  Starea finalã este ºi ea o
stare în acest spaþiu (dacã problema are soluþie).  Soluþia
problemei de planificare este o succesiune de stãri care porneºte
din starea iniþialã ºi ajunge în starea finalã, iar secvenþa de
operatori folosiþi pentru a trece dintr-o stare în alta (pe drumul
între starea iniþialã ºi cea finalã) formeazã planul cãutat.
Un spaþiu de stãri poate fi reprezentat ca un graf în care nodurile
sunt stãri, iar muchiile operatori; o soluþie ca o cãrare în acest
graf (vezi Figura 3).

<P>

<PRE>
                        stare initiala
                            o
                          / | \
                        /   |   \
                      o     o     o    --&gt; succesorii starii initiale
                    / |   / | \     \
                  /   | /   |   \     \
                 o    o     o    o     o  ---&gt; succesorii succesorilor starii
               /            |         / \             initiale
             /              |       /     \
            o               o      o       o
                                 stare
                                finala

                        Figura 3.
</PRE>

<P>
Cum se gãseºte soluþia?  Existã douã variante -- sau se alege o
cãrare anume dupã un criteriu oarecare ºi dacã la sfîrºitul
cãrãrii nu s-a ajuns în starea finalã, atunci se abandoneazã
cãutarea (cãutare ireversibilã); sau se exploreazã toate
cãrãrile pînã cînd se ajunge la o soluþie (cãutare
exhaustivã).  Ordinea de explorare este specificã fiecãrui
algoritm; astfel cãutarea în adîncime exploreazã întotdeauna
succesorii unei stãri înainte de a-i explora ``fraþii'' (nodurile cu
acelaºi pãrinte); cãutarea în lãþime face exact invers --
exploreazã mai întîi fraþii unui nod ºi apoi succesorii lui.
Backtracking-ul este un caz special de cãutare în adîncime.

<P>
Pentru cã de cele mai multe ori spaþiul stãrilor este uriaº, se
folosesc anumiþi algoritmi de cãutare informaþi.  Aceºti algoritmi
fac alegerea stãrii urmãtoare celei curente dupã un criteriu legat
de structura internã a stãrilor candidate, care estimeazã
apropierea acestora de soluþie.  În felul acesta, e posibil sã se
economiseascã timp ºi spaþiu; însã, pe de altã, existã riscul
sã nu se gãseascã o soluþie pentru problema datã.

<P>
Sã presupunem cã am folosi pentru problema noastrã o tehnicã de
cãutare ireversibilã ºi informatã de tipul hill-climbing (``urcuº
de deal'' -- pe româneºte).   Aceasta presupune utilizarea unei
funcþii euristice (de merit), care reprezintã tocmai criteriul
despre care vorbeam în paragraful precedent.  Iatã cum aratã
algoritmul de hill-climbing:

<P>

<OL>
<LI>fã starea iniþialã stare curentã.

<P>
</LI>
<LI>genereazã toþi succesorii stãrii curente (folosind
operatorii ale cãror precondiþii sunt îndeplinite);
dacã vreunul este o stare finalã, atunci stop

<P>
</LI>
<LI>alege ca nouã stare curentã succesorul  care are funcþia
de merit cea mai ``bunã''  dintre toþi succesorii care
nu au fost pînã acum stãri curente ; du-te la pasul 1.
</LI>
</OL>

<P>
Rãmîne sã vedem cum am putea alege o funcþie de merit (euristicã).
Am spus cã o astfel de funcþie estimeazã apropierea unei stãri de
soluþie; am putea deci sã folosim ca euristicã pentru o stare s
funcþia diferenþã datã de numãrul de condiþii din starea finalã
care nu sunt încã satisfãcute în starea s.  O stare este cu atît
mai bunã cu cît funcþia sa de merit este mai micã.

<P>
Vom vedea cã aceastã euristicã este acceptabilã numai cînd
condiþiile ce trebuie satifãcute în starea finalã sunt
independente.  Sã considerãm un exemplu în care funcþia
diferenþã, împreunã cu un algoritm hill-climbing, rateazã
soluþia.

<P>
Fie din nou problema expusã în Figura 1.  Din starea iniþialã
putem ajunge în douã stãri succesoare distincte, corespunzînd
aplicãrii operatorilor IA-DE-PE (b, a) sau IA-DE-PE (d, c).  Cei doi
succesori sunt descriºi în Figurile 2 ºi 4.

<P>

<PRE>
                                                        PE-MASA (a).
                                                        PE (b, a).
                |----|      |                           LIBER (b).
                | b  |    /-|-\                         PE-MASA (c).
                |----|   /| d |\    |----|              LIBER (c).
                | a  |    |---|     | c  |              IN-MINA (d).
         -------|----|--------------|----|------
                        Figura 4.
</PRE>

<P>
Condiþiile satisfãcute în starea scop din Figura 1 ºi
nesatisfãcute în Figura 2 sunt <TT>{ LIBER (c), PE (c, a), PE (d,
b), PE-MASA (b), MINA-LIBERA }</TT>.  Funcþia diferenþa
corespunzãtoare este deci 5.  În ceea ce priveºte starea din Figura
4, condiþiile încã nesatisfãcute sunt <TT>{ PE (c, a), PE (d,
b), PE-MASA (b), MINA-LIBERA }</TT>, deci funcþia diferenþa este 4.
Algoritmul va alege succesorul cu cea mai micã funcþie de merit,
adicã starea din Figura 4.  Aceasta are o funcþie diferenþa mai
bunã pentru simplul fapt cã lasã blocul c liber, fapt de dorit în
starea finalã.  În aceastã nouã stare (cea din Figura 4), se pot
folosi trei operatori: <TT>ASEAZA (d)</TT> sau <TT>PUNE (d, b)</TT> sau
<TT>PUNE (d, c)</TT>.  Ultimul este exclus din start pentru cã ne
întoarce înapoi în starea iniþialã din Figura 1.  Sã vedem care
sunt succesorii ce se pot obþine prin aplicarea celorlalþi doi
operatori (Figura 5 ºi Figura 6).

<P>

<PRE>
                             |
         |----|            /-|-\              PE-MASA (a).
         | d  |           /     \             PE-MASA (c).
         |----|                               PE (b, a).
         | b  |                               PE (d, b).
         |----|     |----|                    LIBER (d).
         | a  |     | c  |                    MINA-LIBERA.
 --------|----|-----|----|-----------
                          Figura 5.
</PRE>

<PRE>
                                 |                        PE-MASA (a).
                               /-|-\                      PE-MASA (d).
                |----|        /     \                     PE-MASA (c).
                | b  |                                    PE (b, a).
                |----|    |----|    |----|                LIBER (b).
                | a  |    | c  |    | d  |                LIBER (c).
      ----------|----|----|----|----|----|-----           MINA-LIBERA.
                                                          LIBER (d).
                                Figura 6.
</PRE>

<P>
Deºi Figura 5 diferã prin mai puþine condiþii de starea finalã
din Figura 1 (funcþie de merit 2) decît Figura 6 (funcþie de merit
3), pentru un om este evident cã Figura 6 este o alegere mai bunã
decît Figura 5 pentru atingerea stãrii finale din Figura 1.
Algoritmul însã va prefera succesorul din Figura 5 pentru cã el
satisface în plus condiþia <TT>PE (d, b)</TT>, care apare în starea
finalã.  El ignorã astfel faptul cã aceastã satisfacerea realã a
acestei condiþii depinde de fapt de condiþia <TT>PE-MASA (b)</TT>.  Cu
alte cuvinte, condiþiile de îndeplinit pentru a ajunge în starea
finalã (numite ºi sub-scopuri) nu sunt independente unele de altele.
În continuare, þinînd cont cã algoritmul va evita ciclarea (adicã
trecerea printr-o stare în care a mai fost) ºi cã el nu se va
întoarce niciodatã înapoi, finalmente se va ajunge în starea în
care blocurile a, b, d, c formeazã un turn ºi programul se va opri
fãrã sã gãseascã soluþia problemei.

<P>
O problemã se numeºte de planificare <EM>liniarã</EM> dacã
sub-scopurile cu care ea are de a face sunt independente.  În
general, foarte puþine probleme intrã în aceastã categorie.

<P>
Am vãzut cã nu putem aplica hill-climbing-ul nici mãcar pentru o
problemã simplã din lumea blocurilor.  Nu vom abandona însã
funcþia de merit pe care am ales-o (cãci ea este de multe ori
utilã, îmbunãtãþind considerabil timpul de cãutare), ci vom
face o cãutare exhaustivã în ghidatã de euristica diferenþã.
În principal, aceasta diferã de o hill-climbing prin faptul cã,
dacã se ajunge la o stare blocantã (în care nu mai e nimic de
fãcut), algoritmul se întoarce înapoi în starea anterioarã ºi
încearcã un alt operator, chiar dacã acesta are o funcþie de merit
mai proastã decît cel folosit iniþial.  De exemplu, într-o
situaþie în care are de ales între stãrile din Figura 5 ºi Figura
6, acest algoritm o va alege întîi pe cea din Figura 5, apoi se va
întoarce înapoi ºi va lua în considerare cealaltã alternativã.

<P>
În secþiunea care urmeazã vom prezenta un algoritm (nu singurul
posibil) pentru un planificator.  El va folosi o cãutare în
adîncime ghidatã de funcþia de merit diferenþã.

<P>

<H1><A NAME="SECTION00080000000000000000">
Algoritm ºi implementare</A>
</H1>

<P>
Ideea algoritmului este sã aleagã cel mai bun posibil succesor al
stãrii curente S ºi sã-l facã urmãtoarea stare curentã Succ.
Dacã Succ nu se gãseºte pe o cãrare spre starea finalã, atunci
programul se întoarce în starea S ºi selecteazã al doilea cel mai
bun succesor, ºi aºa mai departe.

<P>
Algoritmul general este urmãtorul:

<P>
<PRE>
function plan (StareInitiala, StareFinala)
Pasul 1. Creaza o Stiva goala cu operatorii aplicati pina acum:
                StivaOp = {}
         si o stiva a starilor de pe cararea in explorare:
                StivaStari = { StareInitiala }.
         Seteaza StareCurenta = StareInitiala.
Pasul 2. Daca StareCurenta = StareFinala, atunci 
                afiseaza operatorii din StivaOp in ordine inversa
                (ei formeaza planul cautat);
                intoarce succes.
Pasul 3. Genereaza toti succesorii posibili pentru StareCurenta
         aplicind  toti acei operatori ale caror preconditii sunt
         indeplinite.  Pastreaza intr-o coada Succs[StareCurenta]
         toti acei succesori care nu apartin stivei StivaStari.
Pasul 4. Daca coada Succs[StareCurenta] nu este vida, sorteaz-o
         dupa valorile ascendente ale functiei diferenta a starilor
         din aceasta coada.  
Pasul 5. Daca coada Succs[StareCurenta] este vida, atunci
                StareCurenta ia valoarea din virful stivei
                        StivaStari; aceasta valoare se sterge de pe
                        StivaStari;
                sterge virful stivei StivaOp;
                du-te la pasul 5.
Pasul 6. Alege prima stare din coada Succs[StareCurenta] si fa-o
         StareCurenta.  Pune StareCurenta pe StivaStari si operatorul care a
         generat-o in stiva StivaOp.   Du-te la pasul 2.
</PRE>

<P>
Am folosit notaþia <TT>Succs[StareCurenta]</TT> pentru a desemna faptul
cã fiecare stare are coada ei proprie de succesori.

<P>
Algoritmul de mai sus a fost implementat în limbajul PROLOG.
Listing-ul programului poate fi gãsit în anexa care urmeazã.
Programul a fost testat pentru probleme din lumea blocurilor cu 3, 4,
5 blocuri ºi pentru problema maimuþei ºi a bananei, pe care o vom
prezenta pe scurt.  O maimuþa înfometatã se aflã închisã într-o
camerã.  În camerã se gãseºte un scaun lîngã o fereastrã ºi
un ciorchine de banane atîrnã de centrul tavanului.  Maimuþa este
prea scundã ca sã atingã bananele.  Ea este capabilã de
urmãtoarele acþiuni: sã se plimbe prin camerã, sã împingã
scaunul, sã se urce pe scaun, sã ia bananele (dacã ajunge la ele).
Problema este sã se elaboreze un plan pentru maimuþa ca sã
mãnînce bananele.

<P>

<H1><A NAME="SECTION00090000000000000000">
ANEXÃ</A>
</H1>

<P>
<PRE>
/*
 * file plan.ari: planning algorithm
 */

% satisfy_conditions(Conditions, State):
%=======================================
%       check whether the State has among its preconditions all the
%       Conditions. Both arguments should be bound.

satisfy_conditions(Conditions, State):-
        subset(Conditions, State).

% succ_state(State, Effects, NextState)
% =====================================
%       compute the new state NextState in which the last applied operator
%       brought us ; the NextState is the current State
%               - to which we have added the effects in the add-sublist of
%                       Effects
%               - and from which we have deleted the effects in the delete-
%                       sublist of Effects

succ_state(State, [], State).
succ_state(State, [add(Condition) | RestEffects], NextState) :-
        succ_state(State, RestEffects, Temp),
        insert_unique(Condition, Temp, NextState).
succ_state(State, [del(Condition) | RestEffects], NextState) :-
        succ_state(State, RestEffects, Temp),
        delete(Condition, Temp, NextState).

% plan(CurrentState, StateStack, OpStack):
%==========================================
%       print out which operators for a given problem universe should be
%       applied in order to reach the GoalState from a CurrentState;
%       the StateStack contains the sequence of states that were already
%       met; the OpStack is the sequence of operators that were applied
%       (in reverse order).

plan(State, StateStack, OpStack) :-
        goal(GoalState),
        equal(State, GoalState),                % check State = GoalState
        write('Operators that were applied:'), nl,
        display_stack(OpStack).                % print the sequence of
                                                % operators applied
plan(State, StateStack, OpStack) :-
        choose_best_next(State, NextState, StateStack, Operator),
        push(NextState, StateStack, NewStateStack),
        push(Operator, OpStack, NewOpStack),
        plan(NextState, NewStateStack, NewOpStack).

% choose_best_next(State, GoalState, NextState, StateStack, Operator):
%===================================================
% compute all the possible successors of the State, and chooses the
% NextState that is the closest to the GoalState; the operator applied
% to generate the best next state is returned in Operator.

choose_best_next(State, NextState, StateStack, Operator) :-
        bagof(NState / Op, succ(State, StateStack, NState, Op)
                                                         , Succs), !,
        quicksort(Succs, OrdSuccs),
        member(NextState/Operator, OrdSuccs).


% greater(X, Y):
% ==============
% some order relation between two successor states

greater(X / OpX, Y / OpY):-
        goal(Goal), !,
        distance(X, Goal, Dx),!,
        distance(Y, Goal, Dy),!,
        Dx &gt; Dy, !.

% succ(State, StateStack, NState, Op):
% ====================================
% compute the successor of a State in NState; the operator applied in order
% to obtain NState is returned in Op; a check is made to avoid generating
% a state already in StateStack.

succ(State, StateStack, NState, Op) :-
        move(Op, Preconditions, Effects),
        satisfy_conditions(Preconditions, State),
        stack(X, X) \= Op,
        succ_state(State, Effects, NState),
        not(list_member_stack(NState, StateStack)).

% distance(State, Goal, d) :
% ==========================
% computes the distance (heuristic fun) between the State and the Goal;
% returns it in d.

distance(State, Goal, D) :- dist(State, Goal, 0, D).

dist(State, [], Acc, Acc):- !.
dist(State, [Cond | RestCond], Acc, D) :-
        member(Cond, State), !,
        dist(State, RestCond, Acc, D).
dist(State, [Cond | RestCond], Acc, D) :-
        Acc1 is Acc + 1,
        dist(State, RestCond, Acc1, D).


% go(InitialState, GoalState):
% ============================
%       ask for getting from an InitialState to a GoalState.
%       Both arguments should be bound.

go(InitialState, GoalState):-
        asserta(goal(GoalState)),
        empty(StateStack),
        empty(OpStack),
        push(InitialState, StateStack, NewStateStack),
        plan(InitialState, NewStateStack, OpStack),
        retract(goal(X)).

testblock31:-
        go([handempty, ontable(b), ontable(c), on(a, b), clear(a), clear(c)],
           [handempty, ontable(a), ontable(b), on(c, b), clear(a), clear(c)]).

testblock32 :-
        go([handempty, ontable(b), ontable(c), on(a,b), clear(a), clear(c)],
           [handempty, ontable(a), on(c,a), on(b,c), clear(b)]).

testblock33 :- /* Sussman anomaly */
        go([handempty, on(c, a), ontable(b), ontable(a), clear(c), clear(b)],
           [handempty, ontable(c), on(b, c), on(a, b), clear(a)]).

testblock41 :-
        go([handempty, ontable(a), ontable(c), on(b, a), clear(b), on(d, c),
            clear(d)],
           [handempty, ontable(a), ontable(b), on(c, a), clear(c), on(d, b),
            clear(d)]).

testblock42 :-
        go([handempty, ontable(a), ontable(c), ontable(d), on(b, a),
 	    clear(b), clear(c), clear(d)],
           [handempty, on(c, a), ontable(a), on(b, d),
            ontable(d), clear(c), clear(b)]). 
testblock43 :-
        go([handempty, ontable(a), ontable(c), on(b, a), on(d, b), clear(c),
            clear(d)],
           [handempty, ontable(b), on(d, b), on(a, d), on(c, a), clear(c)]).
testblock5:-
        go([handempty, ontable(a), ontable(c), ontable(d),
            on(b, a), clear(b), clear(c), on(e,d), clear(e)],
           [handempty, ontable(c), on(b, a), on(a,c), clear(b),
            ontable(e), on(d,e), clear(d)]).

testape :-
        go([ape(door), on_the_earth, box(window), has(nothing)],
           [ape(middle), on_the_box, box(middle), has(bannana)]).

testrich :-
        go([poor, unknown], [rich, famous]).


/*
 * file blocks.ari: operators for the planning problem in the blocks world
 */

move(
        putdown(X),
        [holding(X)],
        [del(holding(X)),
         add(ontable(X)), add(handempty)]
                 ).

move(
        pickup(X),
        [handempty, clear(X), on(X, Y)],
        [del(handempty), del(on(X, Y)),
         add(clear(Y)), add(holding(X))]
                 ).

move(
        pickup(X),
        [handempty, clear(X), ontable(X)],
        [del(handempty), del(ontable(X)),
         add(holding(X))]
                 ).

move(
        stack(X, Y),
        [holding(X), clear(Y)],
        [del(holding(X)), del(clear(Y)),
         add(handempty), add(on(X,Y))]
     ).

/*
 * file ape.ari: the problem of the ape and the banana
 */

move(
        HOLDING,
        [ape(middle), on_the_box, box(middle), has(nothing)],
        [add(has(bannana)),del(has(nothing))]).

move(
        leaping(X),
        [ape(X), on_the_earth, box(X)],
        [add(on_the_box), del(on_the_earth)]).

% pushing
% ========
move(
        pushing(window, corner),
        [ape(window), on_the_earth, box(window)],
        [add(ape(corner)), add(box(corner)),
         del(ape(window)), del(box(window))]).

move(
        pushing(corner, middle),
        [ape(corner), on_the_earth, box(corner)],
        [add(ape(middle)), add(box(middle)),
         del(ape(corner)), del(box(corner))]).

move(
        pushing(window, door),
        [ape(window), on_the_earth, box(window)],
        [add(ape(door)), add(box(door)),
         del(ape(window)), del(box(window))]).

move(
        pushing(window, middle),
        [ape(window), on_the_earth, box(window)],
        [add(ape(middle)), add(box(middle)),
         del(ape(window)), del(box(window))]).


% walking
% =======
move(
        walking(door, window),
        [ape(door), on_the_earth],
        [add(ape(window)), del(ape(door))]).

move(
        walking(window, middle),
        [ape(window), on_the_earth],
        [add(ape(middle)), del(ape(window))]).

move(
        walking(corner, window),
        [ape(corner), on_the_earth],
        [add(ape(window)), del(ape(corner))]).

move(
        walking(door, middle),
        [ape(door), on_the_earth],
        [add(ape(middle)), del(ape(door))]).

move(
        walking(door, corner),
        [ape(door), on_the_earth],
        [add(ape(corner)), del(ape(door))]).
move(
        walking(middle, window),
        [ape(middle), on_the_earth],
        [add(ape(window)), del(ape(middle))]).
</PRE>
<BR><HR>

</BODY>
</HTML>
