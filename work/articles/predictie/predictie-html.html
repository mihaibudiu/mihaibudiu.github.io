<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Predicþia salturilor</TITLE>
<META NAME="description" CONTENT="Predicþia salturilor">
<META NAME="keywords" CONTENT="predictie-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Predicþia salturilor</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>16 iulie 1999</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>arhitectura modernã a calculatoarelor: predicþia salturilor
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe de arhitectura
procesoarelor moderne
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>salt, dependenþã, predicþie
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html33"
  HREF="predictie-html.html">Maºini pipeline, superscalare ºi dependenþe</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION00030000000000000000">Mãsurãtorile SPEC (benchmarks)</A>
<LI><A NAME="tex2html35"
  HREF="#SECTION00040000000000000000">Costul unui salt</A>
<LI><A NAME="tex2html36"
  HREF="#SECTION00050000000000000000">Dependenþe ale controlului</A>
<UL>
<LI><A NAME="tex2html37"
  HREF="#SECTION00051000000000000000">Dependenþe ale controlului într-un pipeline</A>
</UL>
<BR>
<LI><A NAME="tex2html38"
  HREF="#SECTION00060000000000000000">Soluþia blocantã</A>
<LI><A NAME="tex2html39"
  HREF="#SECTION00070000000000000000">Execuþia speculativã</A>
<LI><A NAME="tex2html40"
  HREF="#SECTION00080000000000000000">Diferite scheme statice de predicþie</A>
<UL>
<LI><A NAME="tex2html41"
  HREF="#SECTION00081000000000000000">Salt niciodatã luat</A>
<LI><A NAME="tex2html42"
  HREF="#SECTION00082000000000000000">Salt mereu luat</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION00083000000000000000">Salt înapoi luat</A>
</UL>
<BR>
<LI><A NAME="tex2html44"
  HREF="#SECTION00090000000000000000">Predicþie dinamicã cu cache-ul de instrucþiuni</A>
<LI><A NAME="tex2html45"
  HREF="#SECTION000100000000000000000">Predicþie dinamicã cu predictori locali</A>
<UL>
<LI><A NAME="tex2html46"
  HREF="#SECTION000101000000000000000">Predictorul cu un bit</A>
<LI><A NAME="tex2html47"
  HREF="#SECTION000102000000000000000">Predictori cu contoare saturate</A>
<LI><A NAME="tex2html48"
  HREF="#SECTION000103000000000000000">Performanþã ºi limitãri</A>
</UL>
<BR>
<LI><A NAME="tex2html49"
  HREF="#SECTION000110000000000000000">Predicþie dinamicã cu predictori globali</A>
<LI><A NAME="tex2html50"
  HREF="#SECTION000120000000000000000">Predictori micºti</A>
<LI><A NAME="tex2html51"
  HREF="#SECTION000130000000000000000">O clasã generalã de predictori: ``value prediction''</A>
<LI><A NAME="tex2html52"
  HREF="#SECTION000140000000000000000">Soluþii ale compilatorului</A>
<LI><A NAME="tex2html53"
  HREF="#SECTION000150000000000000000">Concluzii</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Textul de faþã se constituie într-un al patrulea articol din seria
``Arhitectura modernã a calculatoarelor''.  Deºi fac tot ce îmi stã în
putinþã în a face fiecare articol independent de celelalte, ar fi o
risipã dacã nu aº refolosi unele dintre informaþii; din cauza asta
trimit cititorul doritor de a lãmuri mai multe aspecte la articole
precedente; cel mai folositor este cel intitulat ``<a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#pipe">Despre
conducte</a>'', publicat în PC Report din decembrie 1998.  Pentru cei
care nu au revista, dar au acces la Internet, textul este disponibil
din pagina mea de web.

<P>

<H1><A NAME="SECTION00020000000000000000">
Maºini pipeline, superscalare ºi dependenþe</A>
</H1>

<P>
Procesoarele moderne sporesc performanþa printr-o multitudine de
mijloace; de cãpetenie este exploatarea <EM>paralelismului</EM> din
programe.  Spunem cã un program posedã paralelism dacã pãrþi
diferite din program pot fi executate simultan fãrã a schimba
rezultatele finale.

<P>
Am ilustrat în texte anterioare cum procesoarele moderne exploateazã
paralelismul prezent între instrucþiuni consecutive dintr-un program,
paralelism numit ``la nivel de instrucþiune'' (Instruction Level
Parallelism, ILP).  Douã sunt mijloacele de cãpetenie folosite
pentru acest scop: tehnologia de pipeline, ºi tehnologia
superscalarã.  Voi reaminti pe scurt în ce constau acestea, ºi care
sunt piedicile care stau în calea exploatãrii lor.

<P>
Restul articolului va arãta cum piedicile mai sus-numite includ o
piedicã foarte importantã cantitativ: chiar instrucþiunile de salt
dintr-un program.  Restul articolului va arãta care sunt metodele
tehnologice folosite pentru a reduce impactul negativ al salturilor.

<P>
Paralelismul superscalar este relativ uºor de înþeles: dacã un
procesor obiºnuit are cîte o bucatã din fiecare unitate
funcþionalã, un procesor superscalar are mai multe astfel de copii.
Astfel, un procesor superscalar poate efectua simultan douã adunãri,
pentru ca posedã douã unitãþi aritmetice.  De asemenea, el poate
de obicei lansa în execuþie mai multe instrucþiuni, pentru cã are
mai multe unitãþi care decodificã instrucþiunile, etc.
Paralelismul superscalar este întîlnit peste tot: atunci cînd o
pompã de benzinã angajeazã mai mulþi lucrãtori pentru a manipula
pompele, exploateazã paralelismul în acelaºi fel ca un procesor
superscalar.

<P>
Pe de altã parte, paralelismul pipeline este inspirat dupã banda de
asamblare de la fabricile de maºini (ºi nu numai): un lucrãtor face
ºasiul, altul pune uºile, un al treilea parbrizul; toþi aceºti
lucrãtori manipuleazã simultan maºini diferite; o maºinã trece
succesiv pe la fiecare din ei, ºi în timp ce prima maºinã, cu
uºile deja puse, are parbrizul în curs de montare, o a doua tocmai
îºi primeºte portierele.

<P>
Toate procesoarele moderne de performanþã folosesc ambele tehnici
simultan.

<P>
Din pãcate, în lumea calculatoarelor, lucrurile nu sunt aºa de
simple ca într-o fabricã.  Asta se întîmplã pentru cã
paralelismul se poate aplica numai dacã obiectele asupra cãrora se
opereazã sunt independente.  Dar instrucþiunile unui program depind
adesea una de alta; în definitiv un program nu este decît un ºir de
prelucrãri asupra aceloraºi date.  De exemplu, dacã avem douã
instrucþiuni consecutive: <TT>a=b+c; d=d-a</TT>, a doua evident nu poate
fi executatã pînã cînd prima nu s-a terminat, pentru cã are
nevoie de valoarea lui <TT>a</TT> calculatã de prima.  Spunem cã între
aceste instrucþiuni avem o <EM>dependenþã</EM>.

<P>
Cînd un procesor întîlneºte cod ca cel de mai sus, nu are mare
lucru de fãcut: va trebui ca unii dintre lucrãtori sã stea
nefolosiþi o vreme, pentru cã nu au nimic de fãcut.

<P>

<H1><A NAME="SECTION00030000000000000000">
Mãsurãtorile SPEC (benchmarks)</A>
</H1>

<P>
Trebuie sã realizãm cã, decizia dacã astfel de situaþii sunt sau
nu importante, depinde enorm de <EM>frecvenþa</EM> lor.  Dacã astfel de
cazuri apar extrem de rar, atunci optimizãrile fãcute pentru a le
preveni nu vor avea un impact prea mare, pentru ca nu e mare lucru de
cîºtigat.  Dimpotrivã, dacã astfel dependenþele sunt dese,
impactul lor asupra performanþei este major.

<P>
Bine, dar dese unde?  În care program?  Nici mãcar în interiorul
aceluiaºi program nu avem întotdeauna o densitate constantã de
dependenþe.  Ce trebuie sã mãsurãm?  Atunci cînd un proiectant
construieºte un nou procesor, trebuie sã aibã oarecare metode
pentru a-l evalua.

<P>
Ei bine, experþi din industrie au pus la punct niºte suite de
mãsurãtori (<EM>benchmarks</EM>) pentru a evalua performanþa
sistemelor de calcul.  Cele mai faimoase, ºi probabil ºi cele mai
criticate, sunt cele numite SPEC, de la Standard Performance
Evaluation Corporation.  Puteþi gãsi amãnunte despre acestea la
<TT><A NAME="tex2html3"
  HREF="http://www.specbench.org/">http://www.specbench.org/</A></TT>.  Scopul acestui articol este însã
altul, aºa cã nu voi divaga prea mult despre acest interesant
subiect.  Important este de reþinut cã afirmaþiile cu caracter
cantitativ din acest articol, care nu este clar cui se aplicã, sunt
fãcute în contextul acestor suite de mãsurãtori.

<P>
De exemplu, principalul personaj al acestui articol, salturile, apar
în medie la fiecare ºapte instrucþiuni într-un program din suita
SPEC.  Dacã numãrul era 1 la 100, situaþia era complet diferitã.
Proporþia este însã mai mult decît semnificativã, ºi de aceea
articolul de faþã existã (are un subiect).

<P>

<H1><A NAME="SECTION00040000000000000000">
Costul unui salt</A>
</H1>

<P>
Înainte de a vedea de ce sunt salturile o problemã, vom nota cã
problema se manifestã în faptul cã execuþia unei instrucþiuni de
salt dureazã mai mult decît a unei instrucþiuni obiºnuite, cel
puþin în cazul în care nu aplicãm nici una dintre tehnologiile
descrise mai jos.  Un exemplu tipic este ca o instrucþiune
aritmeticã sã se execute într-un ciclu de ceas, iar un salt sã
dureze 3.  Cît de importantã este contribuþia salturilor în
performanþa programului?  Cu alte cuvinte, cu cît mai încet merge
programul decît în cazul în care fiecare salt ar dura ºi el exact
un ciclu?

<P>
Un pic de aritmeticã rãspunde la aceastã întrebare: raportul este
7/(6 + 1*3), din cauzã cã 7 instrucþiuni ne costa 6+3 cicli în
loc de 7; asta înseamnã 7/9, sau o performanþã de 77%.  Am
pierdut deci un sfert din performanþã.  

<P>
Am mai menþionat ºi cu alte ocazii cã arhitecþii calculatoarelor
din ziua de azi sunt gata de orice pentru o creºtere de 10% a
performanþei, iar multe articole publicate se mulþumesc cu chiar mai
puþin de atît.  În acest context 23 de procente este o cantitate
uriaºã, care categoric meritã diminuatã.

<P>
Chiar dacã ne-am mulþumi cu aceste pierderi, nu am fi liniºtiþi
pentru multã vreme: pe mãsurã ce conductele procesoarelor devin din
ce în ce mai lungi, ºi superscalarele pun la bãtaie din ce în ce
mai multe unitãþi funcþionale, penalizarea unui salt creºte din ce
în ce mai mult.  Asta nu pentru cã durata unui salt creºte
neapãrat, ci pentru cã mai mulþi lucrãtori stau degeaba; un
superscalar cu douã unitãþi funcþionale, în mod ideal ar putea
termina <EM>douã</EM> instrucþiuni în fiecare ceas.  Atunci prezentã
salturilor ar duce la o performanþã de 3.5/(3+1*3) = 3.5/6 (3 cicli
pentru ºase instrucþiuni ºi 3 pentru salt, în loc de 3.5 în
total), sau 58%.  Ori procesoarele moderne au uneori chiar mai multe
resurse paralele decît atît; nu e pãcat ca jumãtate din timp sã
fie irosit?

<P>

<H1><A NAME="SECTION00050000000000000000">
Dependenþe ale controlului</A>
</H1>

<P>
De ce sunt salturile scumpe?  Nu e prea greu de înþeles:
instrucþiunile unui program se executã în mod normal în ordine
crescãtoare a adreselor: 0, 1, 2, 3, etc.  Salturile însã perturbã
aceastã ordine, indicînd noi adrese de unde programul trebuie
executat.  

<P>
Dar cum funcþioneazã un procesor care exploateazã paralelismul?
Extrage mai multe instrucþiuni consecutive ºi încearcã sã le
execute în paralel, în cazul cã nu au dependenþe.  Ori saltul
indicã faptul cã acele instrucþiuni nici nu trebuie executate!

<P>
Salturile sunt categorisite drept tot dependenþe de un tip special:
<EM>dependenþe ale controlului</EM> (control dependencies).  Se numesc
astfel pentru cã în terminologia limbajelor de programare tot ce nu
calculeazã se numeºte control; instrucþiunile care indicã
direcþia de execuþie sunt instrucþiuni de control.

<P>

<H2><A NAME="SECTION00051000000000000000">
Dependenþe ale controlului într-un pipeline</A>
</H2>

<P>
Voi ilustra importanþa dependenþelor controlului pentru un procesor
pipeline; pentru o explicaþie mai amplã despre cum se poate citi o
schemã ca cea de mai jos vedeþi articolul recomandat în
introducere.

<P>
Voi presupune ca procesorul nostru are o conductã formatã din
urmãtoarele stagii: un stagiu de citire a instrucþiunii, care o
aduce din cache, unul de decodificare, care determinã ce face
instrucþiunea ºi aduce operanzii de care are nevoie, stagiul
principal, de execuþie, în care operaþia indicatã este efectuatã
asupra datelor, urmat de stagiul de scriere, în care datele calculate
sunt puse la locul dorit.  Þeava poate conþine ºi alte stagii, dar
deocamdatã doar acestea ne intereseazã.

<P>
Problema saltului (figura&nbsp;<A HREF="predictie-html.html#salt">1</A>) este urmãtoarea: adresa unde se
face saltul ºi condiþia de care saltul depinde sunt calculate doar
în stagiul de execuþie, ºi pot fi folosite doar în stagiul de
scriere.  Dar în momentul cînd instrucþiunea de salt a ajuns în
acest stagiu, în mod normal instrucþiunile de dupã ea au intrat
deja în þeavã.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="salt"></A><A NAME="179"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
Evoluþia instrucþiunilor într-un pipeline în
cazul apariþiei unui salt.  Abia cînd saltul a ajuns în stagiul de
execuþie (la momentul 2 de timp) ºtim care ar trebui sã fie
instrucþiunea urmãtoare.  Dacã saltul trebuie luat, atunci
instrucþiunile din stagiile celelalte nu trebuiau sã fie executate
(marcate haºurat).</CAPTION>
<TR><TD><IMG
 WIDTH="534" HEIGHT="316" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{salt.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Problema este cã salturile condiþionale pot avea douã destinaþii
posibile; oricum am ghici în absenþa rezultatului final, în orice
parte am lua-o, putem greºi.  Ori nu vrem în nici un caz ca
procesorul sã execute instrucþiuni pe care programul nu le indicã!

<P>
Procesoarele oferã de obicei douã tipuri de salturi: condiþionale
ºi necondiþionale.  Marea majoritate a salturilor sunt
condiþionale.  Putem apoi categorisi salturile în salturi la adrese
fixã (dominante ca numãr), salturi la o adresã calculatã (relativ
puþine, sintetizate pentru instrucþiunile de tip <TT>switch-case</TT>
din C/Pascal) ºi instrucþiunile de întoarcere de la un apel de
subrutinã.  Fiecare dintre aceste tipuri de instrucþiune de salt
necesitã alte tehnici pentru a fi optimizatã; în acest text vom
insista asupra instrucþiunilor de salt condiþionat.

<P>

<H1><A NAME="SECTION00060000000000000000">
Soluþia blocantã</A>
</H1>

<P>
Cum facem pentru a trata instrucþiunile de dupã un salt?  Cea mai
simplã ºi mai costisitoare soluþie constã în a detecta
instrucþiunile de salt cît se poate de devreme (în stagiul de
citire, dacã se poate) ºi de a bloca restul þevii din execuþie
pînã cînd adresa ºi condiþia saltului sunt cunoscute.
Terminologia tehnicã pentru blocare este <EM>stall</EM>.  Cel mai simplu
mod de a face stall este de a injecta în mod artificial în þeavã o
instrucþiune care nu face nimic, numitã ``noop'' (``no operation'')
ºi de a continua execuþia cu aceasta.  Aceastã instrucþiune
fictivã se mai numeºte ºi ``bulã'' (bubble).  Figura&nbsp;<A HREF="predictie-html.html#bula">2</A>
ilustreazã acest procedeu.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="bula"></A><A NAME="186"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
Metoda cea mai simplã este de a nu încãrca
nimic în þeavã pînã cînd nu ºtim exact care este instrucþiunea
urmãtoare; þeava o sã prelucreze atunci numai ``bule''.</CAPTION>
<TR><TD><IMG
 WIDTH="540" HEIGHT="279" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{bula.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Din pãcate aceastã soluþie asigurã doar corectitudinea
programului, ºi nu ºi eficienþa sa.  Dacã procedãm astfel plãtim
toate costurile descrise mai sus.  Ar fi grozav dacã am avea o
soluþie mai eficientã.  Aparent nu avem nimic de fãcut, dacã nu
facem o simplã observaþie.

<P>

<H1><A NAME="SECTION00070000000000000000">
Execuþia speculativã</A>
</H1>

<P>
Observaþia de care avem nevoie este cã o instrucþiune, pentru a
avea efecte permanente ºi vizibile, trebuie neapãrat sã-ºi scrie
rezultatele undeva: fie într-un registru, fie în memorie.  Asta
înseamnã cã atîta timp cît instrucþiunea nu a ajuns în stagiul
de scriere ea nu este nicidecum vizibilã dinafarã.  Perfect: atunci
putem face urmãtorul lucru: putem încãrca în þeavã ºi alte
instrucþiuni de dupã cea de salt ºi le lãsãm sã se execute.
Cînd ajungem cu saltul în stagiul de execuþie ºtim deja dacã
celelalte instrucþiuni trebuiau sau nu sã fie executate; dacã
observãm cã am ales bine, suntem oameni fãcuþi, pentru cã saltul
nu ne costã decît un ciclu, succesorii lui fiind deja gata de
execuþie.  Altfel recurgem la o soluþie asemãnãtoare cu cea de mai
sus: ºtergem conþinutul din începutul þevii, introducînd mai
multe bule.  

<P>
Acest tip de execuþie în care mizãm pe anumite instrucþiuni de a
fi utile, ºi în care dacã ne dãm seama cã am greºit renunþãm
la ele, se numeºte <EM>execuþie speculativã</EM> (speculation).
Aceastã tehnicã este din ce în ce mai folositã în procesoarele
moderne.

<P>
Observaþi cã în acest caz nu avem nimic de pierdut: performanþa
poate doar creºte, pentru cã instrucþiunile pentru care am ghicit
bine vor fi mai scurte, iar celelalte vor dura tot atît.

<P>
Un procesor superscalar poate face ºi mai multã speculaþie: poate
porni în execuþie ambele destinaþii ale ramurii (presupunînd cã
adresa destinaþie poate fi calculatã rapid, înainte de a ajunge în
stagiul de execuþie), dupã care poate alege sã pãstreze numai
destinaþia realã.

<P>

<H1><A NAME="SECTION00080000000000000000">
Diferite scheme statice de predicþie</A>
</H1>

<P>
Întrebarea la care nu am rãspuns este: ``cum ghicim dacã saltul
este luat sau nu?''  Ei bine, existã o sumedenie de scheme pentru a
face acest lucru, din ce în ce mai complicate, dintre care unele le
vom explora în continuarea acestui text.  Sã începem însã cu cele
mai evidente, care iau mereu aceeaºi decizie (ºi de aceea le voi
numi ``statice'').

<P>

<H2><A NAME="SECTION00081000000000000000">
Salt niciodatã luat</A>
</H2>

<P>
Cea mai simplã schemã este sã presupunem cã saltul nu este
niciodatã luat, ºi sã continuãm sã executãm instrucþiunile în
continuare.  Schema aceasta are meritul de a fi extrem de simplu de
implementat.  Performanþa ei este de cam 40% (adic'a pentru 40% din
salturi presupunerea se dovedeºte corectã).  (Exerciþiu: calculaþi
care este performanþa procesorului în acest caz; presupuneþi cã
toate instrucþiunile înafarã de salt dureazã un ciclu, 40% din
salturi dureazã tot un ciclu, iar restul salturilor dureazã 3.)

<P>
Un scurt raþionament ne va ºi explica de ce schema aceasta nu are
nici un fel de ºanse sã fie mai eficace de atît.  Cea mai mare
parte a timpului unui program se petrece în cicluri (dacã un program
nu ar avea cicluri, execuþia lui s-ar termina imediat, pentru cã
viteza procesorului este de ordinul a sute de milioane de
instrucþiuni pe secundã).  Ori un ciclu <EM>trebuie</EM> sã conþinã
cel puþin o instrucþiune de salt care este luat în mod frecvent.
Pentru acest salt, metoda de mai sus va ghici mereu eronat.

<P>

<H2><A NAME="SECTION00082000000000000000">
Salt mereu luat</A>
</H2>

<P>
Cînd designerii au realizat acest lucru, s-au gîndit sã schimbe
ghicitul în sens exact opus: vor prezice cã instrucþiunile de salt
sunt toate luate.  Calculul adresei destinaþie în general nu este o
problemã, pentru cã, aºa cum am vãzut mai sus, majoritatea
salturilor se efectueazã la adrese constante, care fac parte din
chiar codul instrucþiunii.  În mod natural, corectitudinea unei
astfel de scheme este de cam 60%.

<P>

<H2><A NAME="SECTION00083000000000000000">
Salt înapoi luat</A>
</H2>

<P>
Un alt rafinament al schemei este a observa cã orice buclã trebuie
sã aibã cel puþin un salt înapoi care este luat.  Mãsurãtori pe
SPEC au arãtat cã o schemã care prezice cã orice salt înainte nu
e luat ºi orice salt înapoi este are performanþe mai bune decît
schema precedentã.

<P>
Figura&nbsp;<A HREF="predictie-html.html#performanta">6</A> aratã acurateþea ghicirii pentru diferite
scheme de salt.  Deocamdatã puteþi citi primele trei coloane; despre
urmãtoarele vom discuta în continuare.

<P>
Trebuie sã observãm cã, orice schemã de predicþie vom implementa,
ea trebuie sã fie foarte simplã ºi rapidã.  Nu ne putem permite
sã executãm un algoritm complicat de zeci de instrucþiuni pentru a
economisi doi cicli de ceas!  Mai mult, soluþiile trebuie sã fie
toate implementabile în hardware, ceea ce este o constrîngere destul
de severã.  Vom vedea însã cã imaginaþia cercetãtorilor
depãºeºte toate aceste obstacole, creind scheme foarte ingenioase.

<P>

<H1><A NAME="SECTION00090000000000000000">
Predicþie dinamicã cu cache-ul de instrucþiuni</A>
</H1>

<P>
O metodã foarte interesantã de a face predicþia este de a memora
în cache-ul de instrucþiuni vechea comportare a unui salt: atît
condiþia sa cît ºi adresa de destinaþie.  S-a observat, tot prin
mãsurãtori, cã foarte adesea salturile tind sã se facã în
aceeaºi direcþie ºi în acelaºi loc de mai multe ori consecutiv.
Aceastã schemã este folositã de microprocesorul PPC604.

<P>
Rafinamente ale acestei scheme au dus la crearea unui mijloc modern de
anticipare a destinaþiei, numit ``trace cache'' (cache-urmã).
Aceasta este o invenþie relativ recentã (la ora actualã nu ºtiu de
nici un procesor care sã o foloseascã, dar este sigur cã în
curînd va fi o prezenþã comunã în fiecare calculator), care
practic rescrie programul în mod dinamic în cache, punînd
instrucþiunile care tind sã fie executate în succesiune una dupã
alta.  De pildã, dacã un salt este mereu luat, trace-cache-ul va
pune instrucþiunile de dinaintea saltului ºi cele de dupã una dupã
alta, ºi va schimba apoi condiþia saltului în cea opusã; schema
aceasta permite de asemenea procesoarelor un acces mult mai eficace la
cache.  Sper sã revin cu mai multe amãnunte asupra acestei
interesante tehnologii în alte articole.

<P>

<H1><A NAME="SECTION000100000000000000000">
Predicþie dinamicã cu predictori locali</A>
</H1>

<P>
Soluþia cu cache-ul (nu cache-ul urmã, ci cea care menþine
informaþiile despre salt) este destul de ingenioasã, dar este cam
costisitoare ºi destul de complicatã din punct de vedere hardware;
cere extragerea mai multor date din cache decît normal ºi aparaturã
mai complicatã de decodificare.

<P>
Putem simplifica schema menþinînd o tabelã separatã în interiorul
procesorului, ºi nu în cache.

<P>

<H2><A NAME="SECTION000101000000000000000">
Predictorul cu un bit</A>
</H2>

<P>
Schema aceasta este extrem de interesantã, pentru cã aparent face un
compromis destul de mare: amestecã laolaltã informaþia despre toate
salturile din program într-o tabelã unicã.  Algoritmul este urmãtorul:

<P>

<OL>
<LI>Cînd întîlnim o instrucþiune de salt notãm adresa sa proprie;

<P>
</LI>
<LI>Apoi aplicãm asupra acestei adrese o funcþie de hash simplã
care transformã adresa într-un domeniu limitat (de exemplu între
0 ºi 1023).  Un exemplu foarte simplu de funcþie de hash este de a
pãstra numai ultimii biþi din adresã (de pildã ultimii
10)<A NAME="tex2html6"
  HREF="#foot93"><SUP>1</SUP></A>.

<P>
</LI>
<LI>Cu aceºti biþi indexãm într-o tabelã de 1024 de linii.  La
linia respectivã gãsim un bit.  Folosim acest bit pentru a prezice
condiþia saltului.  Speculãm executînd instrucþiunile de la
destinaþia aparentã.

<P>
</LI>
<LI>Dupã ce condiþia realã este cunoscutã, marcãm în tabelã
informaþia despre valoarea realã a condiþiei.
</LI>
</OL>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="1bit"></A><A NAME="192"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3:</STRONG>
Predictorul cu un bit conþine o tabelã de
predictori cu contoare saturate în care se indexeazã cu o valoare
care depinde de adresa instrucþiunii de salt.</CAPTION>
<TR><TD><IMG
 WIDTH="537" HEIGHT="294" BORDER="0"
 SRC="img4.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{1bit.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Metoda este extrem de ieftinã de implementat ºi foarte rapidã.
Figura&nbsp;<A HREF="predictie-html.html#1bit">3</A> aratã cum este construitã în hardware.  Ne poate
face însã sã ne simþim nesiguri: funcþia de hash poate amesteca
salturi independente.  Este adevãrat, pentru exemplul de mai sus,
dacã avem douã salturi în program ale cãror adrese se terminã în
aceiaºi 10 biþi, atunci informaþia despre condiþia ambelor va fi
stocatã în acelaºi loc în tabel.

<P>
ªi atunci cum putem avea încredere?  Ei bine, dacã puneþi aceastã
întrebare înseamnã cã aþi uitat de fapt cã tot ceea ce facem
este doar o ghicealã; nimic nu este sigur aici.  Execuþia
speculativã ne asigurã cã nu putem strica nimic ghicind greºit.
Singura care poate avea de suferit este performanþa.  Dar
performanþa depinde de procentul de erori.  Ori avem douã fenomene
care ne vin în ajutor pentru a face schema de mai sus foarte
rezonabilã:

<P>

<UL>
<LI>Probabilitatea ca douã salturi care se executã frecvent ºi
întreþesut sã aibã adresele în acest fel este minimã;

<P>
</LI>
<LI>În general programele manifestã ``localitate spaþialã'';
asta înseamnã cã la momente de timp apropiate se vor executa
instrucþiuni de la adrese apropiate (aceasta este observaþia
crucialã care permite procesoarelor sã foloseascã cu atît de
mult succes cache-uri).  Ei bine, asta înseamnã cã este foarte
puþin probabil ca douã salturi aflate la distanþã atît de mare
unul de altul sã se execute succesiv.
</LI>
</UL>

<P>

<H2><A NAME="SECTION000102000000000000000">
Predictori cu contoare saturate</A>
</H2>

<P>
Predicþia cu 1 bit de ``istorie'' este bunicicã, dar suferã de un
simptom: este prea sensibilã la mici perturbaþii.  Sã presupunem
cã avem un salt care este mai întotdeauna luat, ºi numai în mod
excepþional nu este.  Ei bine, iatã cum se va comporta predictorul:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Salt</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">N</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">N</TD>
<TD ALIGN="LEFT">D</TD>
</TR>
<TR><TD ALIGN="LEFT">Predicþie</TD>
<TD ALIGN="LEFT">-</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">N</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">N</TD>
</TR>
<TR><TD ALIGN="LEFT">Corect</TD>
<TD ALIGN="LEFT">-</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">N</TD>
<TD ALIGN="LEFT">N</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">D</TD>
<TD ALIGN="LEFT">N</TD>
<TD ALIGN="LEFT">N</TD>
</TR>
</TABLE>
</DIV>

<P>
Aþi vãzut slãbiciunea?  Ei bine, la fiecare ``Nu'' predictorul va
ghici prost, dupã care va schimba pe ``Nu'', deci va ghici din nou
prost ºi data viitoare.  La fiecare schimbare facem douã erori.  În
plus, pentru un salt care alterneazã la fiecare execuþie
luat/ne-luat, acest predictor va greºi tot timpul (mai rãu chiar
decît schemele de predicþie staticã).  Aparent acest gen de salturi
este relativ frecvent, aºa cã meritã sã facem un efort sã
îmbunãtãþim cumva metoda.

<P>
Soluþia este din nou la îndemînã: în loc de un bit vom folosi mai
mulþi!  Vom implementa pentru fiecare rînd din tabelã un mic
automat finit, care va avea patru stãri, ca în figura&nbsp;<A HREF="predictie-html.html#finit">4</A>.
Stãrile sunt: ``Sigur Nu'', ``Poate Nu'', ``Poate Da'', ``Sigur Da''.
Automatul va face tranziþii spre dreapta la fiecare salt luat, ºi
spre stînga la fiecare salt ne-luat.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="finit"></A><A NAME="198"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 4:</STRONG>
Automatul finit cu 4 stãri pentru predicþia
salturilor.  Cele douã stãri din stînga vor prezice ``Luat'', iar
cele douã din dreapta ``Ne-luat''.  Fiecare arc este etichetat cu
acþiunea curenta; de exemplu, dacã automatul este în starea ``Poate
Da'' ºi acþiunea programului este de a nu sãri (N), automatul
tranziþioneazã în starea ``Poate Nu''.</CAPTION>
<TR><TD><IMG
 WIDTH="450" HEIGHT="100" BORDER="0"
 SRC="img5.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{finit.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Este un exerciþiu simplu de a vedea cã acest automat se va comporta
mult mai bine pentru exemplul de mai sus (va face, desigur, erori, dar
mult mai puþine).  Implementarea în hardware este de asemenea
banalã: foloseºte ceea ce se numeºte un <EM>contor saturat</EM>
(saturated counter).  Acest contor este ca unul obiºnuit, care
numãrã în sus la fiecare salt luat ºi în jos la fiecare ne-luat,
dar care nu trece niciodatã mai jos de 0 sau mai sus de 3.
``Ghiceala'' va corespunde celui mai semnificativ bit: dacã e 0,
atunci nu sãrim, dacã e 1 sãrim.

<P>
Nu e deloc clar cã putem creºte calitatea predictorului folosind mai
mulþi biþi pentru contoarele saturate, pentru cã atunci predictorii
atunci vor fi prea insensibili la schimbãri.

<P>

<H2><A NAME="SECTION000103000000000000000">
Performanþã ºi limitãri</A>
</H2>

<P>
Sigur, nici schema asta nu e impecabilã: existã pentru fiecare
schemã o succesiune de salturi care o poate facã sã greºeascã la
fiecare pas.  Cu toate acestea, majoritatea procesoarelor din
generaþiile 1997-1998 foloseau aceastã schemã.

<P>
Este un exerciþiu interesant de a face ceea ce se numeºte ``reverse
engineering'': putem scrie un program simplu care sã testeze
comportarea predictorilor la salturi.  Iatã un exemplu prezentat la
cursul doctoral de arhitectura calculatoarelor, þinut de domnul
profesor Randal Bryant în toamna trecutã:

<P>
<PRE>
#define MARIME 1024
#define ABS(x) (((x) &lt; 0) ? (-x) : (x))

int vector[MARIME];
int raspuns;

static void 
bucla() 
{
        int i;
        unsigned suma = 0;
        int prod = 1;
        for (i=0; i &lt; MARIME; i++) {
                x = vector[i];
                unsigned ax = (unsigned)(ABS(x));
                suma += ax;
                prod *= x;
        }
        raspuns = suma + prod;
}
</PRE>

<P>
Instrucþiunea <TT>ABS</TT> se va traduce în ceva de genul:

<P>
<PRE>
  ax = x;
  if (x &gt; 0) goto corect;
  ax = -x;
corect:
</PRE>

<P>
care conþine un salt.

<P>
Pentru a studia comportarea fiecãrui predictor iniþializaþi
vectorul <TT>vector</TT> cu valori potrivite (pozitive sau negative,
dupã cum doriþi sã fie executat sau nu saltul), dupã care
executaþi în mod repetat bucla ºi mãsuraþi timpul de execuþie.
Am scris în trecut un articol lung în douã episoade despre cum se
pot face astfel de mãsurãtori, care include ºi codul necesar; îl
puteþi obþine din pagina mea de web.

<P>
Vã recomand sã iniþializaþi vectorul cu trei feluri de valori:
pozitive (pentru salt ne-luat), negative (pentru salt luat) ºi
aleatoare, în care valorile sunt generate la întîmplare.
Încercaþi tot felul de formule: toate pozitive, alternant + - +
- etc.), alternant dupa o secvenþã de iniþializare + + + + - + - +
etc.), aleator, etc.

<P>

<H1><A NAME="SECTION000110000000000000000">
Predicþie dinamicã cu predictori globali</A>
</H1>

<P>
Schemele de mai sus sunt simpatice, dar suferã de o boalã comunã:
fiecare foloseºte numai informaþie <EM>localã</EM>, despre un singur
salt.  Dar adesea salturile din program sunt corelate între ele:
dacã unul se executã, atunci ºi un altul se executã, etc.

<P>
O schemã deosebit de ingenioasã ºi eficace a fost propusã în 1993
de Yeh ºi Yale Patt (Yale Patt, profesor la Universitatea din
Michigan, este ºi unul dintre inventatorii cache-ului cu urmã
menþionat mai sus, ºi este una dintre figurile cele mai proeminente
din cercetarea contemporanã în arhitectura procesoarelor).

<P>
Schema aceasta þine minte rezultatele ultimelor X salturi (de exemplu
X=6) ºi în funcþie de acestea prezice rezultatul urmãtorului.
Schema este imediat implementabilã în hardware: ne trebuie doar un
``shift register'' în care introducem cîte un bit la fiecare nou
salt, ºi o tabelã de 2<sup>X</sup> înregistrãri în care þinem minte
rezultatul saltului urmãtor, sau un contor saturat
(figura&nbsp;<A HREF="predictie-html.html#global">5</A>).  Arhitectural este destul de asemãnãtoare cu
un predictor local; consumã cam aceeaºi cantitate de resurse hardware.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="global"></A><A NAME="206"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 5:</STRONG>
Predictorul global are un ``shift-register''
care menþine istoricul ultimelor salturi, ºi o tabelã de contoare
saturate care este indexatã cu valoarea registrului.  Performanþa
acestui predictor este excelentã pentru orice model determinist de
salturi, pentru cã învaþã corelaþiile între salturi vecine.</CAPTION>
<TR><TD><IMG
 WIDTH="536" HEIGHT="318" BORDER="0"
 SRC="img9.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{global.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Schema aceasta pare complet paradoxalã, pentru cã nici mãcar nu se
uitã <EM>care</EM> salturi sunt cele X, ci doar la rezultatele lor.  Ca
orice schemã de acest gen, valabilitatea ei poate fi doar verificatã
empiric; mãsurãtori pe testele SPEC aratã cã schema are o
comportare excelentã.

<P>

<H1><A NAME="SECTION000120000000000000000">
Predictori micºti</A>
</H1>

<P>
În fine, cel mai complicat predictor implementat în procesoarele
contemporane este cel din procesorul Alpha 20264 al firmei Compaq
(fost al lui Digital, acum achiziþionatã de Compaq).  Acest
predictor este de fapt o combinaþie a trei predictori:

<P>

<UL>
<LI>Un predictor local pe 3 biþi ceva mai complicat decît cel
descris aici;

<P>
</LI>
<LI>Un predictor global cu 12 biþi de istoric;

<P>
</LI>
<LI>Un al treilea predictor, care alege unul dintre ceilalþi doi
predictori (din pãcate nu existã prea multã informaþie
publicatã despre cum acest al treilea predictor este implementat;
am avut ocazia sã aflu cu ocazia unui seminar þinut de un
cercetãtor din grupul de hardware de la Digital, dar nu mi-am notat;
din cîte îmi amintesc acest al treilea predictor mãsura
performanþa celorlalte douã pentru fiecare salt ºi-l alegea pe
cel mai bun).
</LI>
</UL>

<P>
Performanþele tuturor predictorilor prezentaþi sunt condensate în
figura&nbsp;<A HREF="predictie-html.html#performanta">6</A>.  Dupã cum vedeþi, predictorul mixt este
excelent.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="performanta"></A><A NAME="212"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 6:</STRONG>
Performanþe ale feluritelor scheme de
predicþie.  Pe axa y este procentajul de ghiciri corecte.  Valorile
sunt mãsurate pentru SPECint92.  Etichetele sunt feluritele
procesoare.  Aceste date sunt extrase parþial din revista
Microprocessor Report, 17 Martie 1995.</CAPTION>
<TR><TD><IMG
 WIDTH="541" HEIGHT="327" BORDER="0"
 SRC="img10.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{performanta.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H1><A NAME="SECTION000130000000000000000">
O clasã generalã de predictori: ``value prediction''</A>
</H1>

<P>
Am vãzut cã execuþia speculativã deschide poarta unei serii
întregi de metode empirice de predicþie, unele foarte neverosimile.
Cercetãtorii contemporani însã împing ºi mai departe aceste
tehnici, pentru aplicarea lor ºi înafara domeniului salturilor.  De
exemplu, la ultima conferinþa internaþionalã de arhitectura
calculatoarelor ISCA (International Symposium on Computer
Architecture) nu mai puþin de 5 articole din 26 discutau forme
felurite de predicþie a valorii (<EM>value prediction</EM>).

<P>
Predicþia valorii este o generalizare a predicþiei salturilor.  Ea
poate de pildã fi aplicatã ºi pentru cazul instrucþiunilor de
întoarcere de la apelul unei proceduri, a cãror adresã de
întoarcere este extrasã de pe stiva din memorie.

<P>
În general, predicþia valorii se face de fiecare datã cînd ceva ia
mult timp pentru a fi obþinut: de pildã accesul la memorie dureazã
foarte mult (în cazul în care datele nu sunt cache), sau execuþia
anumitor operaþii aritmetice este foarte costisitoare, sau calculul
destinaþiei unui salt, etc.  Pentru astfel de cazuri este mai bine ca
procesorul sã ghiceascã rezultatul final decît sã stea degeaba
sã-l aºtepte pe cel corect; dacã a greºit nu-i bai: calculele pot
fi reluate de la punctul de unde a început speculaþia.

<P>
Mãsurãtorile experimentale au arãtat cã ºi scheme banale de
predicþie (de pildã: ``ultima valoare a acestui obiect'',
menþinutã într-un cache) oferã îmbunãtãþiri substanþiale.

<P>
Sper sã pot dedica un articol separat tehnicii de predicþie a
valorii, deºi strict vorbind, predicþia salturilor este doar un caz
special.  În procesoarele disponibile la momentul de faþã pe
piaþã însã, putem gãsi din plin implementate metode de predicþie
a salturilor, dar nu prea multe de predicþia valorilor.  Deci
subiectul acestui articol merita o oarecare atenþie individualã.

<P>

<H1><A NAME="SECTION000140000000000000000">
Soluþii ale compilatorului</A>
</H1>

<P>
Toate metodele prezentate se bazeazã pe soluþii hardware: procesorul
menþine informaþii suplimentare ºi are circuite în plus pe care le
foloseºte pentru a anticipa rezultatele unor acþiuni din viitor.  

<P>
Compilatorul, ca întotdeauna în epoca modernã a sistemelor de
calcul (cu precãdere în ultimii 20 de ani) are însã un cuvînt
important de spus pentru a ajuta procesorul sã-ºi sporeascã
performanþa.  Vom indica pe scurt cîteva lucruri pe care
compilatorul, cîteodatã în conjuncþie cu un suport specializat din
partea procesorului însuºi, le poate face pentru a scãdea impactul
costului salturilor:

<P>

<UL>
<LI>Compilatorul poate rearanja codul în aºa fel încît salturile
sã fie mai uºor ºi mai precis de prezis de cãtre hardware;
compilatorul poate oricînd schimba douã blocuri de cod între ele
ºi comuta sensul testului din instrucþiunea de salt;

<P>
</LI>
<LI>Compilatorul poate desfãºura buclele (<EM>unroll loops</EM>).
Astfel frecvenþa salturilor se reduce.  De exemplu bucla:

<P>
<PRE>
for (i=0; i &lt;10; i++) 
   a[i] = b[i] * c[i];
</PRE>

<P>
poate fi transformatã în:

<P>
<PRE>
for (i=0; i &lt; 10; i+=2) {
   a[i] = b[i] * c[i];
   a[i+1] = b[i+1] * c[i+1];
}
</PRE>

<P>
Avantajul acesteia este cã face de douã ori mai puþine comparaþii
cu 10, deci executã mai puþine salturi (metoda se poate generaliza
ºi pentru limite necunoscute sau impare);

<P>
</LI>
<LI>În anumite arhitecturi (ex. PPC 603) compilatorul poate insera
biþi în instrucþiuni prin care îi indicã procesorului cum ar
trebui sã se aºtepte ca un anumit salt sã fie executat;

<P>
</LI>
<LI>Arhitecturile moderne (de exemplu PowerPC604) oferã
instrucþiuni de <EM>încãrcare condiþionalã</EM>, care pot fi
folosite pentru a elimina anumite salturi.  De exemplu, secvenþa de
cod care calculeazã minimumul dintre douã numere:

<P>
<PRE>
c = (a &lt; b) ? a : b
</PRE>

<P>
era implementatã în procesoarele convenþionale în acest fel 
(dau echivalentul în C al codului din limbajul maºinã):

<P>
<PRE>
  d = a - b;
  c = a;
  if (d &gt; 0) goto corect;
  c = b;
corect:
</PRE>

<P>
Instrucþiunea de încãrcare condiþionalã zice ceva de genul
``încarcã o anumitã valoare numai dacã o condiþie este
adevãratã''.  Atunci traducerea ar arãta cam aºa:

<P>
<PRE>
  d = a - b;
  c = a;
  c = (d &gt; 0) ? b : c;   /* incarcare conditionala */
</PRE>

<P>
Observaþi cum saltul a dispãrut cu totul.

<P>
</LI>
<LI>Noua arhitecturã anunþatã de Intel, numitã IA64,
proiectatã împreunã cu Hewlett-Packard, ºi îmbrãþiºatã de
toþi marii fabricanþi de staþii de lucru (în afarã de Sun), al
cãrei prim reprezentant, Merced, este deja cu doi ani în
întîrziere, va conþine o generalizare a instrucþiunilor de
încãrcare condiþionalã.  Aceste instrucþiuni se vor numi
``instrucþiuni cu execuþie predicatã'' (<EM>predicated
execution</EM>).

<P>
Aceste instrucþiuni vor avea asociat un registru de un bit.  Dacã
bitul este 0 instrucþiunile sunt executate.  Dacã bitul este 1,
atunci instrucþiunile vor fi pur ºi simplu ignorate.  Tehnica
seamãnã cu execuþia speculativã, numai cã controlul este dat de
compilator, iar nu de procesor.

<P>
Aparent e o mare risipã: de ce sã execuþi instrucþiuni care nu le
vrei, nu ar fi mai ieftin sã sari peste bucata asta de cod?  Aºa cum
am vãzut, cu cît procesorul este mai paralel (are mai multe stagii
în þeavã sau mai multe unitãþi funcþionale), cu atît costul
unui salt (sau a oricãrei instrucþiuni care se lasã aºteptatã de
cele care depind de ea) este mai mare.  Dacã un salt te costã cît
20 de instrucþiuni, atunci e clar mai bine sã execuþi 10
instrucþiuni inutile decît sã sari peste ele.  De exemplu, dacã notãm cu 

<P>
<PRE>
c# instructiune
</PRE>

<P>
pentru a indica faptul cã <TT>instructiune</TT> este predicatã cu bitul
<TT>c</TT> (adicã se executã numai dacã bitul respectiv este 1),
atunci urmãtorul fragment de cod:

<P>
<PRE>
if (ceva) {
   bla;
   bla;
   bla;
} else {
   tranca;
   tranca;
   tranca;
}
</PRE>

<P>
se va traduce ca:

<P>
<PRE>
   c = (ceva == 0);
   d = !c;
c# bla
c# bla
c# bla
d# tranca
d# tranca
d# tranca
</PRE>
</LI>
</UL>

<P>

<H1><A NAME="SECTION000150000000000000000">
Concluzii</A>
</H1>

<P>
ªtim din articole anterioare cã designerii sporesc performanþa
microprocesoarelor exploatînd paralelismul instrucþiunilor.  Dar mai
ºtim ºi cã unele instrucþiuni nu se pot executa în paralel,
pentru cã sunt dependente una de alta.  Am vãzut în acest articol
cã instrucþiunile de salt implicã astfel de dependenþe, pentru cã
ele indicã de fapt <EM>care</EM> este instrucþiunea urmãtoare de
executat.  

<P>
Faptul cã instrucþiunile de salt sunt extrem de frecvente pe
arhitecturile contemporane (un rezultat al operaþiilor primitive
oferite de procesoare ºi al modului în care compilatoarele
genereazã cod) este extrem de neplãcut, pentru cã împiedicã
exploatarea tuturor resurselor de calcul.  

<P>
Arhitecþii au gãsit o multitudine de soluþii: unele dintre ele
schimbã setul de instrucîuni al procesorului, permiþînd scrierea
de cod cu mai puþine salturi.  Altele se bazeazã pe soluþii
exclusiv hardware, în care procesorul încearcã sã anticipeze
direcþia ºi destinaþia salturilor, ºi sã execute în mod
speculativ de acolo programul, în speranþa cã, dacã a ghicit
corect, va cîºtiga ceva timp.

<P>
Am vãzut tot felul de scheme de predicþie, unele foarte stranii ºi
neintuitive, dar am mai vãzut cã ultimul cuvînt în estimarea
calitãþii unei scheme îl are performanþa ei pe programe reale (de
obicei însã acestea sunt substituite cu teste speciale gen SPEC).

<P>
Înainte de a încheia trebuie sã vã spun cã de fapt bogãþia de
scheme de predicþie este mult mai mare, ºi acest text nu se ocupã
decît de cele mai tradiþionale.  Dacã subiectul vã intereseazã,
faceþi un salt spre web ºi cãutaþi mai multã informaþie.  Eu
deja pot sã prezic unde veþi ``ateriza'': la altavista sau o altã
maºinã de cãutare înruditã.  Se vede cã am învãþat ceva de la
hardware...

<P>
<BR><HR><H4>Note</H4>
<DL>
<DT><A NAME="foot93">...
10)</A><A NAME="foot93"
 HREF="predictie-html.html#tex2html6"><SUP>1</SUP></A>
<DD>În procesoarele moderne cu instrucþiuni de 32 de biþi
toate adresele la care se poate sãri se terminã în ``00'' în baza
doi, deci ar fi mai înþelept sã pãstrãm biþii 2-11 în loc de
0-10.

</DL>
<BR><HR>

</BODY>
</HTML>
