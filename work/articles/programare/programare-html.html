<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Cum se programeazã -- un set de reguli pentru scrierea
eficientã de programe -- </TITLE>
<META NAME="description" CONTENT="Cum se programeazã -- un set de reguli pentru scrierea
eficientã de programe -- ">
<META NAME="keywords" CONTENT="programare-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Cum se programeazã 
<BR>-- un set de reguli pentru scrierea
eficientã de programe -- </H1>
<P ALIGN="CENTER"><STRONG>Mihai BUDIU - mihaib@pub.ro</STRONG></P>
<P ALIGN="CENTER"><STRONG>februarie 1996</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>reguli pentru scrierea programelor.
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>comentariu, indentare, modul, variabilã, procedurã.
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cel puþin un limbaj de programare.
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html12"
  HREF="programare-html.html">Introducere</A>
<LI><A NAME="tex2html13"
  HREF="#SECTION00030000000000000000">Regula de aur</A>
<LI><A NAME="tex2html14"
  HREF="#SECTION00040000000000000000">Împãrþirea programului</A>
<LI><A NAME="tex2html15"
  HREF="#SECTION00050000000000000000">Minima vizibilitate</A>
<LI><A NAME="tex2html16"
  HREF="#SECTION00060000000000000000">Spaþiile albe; i(n)dentarea</A>
<LI><A NAME="tex2html17"
  HREF="#SECTION00070000000000000000">Comentariile</A>
<LI><A NAME="tex2html18"
  HREF="#SECTION00080000000000000000">Variabilele, constantele, funcþiile, procedurile</A>
<LI><A NAME="tex2html19"
  HREF="#SECTION00090000000000000000">Fiabilitatea</A>
<LI><A NAME="tex2html20"
  HREF="#SECTION000100000000000000000">Documentaþia</A>
<LI><A NAME="tex2html21"
  HREF="#SECTION000110000000000000000">Portabilitatea</A>
</UL>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION00020000000000000000">
Introducere</A>
</H1>

<P>
Voi începe cu un citat:

<P>
<BLOCKQUOTE>
As soon as we started programming, we found to our surprise that it
wasn't as easy to get programs right as we had thought.  Debugging had
to be discovered.  I can remember the exact instant when I realized
that a large part of my life from then on was going to be spent in
finding mistakes in my own programs.
<BR>  -- Maurice Wilkes discovers debugging, 1949

</BLOCKQUOTE>

<P>
În traducere asta ar suna cam aºa:

<P>
<BLOCKQUOTE>
Imediat ce am început sã programãm am descoperit spre surprinderea
noastrã ca nu era aºa de uºor sã facem programe bune pe cît
crezusem.  Depanarea (debugging) trebuia sã fie inventatã.  Îmi pot
aminti cu precizie momentul exact cînd am realizat cã o mare parte
din viaþa mea de atunci încolo urma sã fie petrecutã în a gãsi
greºeli în propriile mele programe.

</BLOCKQUOTE>

<P>
De asemenea -- pentru contrast -- îmi place sã citez
urmãtorul fragment din manualul care însoþeºte programul MetaFont,
scris de marele informatician Donald Knuth:

<P>
<BLOCKQUOTE>
On January 4, 1986 the ``final'' bug in Metafont was discovered and
removed.  If an error still lurks in the code, Donald E. Knuth
promises to pay a finder's fee which doubles every year to the first
person who finds it.  Happy hunting.

</BLOCKQUOTE>

<P>
Adicã:

<P>
<BLOCKQUOTE>
Pe 4 ianuarie 1986 ``ultimul'' bug (defect) din Metafont a fost
descoperit ºi scos.  Dacã o eroare mai zace prin cod, Donald E. Knuth
promite sã plãteascã o sumã care se dubleazã în fiecare an celui
care o gãseºte.  Vînãtoare plãcutã.

</BLOCKQUOTE>

<P>
Cîþi dintre dumneavoastrã au reuºit sã scrie un program
mai lung de 2000 de linii sursã (într-un limbaj de nivel înalt)
care sã exhibe acelaºi îngrijorãtor simptom al perfecþiunii?

<P>
Cu riscul de a vã agasa voi mai cita un monstru sacru al
informaticii, de data asta însã din memorie.  Edsger Dijkstra spunea
în cuvîntarea sa fãcutã cu prilejul decernãrii premiului ``Turing''
al prestigioasei societãþi americane ACM (Association for Computing
Machinery), cuvîntare care dealtfel se numea ``The Humble Programmer''
(Programatorul Umil), cã un bun programator trebuie sã recunoascã
faptul cã sarcina ce ºi-a asumat-o îl depãºeºte cu mult
datoritã complexitãþii sale, ºi ca atare trebuie sã încerce cît
mai mult sã o reducã la bucãþi mai mici, cît mai uºor de
manevrat.

<P>
Deºi aparent legãturile dintre cele trei citate de mai sus
sunt cam ºubrede, sper cã textul care urmeazã va arãta cã de fapt
acestea sunt trei feþe ale aceluiaºi poliedru.

<P>
În rezolvarea unei probleme cu calculatorul se pot distinge
mai multe etape (chiar dacã ele nu sunt distincte temporal): analiza
problemei, elaborarea algoritmului, implementarea, documentarea,
testarea, etc.  Acest articol se ocupã de una singurã dintre ele,
care dealtfel este foarte puþin dependentã de problema care trebuie
rezolvatã: presupun cã ºtiu algoritmii, tot ce trebuie sã fac este
sã-i implementez într-un limbaj de programare oarecare.  Aparent
banalã, etapa aceasta se dovedeºte adesea foarte intricatã.  De
fapt acest lucru îl aratã ºi primul citat din introducere.  

<P>
Cele mai multe consideraþii care urmeazã sunt independente
de limbajul ales.

<P>

<H1><A NAME="SECTION00030000000000000000">
Regula de aur</A>
</H1>

<P>
<BLOCKQUOTE>
Un program trebuie sã fie scris în aºa fel încît sã poatã fi
citit de cãtre oricine.

</BLOCKQUOTE>

<P>
Programele sunt fãcute în aºa fel încît pãrþile sunt
strîns dependente.  Trebuie ca cele scrise într-un loc sã fie
folosite într-altul (ºi eventual refolosite).  Mintea unui om normal
nu poate reþine toate amãnuntele din textul unui program, de aceea
trebuie sã-i dãm un ajutor.

<P>
Sfatul acesta este clar obligatoriu cînd se dezvoltã soft
în echipã, pentru cã ceea ce scrie unul trebuie sã fie folosit de
altul.  Paradoxal este cã el este extrem de oportun chiar cînd
întreg procesul de scriere este fãcut de un singur programator.  Nu
vi s-a întîmplat niciodatã sã vã uitaþi la o funcþie scrisã
în urmã cu o lunã ºi sã vã miraþi cã aþi putut scrie aºa
ceva?  Sau sã vã întrebaþi ce face?  Acel ``oricine'' din sfat poate
fi deci un ``alter ego'' al dumneavoastrã.

<P>
Aparent scrierea îngrijitã a unui program consumã prea mult
timp.  

<P>
Pentru programe scurta acest lucru poate fi adevãrat.  Pentru
programe la care lucraþi mai mult de o sãptãmînã timpul cheltuit
cu o scriere îngrijitã este recuperat înzecit în fazele ulterioare
ale dezvoltãrii (depanare, extindere, întreþinere).  Dacã nu
credeþi, încercaþi mãcar o datã.

<P>

<H1><A NAME="SECTION00040000000000000000">
Împãrþirea programului</A>
</H1>

<P>
<BLOCKQUOTE>
Fã bucãþile în aºa fel încît sã înþelegi uºor <EM>ce</EM> face
fiecare fãrã a trebui sã ºtii <EM>cum</EM> face.

</BLOCKQUOTE>

<P>
Domnul Dijkstra (în olandezã se citeºte aproximativ
``daicstra'') recomanda o tacticã veche de pe vremea lui Cezar:
``divide et impera'': ``împarte ºi stãpîneºte''.  Aºa e bine sã
scrieþi ºi programele: în bucãþi cît mai independente unele de
altele, care interacþioneazã intre ele în moduri cît se poate de
clare ºi simple, ºi care nu se influenþeazã ``pe la spate''.

<P>
Din fericire toate limbajele moderne de programare aduc un
suport extrem de eficace acestei metode de scriere: funcþiile,
procedurile ºi modulele.

<P>
Împãrþiþi deci programul dumneavoastrã în astfel de
pãrþi cît mai des cu putinþã.  Faceþi pãrþile logic
independente; funcþiunea fiecãreia trebuie sã fie extrem de clarã
ºi cît se poate de limpede enunþatã.  De exemplu, o funcþie care
cautã ceva într-un ºir nu trebuie sã facã ºi ordonarea ºirului.
Faceþi douã funcþii independente pentru asta, una de cãutare ºi
una de sortare.  

<P>
Dacã limbajul permite module, atunci faceþi-le în fiºiere
separate, ale cãror nume sã fie suficient de clare.  Grupaþi în
fiecare modul numai funcþii ºi variabile înrudite.  Dacã
programaþi într-un limbaj orientat pe obiecte, implementaþi fiecare
clasã într-un modul separat, cu toate metodele ei.  O sã ºtiþi
apoi unde sã le cãutaþi, ºi apoi o sã le puteþi reutiliza cu
uºurinþã în alte programe.

<P>
Cheia economiei de timp este asta: cînd vrei sã foloseºti o
funcþie trebuie sã ºtii numai ceea <EM>ce</EM> face; nu trebuie sã o
citeºti în întregime ca sã vezi <EM>cum</EM> face acest lucru.  De
aceea funcþia este mult mai uºor de folosit, ºi apoi poate fi
la nevoie rescrisã în cu totul alt fel, fãrã a influenþa cîtuºi de puþin
restul programului.  (De exemplu nu conteazã dacã sortarea este
bubble sort sau quick sort, totul este sã fie tot o sortare.
Funcþiile care folosesc funcþia de sortare nu sunt interesate de
modul în care aceasta se face).  Un alt uriaº beneficiu al acestei
relative independenþe între feluritele pãrþi este cã în
momentul în care un bug este descoperit ºi scos dintr-una, 
celelalte vor rãmîne neschimbate, pentru cã nu se bazau pe felul
în care lucra acea parte, ci doar pe ceea ce ea fãcea.

<P>
Cîte funcþii sau linii de program trebuie sã fie într-un
modul?  Asta este destul de mult o chestie de gust, dar editorul de
texte pe care îl folosiþi poate influenþa mult alegerea.  Dacã
aveþi 24 de linii de ecran (din care 3 folosite la borduri ºi
meniuri) este greu sã scrieþi fiºiere mari, pentru cã vã
plimbaþi cu greu prin ele.  Alta este situaþia dacã aveþi 42 sau
80 de linii.

<P>
Un editor inteligent reduce handicapul unor fiºiere mari,
pentru cã vã permite sã va mutaþi cãutînd automat apariþiile
funcþiilor ºi variabilelor.

<P>
Eu personal mã descurc cel mai bine cu fiºiere între 300
ºi 700 de linii, conþinînd pînã în 15 funcþii.

<P>

<H1><A NAME="SECTION00050000000000000000">
Minima vizibilitate</A>
</H1>

<P>
Principiul minimei vizibilitãþi cere ca un obiect sã nu fie
vizibil decît pãrþilor din program care au cu adevãrat nevoie de
el.  Sã vedem niºte aplicãri ale lui:

<P>
<BLOCKQUOTE>
Datele trebuie separate cît se poate de mult de corpul programului.

</BLOCKQUOTE>

<P>
O variantã a acestei reguli este ``în sursa programului nu
trebuie sã aparã <EM>nici</EM> un numãr cu excepþia lui 0, 1, sau
-1''.  Constantele (în particular cele numerice) se mai numesc ºi
``magic numbers'' (numere magice).  Ele trebuie evitate întotdeauna.

<P>
Metoda comunã este de a da <EM>nume</EM> simbolice constantelor
undeva la începutul fiecãrui modul, sau în fiºiere speciale (cu
<TT>const</TT> în Pascal ºi C, cu <TT>#define</TT> în C, etc.).  Numele
dat unei constante are multe avantaje, care sunt expuse în mai toate
cursurile de programare.  Noi vom reaminti decît pe unul: o
constantã face programul <EM>mult</EM> mai uºor de citit.  Aceasta este
o aplicare a principiului minimei vizibilitãþi: ºtii numai numele
constantei (care trebuie sã arate la ce foloseºte ea), ºi nu
valoarea ei!

<P>
Iatã un exemplu:

<P>
<PRE>
for i:=1 to 128 do persoana[i].nume := '';
</PRE>

<P>
ºi tradus:

<P>
<PRE>
for p:=1 to NumarDePersoane do persoana[p].nume := '';
</PRE>

<P>
Nu e mai clar a doua oarã?

<P>
Cum spuneam pãrþile din program interacþioneazã te miri
cum.  Cel mai adesea interacþiunile se fac prin variabile globale, a
cãror valori pot fi modificate de o funcþie ºi citite de alta.

<P>
De aceea este bine sã transmitem funcþiilor (procedurilor)
toate valorile de care au nevoie prin argumente ºi sã nu le lãsãm
sã modifice variabile globale.

<P>
Dacã vi se pare greu sã programaþi fãrã variabile
globale, aflaþi cã existã limbaje de programare în care nu existã
variabile de loc, ºi totuºi se pot face foarte multe lucruri (un
exemplu este Prolog; despre Prolog se crede îndeobºte cã are
variabile, însã o analizã atentã va arãta cã ceea ce în Prolog
se numeºte variabilã nu foloseºte de loc la acelaºi lucru ca o
variabilã în sensul uzual al limbajelor imperative ca Pascalul).

<P>
În realitate este foarte greu adesea sã ne descurcãm fãrã
variabile globale, pentru cã unele funcþii fac modificãri atît de
masive încît ar trebui sã aibã zeci de parametri ºi sã returneze
tot atîtea valori (ceea ce multe limbaje nici nu permit, dealtfel!).
Tocmai pentru a circumveni aceste dezavantaje au fost inventate
limbajele orientate pe obiecte (alde C++), în care în loc sã dai
unei funcþii argumente, grupezi argumentele la un loc într-un obiect
(un fel de <TT>record</TT> din Pascal); funcþia însãºi devine un
cîmp al obiectului (se va numi ``funcþie membru''), ºi în loc sã
chemi funcþia cu cîmpurile obiectului ca argumente, rogi obiectul
sã-ºi aplice singur funcþia.

<P>
Aceastã reducere la maximum a vizibilitãþii din limbajele
orientate pe obiecte (cãci cîmpurile unui obiect sunt în mod normal
accesibile numai funcþiilor care-i sunt membre) se numeºte
``încapsulare'' ºi constituie unul din avantajele majore ale
programãrii orientate pe obiecte faþã de cea ordinarã.

<P>
Cu disciplinã însã se pot aplica beneficiile încapsulãrii
ºi în programe scrise în limbaje fãrã astfel de construcþii (C, Pascal),
cu foarte mult succes.

<P>

<H1><A NAME="SECTION00060000000000000000">
Spaþiile albe; i(n)dentarea</A>
</H1>

<P>
Unii separã pãrþile din programe prin comentarii baroce ca:

<P>
<PRE>
{******************************}
{========intrare/iesire========}
{******************************}
</PRE>

<P>
Ei bine, puþine spaþii albe judicios plasate fac mult mai
mult bine lizibilitãþii programului.  Iatã care sunt recomandãrile
mele în ceea ce le priveºte:

<P>

<OL>
<LI>Separaþi fiecare funcþie de vecinele ei printr-o linie
albã.  

<P>
</LI>
<LI>Între titlul funcþiei ºi corpul ei eu las mereu un rînd
în care pun de obicei comentarii.

<P>
</LI>
<LI>Între declaraþiile variabilelor locale ºi corpul
funcþiei las mereu o linie liberã.

<P>
</LI>
<LI>Puneþi mai multe linii, ºi eventual un comentariu de o
linie de steluþe între pãrþi majore ale programului.

<P>
</LI>
<LI>Am observat cã o expresie este mult mai uºor de citit
dacã separ cu spaþii unii operatori de argumentele lor.  Observaþi:

<P>
<PRE>
for(i=0;i&lt;ultim;i++) if(!a[i]) total++;
</PRE>

<P>
faþã de:

<P>
<PRE>
for (i = 0; i &lt; ultim; i++) if ( ! a[i] ) total++;
</PRE>

<P>
</LI>
<LI>Pentru a uºura depanarea este bine sã puneþi o singurã
instrucþiune pe linie!  Pentru cã linia de mai sus la depanare va
executa întreg ciclul <TT>for</TT> la o singurã comandã ``step'', iar
liniile de mai jos vor permite sã vedeþi ce se întîmplã la
fiecare pas:

<P>
<PRE>
for (i = 0; i &lt; ultim; i++) 
  if ( ! a[i] ) total++;
</PRE>

<P>
</LI>
<LI>Dacã aveþi prea multe argumente la o funcþie scrieþi
aºa:

<P>
<PRE>
     venit(persoana[pozitie_curenta].nume, 
           departament[persoana[pozitie_curenta].cod_departament],
           indexare_salarii);
</PRE>

<P>
</LI>
<LI>Dacã trebuie sã spargeþi o expresie pe douã linii
lãsaþi operatorul la începutul celei de-a doua linii.

<P>
<PRE>
        venit_max = persoana[pozitie_curenta].venit
          + crestere_salariu;
</PRE>

<P>
</LI>
<LI>Logica expresiei rupte pe mai multe linii trebuie sã fie
clarã:

<P>
<PRE>
        copii := numar_copii( indice[disc_curent, compartiment,
                                     raft_curent],
                              eticheta);
</PRE>

<P>
</LI>
<LI>Nu calculaþi prea multe lucruri într-o singurã expresie
complicatã, pentru cã dupã aceea n-o sã înþelegeþi nici
dumneavoastrã ce aþi vrut:

<P>
<PRE>
i := 1;
c := 'y';
while (i &lt; maxN) and not (a[i] &lt; 0) and not (c = 'n') do begin
  i := i + 1;
  read(f, c)
end
</PRE>

<P>
ci:

<P>
<PRE>
i := 1;
gata := false;
c := 'y';
while not gata do begin
  if i &gt;= maxN then gata := true;
  if a[i] &lt; 0  then gata := true;
  if c = 'n'   then gata := true;
  if not gata  then begin
     i := i + 1;
     read(f, c)
  end
end
</PRE>

<P>
</LI>
<LI>În englezã ``to indent'' înseamnã ``a zimþui''.  În
româna s-a format barbarismul ``a identa'' sau ``a indenta''. care
înseamnã a aranja frumos în paginã un program, în aºa fel
încît structura lui sã fie limpede.  Mai toate limbajele moderne
sunt indiferente la numãrul de spaþii, aºa cã folosiþi-le ca sã
indicaþi structura programului.  Exemple se gãsesc ºi mai sus.

<P>
Regula de bazã este ca o instrucþiune care depinde de altã
instrucþiune sã fie scrisã puþin mai la dreapta.  De pildã <TT>if</TT> aratã aºa: <TT>if &lt;expresie&gt; then &lt;instructiune1&gt; else
&lt;instructiune2&gt;</TT>.  <TT>&lt;instructiune1,2&gt;</TT> depind de <TT>if</TT>.  Un <TT>if</TT> se scrie deci aºa:

<P>
<PRE>
        if TrebuieSters then
           StergeJucator(BazaDeDate, NumarulDeOrdine)
        else
           calificari(BazaDeDate, NumarulDeOrdine);
</PRE>

<P>
</LI>
<LI>Dacã instrucþiunea dependentã este o instrucþiune bloc,
aveþi mai multe posibilitãþi de a o aranja în paginã.  Totul e
sã alegeþi una ºi sã o respectaþi mereu.

<P>
<PRE>
        for i := 1 to ultim do begin
           CalculeazaNota(i);
           AlegePostura(i)
        end;
</PRE>

<P>
sau

<P>
<PRE>
        for i := 1 to ultim do 
           begin
           CalculeazaNota(i);
           AlegePostura(i)
           end;
</PRE>

<P>
sau

<P>
<PRE>
        for i := 1 to ultim do 
           begin
           CalculeazaNota(i);
           AlegePostura(i)
        end;
</PRE>

<P>
sau

<P>
<PRE>
        for ( i = 1; i &lt;= ultim; i++) 
          {
            calculeaza_nota(i);
            alege_postura(i);
          }
</PRE>

<P>
</LI>
<LI>Cît de multe spaþii trebuie sã se foloseascã pentru a
indenta?  1 este prea puþin, ºi structura programului nu apare
suficient de clar, 8 este prea mult, pentru cã la o indentare de 4
nivele nu mai ajunge ecranul.  Cel mai bine este între 2 ºi 6.

<P>
</LI>
<LI>Etichetele de la <TT>goto</TT> sau <TT>case</TT> se indenteazã
puþin mai în stînga:

<P>
<PRE>
  repeta:
    switch(raspuns) {
    case 'd': 
	stiut = DA;
	break;
    case 'n':
	stiut = NU;
	break;
    case '?':
	interogare();
	goto repeta;
    default:  /* alt raspuns */
	return;
    }
</PRE>

<P>
</LI>
<LI>Construcþiile de genul <TT>else if</TT> sunt o excepþie de la
regula de indentare.  Ele pot fi scrise în loc de:

<P>
<PRE>
        if e1 then cutare1
        else 
           if e2 then cutare2
           else 
              if e3 then cutare3
              else cutare3
</PRE>

<P>
aºa:

<P>
<PRE>
        if e1 then cutare1
        else if e2 then cutare2
        else if e3 then cutare3
        else cutare3
</PRE>

<P>
pentru cã sunt echivalente cu un <TT>case</TT> din Pascal
(<TT>switch</TT> din C) -- adicã un <TT>if</TT> cu mai multe condiþii,
care au aceeaºi importanþã.
</LI>
</OL>

<P>

<H1><A NAME="SECTION00070000000000000000">
Comentariile</A>
</H1>

<P>
Comentariile sunt într-adevãr extrem de utile pentru a
uºura înþelegerea funcþionãrii unui program.  Rolurile lor sunt
multiple, ºi modul în care se pot folosi extrem de variat.

<P>
În primul rînd existã douã feluri de comentarii:

<P>

<UL>
<LI>comentarii de linie
</LI>
<LI>comentarii de sfîrºit de linie
</LI>
</UL>

<P>
Primele ocupã o linie (sau mai multe) de program în
întregime ºi explicã ceva din funcþionarea lui.  Iatã unde sunt
extrem de utile:

<P>

<OL>
<LI>Orice fiºier (modul) trebuie sã conþinã pe prima sau a
doua linie un comentariu arãtînd numele fiºierului ºi explicînd
pe scurt la ce foloseºte.  Cînd fiºierul este scos la imprimantã
se acest comentariu indicã provenienþa sursei.

<P>
</LI>
<LI>Orice fiºier este bine sã conþinã la început comentarii
descriind autorul, data ºi versiunea ultimei modificãri ale
textului.  Existã programe speciale (``Source Code Control System''
-- control al codului sursã) care ajutã pãstrarea ºi folosirea
tuturor versiunilor unui program.  În cazul în care mai multã lume
lucreazã la un proiect sunt extrem de utile.

<P>
</LI>
<LI>Fiecare funcþie trebuie sa aibã o descriere a
comportãrii ei.  Vedeþi mai jos secþiunea despre funcþii.  Aceste
comentarii se pot întinde pe mai multe linii.

<P>
</LI>
<LI>Algoritmii mai complecºi trebuie sã fie descriºi
printr-un comentariu care explicã sumar comportarea lor.  Acest
comentariu în mod normal se plaseazã înaintea zonei de cod care
implementeazã algoritmul.

<P>
</LI>
<LI>Comentariile se indenteazã la fel cu liniile de cod de
care þin:

<P>
<PRE>
        for i := 1 to sfirsit do
          { verific toate pozitiile }
          verifica( pozitie[i] );
</PRE>
</LI>
</OL>

<P>
Comentariile de sfîrºit de linie în general explicã
operaþia fãcutã pe linia curentã.  Ele sunt mult mai greu de
întreþinut, pentru cã schimbarea uneia din linii stricã întreaga
lor aliniere.

<P>

<OL>
<LI>Ele trebuie sã însoþeascã obligatoriu declaraþiile
variabilelor globale:

<P>
<PRE>
var
  persoane,                     { numar de participanti       }
  locuri,                       { numarul de scaune la masa   }
  LocCurent: integer;           { locul pe care incerc sa pun }
</PRE>

<P>
</LI>
<LI>Orice linie care face o acþiune mai deºucheatã (al
cãrei sens nu este limpede) trebuie sã fie comentatã:

<P>
<PRE>
  /* elementele nu pot fi 0 */
  for ( i = 0; i &lt; nr_elem; i++ ) {
    if ( a[i] == 0 ) break;   /* eroare! opresc procesarea */
    if ( a[i] &lt; a[i+1] ) swap (&amp;a[i], &amp;a[i+1]);
  }
</PRE>

<P>
</LI>
<LI>Variabilele locale ale unei funcþii trebuie sã fie
cîteodatã comentate.

<P>
</LI>
<LI>Mai rar se comenteazã argumentele unei funcþii în
declaraþia ei:

<P>
<PRE>
function arata(x, y, {coordonatele din stinga-sus}
               lungime, latime: integer): boolean;
</PRE>

<P>
</LI>
<LI>Blocurile la mare distanþã de testele care le controleazã
trebuie sã fie comentate astfel (vedeþi la <TT>else</TT>):

<P>
<PRE>
if ( functionare == INTERACTIV ) {
   int alege;

   printf("\a\a\a");           /* un pic de galagie */
   alege = meniu_principal();  /* selectia          */
   switch (alege) {
     case FISIER: 
        fisier();              /* toata intrarea/iesirea */
        break;
     case CALCUL: 
        calcul();
        break;
     default:     
        return 0;               /* nimic valid -&gt; termin */
   }
}
else {                 /* aici functionare != INTERACTIV */
        ...
}
</PRE>
</LI>
</OL>

<P>

<H1><A NAME="SECTION00080000000000000000">
Variabilele, constantele, funcþiile, procedurile</A>
</H1>

<P>
<BLOCKQUOTE>
Dacã nu poþi sã-i dai un nume unei variabile înseamnã cã acea
variabilã nu este bunã.  Reconsiderã arhitectura întregului
program.

</BLOCKQUOTE>

<P>
Într-adevãr, nu trebuie sã faci nici un efort ca sã-þi
aduci aminte ce reprezintã o variabilã; numele ei trebuie sã-þi
spunã tot ce te intereseazã.

<P>
Nu faceþi niciodatã economie înghesuind în aceeaºi
variabilã mai multe valori, depinzînd de context!  Fiecare
variabilã trebuie sã reprezinte un singur lucru în fiecare clipã.
Compilatoarele moderne sunt suficient de inteligente ca sã transforme
cele douã variabile în una singurã dacã asta se poate!  (De fapt
le chiar uºuraþi munca neînghesuind mai multe lucruri laolaltã).

<P>
<BLOCKQUOTE>
Numele unei variabile trebuie sã arate exact ce reprezintã valoarea
ei.

</BLOCKQUOTE>

<P>
Numele variabilelor, funcþiilor, procedurilor, argumentelor
lor, trebuie sã fie de asemenea uºor de reamintit.  Dacã scrii un
program ºi trebuie mereu sã te duci la prima paginã ca sã vezi
dacã o variabilã se cheamã <TT>max_n</TT>. sau <TT>max_numere</TT> sau
<TT>maximum_numere</TT> treaba merge destul de greu.  În principiu nu
se folosesc prescurtãri.  Un nume de variabilã ca <TT>x</TT> sau <TT>total</TT> este absolut inutil, cãci orice poate fi <TT>x</TT>.  Scrieþi
<TT>x_fereastra</TT> sau <TT>total_venit</TT> de pildã.

<P>
Nu trebuie sã va fie lene sã tastaþi.  De altfel un editor
foarte bun (ca de exemplu GNU Emacs) vã ajutã foarte mult (Emacs la
apãsarea tastei <TT>M-/</TT> încearcã sã completeze cuvîntul curent
cu un sufix care se regãseºte undeva prin text.  De pildã dacã am
definit variabila <TT>complexitate_totala</TT>. atunci probabil ajunge
sa tastez <TT>com</TT> ºi apoi <TT>M-/</TT> ca Emacs sã completeze întreg
numele).

<P>
Nu scrieþi funcþii care în funcþie de un argument fac
douã lucruri diferite:

<P>
<PRE>
int operatie(FILE * f, struct persoana * p, int actiune)
/* daca actiune = 0 -&gt; cauta de cite ori apare persoana p in fisier
 * daca actiune = 1 -&gt; sterge toate aparitiile p din f
 */
</PRE>

<P>
Scrieþi douã funcþii, pe care le chemaþi dintr-un if sau
switch (case).

<P>
Este util sã folosiþi notaþii diferite pentru constantele
numite pentru a le distinge de variabile.  În C, în care conteazã
literele mari/mici, aceste constante au de obicei numele scrise numai
cu majuscule.

<P>
Un program cu nume de variabile eficient alese are nevoie de
mult mai puþine comentarii, ºi este mult mai uºor de citit ºi
întreþinut.  Cineva spunea cã pot fi citite la gura sobei, ca o
carte bunã.  Am avut ocazia sã citesc astfel de programe ºi trebuie
sã recunosc cã am învãþat extrem de mult din ele.  Pentru
curioºi recomand doi monºtri sacrii ai programãrii cristaline,
Andrew S. Tanenbaum (autorul sistemelor de operare MINIX ºi Amoeba)
ºi Richard Stallman (autorul compilatorului GCC ºi al lui GNU
Emacs).

<P>
Dacã scrieþi module care exportã multe variabile sau
funcþii puteþi prefixa toate obiectele unui modul cu un text care le
aratã provenienþa ºi semnificaþia.  De exemplu toate procedurile
care lucreazã cu ferestre se vor numi ceva de genul <TT>Win_xxx</TT>
(win de la ``window''..  Aceasta complicã ºi simplificã deopotrivã
unele lucruri.  E mai simplu pentru cã poþi avea o procedurã <TT>make</TT> ºi pentru ferestre, ºi pentru stive, numai cã una se cheamã
<TT>Win_make</TT> iar alta <TT>Stk_make</TT>.

<P>
Dacã vã decideþi pentru prefixe, în general ele sunt
preferabil sufixelor.  Adicã e mai bine <TT>Win_make</TT> decît <TT>make_win</TT>.  pentru cã prefixele se vãd mai uºor.  În nici un caz
nu amestecaþi într-un program cele douã feluri de numire.

<P>
Apropos de amestecare, faceþi la început niºte decizii de
numire omogenã a obiectelor cu care operaþi.  De exemplu: ``toate
comentariile sunt în englezã'', sau ``toate numele de proceduri sunt
cuvinte englezeºti'', º.a.m.d.  În program coexistã greu o
procedurã <TT>numar_persoane</TT> cu una <TT>first_person</TT>.  (Dacã
nu ºtiþi englezã lucrurile sunt ceva mai simple.)

<P>

<H1><A NAME="SECTION00090000000000000000">
Fiabilitatea</A>
</H1>

<P>
``Nu avea încredere în nimeni, nici mãcar în tine
însuþi!''  Respectarea acestei reguli aduce niºte beneficii greu de
imaginat.  Ce înseamnã ea pentru un programator?

<P>

<OL>
<LI>Funcþiile nu trebuie niciodatã sã se bazeze pe cel care
le cheamã, cum cã le furnizeazã argumente corecte.  Verificaþi
toate argumentele înainte de a le prelucra; dacã nu sunt corecte
anunþaþi eroarea, fie scriind ceva pe ecran, fie returnînd o
valoare indicînd eroare utilizatorului.

<P>
</LI>
<LI>Funcþiile nu trebuie sã se bazeze niciodatã pe cele pe
care le cheamã.  De fiecare datã cînd aþi chemat o altã funcþie
verificaþi dacã nu cumva a semnalat o eroare.  Dacã da acþionaþi
în consecinþã, ºi opriþi procesarea.

<P>
</LI>
<LI>Un caz particular al lui 2. este apelul unor funcþii din
biblioteci.  Mai ales cele care fac intrare/ieºire pot eºua din zeci
de motive.  Verificaþi <EM>mereu</EM> dacã au funcþionat înainte de a
vã arunca cu capul înainte.  Dacã vã e lene, scrieþi funcþii
``înveliº'' (``wrappers'') care le cheamã pe cele de bibliotecã
ºi care verificã erorile.  Folosiþi apoi numai wrapper-ele.  De
exemplu:

<P>
<PRE>
void * aloca_memorie(size_t marime)
        /* aloca memorie.  eroare fatala daca nu mai este memorie */
{
        void * p;  /* aici alocam temporar */

        p = malloc(marime);
        if (p == NULL) {
                /* standardul spune ca malloc intoarce NULL numai
                 * daca nu a reusit sa aloce cantitatea indicata */
                fprintf(stderr, " Alocare nereusita!\n");
                exit(1);
        }
        return p;
}
</PRE>

<P>
sau (în TURBO-Pascal):

<P>
<PRE>
procedure deschide_fisier(var f:text; nume:string);
        { deschide un fisier; verifica erorile }
begin
     {$i-}      { inhiba erori de executie pentru intrare-iesire }
     assign(f, nume);
     reset(fis);
     {$i+}      { inversul lui $i- }
     if ioresult &lt;&gt; 0 then begin
        writeln('deschide_fisier: Nu pot deschide fisierul ', nume);
        halt
     end
end;
</PRE>

<P>
</LI>
<LI>Din loc în loc introduceþi verificãri asupra datelor pe care
le prelucraþi, chiar dacã vi se par inutile.  În C existã funcþia
standard <TT>assert</TT> care este <EM>extrem</EM> de utilã, dar puteþi
scrie ºi în Pascal una asemãnãtoare.  Aceastã funcþie opreºte
definitiv programul dacã este chematã cu un argument 0.  Frumuseþea
este cã toate invocãrile lui <TT>assert</TT> sunt scoase definitiv din
program doar definind macro-ul <TT>NDEBUG</TT>.

<P>
Metoda universalã este urmãtoarea: definiþi constanta
booleanã (sau întreagã) <TT>DEPANARE</TT>, pe care o faceþi <TT>true</TT>.  Apoi în program verificaþi mereu astfel:

<P>
<PRE>
  if DEPANARE then begin
      { verificam daca locasele sunt bine initializate }
      for i := 1 to spatii do 
           if locas[i].urmator = nil then begin
                writeln('Locas cu "urmator" nil la indicele ', i);
                halt
           end
  end
</PRE>

<P>
Testele pentru locaºe se vor efectua numai dacã <TT>DEPANARE</TT> este <TT>true</TT>.  Dacã faceþi <TT>DEPANARE</TT> false,
testele dispar cu desãvîrºire!  Puteþi astfel sã vã depanaþi
programul, iar cînd merge sã-l scurtaþi.  Un compilator cu
optimizãri va observa cã liniile de test nu se vor putea efectua
niciodatã (pentru cã <TT>DEPANARE</TT> este o constantã), ºi le va
scoate cu totul din program.  (Pe de altã parte unele teste este
înþelept sã rãmînã pentru totdeauna în program; nu se ºtie
niciodatã pentru ce date de intrare programul o ia razna.  Este
recomandabil sã gãseºti o eroare cît mai repede ºi sã urlii cã
ai gãsit-o decît sã o ignori o vreme ºi ea sã facã prãpãd în
liniºte.  Mulþi utilizatori vor aprecia.)

<P>
</LI>
<LI>Distingeþi în programele dumneavoastrã (cel puþin)
douã tipuri de erori: fatale ºi recuperabile.  Scrieþi douã
funcþii care trateazã aceste tipuri de erori.  Toate erorile ar
trebui sã indice cît mai clar locul unde s-au produs: numele
programului, numele modulului, numele funcþiei, tipul erorii.  La
depanare nu ajutã prea tare dacã vezi ceva de genul: ``eroare de
intrare/iesire''.  Mai bine e ``statistic: functia `citeste_data':
eroare: nu pot deschide fisierul `info.txt'''.
</LI>
</OL>

<P>
Tocmai din aceastã cauzã nu orice eroare trebuie semnalatã
ca fiind fatalã.  Nu poþi sã faci o împãrþire la 0?  Anunþã
doar pe funcþia care te-a chemat cu argumente greºite cã ceva nu e
în regulã.  Cum ar fi un program de calculator de buzunar care s-ar
opri la o astfel de eroare?  Penibil!  Eroarea trebuie doar sã fie
anunþatã ºi procesarea continuatã.

<P>
Poate vom reveni cu un articol special despre tratamentul
erorilor, pentru cã este un subiect extrem de interesant, ºi foarte
prost tratat în literaturã.  O eroare se poate adesea propaga în
sus pe un lanþ de funcþii care s-au chemat între ele (mai ales
dacã una era recursivã) la distanþe extrem de mari de locul
producerii.  Cum se face asta cu grijã, cum se semnaleazã erorile
cel mai simplu, asta meritã discutat mai pe-ndelete.

<P>

<H1><A NAME="SECTION000100000000000000000">
Documentaþia</A>
</H1>

<P>
Donald Knuth (unul din cei cu citatele din introducere) este
unul dintre adepþii a ceea ce se numeºte ``litterate programming''.
Acesta este un sistem (numit Web) în care programul ºi documentaþia
sa se scriu dintr-un singur foc, apoi cu douã compilatoare diferite
se obþin executabilul ºi cartea de descriere a produsului.
Paradoxal, aceastã metodã mãreºte productivitatea ºi
fiabilitatea, pentru cã îþi poþi introduce explicaþiile detaliate
chiar în corpul programului în timp ce-l scrii, gîndind mai uºor
atît asupra programului cît ºi documentaþiei.

<P>
Dacã nu spuneþi <EM>cum</EM> face ceva un program de-al
dumneavoastrã, trebuie totuºi sã spuneþi <EM>ce</EM> face.  Chiar
dacã nu scrieþi programe pentru vînzare este un obicei extrem de
util sã scrieþi scurte documentaþii pentru utilizatorii lor sau cei
care vor sã le modifice.  Un model împãmîntenit este pagina de
manual interactivã din UNIX (sau comanda ``help'' din DOS, într-un
fel).  O descriere a programului dumneavoastrã ar trebui sã
conþinã urmãtoarele informaþii:

<P>

<OL>
<LI>numele programului;
</LI>
<LI>modul de lansare (argumente, etc);
</LI>
<LI>o descriere a comportãrii;
</LI>
<LI>pentru programe interactive indicaþii sumare de folosire;
</LI>
<LI>informaþii despre fiºierele pe care le foloseºte ºi structura
lor;
</LI>
<LI>versiunea curentã;
</LI>
<LI>autorul programului cu adresa lui (nu se recomandã dacã programul
este un virus);
</LI>
<LI>defecþiuni cunoscute;
</LI>
<LI>documentaþii înrudite.
</LI>
</OL>

<P>

<H1><A NAME="SECTION000110000000000000000">
Portabilitatea</A>
</H1>

<P>
Dacã trebuie sã folosiþi trãsãturi ale limbajului care
<EM>nu</EM> sunt standard (de exemplu în Turbo C <TT>gotoxy()</TT>, atunci
nu le chemaþi niciodatã direct; scrieþi pentru ele ``wrappere''.
Astfel de wrappere ar trebui sã asigure o comportare uniformã a
funcþiilor, chiar dacã bibliotecile de care dispuneþi se schimbã.

<P>
De exemplu dacã faceþi un program pe PC care lucreazã cu
mai multe culori, dacã vreþi sã meargã bine ºi pe plãci
monocrome ºi color scrieþi o funcþie <TT>culoare_text()</TT> cam
aºa:

<P>
<PRE>
void culoare_text(int culoare)
        /* alege culoarea textului in functie de numarul 
           de culori disponibile (2 sau 16) */
{
        int cul_reala;

        /* MONOCROM este aflat de exemplu intrebind utilizatorul
           la inceputul programului */
        if (MONOCROM) cul_reala = culoare / 8;
          /* daca avem numai 2 culori pastram numai primul bit */
        else cul_reala = culoare;
        textcolor(cul_reala);
}
</PRE>

<P>
Dacã vã concepeþi programele într-un mod cît mai general
vor deveni adesea ºi ceva mai uºor de scris, ºi cu siguranþã
foarte uºor de întreþinut ºi ``portat'' (mutat de la un compilator
la altul).

<P>
Subiectul este foarte generos, iar tratarea pe care i-am dat-o
aici este departe de a fi exhaustivã.  Numai experienþa vã va
convinge de utilitatea unei discipline în actul programãrii.  Deci
spor la treabã!

<P>
<BR><HR>

</BODY>
</HTML>
