<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Un proiect în Sisteme de Operare</TITLE>
<META NAME="description" CONTENT="Un proiect în Sisteme de Operare">
<META NAME="keywords" CONTENT="proiect-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Un proiect în Sisteme de Operare</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- mihaib+ at cs.cmu.edu, Raluca 
Budiu -- ralucav+ at cs.cmu.edu
<BR><TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>ianuarie 1998</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>cum se argumenteazã în sprijinul unei idei într-un
articol
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe destul de serioase despre
funcþionarea sistemul de operare Unix
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>apel de sistem, intercepþie, performanþã,
model teoretic
</DD>
<DT><STRONG>Articole</STRONG></DT>
<DD>anterioare din PC Report utile (disponibile din pagina
de web a autorului):

<UL>
<LI><a href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#nucleu">``Nucleul''</a>, octombrie-noiembrie 1996
</LI>
<LI><a href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#threads">``Multithreading''</a>, ianuarie 1996
</LI>
<LI><a href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#rapid-fs">``Eficienþa în sistemele de fiºiere''</a>, octombrie 1997
</LI>
<LI><a href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#2fs">``Funcþionarea sistemului de fiºiere din Unix''</a>, decembrie 1997
</LI>
<LI><a href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#linux">``Anatomia unui apel de sistem în Linux''</a>, ianuarie 1998
</LI>
<LI><a href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#3fs">``Sistemul de fiºiere virtual''</a>, februarie 1998
</LI>
</UL>
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html44"
  HREF="proiect-html.html">Informatica</A>
<UL>
<LI><A NAME="tex2html45"
  HREF="#SECTION00021000000000000000">Teoria</A>
<LI><A NAME="tex2html46"
  HREF="#SECTION00022000000000000000">Sistemele</A>
<LI><A NAME="tex2html47"
  HREF="#SECTION00023000000000000000">Totul</A>
</UL><BR>
<LI><A NAME="tex2html48"
  HREF="#SECTION00030000000000000000">Un raport tehnic în sisteme</A>
<LI><A NAME="tex2html49"
  HREF="#SECTION00040000000000000000">O propunere: ``cîini de pazã''</A>
<UL>
<LI><A NAME="tex2html50"
  HREF="#SECTION00041000000000000000">Aplicaþii</A>
</UL><BR>
<LI><A NAME="tex2html51"
  HREF="#SECTION00050000000000000000">Arhitectura sistemului</A>
<UL>
<LI><A NAME="tex2html52"
  HREF="#SECTION00051000000000000000">Terminologie</A>
<LI><A NAME="tex2html53"
  HREF="#SECTION00052000000000000000">Arhitectura</A>
<LI><A NAME="tex2html54"
  HREF="#SECTION00053000000000000000">Un exemplu de watchdog</A>
</UL><BR>
<LI><A NAME="tex2html55"
  HREF="#SECTION00060000000000000000">O întrebare: eficacitatea</A>
<UL>
<LI><A NAME="tex2html56"
  HREF="#SECTION00061000000000000000">Componentele costului</A>
<LI><A NAME="tex2html57"
  HREF="#SECTION00062000000000000000">Costul componentelor</A>
<LI><A NAME="tex2html58"
  HREF="#SECTION00063000000000000000">Performanþa relativã</A>
<LI><A NAME="tex2html59"
  HREF="#SECTION00064000000000000000">Utilitatea proiectului revizuitã</A>
<LI><A NAME="tex2html60"
  HREF="#SECTION00065000000000000000">O mãsurãtoare a performanþei</A>
</UL><BR>
<LI><A NAME="tex2html61"
  HREF="#SECTION00070000000000000000">O aplicaþie a mecanismului: un sistem de fiºiere la
distanþã</A>
<UL>
<LI><A NAME="tex2html62"
  HREF="#SECTION00071000000000000000">Alþi candidaþi ºi slãbiciunile lor</A>
<LI><A NAME="tex2html63"
  HREF="#SECTION00072000000000000000">Un serviciu de ``caching'' inteligent</A>
<LI><A NAME="tex2html64"
  HREF="#SECTION00073000000000000000">Serviciul de fiºiere la distanþã</A>
<LI><A NAME="tex2html65"
  HREF="#SECTION00074000000000000000">Mãsurãtori de performanþã</A>
</UL><BR>
<LI><A NAME="tex2html66"
  HREF="#SECTION00080000000000000000">Concluzii</A>
<LI><A NAME="tex2html67"
  HREF="#SECTION00090000000000000000">Bibliografie</A>
<LI><A NAME="tex2html68"
  HREF="#SECTION000100000000000000000">Bibliography</A>
<LI><A NAME="tex2html69"
  HREF="#SECTION000110000000000000000">Traseul parcurs</A>
</UL>
<!--End of Table of Contents--><BR>
<BR>

<P>

<H1><A NAME="SECTION00020000000000000000">
Informatica</A>
</H1>

<P>
Cea mai grosolanã diviziune a ``ºtiinþei calculatoarelor'' (cum o
numesc anglo-saxonii), sau, dacã preferaþi, a ``informaticii'' (în
accepþiunea francofonã a termenului) va segmenta domeniul în douã
zone relativ distincte prin natura cercetãrii ºi metoda aplicatã.
Cele douã zone sunt ``Teoria'' ºi ``Sistemele''.  

<P>

<H2><A NAME="SECTION00021000000000000000">
Teoria</A>
</H2>

<P>
Despre prima este destul de limpede cum stau lucrurile: este o ramurã
a matematicii, care uzînd de arsenalul acesteia (definiþii, leme,
teoreme, demonstraþii, etc.), manipuleazã o serie de abstracþii ale
fenomenelor petrecute în calculatoare.  Multe pãrþi din
informaticã aparþin majoritar acestui domeniu; cele mai evidente
sunt: teoria algoritmilor, teoria complexitãþii, metodele numerice
(numite ºi ``scientific computing''), etc.  

<P>
Trebuie spus cã aproape întotdeauna dezvoltarea teoreticã a unei
ramuri a calculatoarelor o precede pe cea practicã; calculatoarele
însele existã pe hîrtie dinainte de anii 1930, deºi realizarea lor
concretã început sã prindã contur abia în timpul celui de-al
doilea rãzboi mondial.

<P>
De fapt rolul teoriei în informaticã este enorm; foarte puþini
dintre ``butonari'' realizeazã în ce mãsurã sculele pe care le
folosesc existã numai pentru cã au fost iniþial concepute în
termeni matematici.  Un exemplu frapant este teoria compilãrii, care
a fost dezvoltatã la începutul anilor '70, ºi care a deschis era
unor limbaje mult mai clare ºi mai coerente, care realmente au mãrit
enorm sfera de accesibilitate a calculatoarelor pînã la ``marele
public''.

<P>
Scopul acestui articol <I>nu</I> este însã sã vorbeascã despre
aceastã ramurã, aºa cã mã voi opri aici cu consideraþiunile care
o privesc.

<P>

<H2><A NAME="SECTION00022000000000000000">
Sistemele</A>
</H2>

<P>
A doua parte a informaticii este un teren de activitate
``inginereascã''; denumirea sa dominantã pare sã fie ``sisteme''.
Trãsãtura definitorie este cã manipuleazã ``sisteme'' foarte
complexe (din foarte multe pãrþi) a cãror totalitate sau comportare
nu se preteazã foarte bine la o manipulare analiticã (adicã
folosind uneltele teoretice).  Munca în acest domeniu se bazeazã pe
o mare cantitate de fapte empirice (observate experimental) ºi pe
capacitatea de a agrega mental pãrþile componente într-un tot.

<P>

<H2><A NAME="SECTION00023000000000000000">
Totul</A>
</H2>

<P>
Dichotomia aceasta (teorie-sisteme) este exprimarea dichotomiei
ºtiinþã-tehnicã.  ªtiinþa încearcã sã descrie fenomene
idealizate, simplificate, tehnica încearcã sã aplice aceste
descrieri obiectelor reale, care sunt o întreþesere încîlcitã de
fenomene simple, din care foarte adesea unele încã ``necunoscute''
din punct de vedere ºtiinþific.  Distanþa este cea de la
ecuaþiile cîmpului magnetic ale lui Maxwell ºi fizica cuanticã la
construcþia unui televizor<A NAME="tex2html1"
  HREF="#foot57"><SUP>1</SUP></A>.

<P>
Din observaþiile mele personale aceste douã arii de activitate cer
însuºiri deosebite.  Existã astfel teoreticieni renumiþi care nu
ºtiu mai mult decît cîteva comenzi ale unui calculator, pentru a
manipula poºta electronicã.  Existã de asemenea ``legende vii'' în
sisteme care nu ºtiu prea multe metode de sortare.  Fireºte, existã
ºi celelalte douã extreme: matematicieni de forþã care totodatã
scriu ºi manipuleazã sisteme extrem de complexe (douã nume faimoase
ar fi John von Neumann, care este unul dintre cei mai mari
matematicieni ai secolului ºi care este considerat pãrintele
arhitecturii contemporane a calculatoarelor, ºi Donald Knuth, care,
pe lîngã cele 3 faimoase volume de teoria algoritmilor a scris
programele TeX ºi Metafont pentru tehnoredactare computerizatã), ºi
existã (marea masã a utilizatorilor de calculatoare) inºi care nu
ºtiu nici teorie ºi nici sisteme.

<P>

<H1><A NAME="SECTION00030000000000000000">
Un raport tehnic în sisteme</A>
</H1>

<P>
Acest articol îºi propune sã arate ceva din natura cercetãrii
ºtiinþifice ºi a argumentãrii în domeniul ``sistemelor''.  Eu
însumi sunt un proaspãt învãþãcel, aºa cã sunt mult mai multe
fapte pe care nu le ºtiu decît lucruri pe care le ºtiu.  Cu toate
acestea aº vrea sã spun cîteva lucruri neevidente (cel puþin eu nu
le-am ghicit de unul singur) care ar putea fi de folos celor care
activeazã în acest domeniu.

<P>
Prezentarea se bazeazã pe un proiect de curs pe care l-am realizat
în toamna lui 1997.  Proiectul ºi raportul însoþitor au fost
realizate de Raluca ºi Mihai Budiu.  Textul care urmeazã este destul
de ``greu''; mi-ar fi plãcut sã mã pot apleca mai mult asupra unora
dintre detalii, dar ºi aºa textul a ieºit cam mare.  Voi folosi
tacit informaþii dintr-o mulþime de articole pe care le-am publicat
anterior în PC Report.

<P>
Textul care urmeazã va încerca sã evidenþieze urmãtoarele douã
aspecte care trebuie puse în valoare într-un raport tehnic:

<P>

<UL>
<LI>Detaliile sunt cele care conteazã;
</LI>
<LI>O propunere de nouã tehnologie trebuie sã demonstreze prin
mãsurãtori de performanþã o creºtere a eficienþei faþã de
vechile metode.
</LI>
</UL>

<P>
O sã vedeþi cã articolul poate pãrea plictisitor prin amãnunte,
mai ales în secþiunile de performanþã.  Specificã tot felul de
detalii, parametrii cu care se fac mãsurãtorile, tipul maºinilor,
încãrcãtura reþelei, ce se mãsoarã, cînd începe ºi cînd se
terminã mãsurãtoarea, etc.  Cu toate acestea, este relativ tipic
(nu ca nivel ºtiinþific, ci ca alcãtuire) pentru un articol de
cercetare contemporan în ``sisteme''.

<P>
<BLOCKQUOTE>
În absenþa acestor detalii nu existã nimic; acestea trebuie sã fie
suficiente ca oricine sã poatã duplica experimentele întocmai.
Valoarea unui singur parametru poate schimba complet rezultatele, deci
trebuie încercatã menþinerea sub control a tuturor parametrilor
semnificativi.

</BLOCKQUOTE>

<P>

<H1><A NAME="SECTION00040000000000000000">
O propunere: ``cîini de pazã''</A>
</H1>

<P>
Dorinþa noastrã iniþialã a fost nu prea ambiþioasã: sã
implementãm în cadrul sistemului de operare Linux un mecanism
descris în urmã cu 10 ani într-un articol apãrut în ``Computing
Systems''.  Titlul articolului era ``Watchdogs -- Extending the UNIX
File System'', de Brian Bershad si Brian Pinkerton, de la
universitatea Washington din Seattle<A NAME="tex2html2"
  HREF="#foot64"><SUP>2</SUP></A>.  Traducerea titlului ar fi ``Cîini de pazã:
o extensie a sistemelor de fiºiere din Unix''.

<P>
Articolul propunea implementarea unui mecanism în interiorul
nucleului prin care anumite fiºiere pot fi supravegheate de cãtre
procese.  Cînd un alt proces încearcã sã acceseze un fiºier
supravegheat, supervizorul (cel care este de fapt numit ``cîine de
pazã'') este executat ºi i se paseazã informaþii despre tipul
accesului încercat.  Supervizorul decide care trebuie sã fie
rezultatul accesului.

<P>

<H2><A NAME="SECTION00041000000000000000">
Aplicaþii</A>
</H2>

<P>
Vom face mai tîrziu un desen care aratã cum funcþioneazã un astfel
de sistem.  Pentru început sã observãm cã numãrul de aplicaþii
al unui astfel de mecanism este uriaº.  Iatã cîteva posibilitãþi:

<P>
<DL>
<DT><STRONG>ACL</STRONG></DT>
<DD>(access control lists: liste de control al accesului): Unix
oferã un sistem de protecþie al fiºierelor relativ rudimentar,
bazat pe diviziunea utilizatorilor în 3 categorii: utilizatorul
(unic) care posedã un fiºier, grupul utilizatorilor care posedã
fiºierul ºi restul lumii.  Se pot imagina scheme mai flexibile, în
care un fiºier are drepturi pentru mai mulþi utilizatori, de genul:
X are voie sã scrie dar Y nu are voie sã citeascã.  Un ``watchdog''
ar putea implementa un astfel de control;

<P>
</DD>
<DT><STRONG>fiºiere active:</STRONG></DT>
<DD>în Windows NT fiºierele sunt obiecte
``active'' în sensul cã procesele pot sã primeascã automat
evenimente (events) atunci cînd alte procese acþioneazã asupra
fiºierelor.  În acest fel un manager de fiºiere (File Manager)
poate afiºa permanent situaþia cea mai recentã a fiºierelor.  În
Unix aºa ceva nu este cu putinþã.  Un watchdog ar putea însã
intercepta acþiunile ºi trimite semnale proceselor interesate de
schimbãrile pe fiºiere;

<P>
</DD>
<DT><STRONG>conþinut generat dinamic:</STRONG></DT>
<DD>un watchdog poate genera dinamic
conþinutul fiºierelor în funcþie de anume parametri, cum ar fi
identitatea procesului care acceseazã fiºierul (cu alte cuvinte
fiecare proces ar putea vedea altceva în acelaºi fiºier).
Acest mecanism ar putea fi folosit pentru a implementa un server de
web simplu emulînd mecanismele cgi-bin, prin care serverul executã
alte procese cînd i se cer anume fiºiere.  Watchdog-ul poate subsuma
aceste alte procese;

<P>
</DD>
<DT><STRONG>managere pentru ``obiecte de memorie'':</STRONG></DT>
<DD>sistemul de operare
Mach permite utilizatorilor sã construiascã propriile lor sisteme de
memorie virtualã; fiecare zonã de memorie are un proces responsabil
care pagineazã zona.  În Unix de acest lucru se ocupã nucleul.  Un
watchdog, împreunã cu apelul de sistem <TT>mmap()</TT>, ar putea
permite implementarea unor mecanisme ca cele din Mach: <TT>mmap()</TT>
transformã un fiºier într-o zonã de memorie, iar managementul
fiºierului este fãcut de un watchdog.  Schema asta este foarte
flexibilã; folosind-o se poate implementa de pildã un sistem de
memorie partajatã distribuitã (DSM: distributed shared memory), în
care mai multe procese de pe calculatoare diferite scriu în
``aceeaºi'' zonã de memorie;

<P>
</DD>
<DT><STRONG>colectare de statistici:</STRONG></DT>
<DD>putem scrie un watchdog care numãrã
accesele la fiºiere pentru a permite eventual optimizarea plasãrii
fiºierelor des accesate sau studii despre obiceiurile programatorilor;

<P>
</DD>
<DT><STRONG>mecanismul de portal din BSD Unix:</STRONG></DT>
<DD>BSD 4.4 conþine un mecanism
numit ``portal'' care foloseºte nume de fiºiere pentru ``obiecte''
din reþea; de pildã o legãturã <TT>telnet</TT> TCP/IP la
calculatorul foo.bar.org are un fiºier numit
<TT>/portal/tcpip/foo.bar.org/telnet</TT>.  Un proces care deschide
acest fiºier stabileºte de fapt o legãturã telnet cu acel
calculator.  (Un portal este un fel de URL).

<P>
</DD>
<DT><STRONG>controlul versiunii:</STRONG></DT>
<DD>sistemul de fiºiere Translucent de la Sun
creazã pentru fiecare fiºier cîte o ``versiune'' nouã atunci cînd
este modificat, permiþînd astfel recuperarea versiunilor mai vechi.
Watchdog-ul poate face ceva asemãnãtor;

<P>
</DD>
<DT><STRONG>fiºiere la distanþã:</STRONG></DT>
<DD>vom vedea aceastã aplicaþie în
articolul de faþã;

<P>
</DD>
<DT><STRONG>etc.</STRONG></DT>
<DD>mai putem imagina ºi alte aplicaþii ale mecanismului de
watchdog, dar ne oprim aici.
</DD>
</DL>

<P>

<H1><A NAME="SECTION00050000000000000000">
Arhitectura sistemului</A>
</H1>

<P>

<H2><A NAME="SECTION00051000000000000000">
Terminologie</A>
</H2>

<P>
Sã stabilim niºte convenþii terminologice ca sã simplificãm
discuþia.  Voi numi ``watchdog'' atît procesul care supervizeazã
accesul la un fiºier cît ºi structurile de date din nucleu prin
care watchdog-ul este implementat.

<P>
Procesele care acþioneazã asupra fiºierului supervizat vor fi
numite ``clienþi'' ai watchdog-ului.

<P>

<H2><A NAME="SECTION00052000000000000000">
Arhitectura</A>
</H2>

<P>
Un singur lucru mai avem de lãmurit: cum comunicã procesul watchdog
cu nucleul.  În Unix nu existã nici un mecanism prin care nucleul
sã cearã servicii unui proces.  Am ales urmãtoarea variantã,
inspiratã de sistemul de fiºiere <TT>/proc</TT>: un watchdog
comunicã cu nucleul folosind apelurile de sistem pentru a scrie/citi
fiºiere.  (Aceastã soluþie este diferitã de cea oferitã de
articolul lui Bershad.)

<P>
Introducem un nou apel de sistem prin care nucleul creazã un
``fiºier'' special, de tip ``watchdog''.  Sã ne reamintim cã în
interiorul nucleului fiºierele se reprezintã printr-o structurã de
date specialã numitã <I>vnod</I><A NAME="tex2html3"
  HREF="#foot77"><SUP>3</SUP></A>.  Din multe puncte de vedere funcþionarea unui
watchdog seamãnã cu cea a unui <I>pipe</I> între douã procese; în
interiorul nucleului se vor implementa la fel, sub forma unor
``fiºiere'' (sau mai exact vnod-uri).

<P>
Figura&nbsp;<A HREF="proiect-html.html#arhitectura">1</A> ne aratã cum lucreazã un watchdog.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="arhitectura"></A><A NAME="278"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Arhitectura unui watchdog</CAPTION>
<TR><TD><IMG
 WIDTH="622" HEIGHT="404" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=14cm\epsffile{arhitectura.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Paºii execuþiei sunt urmãtorii:

<P>
Întîi procesul supervizor executã apelul de sistem
<TT>watchdog(fisier)</TT>, prin care anunþã nucleul cã vrea sã
devinã un watchdog pentru fiºierul indicat.  Nucleul construieºte
în interior un fiºier (vnod) care este asociat procesului watchdog
ºi returneazã acest fiºier special (sã-l numim în cele ce
urmeazã <TT>wd</TT>).

<P>

<OL>
<LI>Procesul watchdog încearcã sã citeascã ceva din acest
fiºier special (cu <TT>read(wd, request, sizeof(wd_request))</TT>;
nucleul blocheazã watchdog-ul în operaþia de citire pînã la
apariþia unui client;

<P>
</LI>
<LI>Un proces (client) încearcã sã acceseze fiºierul supervizat;

<P>
</LI>
<LI>Nivelul VFSSW (Virtual File System Switch; descris în <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#vfs">articolul</a>
citat mai sus din PC Report din februarie 1998) intercepteazã apelul
de sistem;

<P>
</LI>
<LI>Nucleul construieºte o structurã de date (de tipul
<TT>wd_request</TT>) care descrie apelul de sistem al clientului;
paseazã aceastã structurã în vnod-ul watchdog-ului.

<P>
</LI>
<LI>Procesul client este suspendat ºi watchdog-ul este trezit;

<P>
</LI>
<LI>Procesul watchdog terminã apelul de sistem început la pasul 0;
rezultatul acelei citiri este structura <TT>wd_request</TT>;

<P>
</LI>
<LI>Watchdog-ul descifreazã structura ºi acþioneazã în
consecinþã;

<P>
</LI>
<LI>Watchdog-ul ar putea decide sã acceseze el însuºi fiºierul
supervizat;

<P>
</LI>
<LI>Accesul watchdog-ului la acel fiºier nu este interceptat ci
merge direct la fiºier;

<P>
</LI>
<LI>Watchdog-ul pune rezultatul deciziei sale într-o structurã de
tipul <TT>wd_reply</TT> ºi face un <TT>write(wd, reply,
sizeof(wd_reply))</TT>, trimiþînd structura nucleului;

<P>
</LI>
<LI>Nucleul decodificã rãspunsul watchdog-ului;

<P>
</LI>
<LI>Nucleul re-porneºte clientul blocat;

<P>
</LI>
<LI>Nivelul VFSSW executã acþiunea indicatã de watchdog; dacã
watchdog-ul a trimis date acestea sunt pasate procesului;

<P>
</LI>
<LI>Dacã watchdog-ul a spus cã putem lãsa clientul sã facã cu
fiºierul ce a cerut, atunci clientul acceseazã direct fiºierul;

<P>
</LI>
<LI>Apelul de sistem al clientului se terminã.
</LI>
</OL>

<P>
Cu toþii sunt gata pentru un nou ciclu de operaþii de la pasul 0.

<P>
Observaþi cã toatã procesarea watchdog-ului este absolut
independentã de tipul fiºierului accesat (pentru cã se petrece în
nivelul VFSSW); fie cã fiºierul este DOS, Unix sau NFS, watchdog-ul
face acelaºi lucru.  Din cauza asta un watchdog poate superviza orice
fel de fiºier sau obiect care se reprezintã în nucleu ca un
fiºier, cum ar fi un periferic, un pipe sau o conexiune de reþea
(socket).

<P>

<H2><A NAME="SECTION00053000000000000000">
Un exemplu de watchdog</A>
</H2>

<P>
Iatã o implementare a unui proces watchdog foarte simplu, care
permite deschiderea unui fiºier, dar nu scrierea în acel fiºier.
Cînd un proces citeºte din fiºier, rezultatul va fi întotdeauna
ºirul ``Paseaza datele astea clientului cind citeste'' (sau un
prefix, dacã clientul a citit mai puþin decît lungimea ºirului).

<P>
<PRE>
#include "watchdog.h"

int main()
{
   int fd, /* Fisier de supervizat. */ 
       wd; /* Interfata watchdog-ului cu nucleul. */
   char buf[] = "Paseaza datele astea clientului cind citeste";

   fd = open("nume_fisier", O_RDWR); /* e nevoie de permisiuni de scriere/citire. */
   wd = watchdog(fd);   /* apel de sistem: ne inregistram ca watchdog. wd=descriptor de fisier */

   while (1) {
      struct wd_request wq;   /* nucleul va descrie apelul de sistem aici */
      struct wd_reply   wr;   /* watchdog-ul raspunde nucleului aici */

      read(wd, (char*)&amp;wq, sizeof(wq));     /* Asta blocheaza watchdog-ul pina
                                               cind nucleul are ceva de zis */
      switch (wq.operation) {
        case WD_OPEN:
                printf("Procesul %d deschide `nume_fisier', mod %d\n", wq.mode);
                wr.action = WD_ALLOW;  /* lasam procesul sa faca ce a cerut */
                break;
        case WD_READ:
                printf("Procesul %d citeste din `nume_fisier', offset %ld,"
                        "marime %ld\n", wq.pid, wq.offset, wq.size);
                wr.action = WD_FAKE;  /* Watchdog-ul o sa dea datele procesului */
                if (wq.size &lt; sizeof(buf)) wr.size = wq.size;
                else wr.size = sizeof(buf);  /* Ii dam atitea date pentru read() */
                wr.buffer = buf;      /* Aici sunt datele de pasat procesului */
                break;
        case WD_WRITE:
                printf("Procesul %d vrea sa scrie in `nume_fisier', offset %ld,"
                        "marime %ld\n", wq.pid, wq.offset, wq.size);
                wr.action = WD_DENY;  /* Nu permitem scrierea. */
                break;
      }
      write(wd, (char *)&amp;wr, sizeof(wr));    /* Trimite raspunsul nucleului. */
      if (wq.operation == WD_CLOSE) break;   /* Daca clientul a inchis fisierul, terminam*/
   }
   close(fd);  /* Gata cu supervizarea fisierului. */
   close(wd);  /* Inchidem fisierul ``watchdog''. */
}
</PRE>
<P>
<FONT SIZE="-1">Iatã cum aratã în implementarea noastrã informaþiile de la nucleu
ºi rãspunsurile:
</FONT>
<P>
<PRE>
enum operation {                /* apeluri de sistem interceptate */
        WD_READ, WD_WRITE, WD_OPEN, WD_CLOSE, WD_LSEEK
};

enum action {                   /* ce spune watchdog-ul nucleului */
        WD_ALLOW,               /* :da-i voie sa faca ce a cerut */
        WD_DENY,                /* :clientul nu are voie sa faca asta */
        WD_FAKE                 /* :OK, paseaza datele la/de la
                                        watchdog (nu din fisier) */
};

struct wd_request {     /* Descrierea operatiei, primita de watchdog de la nucleu */
        enum operation operation; /* operatia */
        int fd;                 /* care fisier */
        int pid;                /* care proces */
        int uid;                /* posesorul procesului */
        int gid;                /* grupul procesului */
        long offset;            /* unde in fisier se opereaza */
        int size;               /* citi octeti se transfera */
        int mode;               /* drepturile cu care se deschide fisierul */
        int whence;             /* pentru lseek: de unde se face lseek */
        int inode_count;        /* cite procese au deschis acest fisier */
};

struct wd_reply {               /* Raspunsuri de la watchdog la nucleu: */
        enum action action;     /* ce actiune sa faca nucleul */
        int fd;                 /* pe care fisier (pot fi mai multe simultan) */
        char * buf;             /* daca e FAKE aici sunt datele pentru read/write */
        int count;              /* cit de multe date pentru read/write */
};
</PRE>
<P>
<FONT SIZE="-1">Singura operaþie care meritã explicaþii este <TT>FAKE</TT>
(``simuleazã'').  Cînd un client face o citire ºi watchdog-ul
rãspunde cu <TT>FAKE</TT>, nucleul trebuie sã preia datele de citit
nu din fiºier ci din buffer-ul indicat de watchdog.
</FONT>
<P>
<FONT SIZE="-1">Cînd un client face o scriere ºi watchdog-ul zice <TT>FAKE</TT>,
nucleul nu trebuie sã scrie datele în fiºier ci în buffer-ul
indicat de watchdog.
</FONT>
<P>

<H1><A NAME="SECTION00060000000000000000">
O întrebare: eficacitatea</A>
</H1>
<P>
<FONT SIZE="-1">Iatã deci principalul avantaj al unui astfel de mecanism:
<I>flexibilitatea</I>.  Un watchdog ne permite sã implementãm o
sumedenie de servicii noi dar fãrã a modifica cu nimic interfeþele
existente, pãstrînd în întregime compatibilitatea.  Procesele care
lucreazã cu fiºiere nu vor afla niciodatã cã de fapt vorbesc cu un
watchdog, pentru ca folosesc exact aceleaºi apeluri de sistem ca
mai-nainte.
</FONT>
<P>
<FONT SIZE="-1">Nimic nu e pe gratis, însã.  Ce avem de plãtit pentru aceastã
flexibilitate?
</FONT>
<P>
<FONT SIZE="-1">Rãspunsul este clar: performanþã.  De fiecare datã cînd un proces
acceseazã un fiºier cu watchdog avem de fãcut multe alte lucruri
în plus faþã de cazul ``normal''. 
</FONT>
<P>
<FONT SIZE="-1">Aceasta este una din tezele acestui articol:
</FONT>
<P>

<BLOCKQUOTE><FONT SIZE="-1"><EM>Înainte de a ne lansa în implementarea unui proiect trebuie sã
estimãm dacã meritã.  Pentru asta trebuie sã avem o idee despre
performanþa sistemului.  
</EM></FONT></BLOCKQUOTE>
<P>
<FONT SIZE="-1">Mai ales dacã avem de construit un sistem foarte mare, trebuie sã ne
facem o idee despre performanþã <I>înainte</I> de a construi
sistemul.  Dacã rezultatul o sa fie de 10 ori mai lent decît orice
existã atunci nu meritã; trebuie reconsiderat întreg proiectul.
</FONT>
<P>
<FONT SIZE="-1">Hai deci sã estimãm ce avem de pierdut.  Care este deci
<I>cãrarea criticã</I>: traseul execuþiei care costã cel mai mult.
</FONT>
<P>

<H2><A NAME="SECTION00061000000000000000">
Componentele costului</A>
</H2>
<P>
<FONT SIZE="-1">Din pãcate cam toþi paºii din figura de mai sus&nbsp;<A HREF="proiect-html.html#arhitectura">1</A>
sunt pe cãrarea criticã, mai puþin pasul 0, care este executat în
paralel de watchdog ºi de client.
</FONT>
<P>

<H3><A NAME="SECTION00061100000000000000">
Costul fãrã watchdog</A>
</H3>
<P>
<FONT SIZE="-1">Dacã nu avem watchdog, o operaþie pe un fiºier constã doar din
paºii 1, 2, 13 ºi 14.  Toþi ceilalþi paºi sunt suplimentari
(overhead), iar costul lor <I>relativ</I> trebuie sã fie scãzut ca
operaþia watchdog-ului sã nu fie disruptivã pentru performanþã.
</FONT>
<P>

<H3><A NAME="SECTION00061200000000000000">
Costul suplimentar cu watchdog</A>
</H3>
<P>
<FONT SIZE="-1">Ia sã vedem ce fel de costuri plãtim pentru watchdog:
</FONT>
<P>

<UL>
<LI>2 comutãri de privilegiu între nucleu ºi spaþiul utilizator:
una în pasul 5 cînd nucleul vorbeºte cu watchdog-ul ºi una în
pasul 9, cînd watchdog-ul raspunde; asta înseamnã cam cît costul
unui apel de sistem obiºnuit;

<P>
</LI>
<LI>În pasul 7 watchdog-ul ar putea face el însuºi apeluri de
sistem (depinde de funcþionalitatea pe care o oferã);

<P>
</LI>
<LI>Pasul 8 al watchdog-ului ar putea costa foarte mult: cît un
acces la fiºier;

<P>
</LI>
<LI>Paºii 12 sau 3 copiazã date între proces ºi watchdog; dacã
datele sunt multe asta costã substanþial;

<P>
</LI>
<LI>Paºii 4 ºi 11 comutã execuþia între proces ºi watchdog;
avem deci cel puþin douã comutãri de procese.
</LI>
</UL>
<P>
<FONT SIZE="-1">Ceilalþi paºi sunt relativ neglijabili în cost<A NAME="tex2html5"
  HREF="#foot116"><SUP>4</SUP></A>.
</FONT>
<P>
<FONT SIZE="-1">Rezultatele sunt prezentate într-un tabel:
</FONT>
<P>

<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">
Operaþie suplimentarã </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> Cantitate </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
Apel de sistem          </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 2 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
Comutare de proces      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 2 -- zeci </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
Copiere a datelor       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 2 </FONT></TD>
</TR>
</TABLE></DIV>
<P>

<H4><A NAME="SECTION00061210000000000000">
Copierea datelor între procese.</A>
</H4>
<P>
<FONT SIZE="-1">Întrebarea este ``cum putem copia date între douã procese''?
Problema constã în faptul cã atunci cînd un proces se executã,
foloseºte propriul sãu spaþiu de memorie virtualã; fiecare proces
are propria lui adresã 5, care nu coincide cu a nici unui alt proces.
Atunci cum pot muta date de la o adresa 7 dintr-un proces la adresa 12
a altui proces?  Nicicum direct, pentru cã atunci cînd se executã
primul, adresa celui de-al doilea nu are sens ºi invers.
</FONT>
<P>
<FONT SIZE="-1">Soluþia este ca datele sã fie copiate în <I>interiorul
nucleului</I>, care aparþine ambelor spaþii de adrese.  (Acesta este
ºi mecanismul folosit de <I>pipe</I> în Unix pentru a transfera
datele între procese.)  Soluþia este deci urmãtoarea:
</FONT>
<P>

<UL>
<LI>Pentru fiecare vnod watchdog alocãm în nucleu un buffer
temporar (nu prea mare, pentru cã memoria nucleului costã, nefiind
paginabilã);

<P>
</LI>
<LI>Ca sã copiem date între douã procese facem aºa: executãm
primul proces, luãm date cît sã umple buffer-ul, îl blocãm pe
primul, dupã care comutãm la al doilea;

<P>
</LI>
<LI>Cînd se executã al doilea golim buffer-ul, blocãm procesul
ºi ne întoarcem la primul;

<P>
</LI>
<LI>Repetãm operaþia pînã am transferat toate datele.
</LI>
</UL>
<P>
<FONT SIZE="-1">Iatã de ce transferul de date implicã mai multe comutãri de
procese; numãrul lor depinde de raportul dintre cantitatea de date
transferate ºi mãrimea buffer-ului intern.  În implementarea
noastrã am folosit un buffer intern de 8Kb (douã pagini).  Asta
înseamnã cã 1Mb de transferat implicã 1000/8 = 125 de comutãri de
proces înainte ºi înapoi.
</FONT>
<P>

<H2><A NAME="SECTION00062000000000000000">
Costul componentelor</A>
</H2>
<P>
<FONT SIZE="-1">Acum hai sã vedem cît costã <I>concret</I> fiecare componentã.
Asta o sã ne dea o idee despre fezabilitate.  Niºte mãsurãtori
simple<A NAME="tex2html6"
  HREF="#foot129"><SUP>5</SUP></A> pentru sistemul pe
care am implementat watchdog-ul (PII 266MHz cu 64M RAM, rulînd Linux
2.0.30) au dat urmãtoarele valori:
</FONT>
<P>

<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">
Operaþie          </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> Cost în <IMG
 WIDTH="17" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$\mu$">s </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
Apel de sistem     </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 2 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
Comutare de proces </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 7.5 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
Copiere de date    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 20 000-40 000/Mb </FONT></TD>
</TR>
</TABLE></DIV>
<P>
<FONT SIZE="-1">(Durata copierii depinde de mai mulþi factori; dimensiunea
influenþeazã rata de succes în cache, care influenþeazã viteza.)
</FONT>
<P>
<FONT SIZE="-1">Se vede cã dominant este costul <I>copierii</I>, chiar pentru
cantitãþi mici de date (1Kb ar lua peste 10<IMG
 WIDTH="17" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$\mu$">s) pentru o copiere,
iar noi avem de fãcut douã, una ``în sus'' ºi una ``în jos''.
</FONT>
<P>

<H2><A NAME="SECTION00063000000000000000">
Performanþa relativã</A>
</H2>
<P>
<FONT SIZE="-1">Toate aceste evaluãri nu s-au preocupat de loc de costul accesului la
disc.  Ori discul este un periferic extrem de lent; numai mutarea
braþului dureazã de ordinul a 10ms (10 000 de <IMG
 WIDTH="17" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$\mu$">s!).  Costul
<I>suplimentar</I> (overhead) al watchdog-ului pentru astfel de
circumstanþe devine oarecum neglijabil.
</FONT>
<P>
<FONT SIZE="-1">Citirea dintr-un fiºier de pe disc (deschis dinainte) a 1Mb de date
dureazã cam 150ms.  Costul operaþiilor watchdog-ului pentru o
operaþie care implicã 1Mb este cam de 40ms + 0.0075ms * 125 + 0.004
= 41ms, deci cam de 25%.
</FONT>
<P>
<FONT SIZE="-1">Pe scurt, iatã importanþa costului suplimentar al unui watchdog, în
funcþie de tipul operaþiei efectuate:
</FONT>
<P>

<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">
Discul accesat  </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> Cantitate de date </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> Overhead </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
nu              </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> puþine           </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 1000%   </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
nu              </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> multe             </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 200%    </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
da              </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> oricîte          </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 25-50%  </FONT></TD>
</TR>
</TABLE></DIV>
<P>

<H2><A NAME="SECTION00064000000000000000">
Utilitatea proiectului revizuitã</A>
</H2>
<P>
<FONT SIZE="-1">Iatã cum o simplã evaluare <I>teoreticã</I> ne spune deja foarte
multe lucruri despre mecanismul de watchdog: ne spune de pildã ce fel
de servicii meritã sã fie oferite de watchdog ºi care nu.  Dacã un
serviciu costã mult mai puþin decît overhead-ul, atunci watchdog-ul
este prea costisitor ºi trebuie sã cãutãm altã soluþie.
</FONT>
<P>
<FONT SIZE="-1">De exemplu nu renteazã sã implementãm ACL (controlul accesului) cu
watchdog, pentru cã astfel de operaþii nu transferã date ºi nu
acceseazã discul (decît prima oarã cînd un fiºier este deschis;
urmãtoarele accese vor merge în cache).  Pentru astfel de operaþii
citim din tabelul de mai sus cã watchdog-ul încetineºte operaþia
de 10 ori!  Locul unui astfel de serviciu este în nucleul sistemului
de operare.
</FONT>
<P>
<FONT SIZE="-1">Un watchdog nu va fi prea costisitor în urmãtoarele cazuri:
</FONT>
<P>

<UL>
<LI>Cînd operaþiile pe fiºiere implicã acces frecvent la disc
(de exemplu datoritã unei localitãþi proaste în cache: accese
aleatoare);

<P>
</LI>
<LI>Cînd operaþiile se fac pe cantitãþi mari de date ºi pot
beneficia de optimizãri speciale specifice aplicaþiei.
</LI>
</UL>
<P>

<H2><A NAME="SECTION00065000000000000000">
O mãsurãtoare a performanþei</A>
</H2>
<P>
<FONT SIZE="-1">Acum cã am vãzut cã un watchdog nu e complet inutil ne-am apucat
sã implementãm mecanismele necesare.  Am construit în nucleu
intercepþia apelurilor de sistem ºi am scris apoi un watchdog foarte
foarte simplu (care seamãnã cu cel din exemplul de cod anterior), cu
care am mãsurat performanþa realã.  Acum vom vedea dacã estimarea
noastrã teoreticã de mai sus a fost realistã.
</FONT>
<P>
<FONT SIZE="-1">Am fãcut un set de 5 experimente, dupã cum urmeazã:
</FONT>
<P>

<OL>
<LI>Am executat un apel de sistem <TT>lseek()</TT> (nu atinge
discul);
</LI>
<LI>Am executat un <TT>lseek()</TT> dupã care am citit din fiºier
un octet;
</LI>
<LI>Am executat <TT>lseek()</TT> ºi am citit o paginã (4K);
</LI>
<LI><TT>lseek()</TT> urmat de citirea a 40K;
</LI>
<LI><TT>lseek()</TT> urmat de citirea a 1M.
</LI>
</OL>
<P>
<FONT SIZE="-1">Am mãsurat costul acestor operaþii atunci cînd sunt efectuate de
cinci entitãþi diferite:
</FONT>
<P>

<OL>
<LI>Costul atunci cînd folosim pentru acelaºi scop douã procese
care comunicã printr-un <I>named pipe</I> (am remarcat mai sus
asemãnarea dintre un watchdog ºi un pipe); (operaþia
<TT>lseek()</TT> nu are sens pe un pipe; se va termina mereu cu o
eroare; am pus-o ca sã mãsurãm acelaºi lucru în toate cazurile);
</LI>
<LI>Costul operaþiei executate de sistemul de operare (SO);
</LI>
<LI>Costul operaþiei atunci cînd watchdog-ul interzice operaþia;
</LI>
<LI>Costul atunci cînd watchdog-ul zice ``da'' (ALLOWED) iar
nucleul executã operaþia;
</LI>
<LI>Costul atunci cînd watchdog-ul executã el însuºi operaþia
ºi paseazã datele clientului (FAKE).
</LI>
</OL>
<P>
<FONT SIZE="-1">Toate operaþiile se fac cu datele în cache; discul nu este folosit
niciodatã.  Iatã rezultatele, în microsecunde:
</FONT>
<P>

<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">
Operaþie </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> seek </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> read(1) </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> read(4096) </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> read(40K) </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> read(1M) </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
SO       </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1">   2.1  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 5.1    </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 8.6        </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 220       </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 21406    </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
pipe     </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1">   2.2  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 11     </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 66         </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 720       </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 57812    </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
interzis </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1">   17   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 33     </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 33         </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 33        </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 33       </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
permis   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1">   17   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 35     </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 42         </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 270       </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 22968    </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
watchdog </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1">   20   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 44     </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 88         </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 634       </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 50300    </FONT></TD>
</TR>
</TABLE></DIV>
<P>
<FONT SIZE="-1">Rezultatele par sã confirme estimãrile noastre: interzicerea costã
o valoare constantã: 17<IMG
 WIDTH="17" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$\mu$">s pentru fiecare serviciu (2 comutãri de
procese plus 1 apel de sistem).  Darea permisiunii adaugã un cost
constant la operaþia cu SO: cel al comutãrii la watchdog ºi
înapoi.  Cînd watchdog-ul face operaþia el însuºi costul copierii
datelor între watchdog ºi client apare în ecuaþie ºi dominã la
cantitãþi mari de date.
</FONT>
<P>
<FONT SIZE="-1">Demn de remarcat este cã datoritã unor optimizãri simple,
watchdog-ul este mai rapid ca un <I>pipe</I>.  Codul nostru foloseºte
buffere în nucleu de douã ori mai mari decît un pipe, (deci face de
douã ori mai puþine comutãri), ºi apoi permite unui apel de sistem
<TT>read()</TT> sã returneze mai mult decît o paginã de date (pipe
nu permite aºa ceva), deci reduce numãrul de apeluri de sistem
executate de client.
</FONT>
<P>

<H1><A NAME="SECTION00070000000000000000">
O aplicaþie a mecanismului: un sistem de fiºiere la
distanþã</A>
</H1>
<P>
<FONT SIZE="-1">Un watchdog este un <I>mecanism</I>.  Avem nevoie de o aplicaþie
pentru a demonstra utilitatea lui.  Am ales o aplicaþie al cãrei
cost intrinsec promitea sã facã overhead-ul unui watchdog
neglijabil: accesul la fiºiere la distanþã, prin reþea.  Timpul
mare de transfer al unei reþele este factorul pe care ne bazãm.
Sã observãm cã latenþa (timpul de transfer) reþelelor este
relativ mare, fiind limitatã de viteza de transmisiune, care nu poate
fi mai mare ca viteza luminii.  Cantitatea de date transmise
(bandwidth sau throughput) este oarecum nelimitatã; vezi reþelele
giga-bit/secundã care devin populare.
</FONT>
<P>

<H2><A NAME="SECTION00071000000000000000">
Alþi candidaþi ºi slãbiciunile lor</A>
</H2>
<P>
<FONT SIZE="-1">Sisteme de fiºiere la distanþã existã de cînd lumea; NFS (Network
File System) de la firma SUN este extrem de popular.  Ne-am propus sã
scriem serviciul nostru în aºa fel încît sã batem NFS-ul.  Pentru
asta trebuie sã profitãm de lucrurile la care NFS este slab.  NFS
este (în implementarea pe Linux) foarte slab la scrieri: deºi þine
într-un cache la client datele citite, scrierile le trimite direct la
server, ca nu cumva alþi clienþi care folosesc acelaºi fiºier sã
nu le vadã.  Mãrimea blocului de cache pentru NFS este de 8K.
</FONT>
<P>
<FONT SIZE="-1">Un al doilea candidat faimos este sistemul de fiºiere distribuit
dezvoltat la Universitatea Carnegie Mellon numit AFS (Andrew File
System).  Andrew este mult mai inteligent ºi foloseºte mult mai bine
cache-ul de la client<A NAME="tex2html7"
  HREF="#foot272"><SUP>6</SUP></A>.  Mãrimea blocului pentru cache-ul Andrew este de 64K.
</FONT>
<P>

<H2><A NAME="SECTION00072000000000000000">
Un serviciu de ``caching'' inteligent</A>
</H2>
<P>
<FONT SIZE="-1">Am discutat pe larg despre performanþa în sistemele de
fiºiere într-un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#rapid-fs">articol</a>
publicat în PC Report în noiembrie 1997.  Voi recapitula aici faptele
care ne intereseazã:
</FONT>
<P>
<FONT SIZE="-1">Sã observãm cã pentru o aplicaþie scrierile ºi citirile se
comportã în mod deosebit:
</FONT>
<P>

<UL>
<LI>Durata scrierilor nu conteazã, pentru cã odatã trimise datele
aplicaþia poate continua execuþia, iar datele se îndreaptã spre
destinaþia lor în acelaºi timp.  Aplicaþia nu trebuie sã aºtepte
terminarea scrierii.  Din cauza asta scrierile sunt <I>asincrone</I>.

<P>
</LI>
<LI>Citirile costã, pentru cã aplicaþia nu poate continua
execuþia fãrã prezenþa datelor.  Dacã nu se folosesc tehnici
speciale de anticipare a citirilor (read-ahead sau prefetching)
citirile sunt practic <I>sincrone</I>.
</LI>
</UL>
<P>
<FONT SIZE="-1">Toate sistemele de fiºiere de reþea încearcã sã amortizeze
latenþa reþelei fãcînd transferuri în <I>blocuri mari</I> de
date.  Cam tot atîta costã sã aduci un octet cît costã 10K, aºa
cã de ce sã nu aduci 10K; poate mai ai nevoie de ei.  Aceastã
caracteristicã a cache-urilor, de a manipula blocuri mari, este
uneori ºi slãbiciunea lor.
</FONT>
<P>
<FONT SIZE="-1">Iatã de ce: problema constã în <I>scrierile mici</I>.  Cînd un
proces scrie mai puþin de un bloc, pentru cã cache-ul manipuleazã
numai blocuri întregi, trebuie sã aducã de la server blocul întreg
ºi sã aplice scrierea peste bloc.  Din cauza asta <I>scrierile
mici sunt sincrone</I>, ca ºi citirile.
</FONT>
<P>
<FONT SIZE="-1">Acest lucru este adevãrat atît în NFS cît ºi în AFS.
</FONT>
<P>
<FONT SIZE="-1">Am scris deci propriul nostru serviciu de cache.  Am încercat sã
exploatãm slãbiciunile sistemelor de fiºiere de reþea în douã
feluri:
</FONT>
<P>

<UL>
<LI>Cache-ul pe care l-am implementat nu mai foloseºte ca unitate
de bazã blocul, ci <I>intervalul</I>.  Dimensiunea intervalului nu
mai este fixã; dacã utilizatorul manipuleazã 1Mega, atunci cache-ul
stocheazã un mega ºi eventual transmite un mesaj de 1M, fiind mult
mai eficace decît multe mesaje mici;

<P>
</LI>
<LI>Cache-ul nostru poate absorbi scrierile mici asincron; sunt doar
niºte intervale ca toate altele.
</LI>
</UL>
<P>
<FONT SIZE="-1">Deºi este foarte interesant în sine, nu vom explora aici arhitectura
cache-ului cu intervale.  Doar intern cache-ul manipuleazã datele tot
în blocuri, iar mãrimea blocului din cache are un oarecare impact
asupra performanþei.  
</FONT>
<P>
<FONT SIZE="-1">Sã vedem cum este el folosit împreunã cu un watchdog pentru a oferi
servicii îmbunãtãþite clienþilor.
</FONT>
<P>

<H2><A NAME="SECTION00073000000000000000">
Serviciul de fiºiere la distanþã</A>
</H2>
<P>
<FONT SIZE="-1">Am implementat deci un watchdog care este ºi un cache manager.  Am
implementat apoi un server care va comunica cu watchdog-ul prin
TCP-IP.  Cache-ul este împãrþit în douã thread-uri care
funcþioneazã asincron:
</FONT>
<P>

<UL>
<LI>``Jumãtatea de jos'' (bottom half) se ocupã de comunicarea în
reþea ºi goleºte asincron cache-ul cînd e plin;
</LI>
<LI>``Jumãtatea de sus'' (top half) este ºi watchdog-ul:
intercepteazã apelurile clienþilor ºi copiazã datele din/în
cache.
</LI>
</UL>
<P>
<FONT SIZE="-1">Pachetul de thread-uri folosit a fost scris tot de
autorul acestui articol, ºi a fost <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#threads">prezentat</a>
în PC Report din ianuarie 1997.
</FONT>
<P>
<FONT SIZE="-1">Figura&nbsp;<A HREF="proiect-html.html#poornfs">2</A>
prezintã arhitectura sistemului de fiºiere.
</FONT>
<P>
<FONT SIZE="-1">
 </FONT>
<P></P>
<DIV ALIGN="CENTER"><A NAME="poornfs"></A><A NAME="284"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Arhitectura Sistemului de fiºiere la distanþã.</CAPTION>
<TR><TD><IMG
 WIDTH="619" HEIGHT="262" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=14cm\epsffile{poornfs.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00074000000000000000">
Mãsurãtori de performanþã</A>
</H2>
<P>
<FONT SIZE="-1">Iatã secþiunea crucialã, cea a mãsurãtorilor de performanþã
comparative.  Am fãcut experimente numai pentru cazurile care ne
intereseazã (unde anticipãm cã sistemul nostru o sã fie ``mai
tare''), ºi anume:
</FONT>
<P>

<UL>
<LI>Scrieri mici rãspîndite, care în alte sisteme sunt sincrone;
</LI>
<LI>Operaþii cu date foarte multe, secvenþiale (unde intervalele
mari transmise sunt foarte eficace).
</LI>
</UL>
<P>
<FONT SIZE="-1">În testele noastre am avut sub control calculatoarele client
(întotdeauna maºina Linux descrisã mai sus).  Serverul pentru
watchdog ºi NFS a fost pe o maºinã Sun SPARC4.  Maºinile nu erau
încãrcate la mãsurãtori.  Maºinile sunt pe acelaºi cablu
Ethernet, separate doar de bridge-uri.
</FONT>
<P>
<FONT SIZE="-1">Nu am avut sub control:
</FONT>
<P>

<UL>
<LI>Încãrcarea reþelei;
</LI>
<LI>Serverul AFS.
</LI>
</UL>
<P>
<FONT SIZE="-1">Din cauza asta am repetat mãsurãtorile de mai multe ori ºi am
considerat <I>cele mai bune</I> valori ale performanþei.
</FONT>
<P>

<H3><A NAME="SECTION00074100000000000000">
Teste secvenþiale</A>
</H3>
<P>
<FONT SIZE="-1">Iatã un test secvenþial care doar copiazã un fiºier de 2M între
cele douã maºini (cu comanda Unix <TT>cp</TT>).  Cache-ul nostru
avea un bloc intern de 64K.  Cache-urile <I>erau goale</I> la
începutul transferului.
</FONT>
<P>
<FONT SIZE="-1">Cache-ul folosit de AFS ºi NFS poate creºte pînã la aprox. 60M,
mãrimea memoriei calculatorului.  WD a avut un cache fixat la 640K
capacitate totalã.
</FONT>
<P>
<FONT SIZE="-1">Comparãm 4 sisteme:
</FONT>
<P>
<DL>
<DT><STRONG>UFS:</STRONG></DT>
<DD>Sistemul de fiºiere din Unix de pe discul local;
</DD>
<DT><STRONG>NFS:</STRONG></DT>
<DD>Sun Network File System;
</DD>
<DT><STRONG>AFS:</STRONG></DT>
<DD>Andrew File System;
</DD>
<DT><STRONG>WD: </STRONG></DT>
<DD>sistemul nostru de fiºiere bazat pe watchdog.
</DD>
</DL>
<P>
<FONT SIZE="-1">Ceea ce mãsurãm este <I>timpul total real al copierii</I> (adicã
cît timp trece de cînd începe pînã se terminã); asta nu e totuna
cu timpul de execuþie al proceselor, pentru cã procesele vor dormi
mult timp aºteptînd datele, deci nu vor consuma timp de procesor.
Copierea se terminã cu un apel de sistem <TT>fsync()</TT> care ne
asigurã cã toate datele au fost trimise la destinaþie, ºi cã nu
au rãmas în cache-ul local!
</FONT>
<P>

<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">
Protocol </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> Sursã           </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> Destinaþie     </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> Timp (s)</FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
UFS      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> disc local       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> disc local      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 0.2  </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
NFS      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> la distanþã    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> disc local      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 8.4  </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
WD       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> la distanþã    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> disc local      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 6.9  </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
AFS      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> la distanþã    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> disc local      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 5.3  </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
NFS      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> disc local       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> la distatþã   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 61.0   </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
WD       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> disc local       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> la distanþã   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 11.3 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
AFS      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> disc local       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> la distanþã   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 9.5  </FONT></TD>
</TR>
</TABLE></DIV>
<P>
<FONT SIZE="-1">Dupã cum se vede am reuºit sã-l batem pe NFS.  NFS face citire
anticipatã (read-ahead), de aceea performanþa la citire este
rezonabilã.  NFS trimite datele una cîte una în blocuri de 8K, deci
pierde foarte mult timp la scrieri pentru a iniþia pachetele.
</FONT>
<P>
<FONT SIZE="-1">AFS trimite blocuri de 64K, deci este foarte eficient.  AFS face ºi
el citire anticipatã.  AFS este implementat în nucleul sistemului de
operare (ca ºi NFS), deci nu are overhead atît de mare ca WD pentru
comutarea proceselor ºi copierea datelor (mai ales!).  De aceea este
mai performant.
</FONT>
<P>

<H3><A NAME="SECTION00074200000000000000">
Performanþa secvenþialã variind bufferele</A>
</H3>
<P>
<FONT SIZE="-1">Datele trebuie sã circule între client ºi server prin douã canale:
</FONT>
<P>

<UL>
<LI>Între watchdog ºi serverul la distanþã pe reþea;
</LI>
<LI>Între watchdog ºi clientul local prin memorie.
</LI>
</UL>
<P>
<FONT SIZE="-1">Performanþa primului transfer este influenþatã de mãrimea blocului
intern de cache folosit (deºi noi transmitem mai multe blocuri pe
reþea într-o singurã operaþie, pentru cã folosim apelul de sistem
<TT>writev()</TT>, acesta impune un numãr maxim de 16 blocuri scrise
simultan).  Performanþa celei de-a doua este influenþatã de
<I>cîte date cere clientul într-un apel de sistem</I>.  Cît cere un
client într-un apel de sistem constituie pentru cache un interval.
</FONT>
<P>
<FONT SIZE="-1">De exemplu, programul <TT>cp</TT> copiazã datele în felii de cîte
4K, chiar dacã fiºierele sunt uriaºe.
</FONT>
<P>
<FONT SIZE="-1">De aceea am scris un alt client, care face ce face ºi <TT>cp</TT>,
dar care face transferul datelor în felii mai mari.
</FONT>
<P>
<FONT SIZE="-1">Iatã performanþa mãsuratã, din nou în secunde:
</FONT>
<P>

<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1">
Interval      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 1K </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 4K   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 16K </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 64K </FONT></TD>
</TR>
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1">  
bloc în cache</FONT></TD>
<TD ALIGN="CENTER" COLSPAN=4><FONT SIZE="-1"> Spre discul local</FONT></TD>
</TR>
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1">  
     64K      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 8   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1">  7   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1">  7  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 8 </FONT></TD>
</TR>
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1"> 
     32K      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 13  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 13   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 13  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 9 </FONT></TD>
</TR>
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1"> 
     16K      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 27  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 27   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 28  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 8 </FONT></TD>
</TR>
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1"> 
      8K      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 54  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 54   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 27  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 8 </FONT></TD>
</TR>
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1">  
              </FONT></TD>
<TD ALIGN="CENTER" COLSPAN=4><FONT SIZE="-1"> Spre discul distant</FONT></TD>
</TR>
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1">  
     64K      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 10  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 10   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 10  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 4 </FONT></TD>
</TR>
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1"> 
     32K      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 16  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 16   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 16  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 4 </FONT></TD>
</TR>
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1"> 
     16K      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 30  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 23   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 4   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 4 </FONT></TD>
</TR>
<TR><TD ALIGN="RIGHT"><FONT SIZE="-1"> 
      8K      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 48  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 57   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 4   </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 4 </FONT></TD>
</TR>
</TABLE></DIV>
<P>
<FONT SIZE="-1">Performanþa depinde mai puþin de mãrimea internã a blocului (cum
am spus, cache-ul poate trimite multe blocuri pe reþea dintr-un foc),
cît de mãrimea intervalului (cerutã printr-un apel de sistem).  Cu
cît intervalele sunt mai mari, cu atît performanþa este mai bunã.
</FONT>
<P>
<FONT SIZE="-1">Performanþa scrierilor este excelentã pentru cã scrierile sunt
asincrone tot timpul (indiferent de raportul interval/bloc).
</FONT>
<P>
<FONT SIZE="-1">O anomalie avem în tabel pe coloana a treia, unde scãderea blocului
creºte performanþa, un rezultat complet ne-intuitiv.  Acesta este un
artifact al modului de implementare: inspectarea codului cache-ului a
revelat faptul cã în cazul în care intervalul este mai mare ca
blocul, totul e în regulã, dar atunci cînd blocul este mai mare
decît intervalul, cache-ul iniþiazã operaþii care puteau fi
evitate.  (Iatã deci cum mãsurãtorile descoperã deficienþe de
implementare ºi sugereazã îmbunãtãþiri!)  Asta se întîmplã pe
coloana a treia: cînd blocul devine mai mic decît intervalul
performanþa creºte brusc.
</FONT>
<P>

<H3><A NAME="SECTION00074300000000000000">
Teste de acces aleator</A>
</H3>
<P>
<FONT SIZE="-1">Programele de calcul intensiv (scientific computing) manipuleazã
adesea cantitãþi enorme de date într-un mod cvasi-aleatoriu ºi în
bucãþi mici (au deci localitate proastã în cache ºi poate scrieri
mici).  Am scris douã aplicaþii (oarecum artificiale, dar
reprezentative la o scarã redusã, sperãm) care încearcã sã
simuleze astfel de accese:
</FONT>
<P>

<UL>
<LI>Un program care înmulþeºte douã matrici de 50*50 de elemente
direct într-un fiºier (în total 10K);
</LI>
<LI>Un program care sorteazã prin selecþie 200 de numere aleatoare
dintr-un fiºier ``in situ'' (800 octeþi).
</LI>
</UL>
<P>
<FONT SIZE="-1">Am plasat fiºierul la distanþã ºi am pus blocul în WD la 4K.
Iatã timpii mãsuraþi:
</FONT>
<P>

<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">
Test    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> Protocol </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> Duratã (s) </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
Matrici </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> UFS      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 1.6     </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
        </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> NFS      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 301.0     </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
        </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> WD       </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 22.5    </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
        </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> AFS      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 4.6    </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
Sortare </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> UFS      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 0.2     </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
        </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> NFS      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 13.6    </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
        </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> WD       </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 1.7     </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
        </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> AFS      </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 0.4     </FONT></TD>
</TR>
</TABLE></DIV>
<P>
<FONT SIZE="-1">Performanþa lui NFS este îngrozitor de slabã (de 12
ori mai lent decît metoda noastrã!)  Mãsurãtori care variau
dimensiunea n a matricii au arãtat cã pentru valori mici ale lui n
timpul lui NFS creºte ca n<sup>2</sup>.  Pentru cã înmulþirea face
n<sup>3</sup> citiri ºi n<sup>2</sup> scrieri deducem cã problema lui
NFS sunt scrierile mici (exact cum am anticipat).
</FONT>
<P>
<FONT SIZE="-1">AFS este excelent pentru cã toate datele încap într-un singur bloc
din cache (64K) care este adus imediat la început, deci face un
singur transfer pe reþea.
</FONT>
<P>
<FONT SIZE="-1">WD este mai slab din cauza overhead-ului comutãrii proceselor.
</FONT>
<P>

<H3><A NAME="SECTION00074400000000000000">
Un test greu pentru AFS: ``strides''</A>
</H3>
<P>
<FONT SIZE="-1">Am vrut sã gãsim ºi un test dificil pentru AFS.  Pentru cã AFS
aduce datele în blocuri de 64K soluþia era sã facem un test care
exploateazã foarte puþin din fiecare felie de 64K, deci care-l pune
pe AFS la muncã degeaba.
</FONT>
<P>
<FONT SIZE="-1">Testul este simplu: scrie într-un fiºier pre-existent de 2M petice
de cîte 20 de octeþi (scrieri mici!) la distanþe variabile
(distanþa dintre douã scrieri o vom numi ``stride'').  Am fãcut
douã serii de teste (blocul în cache-ul WD de 64K):
</FONT>
<P>

<UL>
<LI>În care cache-ul local la client era pre-încãrcat cu
fiºierul (cache ``cald'');
</LI>
<LI>În care cache-ul local era gol (``rece'').
</LI>
</UL>
<P>
<FONT SIZE="-1">Iatã rezultatele:
</FONT>
<P>

<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">
Protocol </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> Cache </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> Stride </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> Intervale scrise  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> Timp (s) </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
AFS      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> rece  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 1K     </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 64*25             </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 9.8 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
AFS      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> cald  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 1K     </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 64*25             </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 5.5 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
AFS      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> rece  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 64K    </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 25                </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 10.0 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
AFS      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> cald  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 64K    </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 25                </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 5.6 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1">  
WD       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> rece  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 1K     </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 64*25             </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 6.3 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
WD       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> cald  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 1K     </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 64*25             </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 6.4 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
WD       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> rece  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 64K    </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 25                </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 6.4 </FONT></TD>
</TR>
<TR><TD ALIGN="LEFT"><FONT SIZE="-1"> 
WD       </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> cald  </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 64K    </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 25                </FONT></TD>
<TD ALIGN="RIGHT"><FONT SIZE="-1"> 6.4 </FONT></TD>
</TR>
</TABLE></DIV>
<P>
<FONT SIZE="-1">WD este remarcabil de constant, pentru cã manipuleazã intervalele
scurte (20 de octeþi) în exact acelaºi fel indiferent unde se aflã
(practic datele sunt permanent în cache).  AFS este mai slab decît
WD cînd are cache-ul gol, dar nu cu mult mai slab!
</FONT>
<P>
<FONT SIZE="-1">Numerele aratã cã performanþa AFS nu depinde de cîte <I>date</I>
se scriu, ci de cîte intervale de 64K se traverseazã; chiar dacã
scriu 64*25 intervale sau doar 25, dacã ating acelaºi numãr de
blocuri, tot atîta conteazã.
</FONT>
<P>

<H1><A NAME="SECTION00080000000000000000">
Concluzii</A>
</H1>
<P>
<FONT SIZE="-1">Acest proiect demonstreazã un lucru foarte interesant:
</FONT>
<P>

<BLOCKQUOTE><FONT SIZE="-1">Preþul flexibilitãþii obþinute prin implementarea serviciilor
înafara nucleului (un watchdog, de pildã) poate fi cîteodatã
rãscumpãrat dacã serviciile oferite se potrivesc foarte bine cu
nevoile clientului.  Nucleul oferã un singur serviciu, care este
eficace pentru o clasã largã de aplicaþii (de exemplu cele care au
localitate bunã în cache).  Dar folosind schema noastrã putem
implementa <I>simultan</I> diferite scheme de cache pentru aplicaþii
diferite, potrivind comportarea cache-ului pentru fiecare aplicaþie,
ºi optimizînd independent.
</FONT></BLOCKQUOTE>
<P>

<H1><A NAME="SECTION00090000000000000000">
Bibliografie</A>
</H1>
<P>
<FONT SIZE="-1">Deºi nu am citat aceste lucrãri, raportul de faþã se bazeazã pe
ele.  Rolul unei bibliografii într-un articol este enorm pentru
cititori, dar despre asta altã datã<A NAME="tex2html9"
  HREF="#foot247"><SUP>7</SUP></A>.
</FONT>
<P>
 </FONT>
<H2><A NAME="SECTION000100000000000000000">
Bibliography</A>
</H2><DL COMPACT><DD>
<P>
<P></P><DT><A NAME="watch">Bersh88</A>
<DD>B. B. Bershad, C. B. Pinkerton. Watchdogs --
Extending the UNIX File System. <I>Computing Systems, 1, 1988</I>,
pp. 169.

<P>
<P></P><DT><A NAME="end-to-end">Saltz84</A>
<DD>J. Saltzer, D. Reed, D Clark -- The
End-to-End Argument in System Design. <I>ACM Transactions on
Computer Systems, vol 2, nr. 4, 1984</I>, pp 277-288.

<P>
<P></P><DT><A NAME="proc">Faul91</A>
<DD>R. Faulkner, R. Gomes. The Process File System
and Process Model in UNIX System V. <I>Proceedings of the 1991
Winter USENIX Conference</I>, Jan. 1991, pp.243-252.

<P>
<P></P><DT><A NAME="vnode">Klei86</A>
<DD>S. R. Kleiman, 1986.  Vnodes: An Architecture
for Multiple File System Types in Sun Unix. <I>USENIX Summer
Conference Proceedings 1986</I>, pp. 238-247.

<P>
<P></P><DT><A NAME="vaha">Vaha96</A>
<DD>Uresh Vahalia.  Chapters 9, 10, 11 in <I>UNIX
Internals.</I>, Prentice Hall, 1996.
</DL>
<P>

<H1><A NAME="SECTION000110000000000000000">
Traseul parcurs</A>
</H1>
<P>
<FONT SIZE="-1">Mai interesante decît concluziile (care ºtiinþific vorbind nu sunt
extraordinare) este drumul parcurs.  Sã-l revedem:
</FONT>
<P>

<OL>
<LI>Un proiect este propus;

<P>
</LI>
<LI>Este comparat cu alte proiecte similare sau disimilare (aceastã
secþiune este mai puþin reprezentatã în acest articol);

<P>
</LI>
<LI>O evaluare teoreticã a performanþei este fãcutã; acesta este
ºi un studiu de fezabilitate; eventual proiectul este simulat sau
evaluat din pãrþile componente;

<P>
</LI>
<LI>Designul este adaptat pentru a ataca pãrþile slabe indicate de
evaluare;

<P>
</LI>
<LI>O serie de ipoteze asupra comportãrii sistemului sunt enunþate
explicit;

<P>
</LI>
<LI>Proiectul este implementat;

<P>
</LI>
<LI>Proiectul este mãsurat cu mare grijã, într-o varietate de
circumstanþe, controlînd (pe cît posibil) toþi parametri
influenþi;

<P>
</LI>
<LI>Eventualele slãbiciuni sunt remediate;

<P>
</LI>
<LI>Concluziile verificã în ce mãsurã ipotezele s-au dovedit
corecte ºi explicã rezultatele obþinute;

<P>
</LI>
<LI>Noi direcþii de cercetare ºi întrebãri sunt formulate
(lipsesc din acest text).
</LI>
</OL>
<P>
<FONT SIZE="-1">Iatã de ce spun cã în sisteme totul stã în detalii: dacã pentru
watchdog raportul valorilor duratelor diferitelor componente ar fi
fost altul (de exemplu dacã un apel de sistem ar fi fost de 10 ori
mai costisitor decît copierea datelor), atunci relevanþa ºi
aplicabilitatea watchdog-ului ar fi fost cu totul altele.  Cum spunea
cineva în fizicã:
</FONT>
<P>

<BLOCKQUOTE><FONT SIZE="-1">Dacã ai de-a face cu valori [pentru un parametru] care diferã cu un
ordin de mãrime, de fapt ai de-a face cu douã fenomene diferite.
</FONT></BLOCKQUOTE>
<P>
<FONT SIZE="-1">Asta am avut de zis; probabil am fost cam ocolit...
</FONT>
<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot57">... televizor</A><A NAME="foot57"
 HREF="proiect-html.html#tex2html1"><SUP>1</SUP></A>
<DD>Paragraful acesta trebuie luat ca
o opinie strict personalã.

<DT><A NAME="foot64">... Seattle</A><A NAME="foot64"
 HREF="proiect-html.html#tex2html2"><SUP>2</SUP></A>
<DD>Departamentul de
calculatoare al acestei universitãþi este clasat între primele 10
din Statele Unite; Brian Bershad însuºi este o somitate în lumea
sistemelor de operare.

<DT><A NAME="foot77">...vnod</A><A NAME="foot77"
 HREF="proiect-html.html#tex2html3"><SUP>3</SUP></A> <DD>Vedeþi ºi <a
 href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#vfs">articolul</a>
 meu din PC Report din februarie 1998, a cãrui copie este disponibilã
 din pagina mea de web.

<DT><A NAME="foot116">... cost</A><A NAME="foot116"
 HREF="proiect-html.html#tex2html5"><SUP>4</SUP></A>
<DD>Mai existã
un cost ascuns al serviciilor oferite de un watchdog: ºi anume
memoria watchdog-ului este paginabilã, spre deosebire de a
nucleului.  Dacã implementãm un serviciu în nucleu ar putea fi mai
rapid decît dacã îl punem în watchdog pentru cã memoria nucleului
rãmîne tot timpul în memoria fizicã.  Vom ignora acest lucru în
acest articol.

<DT><A NAME="foot129">...
simple</A><A NAME="foot129"
 HREF="proiect-html.html#tex2html6"><SUP>5</SUP></A>
<DD>Sper sã pot discuta într-un articol viitor despre
metoda prin care am fãcut aceste mãsurãtori.

<DT><A NAME="foot272">... client</A><A NAME="foot272"
 HREF="proiect-html.html#tex2html7"><SUP>6</SUP></A>
<DD>AFS este un sistem de fiºiere
``mondial''; sper sã pot reveni într-un articol asupra lui.  Practic
este un singur arbore de directoare pentru cîteva sute de instituþii
din cîteva zeci de þãri; cu un simplu <TT>cd</TT> eu pot citi
directoare aflate pe servere din Elveþia.  Toate calculatoarele din
universitatea Carnegie Mellon sunt clienþi ai acestui sistem de
fiºiere.

<DT><A NAME="foot247">... a</A><A NAME="foot247"
HREF="proiect-html.html#tex2html9"><SUP>7</SUP></A> <DD>E adevãrat cã
în textele trimise la PC Report am omis în mod sistematic
bibliografiile.  Mea culpa.

</DL><BR><HR>

</BODY>
</HTML>
