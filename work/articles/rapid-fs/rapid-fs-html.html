<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Eficienþa în sistemele de fiºiere</TITLE>
<META NAME="description" CONTENT="Eficienþa în sistemele de fiºiere">
<META NAME="keywords" CONTENT="rapid-fs-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Eficienþa în sistemele de fiºiere</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- mihaib+ at cs.cmu.edu 
<BR><TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>24 iunie 1997</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Tehnici pentru a face sistemele de fiºiere mai rapide;
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>Funcþionarea unui sistem de fiºiere;
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>disc, cache, fiºier.
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html44"
  HREF="rapid-fs-html.html">Hard-disc-ul</A>
<UL>
<LI><A NAME="tex2html45"
  HREF="#SECTION00021000000000000000">Accesul la disc</A>
</UL>
<BR>
<LI><A NAME="tex2html46"
  HREF="#SECTION00030000000000000000">Reducerea timpului de acces prin aranjarea grijulie</A>
<UL>
<LI><A NAME="tex2html47"
  HREF="#SECTION00031000000000000000">Accesul la nivel de bloc</A>
<LI><A NAME="tex2html48"
  HREF="#SECTION00032000000000000000">``Localitate'' spaþialã</A>
</UL>
<BR>
<LI><A NAME="tex2html49"
  HREF="#SECTION00040000000000000000">Cache-uri agresive (mai ales la clienþi)</A>
<LI><A NAME="tex2html50"
  HREF="#SECTION00050000000000000000">Scrieri asincrone</A>
<UL>
<LI><A NAME="tex2html51"
  HREF="#SECTION00051000000000000000">Gruparea scrierilor (write batching)</A>
<LI><A NAME="tex2html52"
  HREF="#SECTION00052000000000000000">Re-ordonarea acceselor</A>
<LI><A NAME="tex2html53"
  HREF="#SECTION00053000000000000000">Evitarea scrierilor</A>
<LI><A NAME="tex2html54"
  HREF="#SECTION00054000000000000000">Scrierea finalã</A>
</UL>
<BR>
<LI><A NAME="tex2html55"
  HREF="#SECTION00060000000000000000">Citirea în avans (read-ahead)</A>
<UL>
<LI><A NAME="tex2html56"
  HREF="#SECTION00061000000000000000">Indicaþii de citire în avans (read-ahead hints)</A>
</UL>
<BR>
<LI><A NAME="tex2html57"
  HREF="#SECTION00070000000000000000">Gruparea cererilor (batching)</A>
<LI><A NAME="tex2html58"
  HREF="#SECTION00080000000000000000">Tehnici RAID (Redundant Arrays Of Independent Disks)</A>
<LI><A NAME="tex2html59"
  HREF="#SECTION00090000000000000000">Folosirea ``log''-urilor</A>
<LI><A NAME="tex2html60"
  HREF="#SECTION000100000000000000000">Discuri separate</A>
<UL>
<LI><A NAME="tex2html61"
  HREF="#SECTION000101000000000000000">LFS cu un disc pentru log</A>
<LI><A NAME="tex2html62"
  HREF="#SECTION000102000000000000000">Discuri diferite pentru fiºiere diferite</A>
</UL>
<BR>
<LI><A NAME="tex2html63"
  HREF="#SECTION000110000000000000000">Replicare</A>
<LI><A NAME="tex2html64"
  HREF="#SECTION000120000000000000000">Indexare</A>
<LI><A NAME="tex2html65"
  HREF="#SECTION000130000000000000000">Folosirea timpului de inactivitate</A>
<UL>
<LI><A NAME="tex2html66"
  HREF="#SECTION000131000000000000000">Folosirea mai multor fire de execuþie (threads)</A>
</UL>
<BR>
<LI><A NAME="tex2html67"
  HREF="#SECTION000140000000000000000">Alocarea întîrziatã</A>
<UL>
<LI><A NAME="tex2html68"
  HREF="#SECTION000141000000000000000">Alocarea în ``extents''</A>
<LI><A NAME="tex2html69"
  HREF="#SECTION000142000000000000000">Prealocare</A>
<LI><A NAME="tex2html70"
  HREF="#SECTION000143000000000000000">Alocare la scriere fizicã</A>
<LI><A NAME="tex2html71"
  HREF="#SECTION000144000000000000000">Realocare la scriere fizicã</A>
</UL>
<BR>
<LI><A NAME="tex2html72"
  HREF="#SECTION000150000000000000000">Plasamentul sistemului de fiºiere; NASD</A>
<LI><A NAME="tex2html73"
  HREF="#SECTION000160000000000000000">Compresie de date transparentã</A>
</UL>
<!--End of Table of Contents-->
<BR>
<BR>

<P>
Sistemul de fiºiere (file system) este o parte a unui sistem de
operare care oferã utilizatorului accesul la dispozitive de memorare
permanentã (discuri mai ales) sub formã de <EM>fiºiere</EM>.  Aceasta
nu este o sarcinã facilã, pentru cã transformarea unui spaþiu de
memorie cvadridimensional (cum este discul, cu coordonate
cap/cilindru/sector/octet) într-o mulþime de fiºiere cu nume
ierarhice (directoare) ºi care cresc independent ºi simultan nu este
o treabã tocmai banalã.

<P>
De fapt tehnici pentru a face acest lucru sunt studiate în orice curs
de structuri de date la capitolul ``alocarea dinamicã a memoriei''.
Problema esenþialã este însã cã metoda cea mai simplã -- teoretic
vorbind -- este adesea departe de a fi cea mai rapidã atunci cînd este
implementatã.  Am scris aiurea un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#sistem-f">articol</a>
despre structurile de date ale sistemului de fiºiere din sistemul de
operare Unix tradiþional (vezi PC Report Decembrie 1996, sau pagina
mea de Web pentru o copie).  Consacrãm acest articol expunerii la
``grãmadã'' a unei serii întregi de trucuri fãcute de proiectanþii de
sisteme de fiºiere comerciale în lupta cu milisecundele.

<P>
Concluzia care se impune este cã cele mai multe sisteme de fiºiere
sunt derivate mai mult sau mai puþin din sistemul clasic Unix (UFS:
Unix File System), dar cã efortul depus pentru a le face mai rapide
este adesea reflectat dominant în cantitatea de cod.  Astfel se
ajunge de la un cod de 3-4000 de linii în UFS la 60000 de linii în
sistemul de fiºiere din IRIX 6.x, Unix-ul de la Silicon Graphics.
Reþineþi: pentru utilizator funcþionalitatea este pînã la urmã
aceeaºi!

<P>
Metodele care urmeazã aratã de ce aria sistemelor de operare este
atît de mult o îndeletnicire de inginerie (sau, dacã preferaþi, de
meºteºug).  Fireºte cã nu toate tehnicile sunt aplicabile
simultan, fiecare rezolvînd cîteodatã o anumitã clasã de
probleme, dar creînd altele, socotite mai puþin importante de
arhitect.  Oricum, dupã pãrerea mea, chiar înºirarea tehnicilor
este instructivã.

<P>
Desigur, este posibil sã fi sãrit din enumerare alte tehnici
importante.  Cei care le cunosc sunt rugaþi sã-mi atragã atenþia
asupra lor, ca un viitor articol sã fie mai comprehensiv.

<P>
Sã mai observãm cã majoritatea aserþiunilor fãcute aici se
potrivesc pentru sisteme de fiºiere tradiþionale, de gen Unix.  Noi
domenii de activitate, ca multimedia, tind sã cearã propriile
structuri de date, specializate, pentru a oferi proprietãþi
necunoscute de sistemele de fiºiere tradiþionale (de exemplu pentru
reproducerea unui film video de pe disc trebuie oferitã o ratã de
transfer constantã a informaþiei, independentã de numãrul de alte
cereri la disc).  Acest gen de fiºiere probabil cã nu este foarte
bine reprezentat de curentul articol.

<P>

<H1><A NAME="SECTION00020000000000000000">
Hard-disc-ul</A>
</H1>

<P>
Sã vedem cu ce material lucrãm.

<P>
Piaþa de discuri dure (hard-disk) la ora actualã are o creºtere
anualã mai mare decît cea de sisteme de calcul, de circa 60% pe an
(volum de vînzãri); discurile dure sunt dispozitivul dominant de
memorie permanentã.  Din aceastã cauzã vom discuta în acest
articol despre hard-discuri în mod special (ºi nu despre CD-ROM-uri
de pildã).  Anumite dintre consideraþiile pe care le facem sunt
valabile numai pentru acest mediu de stocare a informaþiei.  De aici
înainte cuvîntul ``disc'' înseamnã disc dur.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="disc"></A><A NAME="159"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Geometria unui hard-disc</CAPTION>
<TR><TD><IMG
 WIDTH="261" HEIGHT="348" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=5.8cm\epsffile{disc.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Figura&nbsp;<A HREF="rapid-fs-html.html#disc">1</A> încearcã sã ilustreze geometria
discurilor<A NAME="tex2html2"
  HREF="#foot57"><SUP>1</SUP></A>; în cuvinte lucrurile stau cam
aºa: un disc este o colecþie de platane circulare pe o axã comunã,
fiecare avînd douã capete de citire/scriere, cîte unul pe fiecare
din feþe.  Pe fiecare platan informaþia este aºezatã pe o serie de
cercuri concentrice, numite piste (tracks) (în cercuri ºi nu în
spiralã ca la pick-up).  Totalitatea pistelor de razã egalã se
numeºte cilindru (cylinder).  Pentru cã toate capetele unui disc
sunt solidare, se aflã toate pe un acelaºi cilindru la un moment
dat.  Asta implicã faptul cã datele plasate pe un acelaºi cilindru
se pot accesa fãrã a deplasa capetele, selectînd doar dintre capete
pe cel activ (unul singur la un moment dat).  Fiecare pistã este
împãrþitã la rîndul ei în sectoare (sectors), care la rîndul
lor sunt o colecþie de octeþi.  Indicînd capul, pista (sau
cilindrul), numãrul sectorului din pistã ºi numãrul octetului din
sector identificãm unic un octet pe disc.

<P>
Discurile sunt toate sudate pe aceeaºi axã, ºi se aflã în
miºcare permanentã de rotaþie (la laptop-uri ele sunt oprite dupã
perioade prelungite de inactivitate pentru a economisi bateriile).
Viteza de rotaþie este de aproximativ 5000-8000 de ture pe minut,
depinzînd de disc.  Viteza este constantã, spre deosebire de CD-uri,
care se rotesc mai repede cînd se citeºte de la centru.

<P>
Timpul de miºcare a capetelor de citire între cilindri vecini
(track-to-track seek time) este foarte mare (la scara de viteze a
microprocesoarelor), ºi este dat de inerþia mecanicã a ansamblului
de capete.  O valoare tipicã este de 3-4 milisecunde.  Miºcarea
capetelor între doi cilindri oarecare are o valoare medie (average
seek time) de 8 milisecunde pentru discuri de vîrf.  (To seek = a
cãuta.)  Accelerarea ºi decelerarea sunt dominante ca duratã, aºa
cã o miºcare de 10 piste nu dureazã cît 10 miºcãri de la pistã
la pistã.

<P>
Cantitatea de informaþie de pe o pistã este constantã, deºi
pistele de la exterior sunt mult mai lungi decît cele de la interior.
Asta înseamnã cã densitatea informaþiei la margine este mai micã.
O tendinþã nouã este de a plasa informaþia cu densitate constantã
peste tot, dar asta complicã un pic calculul locului pe disc.  De
obicei aceastã tehnologie se foloseºte pentru a þine niºte blocuri
``ascunse'', de rezervã, pe pistele exterioare.  Atunci cînd blocuri
ale discului se stricã (lucru foarte comun, de altfel), ele sunt
automat ``mutate'' în blocurile de la periferie, ascunse, ºi cele
originale sunt marcate ca defecte.  Adesea aceastã mutare este
invizibilã calculatorului gazdã, fiind fãcutã de controlerul
ataºat la disc în mod transparent.  (Acest lucru are consecinþe
nefaste dacã sistemul de operare optimizeazã accesul la disc bazat
pe poziþie.)  O pistã tipicã are între 32 ºi 64 de kiloocteþi.

<P>
Iatã de pildã specificaþiile pentru un disc Western Digital Caviar
de 3,5 inci, de ultimã orã:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">Capacitate</TD>
<TD ALIGN="LEFT">2000 Mb</TD>
</TR>
<TR><TD ALIGN="LEFT">Timp mediu de cãutare (seek)</TD>
<TD ALIGN="LEFT">11ms</TD>
</TR>
<TR><TD ALIGN="LEFT">Vitezã de rotaþie</TD>
<TD ALIGN="LEFT">5200 rot/min</TD>
</TR>
<TR><TD ALIGN="LEFT">Cilindri</TD>
<TD ALIGN="LEFT">3876</TD>
</TR>
<TR><TD ALIGN="LEFT">Capete (2 * platane)</TD>
<TD ALIGN="LEFT">16</TD>
</TR>
<TR><TD ALIGN="LEFT">Sectoare/pistã</TD>
<TD ALIGN="LEFT">64</TD>
</TR>
<TR><TD ALIGN="LEFT">Cache intern</TD>
<TD ALIGN="LEFT">256Kb</TD>
</TR>
<TR><TD ALIGN="LEFT">Rata de transfer</TD>
<TD ALIGN="LEFT">16.6 Mb/s</TD>
</TR>
<TR><TD ALIGN="LEFT">Timp mediu între defecþiuni</TD>
<TD ALIGN="LEFT">350 000 ore</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION00021000000000000000">
Accesul la disc</A>
</H2>

<P>
În momentul cînd utilizatorul indicã ce octet de pe disc vrea sã
acceseze sunt implicate trei durate importante:

<P>

<OL>
<LI>Capul trebuie miºcat pe cilindrul corect; aceastã miºcare
depinde de cilindrul curent pe care se aflã capul ºi de distanþa
pînã la destinaþie.  Aceastã întîrziere este datã de ``seek
time'';

<P>
</LI>
<LI>Capul trebuie sã aºtepte ca sectorul ºi octetul corect sã
ajungã sub cap datoritã rotaþiei; aceastã întîrziere depinde de
viteza de rotaþie ºi se numeºte ``rotational delay'': întîrziere
de rotaþie; durata ei medie este durata unei jumãtãþi de
revoluþie a discului;

<P>
</LI>
<LI>Dupã ce octetul corect a sosit sub cap începe transferul;
durata transferului depinde de densitatea de informaþie, de viteza de
rotaþie ºi, evident, de numãrul de octeþi consecutivi
transferaþi.
</LI>
</OL>

<P>
Pentru ilustraþie sã considerãm un transfer de 1 kilooctet,
octeþii transferaþi fiind plasaþi consecutiv.  Cei trei timpi ar
putea fi pentru discul de mai sus: cãutare a pistei 11ms,
întîrziere medie de rotaþie 1/(5200/60) * 1/2s = 5ms ºi timp de
transfer 5/16 = 0.3ms (o pistã are 32k<A NAME="tex2html3"
  HREF="#foot66"><SUP>2</SUP></A>, deci transferul a 1k este 1/16 din
timpul mediu de rotaþie, sau 1/32 din timpul de rotaþie).

<P>
Spre deosebire de memorii ºi microprocesoare, creºterea
performanþelor discurilor este mult mai lentã.  Cele mai notabile
progrese s-au înregistrat în creºterea densitãþii de
informaþie ºi viteza de rotaþie; în ultimii 10 ani însã timpul
de miºcare a capetelor a înregistrat o scãdere practic
neglijabilã, ºi nici nu sunt semne cã una s-ar produce în viitorul
apropiat.  Limitãrile mecanice sunt foarte greu de depãºit.

<P>
Iatã acum tehnicile folosite pentru a mãri eficienþa utilizãrii
discurilor, fiecare discutatã într-o secþiune separatã.

<P>

<H1><A NAME="SECTION00030000000000000000">
Reducerea timpului de acces prin aranjarea grijulie</A>
</H1>

<P>
Datoritã faptului cã accesarea locului unde informaþia se aflã pe
disc este foarte costisitoare în milisecunde, un plasament
bine-gîndit al informaþiei pe disc poate aduce beneficii
substanþiale.

<P>

<H2><A NAME="SECTION00031000000000000000">
Accesul la nivel de bloc</A>
</H2>

<P>
Calculele anterioare aratã cã timpul de acces la informaþie este
complet dominat de timpii de cãutare (seek) ºi întîrziere de
rotaþie.  În acest caz este la fel de rapid sã transferi o mulþime
de octeþi consecutivi sau unul singur; timpul plãtit pentru
miºcarea capului este cel dominant.  Diferenþa de mãrime este atît
de importantã încît acest principiu este folosit în <EM>toate</EM>
sistemele de fiºiere existente (chiar ºi de cele care folosesc
memorii flash<A NAME="tex2html4"
  HREF="#foot70"><SUP>3</SUP></A> în loc de discuri.

<P>
Din cauza asta toate implementãrile sistemelor de fiºiere trateazã
discul ca pe o colecþie de blocuri de mãrime fixatã, ºi nu ca pe o
colecþie de octeþi.  Alocarea ºi dealocarea, scrierea ºi citirea
se fac toate la nivel de bloc.  Valori tipice pentru mãrimea unui
bloc?  Între 512 octeþi ºi 8 kiloocteþi.

<P>
Singurul dezavantaj al metodei este cunoscut din studiul algoritmilor
de alocare dinamicã a memoriei, ºi se numeºte ``fragmentare
internã''.  Asta înseamnã cã uneori blocurile nu sunt folosite în
întregime, ca de exemplu în cazul fiºierelor care nu ocupã spaþiu
un multiplu întreg de mãrimea blocului.  Datoritã faptului cã la
discuri capacitatea a crescut foarte repede în ultimii ani, iar
mãrimea medie a fiºierelor de asemenea, spaþiul pierdut prin
fragmentare nu mai este considerat o problemã importantã.

<P>

<H2><A NAME="SECTION00032000000000000000">
``Localitate'' spaþialã</A>
</H2>

<P>
În 1984 cercetãtorii de la Universitatea Berkeley din California
(K.M. McKusick, William Joy<A NAME="tex2html5"
  HREF="#foot72"><SUP>4</SUP></A>, S. Laffler ºi L. Fabry)
au publicat un articol epocal numit ``A Fast File-system for Unix''
(FFS).  Acest articol arãta cum în sistemul de operare BSD (Berkeley
Software Development, o variantã de Unix<A NAME="tex2html6"
  HREF="#foot73"><SUP>5</SUP></A>) a fost implementat un sistem de fiºiere mult mai rapid decît
cel tradiþional (UFS), care funcþiona din 1974.  Principala tehnicã
exploatatã de McKusick ºi colegii lui pentru o dublare a vitezei a
fost exploatarea ``localitãþii''.

<P>
Intenþionez sã consacru un articol special managementului spaþiului
liber la discuri, dar pînã atunci iatã esenþa tehnicii: sistemul
de fiºiere tradiþional din Unix aloca blocuri libere practic la
întîmplare, cum se gãseau pe disc.  Echipa de la Berkeley a
``spart'' discul în mulþimi de cilindri (cylinder groups) contigui,
ºi a încercat sã aloce blocuri consecutive ale aceluiaºi fiºier
(sau inod-urile dintr-un acelaºi director) în acelaºi grup de
cilindri.  Între cilindri din acelaºi grup timpul de cãutare (seek)
este apropiat de cel minim (3ms), spre deosebire de timpul mediu
(11ms) între doi cilindri mai îndepãrtaþi.  De aici rezultã un
beneficiu imediat.  În plus, ei încercau pe baza unui algoritm
complex sã aloce blocul ``cel mai apropiat'' în sens temporal:
blocul liber la care se ajunge prin cea mai rapidã miºcare, luînd
în considerare ºi faptul cã pe mãsurã ce se face ``seek'' discul
se roteºte.

<P>
Algoritmul lor a avut un succes instantaneu, încît schimbãrile
propuse de ei au devenit standard, ºi au fost adoptate de întreaga
lume Unix.

<P>
ªi alte cîteva detalii secundare au contribuit la succesul FFS:
blocuri de mãrime foarte mare (8k faþã de 0.5k din UFS), ceea ce
ducea la mult mai puþine ``seek''-uri pentru un fiºier (încãpea
în mai puþine blocuri), deci din nou la o eficienþã sporitã.
Pentru a contracara efectele fragmentãrii interne, ei au folosit ºi
o metodã prin care blocurile incomplet folosite sunt sparte în
fragmente mai mici (1k), care pot fi folosite de fiºiere diferite.
Inutil de spus, algoritmii de management se complicã puþin, dar
viteza nu suferã scãderi considerabile.

<P>
Tehnica ``localitãþii'' se rezumã astfel: <EM>alocã în blocuri
``apropiate'' (care se pot citi repede unul dupã altul; asta nu
înseamnã neapãrat consecutive!<A NAME="tex2html7"
  HREF="#foot74"><SUP>6</SUP></A>) informaþiile care probabil vor fi accesate consecutiv.</EM>

<P>
Un alt proiect de la aceeaºi universitate care a fãcut vîlvã la
vremea lui este cel al ``Sistemului de fiºiere cu log-uri''
(Log-structured File-system, LFS pentru intimi) propus în 1991 de
M. Rosenblum ºi J.K.  Ousterhout.  Vom discuta pe scurt despre acest
sistem de fiºiere mai jos, cînd vorbim de scrierile asincrone ºi
folosirea cache-urilor.  Performanþa este obþinutã în LFS
datoritã faptului cã toate scrierile se fac în felii de cîte 64 de
kiloocteþi (2 piste de pildã), care se scriu în blocuri
consecutive, fãrã ``seek'' între ele (ºi dacã se poate, fãrã
întîrziere rotaþionalã).

<P>

<H1><A NAME="SECTION00040000000000000000">
Cache-uri agresive (mai ales la clienþi)</A>
</H1>

<P>
Metoda cea mai bunã de a face accese la disc este de a le evita.
Pentru asta, datele citite de pe disc sunt þinute într-o memorie
RAM, în speranþa cã vor fi refolosite.  De asemenea, datele sunt
citite de pe disc în blocuri, dar accesate de programe în bucãþi
arbitrare (poate chiar octet cu octet).  O citire
secvenþialã<A NAME="tex2html8"
  HREF="#foot76"><SUP>7</SUP></A> va aduce un bloc
întreg la primul octet, dupã care va lucra direct în
memorie<A NAME="tex2html9"
  HREF="#foot77"><SUP>8</SUP></A>  Zona din RAM
destinatã memorãrii datelor de acest gen (al cãror loc permanent
este pe disc) se numeºte cache (sau memorie ascunsã)<A NAME="tex2html10"
  HREF="#foot78"><SUP>9</SUP></A>.

<P>
Singura problemã realã cu cache-urile este cã în general nu avem
destulã memorie pentru a þine toate datele de pe disc, aºa încît
trebuie algoritmi care sã arunce din date din RAM cînd nu mai e loc.
Tema iese din domeniul acestui articol.

<P>
Sã observãm cã atunci cînd se foloseºte un server de fiºiere (de
pildã NFS -- Network File System -- într-o reþea de calculatoare,
sau un server Novell) cache-ul poate fi plasat în mod logic în 3
locuri: la server în RAM, la client pe disc sau la client în RAM.
Pentru reþelele locale rapide e mai eficient RAM-ul de la server
decît discul de la client: o reþea este mai rapidã decît un disc!

<P>
Un cache este util deci în cazul în care informaþia este accesatã
în mod repetat.  Iatã în secþiunile urmãtoare cum cache-ul se
poate dovedi util în feluri diferite pentru scrieri ºi citiri.

<P>

<H1><A NAME="SECTION00050000000000000000">
Scrieri asincrone</A>
</H1>

<P>
Un cache funcþioneazã în cazul <EM>scrierii</EM> pe disc astfel: un
proces vrea sã scrie, dar datele sunt copiate (de sistemul de operare
de obicei) într-un cache, unde sunt þinute o vreme.  Procesul care a
scris poate însã sã-ºi continue execuþia imediat.  Atunci cînd
cache-ul crede de cuviinþã, scrie datele pe disc.  Din cauzã cã
între scrierea efectuatã de proces ºi accesul la disc nu existã
nici o sincronizare (sunt practic independente), aceste scrieri ale
procesului se numesc <EM>asincrone</EM>.

<P>
Un dezavantaj al scrierii asincrone este pierderea definitivã a
datelor în cazul unei catastrofe survenite înainte de golirea
cache-urilor.  Sistemul de operare MS-DOS folosea scrieri sincrone
pentru a evita astfel de situaþii, dar aceasta a dus ºi la o
eficienþã extrem de scãzutã, care pînã la urmã i-a semnat
sentinþa MS-DOS-ului: nu se mai produce; cînd totuºi se mai
utilizeazã, se folosesc programe (ca smartdrive) care implementeazã
cache-uri.

<P>
Putem gãsi patru beneficii ale scrierii asincrone:

<P>

<H2><A NAME="SECTION00051000000000000000">
Gruparea scrierilor (write batching)</A>
</H2>

<P>
O primã metodã prin care care cache-ul se dovedeºte benefic este
cã permite strîngerea mai multor scrieri laolaltã ºi efectuarea
lor într-un singur acces.  Vom vedea cã sistemul de fiºiere cu
``log''-uri face chiar acest lucru: toate blocurile modificate sunt
scrise periodic în grup, în accese de 64k.  Se economisesc astfel o
grãmadã de timpi de poziþionare (seek) ºi întîrzieri
rotaþionale, care costã, nu glumã.

<P>

<H2><A NAME="SECTION00052000000000000000">
Re-ordonarea acceselor</A>
</H2>

<P>
O tehnicã folositã de toate driverele de disc normale este de a
scrie blocurile pe disc în ordinea în care se minimizeazã timpul de
deplasare.  Astfel, cache-ul paseazã permanent cereri driver-ului:
vreau blocul ãsta, ia blocul ãsta.  Driver-ul se întoarce asincron
zicînd: ``ok, mã ocup eu, tu vezi-þi de treabã''.  Astfel
driver-ul poate avea (ºi în momentele de activitate intensã chiar
are) o mulþime de cereri încã nesatisfãcute de blocuri.  Atunci
el aranjeazã aceste cereri în aºa fel încît sã fie cît mai
puþinã miºcare.

<P>
Un algoritm faimos este cel al ``liftului'' (elevator algorithm):
aranjeazã blocurile în ordine crescãtoare a cilindrilor, miºcã
din capete de la cilindrul 0 la cel maxim, ºi scrie pe mãsurã ce
avansezi.  Algoritmul are tot felul de variante, este relativ
eficient, ºi nici nu face vreun un bloc sã aºtepte prea mult pînã
îi vine rîndul.

<P>

<H2><A NAME="SECTION00053000000000000000">
Evitarea scrierilor</A>
</H2>

<P>
Foarte multe fiºiere trãiesc un timp scurt; fiºiere temporare,
fiºiere încuietoare (lock) existã cîteodatã pentru cîteva
secunde.  Dacã cache-ul evitã scrierea acestor fiºiere destul de
mult timp, ar putea avea surpriza ca fiºierele sã disparã înainte
de a le veni rîndul sã fie scrise, ºi ca blocurile lor sã fie
eliberate.

<P>

<H2><A NAME="SECTION00054000000000000000">
Scrierea finalã</A>
</H2>

<P>
Foarte adesea modificãri succesive se aplicã aceluiaºi bloc, sau
chiar aceluiaºi octet.  În cazul acesta cache-ul cumuleazã
rezultatele tuturor modificãrilor, ºi scrie numai rezultatul final,
economisind niºte accese la disc.

<P>

<H1><A NAME="SECTION00060000000000000000">
Citirea în avans (read-ahead)</A>
</H1>

<P>
Al doilea beneficiu al cache-urilor se manifestã la citire.  Este
limpede de ce un cache este util dacã aceleaºi date sunt citite de
mai multe ori.  Paradoxal însã, un cache se poate dovedi util chiar
dacã datele sunt citite o singurã datã!

<P>
Un sistem de fiºiere poate încerca sã ghiceascã dinainte ce
blocuri vor fi cerute în viitor de utilizatori, ºi sã cearã
driver-ului sã aducã blocurile din timp.  Atunci cînd aplicaþia
face cererea de citire, datele sunt servite din cache imediat!
Utilizatorul nu observã nici o întîrziere (sau o întîrziere mai
micã, dacã datele sunt pe drum).  Aceastã tehnicã se numeºte
``citire-înainte'' (read-ahead; pre-fetching).

<P>
Inutil de spus, riscul este, ca în cazul oricãrui profet, de a face
o prezicere eronatã, care se soldeazã cu o citire inutilã.  Vestea
cea bunã este cã un studiu empiric asupra programelor obiºnuite a
observat cã se pot prezice cu destul de mare acurateþe accesele
secvenþiale la un fiºier: dacã un program a cerut primele 3 blocuri
în ordine probabil va continua sã le cearã ºi pe urmãtoarele.

<P>
Toate sistemele de fiºiere moderne folosesc aceastã optimizare, cu
destul de mult succes.

<P>

<H2><A NAME="SECTION00061000000000000000">
Indicaþii de citire în avans (read-ahead hints)</A>
</H2>

<P>
Fireºte, existã un caz în care citirea în avans nu este cu nimic
dãunãtoare: cînd suntem siguri cã ea va fi utilã.  Sisteme
experimentale pun la dispoziþia programatorului apeluri de sistem
speciale prin care poate indica porþiunile de fiºiere pe care le va
accesa în viitor.

<P>
Se fac de asemenea încercãri de a crea compilatoare care sã
genereze automat ``indicaþii'' (hints) pentru sistemul de fiºiere
privitor la accesele viitoare, fãrã ca programatorul sã trebuiascã
sã abandoneze stilul obiºnuit de programare.

<P>

<H1><A NAME="SECTION00070000000000000000">
Gruparea cererilor (batching)</A>
</H1>

<P>
O rudã a metodei cache-urilor folositã în cazul sistemelor de
fiºiere în reþea, aceastã tehnicã reduce traficul în reþea ºi
numãrul de accese la disc: mai multe cereri de scriere/citire ºi
rãspunsurile lor sunt grupate laolaltã (fie la client, fie la
server) ºi transmise într-o bucatã.

<P>

<H1><A NAME="SECTION00080000000000000000">
Tehnici RAID (Redundant Arrays Of Independent Disks)</A>
</H1>

<P>
Viteza de transfer a datelor pe magistrale este mult mai mare decît
cea între disc ºi magistralã.  Limitarea ratei de transfer a
discului este datã de viteza de rotaþie: discul Caviar de mai sus
face 5200 rpm, iar la fiecare rotaþie poate transfera capacitatea
unei piste, de 32k.  Asta înseamnã o limitã superioarã (în
absenþa oricãror poziþionãri) de 5200/60 * 32 k/sec = 2,77M/sec.
(Viteza de transfer mult mai mare din specificaþiile discului de mai
sus poate fi atinsã cînd acesta are cache-ul propriu deja încãrcat
cu date.)

<P>
O idee interesantã este atunci de a folosi mai multe discuri
conectate simultan la aceeaºi magistralã, ºi de a scrie
informaþiile în felii (stripes) care acoperã toate discurile.
Astfel, folosind 3 discuri, primul bloc o sã fie pe discul 1, al
doilea pe discul 2, al treilea pe discul 3, al patrulea din nou pe
discul 1, etc (puteþi pune orice valoare în locul lui 3).  Atunci
fiecare disc poate transfera date din/spre memorie la viteza maximã a
magistralei folosind propriul cache, de pe unitatea de disc, dupã
care poate scrie cache-ul pe disc la o vitezã mult mai micã, în
timp ce vecinii sãi se ocupã de celelalte blocuri.

<P>
Pentru cã acolo unde ai trei aparate probabilitatea de defecþiune
creºte de mai mult de trei ori, în general tehnica de striping se
combinã cu una de redundanþã (ideea este ca atunci cînd un disc se
stricã sã nu devinã toate inutilizabile).  Cea mai folositã
metodã este de a avea un al patrulea disc, pe care se aflã
calculatã paritatea (``sau exclusiv'') a celorlalte trei.  Astfel,
dacã un disc se stricã, informaþia de pe el se poate reconstitui
integral folosind celelalte 3 discuri (folosind proprietatea funcþiei
paritate: dacã A + B + C = P (notînd cu ``+'' sau exclusiv), atunci
B = A + C + P, deci discul B se poate reconstrui folosind A, C ºi
discul de paritate P).  De aici vine ºi numele dispozitivelor, RAID:
mulþime redundantã de discuri independente.

<P>
Douã cuvinte în plus despre aceastã fascinantã metodã, despre
care poate vom reveni într-un articol separat:

<P>

<UL>
<LI>Cea mai simplã schemã RAID este cea cu douã discuri, care
menþin informaþii identice.  Acestea se numesc ``discuri în
oglindã'' (mirrored disks).

<P>
</LI>
<LI>Atunci cînd un disc dintr-un RAID se stricã, operatorul uman
îl înlocuieºte ºi se procedeazã la reconstituirea informaþiei de
pe discul nou plasat; acesta este modul de funcþionare ``degradat''
al dispozitivului RAID, pentru cã se consumã o grãmadã de timp cu
reconstituirea, ºi pentru cã o a doua defecþiune în acest moment
ar face toate datele inutilizabile;

<P>
</LI>
<LI>Metoda de lucru cu paritate face scrierile ``mici'' foarte
ineficiente, pentru cã atunci cînd se modificã un singur disc
trebuie citite toate celelalte ºi recalculatã paritatea, deci se
genereazã o grãmadã de trafic suplimentar.
</LI>
</UL>

<P>
Cu toate aceste slãbiciuni, calitãþile schemelor RAID depãºesc
defectele, aºa încît este de aºteptat ca utilizarea lor sã
devinã din ce în ce mai rãspînditã.  Dacã controlerul de RAID
are ºi o cantitate suficientã de NVRAM pentru a implementa un cache
mare, atunci ºocul scrierilor mici poate fi oarecum absorbit de
acesta, utilizatorii ne-trebuind sã aºtepte calculul paritãþii,
percepînd deci o creºtere substanþialã de vitezã (datoritã
paralelismului accesului la discuri).

<P>

<H1><A NAME="SECTION00090000000000000000">
Folosirea ``log''-urilor</A>
</H1>

<P>
În aceastã secþiune vom arunca o privire rapidã asupra sistemului
de fiºiere bazat pe ``log''-uri LFS, citat puþin mai sus.
Arhitectura sa este oarecum revoluþionarã, diferind substanþial de
sistemele de fiºiere clasice (UFS, FFS).

<P>
Tehnica ``log''-ului este împrumutatã din bazele de date.  Log-ul
(în românã o traducere aproximativã ar fi ``înregistrare'')
descrie <EM>modificãrile</EM> fãcute datelor.  Astfel, în sistemul de
fiºiere bazat pe log, în loc sã modifici fiºierul, scrii un nou
bloc (în log) în care zici: ``modific fiºierul cutare aici cu
atît''.  Fiºierul va subzista în forma originalã, alãturi de
înregistrãrile din log.  În acest fel putem vorbi de <EM>versiuni</EM>
ale datelor: fiecare nouã scriere în log produce o nouã versiune,
care coexistã cu cele vechi, ocupînd un loc diferit pe disc.  Dacã
vrei sã afli ultima valoare, citeºti ultima modificare.

<P>
Care e ºpilul?  De ce, adicã, ar fi metoda asta eficientã?  Pentru
cã avînd libertatea de a face scrierile oriunde (ºi nu în locurile
unde fuseserã plasate blocurile iniþial), poþi alege sã scrii
toate blocurile consecutiv, fãcînd foarte puþine deplasãri ale
capului!  În felul acesta se cîºtigã o grãmadã de timp.

<P>
Înainte de a vã entuziasma de ideea aceasta atît de simplã, sã
observãm ºi reversul medaliei: citirile trebuie sã ia de pe disc
blocurile din locurile în care se aflã, deci nu vor beneficia
probabil de alocarea contiguã a blocurilor la scriere (în sensul cã
vor cauza la fel de multe deplasãri de capete ca în schema UFS).
LFS presupune deci cã traficul dominant spre disc este de scrieri;
pentru ca acest lucru sã fie adevãrat cache-ul de disc trebuie sã
fie foarte mare ºi cererile de citire de date trebuie sã ia adesea
datele din cache.

<P>
Un al doilea dezavantaj al acestui sistem de fiºiere este generarea
continuã de noi blocuri.  Ce se întîmplã cu versiunile vechi?
Dupã ce discul a fost ocupat în întregime (ceea ce nu dureazã prea
mult), de unde se mai obþine spaþiu suplimentar pentru scrieri, care
trebuie sã fie ºi <EM>contiguu</EM> (dacã spaþiul liber este
fragmentat am pierdut toate avantajele scrierii mari, pentru cã
trebuie sã facem din nou toate deplasãrile de cap)?

<P>
Pentru acest scop sistemele de fiºiere bazate pe log (LFS) au nevoie
de un <EM>compactor</EM> care eliminã versiunile vechi ale datelor
(garbage collection) ºi strînge blocurile utilizate laolaltã.  În
general acest compactor funcþioneazã ca un proces separat care
traverseazã structurile de date ale discului atunci cînd spaþiul
liber a scãzut sub o anumitã cantitate, strîngînd laolaltã
blocurile utilizate ºi rescriindu-le.  Activitatea compactorului este
o sursã importantã de trafic spre disc, scãzînd dramatic din
eficienþa sistemului de fiºiere.

<P>
Studii detaliate au fost fãcute pentru a determina dacã schema LFS
este mai bunã decît cea a FFS, dar un rezultat clar în favoarea
unuia dintre ele nu a fost obþinut.  Fiecare dintre ele se comportã
mai bine în anumite condiþii ºi pentru un anumit tip de trafic (de
exemplu LFS cîºtigã la scriere).  Tehnici de gen LFS sunt folosite
în sisteme comerciale, cum ar fi cel citat mai sus, Xfs, din sistemul
IRIX, în care se folosesc log-uri numai pentru directoare, dar nu ºi
pentru fiºierele propriu-zise.

<P>
Un mare avantaj al log-urilor este reconstrucþia extrem de rapidã a
discurilor dupã o cãdere a calculatorului.  Pentru cã sistemele de
fiºiere tradiþionale (UFS, FFS) fac tot timpul modificãri în toate
zonele, o oprire subitã a calculatorului poate lãsa sistemele de
fiºiere într-o stare incorectã, fiindcã informaþiile din cache nu
au fost salvate.  Depistarea ºi corectarea acestui gen de defecte
cere programe foarte sofisticate (<TT>fsck</TT>).  Sistemele bazate pe
log-uri în schimb au toate modificãrile recente la sfîrºitul
log-ului, deci sunt foarte uºor de reparat.  (Atenþie: pierderi de
informaþie se petrec în ambele cazuri, pentru cã nimeni nu poate
reconstitui informaþia ne-salvatã din cache; problema care se pune
este de a face din nou funcþionale sistemele de fiºiere.)

<P>

<H1><A NAME="SECTION000100000000000000000">
Discuri separate</A>
</H1>

<P>
Aceste metode folosesc mai multe discuri beneficiind, ca în cazul
RAID, de transferuri paralele spre controlere, care pot apoi face
scrierile simultan.

<P>

<H2><A NAME="SECTION000101000000000000000">
LFS cu un disc pentru log</A>
</H2>

<P>
Mai curînd o variaþie a schemei LFS, aceastã îmbunãtãþire
foloseºte un disc pentru scrierea log-ului, compactorul mutînd
informaþiile ``vii'' pe un alt disc, unde informaþia care trãieºte
mult timp (de pildã fiºierele care se schimbã rar, cu executabile)
se va strînge dupã o vreme.

<P>

<H2><A NAME="SECTION000102000000000000000">
Discuri diferite pentru fiºiere diferite</A>
</H2>

<P>
Autorul acestui articol a transformat sistemul de fiºiere din Linux
numit <TT>ext2</TT> (care este de tip FFS) pentru a folosi un disc pentru
directoare ºi un altul pentru fiºiere<A NAME="tex2html11"
  HREF="#foot102"><SUP>10</SUP></A>.  În felul acesta
cache-ul poate programa scrieri sau citiri simultan pe ambele discuri.
Au fost mãsurate cu teste simple creºteri de performanþã de 30%
faþã de folosirea unui singur disc.

<P>
Un alt potenþial avantaj al unei astfel de scheme este acela cã se
pot implementa politici de alocare a blocurilor speciale pentru
directoare ºi fiºiere obiºnuite, care sã exploateze
caracteristicile speciale ale accesului (de exemplu directoarele tind
sã fie mici ºi nu ``scad'' niciodatã).

<P>

<H1><A NAME="SECTION000110000000000000000">
Replicare</A>
</H1>

<P>
O altã idee interesantã: prea multe cereri la un server?  Atunci
foloseºte mai multe servere, fiecare rãspunzînd la o fracþiune din
cereri.  Sunt, fireºte, douã posibilitãþi: ori îi dai fiecãrui
server niºte date de care e singur responsabil, ori pui aceleaºi
date pe toate serverele.  A doua metodã se numeºte <EM>replicare</EM>,
pentru cã are mai multe copii (replici) ale datelor.  Clienþii vor
face cererile la servere diferite, ºi fiecare server va avea o coadã
de cereri de satisfãcut mai scurtã, deci un timp de rãspuns mai
bun.

<P>
Cititorul ager a observat imediat cã schema are iarãºi dezavantaje:
cu citirea totul e bine, dar ce faci dacã cineva vrea sã modifice
ceva?  Trebuie sã faci scrierea de mai multe ori!  Existã o serie
întreagã de tehnici pentru a modifica fiºiere replicate, dar ne vom
mulþumi sã le enumerãm; problemele ridicate sunt mult mai mari
decît par la prima vedere.

<P>

<UL>
<LI>Se pot folosi tehnici cu voturi (quorum techniques; quorum =
majoritate): pentru a modifica un fiºier trebuie obþinut acordul
unei majoritãþi de servere.  Citirea la rîndul ei va contacta o
majoritate de servere, pentru a fi sigurã cã acceseazã cea mai
recentã copie.  Metoda aceasta se bucurã mai curînd de fiabilitate
decît de eficienþã.

<P>
</LI>
<LI>Se pot folosi fiºiere imutabile (care nu se pot modifica odatã
scrise).  Cum?  Nu poþi scrie?  Pãi ce sã faci cu ele?  Simplu:
dacã vrei sã le modifici faci o nouã copie.  (Limbajul Pascal
standard oferã acest tip de fiºiere: odatã scrise nu pot fi
modificate).  Sistemul de operare Amoeba implementeazã astfel de
fiºiere, care sunt foarte rapide (din aceastã cauzã serverul de
fiºiere se numeºte în Amoeba ``the bullet server'': serverul
glonte).

<P>
</LI>
<LI>Relaþii master/slave: folosite cîteodatã ºi în schemele
mirror (de care am vorbit un pic la capitolul RAID); asta înseamnã
cã toate modificãrile se fac pe un server desemnat, care le propagã
apoi tuturor serverelor care au copii.
</LI>
</UL>

<P>
Replicarea fiºierelor de fapt este un fenomen foarte întîlnit,
dacã stãm sã ne gîndim bine: de fiecare datã cînd avem un sistem
de fiºiere în reþea, care poate fi accesat de mai mulþi clienþi,
fiecare client va tinde sã aibã în cache-ul lui propria lui copie a
(unora) din fiºiere.  Este tot un caz de replicare, care pune
aceleaºi probleme ale modificãrii fiºierelor.  Sistemele comerciale
(NFS de la Sun, AFS -- Andrew File System -- de la compania Transarc
ºi universitatea Carnegie Mellon) rezolvã fiecare problema
replicãrii datelor în felul lui (mai mult sau mai puþin
satisfãcãtor).  Fãrã a intra în detalii, sã reþinem ºi
replicarea ca o tehnicã posibilã pentru creºterea eficienþei.

<P>

<H1><A NAME="SECTION000120000000000000000">
Indexare</A>
</H1>

<P>
Structurile de date de pe disc sunt foarte complexe: un arbore de
directoare, blocurile unui fiºier sunt grupate într-un arbore
dezechilibrat, blocurile libere într-un fel de listã stufoasã sau
un ``bitmap'', etc.  Pentru a deschide un fiºier trebuie traversate o
mulþime din aceste structuri, accesînd poate zeci de blocuri.
Construirea unor indexuri eficiente (idee împrumutatã din tehnologia
bazelor de date) poate mãri foarte mult viteza de acces la disc.

<P>
Arbori, tabele de dispersie (hash tables), arbori B+ sunt folosiþi
pentru a creºte performanþa cãutãrii, mai ales în cazul
fiºierelor ºi discurilor foarte mari.  De asemenea, structurile de
date din memorie, care descriu fiºierele deschise ºi cache-urile
(cache-ul blocurilor din memorie, cache-ul numelor de directoare,
cache-ul inodurilor din memorie, etc.)  sunt organizate dupã astfel
de structuri de date, cu cãutare rapidã (de exemplu pentru a
verifica dacã un bloc se gãseºte în cache se foloseºte de obicei
o tabelã de dispersie ºi nu cãutare binarã).

<P>

<H1><A NAME="SECTION000130000000000000000">
Folosirea timpului de inactivitate</A>
</H1>

<P>
Activitatea unui server de fiºiere are perioade febrile ºi zone de
repaos.  Acestea din urmã pot fi folosite pentru a programa
activitãþi auxiliare, care sunt utile, dar care nu trebuie sã
consume din timpul util.  Candidaþi sunt: compactarea log-urilor,
calculul paritãþii în sisteme RAID, reconstrucþia discurilor
defecte în sisteme RAID, compresia fiºierelor, compactarea
spaþiului liber, defragmentarea fiºierelor (pentru citire rapidã
secvenþialã).

<P>

<H2><A NAME="SECTION000131000000000000000">
Folosirea mai multor fire de execuþie (threads)</A>
</H2>

<P>
În general în sistemele de fiºiere tradiþionale toate operaþiile
se desfãºoarã pentru cã sunt cerute de cineva.  În alte
arhitecturi, gen LFS, existã o serie de activitãþi pentru care
momentul execuþiei nu este precis determinat (compactarea log-ului la
LFS).  Toate activitãþile citate mai sus, care se pot face în
timpul liber, sunt de acest gen, iar cea mai eficientã implementare a
lor este de a construi un thread (de preferinþã chiar în interiorul
nucleului, ca sã nu trebuiascã sã facã apeluri de sistem
costisitoare) pentru fiecare din ele.

<P>

<H1><A NAME="SECTION000140000000000000000">
Alocarea întîrziatã</A>
</H1>

<P>
Ajungem la o tehnicã foarte interesantã, care se bazeazã pe o
observaþie destul de subtilã.  Pentru aceasta trebuie sã aruncãm o
privire la momentul în care se alocã blocuri fiºierelor.  Un nou
bloc se alocã atunci cînd se scrie în el pentru prima oarã.  Sã
presupunem cã un utilizator cheamã un apel de sistem <TT>write()</TT>
pentru a scrie ceva la într-un fiºier, începînd de la octetul cu
numãrul <TT>offset_curent</TT> (valoarea acestuia a fost fixatã de un
apel <TT>lseek()</TT> anterior).  Codul acestui apel de sistem aratã
cam aºa într-un pseudo-cod C:

<P>
<PRE>
write(int fisier, char * sursa, int marime)
{
    while (marime) {
        bh = aloca_bloc(fisier, offset_curent);
        copiaza_date(sursa, bh, MIN(marime, marime_bloc));
        marcheaza_modificat(bh);

        offset_curent += marime_bloc;
        marime -= marime_bloc;
        sursa += marime_bloc;
        if (marime &lt; 0) marime = 0;
    }
}
</PRE>

<P>
(Codul este foarte simplificat: în mod normal în <TT>while</TT> se
cheamã o funcþie <TT>cauta_bloc()</TT>, care va aduce blocul care
conþine <TT>offset_curent</TT>, sau va chema ea însãºi <TT>aloca_bloc()</TT> dacã acest bloc nu a fost încã alocat; în plus am
asumat cã datele sunt aliniate ºi scrierea se face de la un început
de bloc; codul real este ceva mai complicat, însã acesta ilustreazã
perfect ce ne intereseazã.)  Funcþia <TT>aloca_bloc()</TT> cautã un
bloc liber pe disc ºi alocã simultan un bloc în cache pentru acel
bloc; rezultatul întors este un bloc de cache numit <TT>bh</TT>, pe care
cache-ul îl va salva pe disc asincron.

<P>
Observaþia interesantã este: chiar dacã avem o scriere de un
megaoctet, blocurile sunt alocate <EM>unul cîte unul</EM>.  Asta
înseamnã cã s-ar putea ca blocurile sã nu fie unul lîngã altul,
cãci rutina de alocare <TT>aloca_bloc()</TT> nu are idee despre
blocurile alocate anterior.

<P>
În plus, rutina de alocare trebuie sã parcurgã structurile de date
aflate pe disc, ori aceastã operaþie este blocantã: pînã se
citeºte structura de date de pe disc procesul curent este oprit ºi
un altul se executã.  Asta poate cauza interclasarea alocãrilor
blocurilor pentru douã apeluri simultane <TT>write()</TT>: primul proces
alocã un bloc, se blocheazã pînã structurile sunt citite, al
doilea proces începe sã se execute ºi alocã alt bloc, se
blocheazã, dar primul terminã ºi cere un al treilea, ºi tot aºa.

<P>
Dacã implementarea lui <TT>aloca_bloc()</TT> extrage pur ºi simplu
blocuri dintr-o listã de blocuri libere rezultatul va fi cã blocuri
succesive dintr-un fiºier vor fi plasate pe disc cum vine la mînã,
fãrã nici o relaþie între ele.  Paradoxul este aceste: deºi este
clar de la început de cîte blocuri este nevoie (<TT>marime/marime_bloc</TT>), rutina de alocare obþine blocurile unul cîte
unul, ºi atunci ele nu sunt neapãrat consecutive!  (Plasarea în
blocuri consecutive face accesul secvenþial la fiºier mult mai
eficient, mai ales în combinaþie cu citirea anticipatã.)

<P>
Se pot folosi patru scheme pentru a ocoli aceastã deficienþã a
alocatorului:

<P>

<H2><A NAME="SECTION000141000000000000000">
Alocarea în ``extents''</A>
</H2>

<P>
O metodã interesantã este de a schimba complet unitatea de alocare a
discului din blocuri cu mãrime fixã în cantitãþi de mãrime
variabilã (dar nu oricît de mici), numite <EM>extents</EM>
(întinderi?).  Astfel la apelul de sistem <TT>write()</TT> se alocã
întreaga cantitate de spaþiu pe disc de la început, dupã care este
scrisã, dacã se poate dintr-o bucatã.  Aceasta complicã codul
alocatorului, dar nu este nicidecum o problemã nefezabilã.

<P>

<H2><A NAME="SECTION000142000000000000000">
Prealocare</A>
</H2>

<P>
De fiecare datã cînd trebuie sã aloci un bloc, alocã ºi cîteva
blocuri imediat consecutive pe disc, în eventualitatea creºterii
fiºierului.  Aceastã schemã este folositã cu succes în sistemul
de fiºiere din Linux, <TT>ext2</TT>.

<P>
Dacã fiºierul nu mai creºte, sau nu creºte secvenþial, blocurile
pre-alocate sunt eliberate.

<P>

<H2><A NAME="SECTION000143000000000000000">
Alocare la scriere fizicã</A>
</H2>

<P>
Nu se alocã pe disc blocurile pînã cînd nu vine momentul golirii
cache-ului.  Scrierea alocã blocuri doar în cache, iar algoritmul
golirii cache-ului studiazã pentru fiecare fiºier cîte blocuri
trebuie alocate pe disc ºi face aceastã alocare.  Aceastã tehnicã
este folositã în sistemul de operare IRIX.

<P>

<H2><A NAME="SECTION000144000000000000000">
Realocare la scriere fizicã</A>
</H2>

<P>
Aceastã tehnicã este o optimizare întîlnitã în anumite
implementãri ale FFS: alocarea merge ca în codul de mai sus, însã
procedura de golire a cache-ului încearcã sã ``mute'' blocurile
dacã ar fi util: blocuri consecutive din acelaºi fiºier sunt puse
contiguu dacã se poate.

<P>

<H1><A NAME="SECTION000150000000000000000">
Plasamentul sistemului de fiºiere; NASD</A>
</H1>

<P>
Sistemul de fiºiere este un serviciu oferit aplicaþiilor, ºi poate
fi plasat în mai multe locuri: într-o bibliotecã de funcþii
(foarte rar), în nucleul sistemului de operare sau într-un proces
separat (server).  Fiecare metodã are avantajele ºi dezavantajele
ei, iar în anumite configuraþii speciale fiecare poate fi mai
eficientã.

<P>
O încercare notabilã este cea de a distribui serviciul cît mai
mult, în aºa fel încît sã nu existe o singurã autoritate
responsabilã cu majoritatea operaþiilor.  Un proiect foarte
interesant în curs de desfãºurare la universitatea Carnegie Mellon
se numeºte ``Discuri sigure legate la reþea'': Network Attached
Secure Disks (NASD).  Ideea este de a avea o reþea localã rapidã
(ATM, Fiber Channel, etc.) care leagã multe calculatoare client cu
ºi mai multe unitãþi de disc inteligente.  Clienþii folosesc
serverul de fiºiere numai pentru a afla care sunt discurile care
conþin fiºierele ºi pentru a obþine o autorizaþie de acces, dupã
care transferul de date se face direct între clienþii interesaþi
ºi discurile cu informaþie, fãrã a mai implica serverul nicicum.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="nasd"></A><A NAME="165"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Traseul informaþiei în formula tradiþionalã ºi 
în NASD</CAPTION>
<TR><TD><IMG
 WIDTH="452" HEIGHT="436" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{nasd.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Comparaþi aceastã tehnologie cu cea tradiþionalã, în care
serverul, un proces obiºnuit, trebuie sã citeascã discul asociat
în memorie ºi sã trimitã apoi imediat rezultatul pe reþea: pe
lîngã faptul cã o singurã autoritate face toate operaþiile, deci
este foarte încãrcatã, se petrec o mulþime de copieri inutile;
sistemele moderne în general nu oferã facilitãþi de genul:
``trimite de pe disc direct pe reþea'', ci doar de genul ``citeºte
de pe disc în memorie'' ºi ``trimite în reþea din memorie.''  
Figura&nbsp;<A HREF="rapid-fs-html.html#nasd">2</A> aratã diferenþele între mersul informaþiei în cele
doua arhitecturi.  Pentru citirea de date în formula client-server paºii 
sunt (scrierea este asemãnãtoare):

<P>

<OL>
<LI>Clientul transmite un mesaj pentru server de cerere de acces la disc;
</LI>
<LI>Mesajul este transmis spre server;
</LI>
<LI>Serverul primeºte mesajul ºi îl decodificã;
</LI>
<LI>Nucleul de la Server transferã date dinspre discul local;
</LI>
<LI>Serverul preia datele din nucleu;
</LI>
<LI>Serverul roagã nucleul sã trimitã datele la client;
</LI>
<LI>Nucleul clientului primeºte datele;
</LI>
<LI>Clientul copiazã datele din nucleu.
</LI>
</OL>

<P>
Paºii 4, 5, 6, 7, 8 copiazã o cantitate mare de date dintr-un loc într-altul.
Orice citire va trece prin aceastã secvenþã de operaþii.

<P>
Pe cînd în NASD o citire trece prin urmãtorii paºi:

<P>

<OL>
<LI>Cleintul trimite un mesaj la server pentru a obþine autorizaþia
de transfer;
</LI>
<LI>Mesajul este transmis prin reþea;
</LI>
<LI>Serverul primeºte mesajul ºi îl decodificã;
</LI>
<LI>Serverul trimite autorizaþia ºi descrierea discului;
</LI>
<LI>Mesajul este transmis prin reþea spre client;
</LI>
<LI>Clientul primeºte mesajul ºi descoperã autorizaþia;
</LI>
<LI>Clientul trimite un mesaj spre discul inteligent legat la reþea;
</LI>
<LI>Mesajul este transmis spre disc;
</LI>
<LI>Discul pune datele direct în reþea;
</LI>
<LI>Clientul primeºte datele din nucleu.
</LI>
</OL>

<P>
Transfer de date se face numai în paºii 9 ºi 10.  Paºii 1, 3, 4, ºi 6 pot
conþine criptare/decriptare, care este o operaþie relativ costisitoare.
Odatã obþinutã autorizaþia clientul poate repeta de oricîte ori doreºte
paºii 7-10 fãrã a mai interveni pe lîngã server.

<P>
Discul trebuie sã fie ``inteligent'' pentru cã trebuie sã:

<UL>
<LI>execute un protocol de comunicaþie în reþea;
</LI>
<LI>aplice metode criptografice pentru verificarea identitãþii.
</LI>
</UL>

<P>

<H1><A NAME="SECTION000160000000000000000">
Compresie de date transparentã</A>
</H1>

<P>
Programe care dubleazã capacitatea discului sunt oricui familiare din
MS-DOS.  Un avantaj neevident al acestor programe este cã reducînd
cantitatea de date scrise pe disc reduc ºi timpul necesar
transferului.

<P>
Dintre dezavantajele metodei: este greu de estimat spaþiul ocupat
dupã compresie, deci alocarea este mai dificilã, compresia este cu
atît mai eficientã cu cît manipuleazã o cantitate mai mare de
date, dar decomprimarea unui întreg fiºier pentru a citi ultimele
douã linii este o irosire, compresia însãºi consumã mult timp de
procesor.

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot57">...
discurilor</A><A NAME="foot57"
 HREF="rapid-fs-html.html#tex2html2"><SUP>1</SUP></A>
<DD>Un articol foarte interesant despre discuri cu
capete magneto-rezistive, care intrã mai adînc în alte detalii a
apãrut în PC Report din iulie 1997.

<DT><A NAME="foot66">... 32k</A><A NAME="foot66"
 HREF="rapid-fs-html.html#tex2html3"><SUP>2</SUP></A>
<DD>Pentru a calcula
mãrimea unei piste am aflat numãrul de piste = cilindri * capete =
3876 * 16 = 62016, ºi am împãrþit capacitatea discului la numãrul
de piste: 2000000k/62016 = 32k.  În plus un sector are 32k/(64
sectoare/pistã) = 512 octeþi.

<DT><A NAME="foot70">... flash</A><A NAME="foot70"
 HREF="rapid-fs-html.html#tex2html4"><SUP>3</SUP></A>
<DD>Memoriile flash sunt memorii RAM care nu-ºi
pierd informaþia dupã întreruperea curentului.  Nu confundaþi
memoriile flash cu memoriile RAM ne-volatile (NVRAM), de care se
deosebesc prin: preþ mai scãzut, prezenþa operaþiei de ºtergere,
care trebuie neapãrat sã survinã între douã scrieri ale
aceleiaºi adrese, etc.  Memoriile NVRAM sunt practic niºte memorii
RAM cu alimentare de la baterii.  Sisteme de fiºiere bazate pe
memorii flash sunt în mod frecvent folosite în ruterele din
reþelele de calculatoare.

<DT><A NAME="foot72">... Joy</A><A NAME="foot72"
 HREF="rapid-fs-html.html#tex2html5"><SUP>4</SUP></A>
<DD>Întemeietorul lui Sun
Microsystems, una dintre cele mai mari ºi agresive companii de
calculatoare din lume de la ora actualã.

<DT><A NAME="foot73">... Unix</A><A NAME="foot73"
 HREF="rapid-fs-html.html#tex2html6"><SUP>5</SUP></A>
<DD>Pentru o scurtã
istorie a sistemului de operare Unix vedeþi ºi BYTE din august
1996.

<DT><A NAME="foot74">... consecutive!</A><A NAME="foot74"
 HREF="rapid-fs-html.html#tex2html7"><SUP>6</SUP></A>
<DD>Foarte adesea controlerul
de disc nu poate citi imediat douã blocuri consecutive pe pistã:
dupã citirea primului îi trebuie un pic de timp pentru prelucrare,
timp în care discul se roteºte ºi urmãtorul bloc fuge de sub
cap.

<DT><A NAME="foot76">... a</A><A NAME="foot76"
 HREF="rapid-fs-html.html#tex2html8"><SUP>7</SUP></A>
<DD>``Secvenþial'' înseamnã cã octeþii sunt
accesaþi în ordine crescãtoare, unul dupã altul.

<DT><A NAME="foot77">...
memorie</A><A NAME="foot77"
 HREF="rapid-fs-html.html#tex2html9"><SUP>8</SUP></A>
<DD>Un timp de acces la un RAM normal, fãrã cache de
microprocesor, este de 10ns.  Comparaþi aceastã valoare cu 20ms
pentru un disc: raportul este de 500000 (jumãtate de milion); poate
50000 dacã citim un bloc întreg de pe disc!

<DT><A NAME="foot78">... a)</A><A NAME="foot78"
 HREF="rapid-fs-html.html#tex2html10"><SUP>9</SUP></A> <DD>Un <a
 href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#cache">articol</a>
 mai amplu despre cache-uri poate fi gãsit în PC Report din martie
 1997.

<DT><A NAME="foot102">... siere</A><A NAME="foot102"
 HREF="rapid-fs-html.html#tex2html11"><SUP>10</SUP></A>
<DD>O implementare este
disponibilã din pagina de web a autorului.

</DL>
<BR><HR>

</BODY>
</HTML>
