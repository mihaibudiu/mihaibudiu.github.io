<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Hardware reconfigurabil: o nouã paradigmã arhitecturalã</TITLE>
<META NAME="description" CONTENT="Hardware reconfigurabil: o nouã paradigmã arhitecturalã">
<META NAME="keywords" CONTENT="reconf-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Hardware reconfigurabil: o nouã paradigmã arhitecturalã</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>7 iunie 1998</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>hardware reconfigurabil prin software
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare despre
arhitectura calculatoarelor
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>poartã, memorie, procesor, FPGA, ASIC
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html32"
  HREF="reconf-html.html">Tehnologia</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION00030000000000000000">Hardware-ul tradiþional</A>
<UL>
<LI><A NAME="tex2html34"
  HREF="#SECTION00031000000000000000">Microprocesoare</A>
<LI><A NAME="tex2html35"
  HREF="#SECTION00032000000000000000">ASIC-uri</A>
<LI><A NAME="tex2html36"
  HREF="#SECTION00033000000000000000">Microcod; circuite configurabile</A>
</UL>
<BR>
<LI><A NAME="tex2html37"
  HREF="#SECTION00040000000000000000">Hardware reconfigurabil</A>
<UL>
<LI><A NAME="tex2html38"
  HREF="#SECTION00041000000000000000">Caracteristici fizice</A>
<LI><A NAME="tex2html39"
  HREF="#SECTION00042000000000000000">Sisteme cu hardware reconfigurabil</A>
<LI><A NAME="tex2html40"
  HREF="#SECTION00043000000000000000">Aplicaþii</A>
<LI><A NAME="tex2html41"
  HREF="#SECTION00044000000000000000">Ineficienþe; subiecte de cercetare</A>
<LI><A NAME="tex2html42"
  HREF="#SECTION00045000000000000000">Prototipul CMU</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION00046000000000000000">Sculele</A>
</UL>
<BR>
<LI><A NAME="tex2html44"
  HREF="#SECTION00050000000000000000">Concluzii</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Despre hardware reconfigurabil am auzit cu puþina vreme în urmã;
atracþia a fost însã imediatã.  Acest articol va încerca sã vã
transmitã o parte din motivele pentru care domeniul mi se pare demn
de atenþie.  Unul dintre ele este faptul cã relativ puþinã
cercetare sistematicã s-a fãcut în domeniul circuitelor
reconfigurabile.  Noþiunea în sine este destul de veche: primul
prototip a fost introdus de firma Xilinx în 1986, deci cu 12 ani în
urmã.  O serie de conjuncturi au þinut însã zona în umbrã faþã
de atenþia marilor companii ºi a cercetãtorilor.  Brusc însã, în
urmã cu cîþiva ani, o creºtere a activitãþii orientate spre
acest subiect a putut fi observatã.  Principalul motiv este
tehnologia.

<P>

<H1><A NAME="SECTION00020000000000000000">
Tehnologia</A>
</H1>

<P>
În anii '60 Gordon Moore a observat o interesantã lege de evoluþie
a densitãþii ºi performanþei circuitelor integrate (cele douã
sunt strîns legate: cu cît un circuit este mai mic cu atît poate fi
fãcut sã funcþioneze mai repede, pentru cã semnalele electrice
trebuie sã circule pe distanþe mai scurte).  Moore a pronosticat cã
densitatea circuitelor se dubleazã la fiecare 18 luni.  Evident,
aceastã evoluþie nu poate þine la infinit, pentru cã dupã o vreme
dimensiunile componentelor ar deveni sub-atomice.  Dar cît de mult se
poate merge cu aceastã ratã de îmbunãtãþire a tehnologiei?  Ei
bine, experþii s-au înºelat în numeroase rînduri prezicînd
încetinirea evoluþiei: ºi la ora actualã legea este valabilã.
Se estimeazã cã în urmãtorii cinci-zece ani rata de evoluþie va
putea fi menþinutã.

<P>
Evoluþia tehnologiilor semiconductoarelor însã dã naºtere la o
creºtere în salturi a celorlalte tehnologii.  De exemplu, pentru cã
cipurile de memorii RAM sunt pãtrate<A NAME="tex2html1"
  HREF="#foot150"><SUP>1</SUP></A>, capacitatea lor
în general creºte în multipli de 4 (se dubleazã lãþimea ºi
lungimea).  Deci în loc sã se dubleze la fiecare 18 luni, RAM-urile
se cvadrupleazã în capacitate la fiecare 3 ani.

<P>
Un salt mai spectaculos este evident în urmãtorul exemplu: la
începutul anilor '70 densitatea a devenit suficient de mare pentru a
permite plasarea tuturor componentelor unei unitãþi centrale pe un
singur integrat.  Aºa a apãrut microprocesorul (primul
microprocesor, 4004, a fost creat de firma Intel).  La începutul
anilor '80 aceeaºi creºtere a permis înghesuirea pe o singurã
pilulã de siliciu a tuturor tranzistorilor (între 25.000 ºi 50.000)
pentru un microprocesor complex pe 32 de biþi.  Atunci cînd poþi
pune toate pãrþile la un loc de fapt saltul calitativ este mult mai
mare, pentru cã legãturile dintre circuite se reduc substanþial,
ºi performanþa creºte brusc.

<P>
La ora actualã cele mai complexe microprocesoare (Pentium II de
pildã) au peste 15,000,000 de tranzistori!  Cu aceeaºi ratã de
evoluþie, în acelaºi spaþiu în 2005 vor încãpea peste 1 miliard
de tranzistori.

<P>
Tot evoluþia tehnologicã a scos ºi circuitele reconfigurabile,
despre care vorbeam mai sus, din anonimat.  Subit ele au devenit
suficient de mari ºi de complicate pentru a putea implementa în mod
eficient aplicaþii interesante.

<P>
Douã motive fac deci interesant studiul circuitelor reconfigurabile:

<P>

<UL>
<LI>Circuitele hardware reconfigurabile sunt acum suficient de mari
pentru a fi folosite în aplicaþii utile;

<P>
</LI>
<LI>Proiectanþii de microprocesoare ai viitorului vor avea la
dispoziþie o cantitate uriaºã de tranzistoare pe care vor trebui
sã le foloseascã pentru a creºte eficienþa.  O parte dintre aceste
tranzistoare vor putea fi utilizate pentru a implementa circuite
reconfigurabile.
</LI>
</UL>

<P>
Ce este deci hardware-ul reconfigurabil?  Înainte de a rãspunde la
aceastã întrebare voi face o scurtã ºi incompletã trecere în
revistã a celorlalte paradigme hardware folosite.  Prin contrast vom
înþelege mai bine care sunt calitãþile ºi lipsurile noii
generaþii de circuite.

<P>

<H1><A NAME="SECTION00030000000000000000">
Hardware-ul tradiþional</A>
</H1>

<P>
Putem distinge douã feluri de circuite: care pot fi programate ºi
care nu.  Din prima categorie fac parte microprocesoarele, din a doua
circuitele integrate specifice unei aplicaþii (ASIC: Application
Specific Integrated Circuits).  Vom vedea ºi niºte categorii
intermediare.

<P>

<H2><A NAME="SECTION00031000000000000000">
Microprocesoare</A>
</H2>

<P>
Un microprocesor este practic o colecþie de unitãþi funcþionale
plasate pe ceea ce se numeºte ``data-path'' (cãrare a datelor?).
Simplificatã la maximum, funcþionarea unui procesor poate fi
descrisã în urmãtorii termeni:

<P>

<OL>
<LI>Procesorul citeºte din memorie urmãtoarea instrucþiune de
executat;

<P>
</LI>
<LI>Procesorul decodificã instrucþiunea: sunt trimise semnale de
comandã spre feluritele unitãþi funcþionale.  Datele de prelucrat
sunt extrase de unde se aflã (probabil din regiºtrii) ºi trimise
spre una dintre unitãþile funcþionale (de exemplu, dacã trebuie
executatã o instrucþiune de adunare, datele sunt trimise la unitatea
care face adunãri);

<P>
</LI>
<LI>Unitatea funcþionalã activã prelucreazã datele ºi
genereazã rezultatul;

<P>
</LI>
<LI>Rezultatul este trimis la destinaþia sa (posibil un registru);

<P>
</LI>
<LI>Ciclul se reia de la pasul 1.
</LI>
</OL>

<P>
Sã observãm urmãtoarele caracteristici ale unui microprocesor, pe
care le vom contrasta apoi cu cele ale hardware-ului reconfigurabil:

<P>

<UL>
<LI>Procesorul are în interior un numãr relativ limitat de
unitãþi funcþionale.  Orice procesare de date trebuie exprimatã
în termenii operaþiilor pe care aceste unitãþi funcþionale le pot
executa.

<P>
</LI>
<LI>Toate operaþiile se executã pe date de aproximativ aceeaºi
mãrime, numitã ``cuvînt'' (unele procesoare pot efectua prelucrãri
pe mai multe dimensiuni, cum ar fi 8, 16 ºi 32 de biþi, dar oricum
este vorba de un set foarte limitat de dimensiuni).

<P>
</LI>
<LI>Teoretic, pentru fiecare program am putea construi un procesor
special, care executã numai acest program: dacã programul nostru are
douã adunãri independente am putea construi un procesor cu douã
unitãþi aritmetice.  Microprocesoarele nu sunt astfel construite:
ele <EM>refolosesc</EM> aceeaºi unitate; o <EM>multiplexeazã</EM> în
timp.  Toate adunãrile sunt fãcute una dupã alta, cu aceeaºi
unitate aritmeticã.

<P>
</LI>
<LI>Un procesor nu poate executa foarte multe instrucþiuni
simultan.  Procesoarele moderne beneficiazã de douã tehnici care
sporesc viteza de execuþie:

<P>

<UL>
<LI><EM>Pipelining:</EM> un procesor poate avea simultan mai multe
instrucþiuni succesive în curs de execuþie, în faze diferite.  Sã
zicem cã am acasã o maºinã de spãlat ºi una de uscat.  Atunci
pot usca o încãrcãturã de rufe în timp ce spãl alta.  Practic
pot face de douã ori mai multe rufe în acelaºi timp decît în
cazul în care am o singurã maºinã care face amîndouã
operaþiile.  Asta se cheamã ``pipelining''; toate procesoarele
moderne folosesc aceastã tehnicã: în timp ce o instrucþiune este
decodificatã, alta este executatã ºi alta este cititã, etc.

<P>
</LI>
<LI><EM>Multiple issue:</EM> un procesor are de obicei mai multe
unitãþi funcþionale; de pildã înmulþitorul este diferit de
sumator.  Atunci procesorul poate lansa în execuþie mai multe
instrucþiuni care folosesc unitãþi diferite simultan.  Astfel de
procesoare se numesc ``superscalare''.
</LI>
</UL>

<P>
Cu toate acestea, cantitatea de paralelism disponibilã unui procesor
este relativ limitatã.  Un procesor Pentium II poate teoretic lansa
în execuþie 4 instrucþiuni simultan, dar în medie, mãsurînd
performanþa pe programe mari, reuºeºte sã execute doar în jur de
2 pe fiecare ciclu de ceas (din felurite motive, cum ar fi
instrucþiuni succesive care vor aceeaºi unitate funcþionalã).
</LI>
</UL>

<P>
Un microprocesor trebuie sã fie ``bun la toate'' ºi nu este excelent
pentru nimic.  Anumite tipuri de calcule nu pot fi fãcute cu
procesoare din aceastã cauzã; este nevoie de ASIC-uri.

<P>

<H2><A NAME="SECTION00032000000000000000">
ASIC-uri</A>
</H2>

<P>
Atunci cînd ºtii exact ce ai de calculat ºi timpul disponibil este
foarte puþin, nu ai de ales altceva decît sã proiectezi un circuit
care face numai acel lucru.  Un astfel de integrat, construit sã
rezolve o singurã problemã, se numeºte ASIC.

<P>
Un exemplu tipic de ASIC este cipul DES care cripteazã cu algoritmul
de criptografie cu cheie privatã Data Encryption Standard.  Într-un
PC se gãsesc o grãmadã de ASIC-uri, de la controlerele de
magistralã la controlerele perifericelor.  (Într-un PC se pot gãsi
ºi mai multe procesoare; unele periferice sunt controlate de
procesoare al cãror program este fixat odatã pentru totdeauna.)

<P>
Un ASIC este mult mai simplu, mai ieftin ºi mai rapid decît un
microprocesor.  Dar nu este deloc flexibil: nu poate rezolva decît o
singurã problemã.

<P>

<H2><A NAME="SECTION00033000000000000000">
Microcod; circuite configurabile</A>
</H2>

<P>
Atît microprocesoarele<A NAME="tex2html2"
  HREF="#foot69"><SUP>2</SUP></A> cît ºi ASIC-urile sunt construite din fabricã ºi
aºa rãmîn pînã la moarte.  Existã însã niºte clase de
circuite care pot fi modificate de cãtre utilizator, la o scarã
redusã.

<P>
Procesoarele cu set de instrucþiuni complex (CISC: Complex
Instruction Set Computer) sunt adesea implementate folosind în
interior <EM>microcod</EM>.  Practic acþiunile indicate mai sus:
decodificarea instrucþiunii, execuþia, scrierea rezultatului, etc.,
sunt mult mai complexe pentru un CISC, ºi sunt fiecare descompuse la
rîndul lor în instrucþiuni mai simple.  Pentru fiecare pas se
executã deci un progrãmel, numit <EM>microprogram</EM>, care indicã
fiecãrei unitãþi funcþionale ce sã facã.  Microprogramul este de
obicei înscris într-o memorie ROM din interiorul procesorului.
'Procesoarele CISC mai vechi uneori permiteau utilizatorilor sã
schimbe microcodul în timpul funcþionãrii, permiþînd sinteza de
noi instrucþiuni, care nu existau la fabricarea procesorului.
Libertatea era însã relativ limitatã.  (Microprocesorul Pentium Pro
permite ``microcode patching'': peticirea microcodului.  Aceasta este
o tehnologie introdusã de Intel dupã apariþia celebrului bug din
Pentium, care efectua greºit împãrþirea.  Algoritmul de
împãrþire era scris în microcod ºi avea un bug.  Acum Intel poate
corecta astfel de erori chiar dupã ce procesorul a fost livrat
utilizatorilor, prin software.  Acest subiect însã depãºeºte
cadrul acestui articol.)

<P>
O altã varietate de circuite configurabile conþine, printre altele,
clasa numitã PLA: Programmable Logic Array.  Acest tip de circuite
poate fi modificat ``off-line'' (adicã nu în timp ce
funcþioneazã).  Un PLA tipic conþine un rînd de porþi SAU ºi un
rînd de porþi ªI.  Fiecare ieºire de la o poartã SAU este
conectatã la fiecare intrare la o poartã ªI, avînd astfel o
matrice de conexiuni.  Cel care foloseºte circuitul poate suda sau
desface unele dintre conexiuni, obþinînd felurite
funcþionalitãþi.  Pentru cã orice funcþie logicã se poate
exprima folosind o conjuncþie de disjuncþii, astfel se poate
(teoretic) sintetiza orice circuit.  Desigur cã metoda nu este
practicã pentru circuite complicate, dar este folositã cîteodatã
pentru a sintetiza ``glue logic'': circuite care fac legãtura între
alte circuite.

<P>
Motivul pentru care PLA-urile sunt importante este unul <EM>economic</EM>: desigur cã am putea fabrica un ASIC pentru fiecare
funcþionalitate a unui PLA, dar atunci ar costa mult mai mult.  Toate
PLA-urile sunt de fapt la fel, deci sunt fabricate de o singurã linie
tehnologicã, pe cînd fiecare ASIC care calculeazã o altã funcþie
este diferit, deci are nevoie de propria lui linie de fabricaþie.

<P>

<H1><A NAME="SECTION00040000000000000000">
Hardware reconfigurabil</A>
</H1>

<P>
Am vãzut deci cã hardware-ul tradiþional are în general o
funcþionalitate fixatã de la bun început de cãtre fabricant;
aceastã funcþionalitate poate fi controlatã ºi multiplexatã în
timp, ca la microprocesoare, pentru a sintetiza funcþii noi, sau
poate fi fixatã odatã pentru totdeauna, ca la ASIC-uri.  Anumite
genuri de circuite pot fi fãcute sã facã lucruri pentru care nu au
fost proiectate (ca procesoarele cu microcod), sau pot fi schimbate cu
un efort considerabil (ca PLA-urile).

<P>
Ce-ar fi însã dacã am avea un circuit a cãrui funcþionalitate sã
poatã fi schimbatã la fel de repede pe cît funcþioneazã (spre
deosebire de PLA, la care treaba asta dureazã minute sau ore), ºi
care sã permitã o flexibilitate totalã (spre deosebire de microcod,
care poate doar controla unitãþile funcþionale existente)?  Ce-ar
fi dacã circuitele astea s-ar putea configura prin aceleaºi
mecanisme folosite pentru a le folosi (spre deosebire de anumite
memorii EEPROM care sunt ºterse prin expunere la ultraviolete)?
Ce-ar fi dacã am avea un circuit care ar putea sã-ºi schimbe
funcþionalitatea în timp ce lucreazã?

<P>
Existã aºa ceva?  Da; se numeºte hardware reconfigurabil.

<P>

<H2><A NAME="SECTION00041000000000000000">
Caracteristici fizice</A>
</H2>

<P>
Un circuit hardware reconfigurabil constã din douã entitãþi
distincte: porþi logice ºi sîrme care leagã porþile.  Spre
deosebire de circuitele VLSI obiºnuite, funcþionalitatea unei porþi
nu este fixatã, ci poate fi schimbatã dinamic.  De asemenea,
sîrmele se întind de-a lungul circuitului, iar la fiecare
intersecþie se aflã un mic comutator.  Fiecare comutator poate fi
închis sau deschis prin software.  Un circuit reconfigurabil generic
aratã cam ca în figura&nbsp;<A HREF="reconf-html.html#reconfigurabil">1</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="reconfigurabil"></A><A NAME="156"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Circuit reconfigurabil.</CAPTION>
<TR><TD><IMG
 WIDTH="361" HEIGHT="217" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{reconfigurabil.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Tehnologic problema este foarte simplã; ambele dispozitive se pot
face reconfigurabile folosind mici celule de memorie.

<P>

<H3><A NAME="SECTION00041100000000000000">
Poarta universalã</A>
</H3>

<P>
O poartã logicã ``universalã'' cu douã intrãri de 1 bit ºi o
ieºire de 1 bit se poate sintetiza folosind o memorie cu capacitatea
de 4 cuvinte de 1 bit.  Cele douã intrãri sunt adresa cu care se
indexeazã în memorie, iar conþinutul memoriei este ieºirea.  Iatã
de exemplu care cum se pot sintetiza felurite porþi în acest fel:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="CENTER" COLSPAN=3>Conþinutul memoriei</TD>
</TR>
<TR><TD ALIGN="LEFT">adresa</TD>
<TD ALIGN="LEFT"><IMG
 WIDTH="52" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$A \lor B$"></TD>
<TD ALIGN="LEFT"><IMG
 WIDTH="52" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$A \land B$"></TD>
<TD ALIGN="LEFT"><IMG
 WIDTH="31" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$\lnot A$"></TD>
</TR>
<TR><TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT">1</TD>
</TR>
<TR><TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT">0</TD>
</TR>
<TR><TD ALIGN="LEFT">2</TD>
<TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT">1</TD>
</TR>
<TR><TD ALIGN="LEFT">3</TD>
<TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT">0</TD>
</TR>
</TABLE>
</DIV>

<P>
E clar cum lucreazã?  De pildã, dacã vrem sã folosim memoria ca o
poartã SAU (<IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="$\lor$">) o sã încãrcãm în cei 4 biþi valorile 0, 1,
1, respectiv 1.  Atunci cînd vrem sã calculãm ``<IMG
 WIDTH="43" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="$1 \lor 0$">'',
primul bit la intrare va fi 1, iar al doilea 0.  Asta formeazã la un
loc adresa 10 (2 în baza 2); cuvîntul de memorie de la adresa 2 este
1, deci <IMG
 WIDTH="75" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.png"
 ALT="$1 \lor 0 = 1$">.  Corect.

<P>
În terminologia hardware-ului reconfigurabil, o astfel de memorie
folositã pentru a calcula valoarea unei funcþii booleene se
numeºte, din motive evidente, ``tabelã de cãutare'', <EM>Look-Up
Table</EM>, LUT.  Blocurile logice folosite în circuitele comerciale
conþin mai multe astfel de ``porþi''.

<P>

<H3><A NAME="SECTION00041200000000000000">
Switch-ul</A>
</H3>

<P>
Cu ajutorul LUT-urilor putem schimba funcþionalitatea unei porþi
logice.  Cu ajutorul comutatoarelor (switch) putem schimba
interconexiunile.  Imaginaþi-va o grilã formatã din ``sîrme'', iar
la fiecare intersecþie de sîrme un tranzistor, cu emitorul pe o
sîrmã ºi cu colectorul pe cealaltã.  Baza tranzistorului este
cuplatã la o memorie care conþine un singur bit.  Dacã în memorie
punem un ``1'', atunci tranzistorul va conduce electric între emitor
ºi colector, realizînd o conexiune între cele douã sîrme.  Dacã
baza este la ``0'', atunci sîrmele sunt izolate electric una de
cealaltã.  Figura&nbsp;<A HREF="reconf-html.html#comutatoare">2</A> ilustreazã cum se poate conecta
ieºirea unei porþi la intrarea alteia.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="comutatoare"></A><A NAME="162"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Conexiunile între sîrme pot fi fãcute
ºi desfãcute cu ajutorul unui tranzistor controlat de o memorie de
un bit.</CAPTION>
<TR><TD><IMG
 WIDTH="271" HEIGHT="210" BORDER="0"
 SRC="img8.png"
 ALT="\begin{figure}\centerline{\epsfxsize=6cm\epsffile{comutatoare.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Putem deci configura foarte simplu legãturile dintre elementele de
procesare, folosind un bit pentru fiecare intersecþie.

<P>
<BR>
<BR>

<P>
Aceste douã elemente reconfigurabile, ``porþile'' ºi comutatoarele,
fac întregul circuit extrem de flexibil.  Prin simpla operaþiune de
scriere într-o memorie putem schimba dinamic funcþionalitatea
circuitului!  Din aceastã cauzã voi numi astfel de circuite <EM>re</EM>configurabile, prin contrast cu circuitele configurabile: putem
oricînd sã le schimbãm cu uºurinþã configuraþia, într-un timp
relativ scurt.

<P>
La ora actualã existã mai multe firme care produc circuite integrate
reconfigurabile comerciale.  Cele mai importante sunt, în ordinea
volumului de circuite de acest gen: Xilinx, Altera, AT&amp;T, Actel,
Quicklogic.  Fiecare din aceste firme produce mai multe tipuri de
circuite, folosind tehnologii diferite, cu diferite complexitãþi ale
tabelelor, cu mici bucãþele de hardware specializat vîrîte printre
porþile generice, etc.  Ideea de bazã însã este cea descrisã mai
sus.  

<P>
Denumirea acestui gen de circuite nu este încã bine
împãmîntenitã; termenul care capãtã însã cea mai mare
acceptare este cel de ``matrici de porþi logice programabile cu
ajutorul cîmpului [electromagnetic]'': Field Programmable Gate
Arrays, FPGA.

<P>
Înainte de a vedea care sunt deficienþele circuitelor
reconfigurabile ºi problemele care sunt de rezolvat de cãtre
cercetare în ceea ce le priveºte, sã aruncãm o privire la
domeniile în care aceste circuite sunt foarte necesare.

<P>

<H2><A NAME="SECTION00042000000000000000">
Sisteme cu hardware reconfigurabil</A>
</H2>

<P>
Trebuie de la bun început înþeles cã hardware-ul reconfigurabil nu
îºi propune sã înlocuiascã celelalte paradigme de calcul, ci sã
le <EM>suplimenteze</EM>.  Locul unitãþilor reconfigurabile este
alãturi de cele clasice (procesoare, ASIC-uri), pentru a executa acea
parte din treabã care li se potriveºte cel mai bine.  Existã mai
multe propuneri de utilizare a acestui tip de hardware, care diferã
prin gradul de integrare cu sistemul.  Iatã unele dintre
posibilitãþi enumerate în ordine descrescãtoare a integrãrii:

<P>
<DL>
<DT><STRONG>Unitate funcþionalã:</STRONG></DT>
<DD>fiecare microprocesor ar putea avea, pe
lîngã unitatea aritmeticã ºi logicã, o unitate a cãrei
funcþiune este dinamic configurabilã.  Instrucþiuni speciale ar
configura unitatea ºi alte instrucþiuni ar folosi-o.

<P>
</DD>
<DT><STRONG>Coprocesor:</STRONG></DT>
<DD>aºa cum înainte de 80486 Intel avea un procesor
principal ºi un coprocesor, putem sã ne imaginãm o unitate
reconfigurabilã plasatã pe aceeaºi magistralã ºi comandatã de
procesorul principal.  Modul de folosire este asemãnãtor cu cel
precedent, dar timpii de comunicare între module sunt mai mari.

<P>
</DD>
<DT><STRONG>Procesor independent:</STRONG></DT>
<DD>putem sã ne imaginãm unitatea
reconfigurabilã ca fiind un master de magistralã autonom pe lîngã
microprocesor, capabil sã acceseze memoria, sã preia date ºi sã le
prelucreze.  Microprocesorul central ar iniþia doar acþiunile sale,
indicînd de exemplu unde în memorie se aflã configuraþia.
Unitatea reconfigurabilã ar citi configuraþia, s-ar configura
singurã ºi apoi ar începe sã execute aplicînd operaþii asupra
unor date a cãror adresã a fost indicatã tot de procesorul central.

<P>
</DD>
<DT><STRONG>Sistem complet de calcul autonom:</STRONG></DT>
<DD>pentru unele aplicaþii
(destul de puþine) se pot construi sisteme complete de calcul bazate
pe circuite reconfigurabile; unele exemple apar mai jos.
</DD>
</DL>

<P>

<H2><A NAME="SECTION00043000000000000000">
Aplicaþii</A>
</H2>

<P>
Putem distinge douã clase de aplicaþii: unele care în mod
tradiþional sunt rezolvate folosind ASIC-uri, ºi altele care
necesitã procesoare.  Iatã ce poate ``fura'' de la fiecare din ele
noua tehnologie:

<P>

<H3><A NAME="SECTION00043100000000000000">
FPGA versus ASIC</A>
</H3>

<P>
Trebuie dinainte spus cã dacã putem implementa aceeaºi soluþie pe
un ASIC ºi pe un circuit reconfigurabil, soluþia cu ASIC-ul va fi
mai rapidã în execuþie.  Motivele sunt multiple, ºi le vom explora
în secþiunea consacratã deficienþelor.  Cu toate acestea
circuitele reconfigurabile nu sunt deloc inutile!  Marile lor avantaje
faþã de ASIC-uri sunt preþul scãzut ºi reconfigurabilitatea.

<P>
Iatã deci genurile de aplicaþii la care se preteazã excelent
hardware-ul reconfigurabil:

<P>
<DL>
<DT><STRONG>Produse de serie micã.</STRONG></DT>
<DD>Costul construirii unei linii de
fabricaþie pentru ASIC-uri este foarte mare, pentru cã fiecare ASIC
cere o serie de dispozitive unice.  În schimb toate FPGA-urile sunt
la fel; funcþionalitatea uneia este programatã ulterior, prin
software.

<P>
</DD>
<DT><STRONG>Dezvoltare de ASIC-uri.</STRONG></DT>
<DD>Proiectarea ºi depanarea unui ASIC
este o treabã deosebit de complicatã<A NAME="tex2html5"
  HREF="#foot105"><SUP>3</SUP></A>.  Testarea mai ales este dificil de fãcut.
Desigur, nimeni nu-ºi permite sã fabrice un ASIC numai ca sã
gãseascã un bug ºi sã schimbe apoi întreaga linie de fabricaþie.
Metoda uzual folositã este simularea în software, dar aceasta este
extrem de lentã (de mii de ori mai lentã decît viteza de
funcþionare a circuitului real).  O soluþie foarte eficientã este
de a implementa schema ASIC-ului pe un FPGA ºi de a-l rula astfel.
Raportul de vitezã este cam de genul 1/2.  În plus, orice bug se
poate foarte uºor corecta schimbînd configuraþia.  Existã o
firmã, Quickturn, care cu asta se ocupã: îþi vinde plãci mari cu
sute de FPGA-uri ºi software care ia descrierea unui circuit într-un
limbaj de descriere hardware (HDL) ºi construieºte automat o
versiune a circuitului folosind FPGA-uri.  Rezultatul apoi poate fi
``înfipt'' în locul unde ar trebui sã fie circuitul real ºi poate
fi folositã pentru simulare.

<P>
</DD>
<DT><STRONG>``Rapid prototyping''.</STRONG></DT>
<DD>Construirea unei linii de fabricaþie
de ASIC-uri dureazã cîteva sãptãmîni în cel mai bun caz; un
FPGA poate fi reconfigurat în milisecunde.  Atunci cînd nu-þi poþi
permite sã aºtepþi, hardware-ul reconfigurabil poate fi singura
soluþie fezabilã.

<P>
</DD>
<DT><STRONG>Toleranþã la defecte.</STRONG></DT>
<DD>Dacã o parte din circuitul
reconfigurabil se defecteazã, putem reconfigura o altã parte pentru
a-i prelua funcþionalitatea: orice LUT poate calcula orice funcþie.
Existã clase de circuite reconfigurabile care se auto-verificã ºi
se auto-reconfigureazã în cazul unei malfuncþii, ocolind partea cu
defecte, pe care pur ºi simplu nu o folosesc!  Acest gen de
aplicaþii abia emerge, dar este foarte promiþãtor.  NASA se
intereseazã cu precãdere de astfel de aplicaþii; este destul de
greu sã faci service pe un satelit...

<P>
</DD>
<DT><STRONG>Aplicaþii care se schimbã.</STRONG></DT>
<DD>Cum spuneam, un ASIC rezolvã
întotdeauna o singurã problemã.  Dacã anticipãm cã problema se
va schimba în timp (gîndiþi-vã de pildã la ``upgrades'' pentru
modemuri, telefoane celulare, etc.) trebuie sã folosim o soluþie
flexibilã.  Dacã problema nu este prea complicatã, atunci este
sinucidere financiarã sã folosim un microprocesor pentru a o
rezolva; un circuit reconfigurabil va fi aproape întotdeauna mai
ieftin.  ªi vom vedea mai jos cã un circuit reconfigurabil are
potenþialul de a avea o performanþã net superioarã
microprocesorului, pentru cã microprocesorul este extrem de general,
însã hardware-ul poate fi special reconfigurat pentru problema pe
care vrem sã o rezolvãm.

<P>
</DD>
<DT><STRONG>Algoritmi sistolici.</STRONG></DT>
<DD>Hardware-ul reconfigurabil pare a fi
þinta idealã pentru a implementa anumite clase de algoritmi masivi
paraleli.  De exemplu, algoritmii sistolici (în care o mulþime de
elemente de procesare funcþioneazã sincron ºi paseazã date pentru
prelucrat de la unul la altul) sau automatele celulare (în care o
mulþime de procesoare foarte simple opereazã independent ºi
comunicã cu vecinii în mod asincron) par a fi fãcute pentru acest
mediu.  Simetria circuitelor reconfigurabile ne permite sã
împãrþim circuitul în bucãþele care implementeazã astfel de
automate simple.

<P>
</DD>
</DL>

<P>

<H3><A NAME="SECTION00043200000000000000">
FPGA versus procesoare</A>
</H3>

<P>
Hardware-ul reconfigurabil are ºansa sã batã microprocesoarele în
performanþã pentru anumite genuri de aplicaþii.  Care sunt acestea?
Pentru a rãspunde trebuie sã înþelegem de fapt unde-ºi petrece
timpul un program.

<P>
Un procesor care ruleazã la 300Mhz ºi lanseazã în medie 2
instrucþiuni pe ciclu (tipic pentru un Pentium II modern) va executa
<EM>600 de milioane</EM> de instrucþiuni pe secundã.  Mai mult decît
numãrul total de instrucþiuni din cel mai mare program scris
vreodatã.  Este clar, timpul este petrecut re-executînd o serie de
instrucþiuni de multe ori.  De fapt orice program are undeva o buclã
în care-ºi petrece majoritatea timpului.  O regulã empiricã spune
cã 90% din timp se execut'a 10% din cod; de fapt numerele sunt mai
aproape de 98%/2%.

<P>
Asta înseamnã cã dacã reuºim sã optimizãm acele 2% din program
pentru a mearge de 2 ori mai rapid, întreaga duratã a programului se
reduce aproape la jumãtate!  Orice cîºtig de performanþã în
``cea mai interioarã buclã'' (innermost loop) este foarte important.

<P>
Dacã vã uitaþi la caracteristicile procesoarelor enumerate mai sus,
vedeþi care sunt exact caracteristicile care pot fi exploatate de un
circuit reconfigurabil:

<P>
<DL>
<DT><STRONG>Dimensiuni neobiºnuite ale datelor.</STRONG></DT>
<DD>Un procesor RISC o sã
facã adunãri pe 32 de biþi chiar dacã trebuie sã adune numere pe
3 biþi.  Folosind hardware reconfigurabil putem însã genera
sumatoare de orice dimensiune, adaptate pentru problema pe care vrem
sã o rezolvãm.  Un sumator foarte mic este mult mai rapid; de aici
creºtere de vitezã ºi de eficienþã în ocuparea spaþiului.

<P>
</DD>
<DT><STRONG>Instrucþiuni greu sintetizabile</STRONG></DT>
<DD>de cãtre un microprocesor.
Consideraþi o subrutinã care trebuie sã inverseze biþii dintr-un
numãr de 32 de biþi: primul sã devinã ultimul, º.a.m.d.  Cu un
procesor obiºnuit aceasta se face folosind o buclã ºi o serie
complicatã de instrucþiuni care extrage biþi ºi îi ``vîrã'' în
cealaltã parte; rezultatul este un program care dureazã sute de
cicli de ceas.  În hardware reconfigurabil un astfel de program nu
are nevoie de nici un fel de calcule: pur ºi simplu tragi niºte
sîrme care se încruciºeazã: prima merge la ultima poziþie, etc.
Timp de execuþie: aproape 0!

<P>
De fiecare datã cînd un program are nevoie de astfel de operaþii
care se sintetizeazã greu din instrucþiuni primitive ale unui
procesor este un candidat bun la implementarea pe un circuit
reconfigurabil.

<P>
</DD>
<DT><STRONG>Programe care beneficiazã de paralelism masiv.</STRONG></DT>
<DD>Am vãzut mai
sus cã paralelismul oferit de un procesor este relativ limitat.
Uneori însã avem de-a face cu aplicaþii care pot prelucra
cantitãþi extrem de mari de date într-un mod uniform.  Prelucrarea
digitalã de semnal (sunet, imagine, etc.) este un exemplu.  Un FPGA
poate cîºtiga creînd atîtea unitãþi funcþionale cîte încap în
hardware, poate zeci!

<P>
</DD>
<DT><STRONG>Programe care pot fi executate în regim ``pipeline''.</STRONG></DT>
<DD>Anumite
genuri de programe (aplicaþiile vectoriale) aplicã o serie lungã de
operaþii fiecãrei date dintr-un set mare.  Putem sintetiza toate
operaþiile în hardware ºi putem aplica simultan operaþii diferite
unor date diferite.

<P>
</DD>
<DT><STRONG>Sinteza unor circuite specifice unei instanþe (generare
dinamicã de cod).</STRONG></DT>
<DD>Aceastã metodã de creºtere a eficienþei este
disponibilã parþial ºi procesoarelor obiºnuite.  Sã ne gîndim la
un program de criptare.  Criptarea se face în funcþie de o cheie, pe
care utilizatorul o introduce.  Dupã ce utilizatorul introduce cheia,
aceasta va rãmîne constantã pentru toatã durata criptãrii.
Algoritmul poate beneficia de forma cheii pentru a deveni mai
eficient.  De exemplu dacã ultima cifrã din cheie este 0, toate
înmulþirile cu acea valoare pot fi sãrite.

<P>
Aceastã tehnologie este un subiect foarte fierbinte în teoria
compilatoarelor, ºi se numeºte <EM>dynamic code generation</EM>:
generezi cod abia atunci cînd ºtii maximum de informaþie.
Compilatoarele de tip JIT (Just In Time), sau Hot-Spot de la Sun de
pildã, folosesc chiar aceastã tehnicã.

<P>
Metoda este cu atît mai eficientã în cazul circuitelor
reconfigurabile, pentru cã libertatea este mult mai mare decît în
cazul unui procesor în ceea ce priveºte ``cãrãmizile'' de bazã.

<P>
</DD>
</DL>

<P>
La ora actualã cele mai rapide cipuri de criptare sunt construite
folosind hardware reconfigurabil, tocmai pentru cã folosesc toate
tehnicile de mai sus: dupã ce cheia este cunoscutã se genereazã un
circuit special care cripteazã cu o singurã cheie, ºi care este
extrem de eficient.

<P>
Alt exemplu interesant: sã considerãm setul de instrucþiuni MMX
introdus de Intel pentru procesoarele sale.  MMX un set de
instrucþiuni foarte specializat, destinat procesãrii de semnale
pentru aplicaþii multimedia.  Problema principalã a lui Intel este
de compatibilitate: lumea se fereºte sã scrie programe folosind
instrucþiuni MMX pentru cã acestea nu se pot executa pe procesoare
care nu au aceastã extensie (sau se pot executa numai foarte lent,
folosind emulare software).  MMX sunt exact instrucþiuni care se pot
implementa foarte simplu ºi eficient în hardware reconfigurabil: se
aplicã la date de dimensiuni bizare (de obicei pe cîte 8 biþi),
sunt destinate unor procesãri vectoriale, care poate fi de obicei
eficient tradusã în regim de pipe-line.  Dacã Intel ar fi avut
niºte hardware reconfigurabil în Pentium, nu ar mai fi avut grija
compatibilitãþii ºi eficienþei instrucþiunilor MMX: oricine le
putea sintetiza automat la momentul execuþiei, ºi eventual, dacã se
dovedea cã unele dintre instrucþiuni nu erau prea folosite, puteau
fi scoase din configuraþie, fãrã a schimba nimic în linia de
fabricaþie a chipului!  (Motorola a introdus de curînd o serie de
procesoare care conþine astfel de hardware.)

<P>

<H2><A NAME="SECTION00044000000000000000">
Ineficienþe; subiecte de cercetare</A>
</H2>

<P>
Sã nu credeþi cã FPGA-urile sunt un panaceu; existã o grãmadã de
probleme caracteristice numai lor; unele pot fi rezolvate, altele sunt
probabil intrinseci:

<P>
<DL>
<DT><STRONG>Viteza de propagare</STRONG></DT>
<DD>a semnalului este cea mai neplãcutã
problemã.  O sîrmã într-un ASIC este un obiect aproape demn de
ignorat; timpul de propagare printr-un switch de la o încruciºare
într-un FPGA este însã semnificativ.  Propagarea dã mãsura
tactului de ceas care poate fi folosit.  Dacã întîmplãtor un
semnal trebuie sã traverseze mai multe încruciºãri, am zbîrcit-o.
Viteza unui program este deci dependentã de plasamentul fizic, care
este greu de controlat de cãtre programator.

<P>
</DD>
<DT><STRONG>Sîrmele:</STRONG></DT>
<DD>din cauzã cã nu se ºtie dinainte ce cu ce este
legat, un FPGA trebuie sã conþinã o mare cantitate de sîrme,
pentru a permite tot felul de combinaþii posibile.  Peste 90% din
suprafaþa unui FPGA este ocupatã de sîrme, dintre care multe
rãmîn nefolosite.  Asta înseamnã eficienþã scãzutã ºi
densitate efectivã micã de porþi.  Cel mai mare FPGA are de ordinul
a sute de mii de porþi, la aceeaºi suprafaþã cu un procesor.  De
aici o serie întreagã de constrîngeri pentru proiectanþii de
aplicaþii.

<P>
</DD>
<DT><STRONG>Compilatoarele ineficiente</STRONG></DT>
<DD>sunt probabil cel mai dificil
obstacol de trecut pentru acceptarea pe scarã largã a fenomenului.
La ora actualã lumea proiecteazã programe pentru circuite
reconfigurabile aºa cum proiecteazã hardware: folosind limbaje HDL
ºi scule CAD (Computer Aided Design) pentru aranjare pe circuit.
Acest procedeu este mult mai dificil decît proiectarea în limbaje de
nivel înalt, ºi în general compilatoarele sunt mult mai lente
(pentru a sintetiza progrãmele de mii de linii durata poate fi de
ordinul orelor!).

<P>
O altã dificultate majorã este proiectarea de programe care folosesc
simultan microprocesorul ºi o unitate reconfigurabilã auxiliarã.
Cu tehnologia curentã, programatorul trebuie atunci nu numai sã
scrie programele pentru ambele procesoare, ci ºi sã aibã grijã de
comunicaþia dintre programul de pe procesor ºi cel de pe circuitul
auxiliar.  Programatorii nu sunt obiºnuiþi sã gîndeascã în
astfel de termeni.

<P>
În al treilea rînd avem o problemã de inadecvare a limbajelor.  Un
limbaj de nivel înalt, ca C-ul, exprimã uneori concepte care nu sunt
uºor sau eficient de modelat pe un circuit reconfigurabil.  Luînd
exemplul de mai sus, cu inversarea biþilor, un programator nici nu
poate scrie aºa ceva în C decît folosind o buclã.  Cum ar putea
atunci un compilator pentru FPGA sã observe cã utilizatorul vrea de
fapt doar sã miºte niºte sîrme?  Nu e un lucru evident nici pentru
un om.  Încã nu este clar ce fel de limbaje ar trebui folosite în
domeniu.

<P>
</DD>
<DT><STRONG>Mãrime limitatã:</STRONG></DT>
<DD>pentru calculatoarele obiºnuite, mecanisme
ca memoria virtualã ºi RAM mare au fãcut o non-problemã mãrimea
unui program.  Resursele unui circuit reconfigurabil sunt însã
încã foarte limitate ºi foarte vizibile pentru utilizator.
Compilarea unui program pentru un FPGA poate eºua de pildã dacã nu
sunt destule sîrme într-o anumitã zonã pentru a conecta douã
porþi, chiar dacã circuitul sintetizat este relativ mic faþã de
cantitatea totalã de resurse disponibile.

<P>
</DD>
</DL>

<P>

<H2><A NAME="SECTION00045000000000000000">
Prototipul CMU</A>
</H2>

<P>
Voi încheia acest text cu descrierea sumarã a cercetãrii care se
desfãºoarã la Universitatea Carnegie Mellon.  Proiectul are o
paginã de web, dar deocamdatã acp;p se aflã destul de puþinã
informaþie pentru cã încã nu avem rezultate
substanþiale<A NAME="tex2html6"
  HREF="#foot116"><SUP>4</SUP></A>.  Puteþi ajunge acolo folosind o legãturã
din pagina mea personalã de web.

<P>
Carnegie Mellon are douã grupuri care lucreazã la un prototip
special de circuit reconfigurabil numit <EM>PipeRench</EM>.  Asta vine de
la ``pipe'': þeavã (subliniind natura ``pipelined'' a circuitului)
ºi ``wrench'': cheie francezã.  Circuitul acesta se vrea o unealtã
generalã pentru a scrie aplicaþii ``pipelined''.  Unul dintre
grupuri lucreazã la proiectarea, depanarea ºi construirea unui
circuit prototip ºi a interfeþei sale cu un sistem de calcul (bazat
pe o magistralã PCI), iar celãlalt la un compilator care sã
genereze cod pentru PipeRench.  Între cele douã grupuri existã o
oarecare independenþã, în sensul cã, deºi pentru moment
compilatorul dezvoltat are ca singurã þintã prototipul PipeRench,
în mod ideal ar trebui sã fie uºor portat ºi pentru alte feluri de
circuite reconfigurabile, cum ar fi cele comerciale.

<P>
De la început au fost fãcute o serie de decizii în spaþiul
posibilelor design-uri, care limiteazã aplicabilitatea, dar fac
problema tractabilã.  Ca oricînd în cercetarea ºtiinþificã, nu
este clar de la început cã aceste decizii au fost cele mai bune;
numai viitorul va arãta dacã aceastã cãrare este profitabilã, sau
dacã rezultatele vor fi foarte specifice.

<P>
Voi discuta pe scurt unele dintre deciziile mai interesante, pentru a
ilustra natura unora dintre problemele întîlnite ºi soluþiile
oferite.

<P>

<H3><A NAME="SECTION00045100000000000000">
Aplicaþii vectoriale</A>
</H3>

<P>
Principalele aplicaþii care sunt þinta implementãrii pe PipeRench
sunt cele care aplicã o aceeaºi procesare relativ complicatã asupra
unui set mare de valori (unui vector).  Exemple ideale: compresia,
criptarea, codificarea, filtrarea de semnal, analiza statisticã, etc.
PipeRench va implementa atunci funcþiunea care trebuie aplicatã
repetat ºi datele vor fi trimise una cîte una spre el; la ieºire se
vor culege rezultatele.

<P>

<H3><A NAME="SECTION00045200000000000000">
Un coprocesor master de magistralã</A>
</H3>

<P>
PipeRench are un controler special care este capabil sã genereze
adrese pentru magistralã pentru a citi ºi scrie singur din memorie.
Controlerul are mai multe scopuri:

<P>

<UL>
<LI>Controlerul citeºte chiar informaþia de configurare
pentru PipeRench din memorie.  Cînd procesorul principal vrea ca
PipeRench sã facã ceva anume, îi trimite doar un semnal ºi adresa
în memorie unde se aflã configuraþia de încãrcat.  PipeRench apoi
se încarcã singur.

<P>
</LI>
<LI>Controlerul lui PipeRench este capabil sã citeascã de unul
singur vectori din memorie ºi sã-i proceseze.  Procesorul central
îi spune lui PipeRench unde sunt datele, cîte ºi cum sunt aranjate,
iar PipeRench aplicã întregul program fiecãreia dintre date, în
regim de pipeline.

<P>
</LI>
<LI>Controlerul manipuleazã de asemenea un cache intern
circuitului, în care configuraþiile mai des folosite sunt
þinute, pentru a evita accesul frecvent la magistrala calculatorului
ºi la memoria lentã.
</LI>
</UL>

<P>

<H3><A NAME="SECTION00045300000000000000">
Hardware virtualizat</A>
</H3>

<P>
Probabil cea mai interesantã decizie este aceea de a ``virtualiza''
hardware-ul.  Aceasta simplificã enorm scrierea de programe, pentru
cã utilizatorul nu mai trebuie sã se preocupe de resursele
disponibile.  Ideea este asemãnãtoare cu cea de la memoria
virtualã: 

<P>

<UL>
<LI>Utilizatorul scrie un program pentru o maºinã cu mãrime
nelimitatã;
</LI>
<LI>Programul este împãrþit în felii ``virtuale''; sã zicem cã
sunt m astfel de felii;
</LI>
<LI>Hardware-ul disponibil poate cuprinde numai cîteva din aceste
felii, sã zicem n &lt; m (cazul n &gt;= m este un caz particular);
</LI>
<LI>Primele n felii din cele m sunt încãrcate ºi se
executã.  Cînd vine rîndul execuþiei feliei virtuale n+1, din
hardware este scoasã felia 1 ºi înlocuitã cu n+1.;
</LI>
<LI>La fiecare ciclu de ceas ulterior o nouã felie virtualã este
scoasã ºi înlocuitã cu alta.
</LI>
</UL>

<P>
În felul acesta circuitul hardware ``alunecã'' (ca în
figura&nbsp;<A HREF="reconf-html.html#functionare">3</A>) peste program.  Figura ilustreazã primii 6
paºi din procesarea unui vector <TT>v[]</TT> de valori.  Fiecare
valoare a vectorului trebuie procesatã de un program în 4 paºi.
Fiecare ``felie'' virtualã este un pas din program.  Datele intrã
în felia 0, trec apoi prin 1, 2 ºi ies din 3, dupã care sunt scrise
în memorie.  Aceeaºi operaþie este aplicatã tuturor elementelor
din vector.  Pentru figurã deci m=4, n=2.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="functionare"></A><A NAME="168"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
Funcþionarea unui program pentru un
circuit cu 4 ``felii'' virtuale folosind hardware real cu 2
``felii''.</CAPTION>
<TR><TD><IMG
 WIDTH="534" HEIGHT="217" BORDER="0"
 SRC="img16.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{functionare.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Metoda are o sumedenie de avantaje.  De exemplu, atunci cînd apare un
circuit mai mare pe piaþã, programele se vor executa mai repede,
pentru cã vor avea mai mult hardware la dispoziþie.  Nu trebuie
deloc recompilate.  În plus, putem executa azi (mai lent) programe
pentru care nu vom avea destul hardware decît mîine.

<P>

<H3><A NAME="SECTION00045400000000000000">
O arhitecturã ``pipe-line''</A>
</H3>

<P>
Dupã cum vedeþi fiecare felie lucreazã la un moment asupra altor
date de intrare; la fiecare m/n paºi se produce un rezultat.

<P>
Din cauzã cã felia 1 este scoasã cînd apare n+1 e clar cã
datele pot curge numai într-o direcþie în acest circuit.  Acest
model este asemãnãtor cu al maºinilor ``data-flow'' (subiectul
depãºeºte cadrul acestui articol).  În principiu orice aplicaþie
poate fi adusã în aceastã formã, dar nu orice aplicaþie este
eficient prelucratã astfel.

<P>

<H3><A NAME="SECTION00045500000000000000">
Un limbaj intermediar independent de arhitecturã</A>
</H3>

<P>
Pentru a uºura sarcina utilizatorilor dezvoltãm un compilator a
cãrui þintã este PipeRench.  Existã foarte puþinã experienþã
în a scrie compilatoare pentru limbaje imperative gen C pentru astfel
de maºini:

<P>

<UL>
<LI>Un compilator clasic de C are la bazã cãrãmizi relativ
complicate, din care trebuie sã sintetizeze programul (ºi anume
instrucþiunile procesorului).  Un compilator pentru hardware
reconfigurabil are niºte elemente mult mai simple (porþi ºi
sîrme), pe care trebuie sã le manipuleze într-un fel eficace.

<P>
</LI>
<LI>Compilatorul pentru PipeRench are sarcini care nu au echivalent
în compilatoarele clasice, cum ar fi plasamentul porþilor ºi
alegerea legãturilor între porþi dintre sîrmele disponibile (Place
and Route).  În sculele CAD acesta este un proces extrem de complicat
care dureazã foarte mult; þinta compilatorului nostru este însã
sã fie comparabil cu alte compilatoare de C.

<P>
</LI>
<LI>Dacã vrea sã fie competitiv, compilatorul pentru PipeRench
trebuie sã foloseascã calitãþile pe care acest gen de circuite le
are ºi care lipsesc unui procesor.  Astfel, trebuie sã lucreze cu
mãrimi de date variabile, sã genereze programe ``pipelined'' ºi sã
fie capabil sã foloseascã capacitãþile suplimentare ale
hardware-ului (ca în exemplu de mai sus cu inversatul biþilor).
</LI>
</UL>

<P>
Pentru a fi relativ independent de limbajul sursã (poate va fi Java,
poate C, poate ML?) ºi de circuitul destinaþie, compilatorul trebuie
sã foloseascã niºte abstracþii pentru hardware ºi limbajul
surºa.  Aceste abstracþii trebuie sã nu fie atît de generale
încît sã ascundã complet hardware-ul, pentru cã atunci nu se
poate obþine eficienþã.

<P>
Deocamdatã compilatorul nostru ia ca sursã un limbaj intermediar
special funcþional (numit DIL: Data Intermediate Language) care
descrie eficace calcule pe ºiruri de biþi de lungimi arbitrare.
Compilatorul traduce programe Dil în asamblare pentru PipeRench.
``Gaura'' dintre C ºi Dil este (sperãm) ceva mai uºor de umplut
decît direct dintre C ºi asamblare; cum se face asta este subiectul
cercetãrii viitoare.

<P>

<H2><A NAME="SECTION00046000000000000000">
Sculele</A>
</H2>

<P>
Iatã pe scurt în figura&nbsp;<A HREF="reconf-html.html#scule">4</A> care sunt sculele pe care
proiectul le-a dezvoltat ºi cu care experimenteazã tot felul de
parametri arhitecturali ºi tehnici de compilare.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="scule"></A><A NAME="174"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4:</STRONG>
Sculele folosite în proiectul PipeRench</CAPTION>
<TR><TD><IMG
 WIDTH="452" HEIGHT="365" BORDER="0"
 SRC="img18.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{scule.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Sculele hardware sunt în partea stîngã a desenului; din programe
scrise în Verilog (un HDL) se poate sintetiza fie direct circuitul
configurabil, fie se poate simula funcþionarea circuitului.

<P>
Sculele desenate cu linie punctatã încã nu existã.  În principiu
compilarea va trece prin urmãtorii paºi:

<P>

<OL>
<LI>Programul sursã este partiþionat în douã, separînd
instructîunile care vor fi efectuate folosind hardware
reconfigurabil;

<P>
</LI>
<LI>Partea rãmasã este compilatã cu un compilator ordinar de C;

<P>
</LI>
<LI>Partea destinatã circuitului reconfigurabil este tradusã în
limbajul Dil;

<P>
</LI>
<LI>Compilatorul de Dil compileazã programul, optimizeazã ºi
plaseazã operatorii pe circuit; rezultatul este un program într-un
limbaj de asamblare special pentru PipeRench;

<P>
</LI>
<LI>Un asamblor ia programul ºi genereazã configuraþia
corespunzãtoare.
</LI>
</OL>

<P>
Configuraþia este apoi oferitã circuitului reconfigurabil (sau
simulatorului), care se executã în tandem cu procesorul.  

<P>
La ora aceasta o versiune preliminarã a tuturor programelor desenate
cu linie continuã existã ºi este în curs de evaluare.  Deºi
partea din stînga a figurii pare mult mai micã, este extrem de
complicatã, pentru cã hardware-ul reconfigurabil conþine circuitul
propriu-zis, controlerul pentru memorie ºi configurare, ºi o
interfaþã pentru o magistralã PCI care este în proiectare.

<P>

<H1><A NAME="SECTION00050000000000000000">
Concluzii</A>
</H1>

<P>
Hardware-ul reconfigurabil promite un viitor frumos, datoritã
capacitãþii sale de a-ºi schimba funcþionalitatea extrem de rapid,
poate chiar în timpul funcþionãrii.  Abilitatea de a folosi
operaþiuni de bazã extrem de simple îl face un candidat pentru a
implementa procesãri care în mod convenþional nu se pot exprima cu
uºurinþã.  Capacitatea sa de reconfigurare îi poate da ºi alte
atribute dezirabile, cum ar fi rezilienþa la erori ºi capacitatea de
virtualizare a resurselor.

<P>
Nu mai este o dilemã dacã circuitele reconfigurabile vor intra sau
nu în galeria uneltelor ordinare ale arhitectilor calculatoarelor ºi
utilizatorilor lor.  Singura întrebare este ``cînd'' se va petrece
acest lucru.  Rãspunsul depinde numai de cei care cerceteazã în
acest domeniu: cît de repede vor reuºi sã gãseascã optica cea mai
potrivitã ºi uneltele cele mai eficace pentru a exploata puterea
expresivã a acestor circuite.  

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot150">... atrate</A><A NAME="foot150"
 HREF="reconf-html.html#tex2html1"><SUP>1</SUP></A>
<DD>Asta are de-a face cu
modul în care DRAM-ul funcþioneazã: jumãtate din biþii de adrese
selecteazã o <EM>linie</EM>, iar cealaltã jumãtate din biþii de
adrese selecteazã un cuvînt de memorie din linie.

<DT><A NAME="foot69">... microprocesoarele</A><A NAME="foot69"
 HREF="reconf-html.html#tex2html2"><SUP>2</SUP></A>
<DD>Aceastã aserþiune este valabilã
pentru procesoarele RISC; procesoarele CISC sunt de obicei
microprogramate.

<DT><A NAME="foot105">... a</A><A NAME="foot105"
 HREF="reconf-html.html#tex2html5"><SUP>3</SUP></A>
<DD>Proiectarea,
descrierea ºi simularea de circuite hardware se face folosind o
clasã specialã de limbaje, numite HDL: Hardware Description
Languages.  Cele mai rãspîndite limbaje de acest gen sunt VHDL (VLSI
HDL) ºi Verilog.

<DT><A NAME="foot116">... tiale</A><A NAME="foot116"
 HREF="reconf-html.html#tex2html6"><SUP>4</SUP></A>
<DD>Multe alte universitãþi au proiecte de acest
gen; legãturi spre unele dintre proiectele lor se pot gãsi tot în
aceastã paginã de web.

</DL>
<BR><HR>

</BODY>
</HTML>
