<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Redenumirea regiºtrilor Seria: arhitectura modernã a calculatoarelor</TITLE>
<META NAME="description" CONTENT="Redenumirea regiºtrilor Seria: arhitectura modernã a calculatoarelor">
<META NAME="keywords" CONTENT="redenumire-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Redenumirea regiºtrilor 
<BR>
Seria: arhitectura modernã a calculatoarelor</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>18 iunie 1999</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>tehnici de creºtere a performanþei procesoarelor
moderne: redenumirea regiºtrilor (register renaming)
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare despre
arhitectura procesoarelor
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>registru, redenumire, dependenþã
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html33"
  HREF="redenumire-html.html">Performanþã ºi compatibilitate</A>
<UL>
<LI><A NAME="tex2html34"
  HREF="#SECTION00021000000000000000">Compatibilitatea ºi regiºtrii</A>
</UL>
<BR>
<LI><A NAME="tex2html35"
  HREF="#SECTION00030000000000000000">Paralelism ºi dependenþe</A>
<LI><A NAME="tex2html36"
  HREF="#SECTION00040000000000000000">Procesoare superscalare ºi LIW</A>
<LI><A NAME="tex2html37"
  HREF="#SECTION00050000000000000000">Pipelines (conducte)</A>
<LI><A NAME="tex2html38"
  HREF="#SECTION00060000000000000000">Dependenþele sub lupã</A>
<LI><A NAME="tex2html39"
  HREF="#SECTION00070000000000000000">Redenumirea regiºtrilor</A>
<UL>
<LI><A NAME="tex2html40"
  HREF="#SECTION00071000000000000000">Un exemplu</A>
</UL>
<BR>
<LI><A NAME="tex2html41"
  HREF="#SECTION00080000000000000000">De ce apar dependenþe inutile</A>
<UL>
<LI><A NAME="tex2html42"
  HREF="#SECTION00081000000000000000">Un panaceu?</A>
</UL>
<BR>
<LI><A NAME="tex2html43"
  HREF="#SECTION00090000000000000000">Concluzii</A>
</UL>
<!--End of Table of Contents-->
<P>
Cu cîtãva vreme în urmã am publicat în PC Report douã articole
despre arhitectura procesoarelor moderne, care se doreau a fi parte
dintr-o suitã despre acest subiect foarte generos.  Din pãcate (sau
din fericire, depinzînd de perspectivã), m-am luat cu vorba despre
Internet ºi alte lucruri, ºi nu am mai continuat pe acest subiect,
deºi unul dintre articole promitea ``demistificarea'' unei liste
impresionante de termeni.

<P>
Articolul de faþã este o continuare a celor douã anterioare.
Pentru o tratare maturã a subiectului rãmîne valabilã referinþa
oferitã cu acea ocazie, Hennessy and Patterson ``Computer
Architecture -- a Quantitative Approach'', Morgan Kaufmann, ediþia
II, 1995.

<P>

<H1><A NAME="SECTION00020000000000000000">
Performanþã ºi compatibilitate</A>
</H1>

<P>
Intel este cea mai mare companie din domeniul hardware, cu un venit
anual de 26 de miliarde de dolari în 1998.  Într-un fel ar fi de
aºteptat ca cei care au inventat microprocesorul sã fie ºi liderii
din punct de vedere economic.  Pe de altã parte, adesea, tehnologic
vorbind, compania a fost depãºitã de altele în ceea ce priveºte
performanþa microprocesoarelor realizate.  De fapt, multã vreme
procesoarele 8086, 80386, Pentium, etc. au fost cu mult mai slabe în
performanþe decît procesoare contemporane lor ale unor firme
concurente.  Atunci cum se explicã succesul economic nemaipomenit al
lui Intel?  Probabil cã nu existã un rãspuns simplu, dar cel puþin
o fãrîmã de rãspuns stã în <EM>producþia de masã</EM>.  PC-urile
sunt de departe cele mai rãspîndite calculatoare acum, aºa cã,
chiar în condiþiile unor produse inferioare calitativ (dar cu
preþuri mici) Intel a putut sã cîºtige mult mai mult decît
celelalte companii.  Cîºtiguri care apoi au fost investite în
cercetare ºi dezvoltare, care au dus la crearea lui Pentium II, care
este un chip cu adevãrat extraordinar.

<P>
De fapt avantajele ºi dezavantajele lui Intel provin din aceeaºi
sursã, producþia de masã.  Producþia de masã necesitã
compatibilitate între produse, pentru ca utilizatorii sã poatã
beneficia de software-ul care a fost deja scris.  Asta este un avantaj
nemaipomenit, ºi este cert cã relaþia strînsã cu Microsoft a
însemnat enorm în succesul lui Intel (Microsoft fiind acum compania
cea mai mare din lume, socotind cotaþia la bursã).  Dar
compatibilitatea a fost ºi blestemul lui Intel.

<P>
La începutul anilor '80, din laboratoarele de cercetare de la
universitãþile Stanford ºi Berkeley ieºea un concept complet nou
de arhitecturã a procesoarelor: procesorul RISC, încarnat în
procesorul MIPS (actualmente în posesiunea lui Silicon Graphics).
RISC-urile sunt procesoare care implementeazã instrucþiuni extrem de
simple, dar care profitã de aceastã simplitate pentru a rula la
viteze extreme, folosind un hardware foarte eficace.  Aparent RISC-ul
era sortit sã fie învingãtor, ºi o sumã întreagã de companii au
început sã fabrice RISC-uri.  Performanþele lor erau într-adevãr
spectaculoase, comparat cu procesoarele de tip CISC, tradiþionale.

<P>
Aceasta era ºi problema lui Intel: 8088 ºi toþi descendenþii lui
sunt de la început compatibile unul cu altul, deci trebuie sã
implementeze acelaºi set de instrucþiuni.  Dar setul de
instrucþiuni x86 (cum este abreviatã familia) a fost proiectat
înaintea revoluþiei RISC (mai exact în 1978), deci nu putea
beneficia de toate avantajele tehnologice care pot fi aplicate în
cazul acestora.  Intel era sortitã sã rãmînã în urmã.

<P>
Salvarea a venit însã dintr-o direcþie oarecum neaºteptatã: din
tehnologie.  Intel a reuºit în ultimii ani sã recupereze toate
diferenþele faþã de competitorii sãi, ºi sã livreze procesoare
extrem de performante.  Cum se explicã acest lucru?

<P>
Diferenþa RISC-CISC este o diferenþã <EM>relativã</EM>; relativã la
tehnologia curentã.  Dimensiunea tranzistoarelor dintr-un circuit
integrat în 1986, ºi deci numãrul de tranzistoare care se puteau
construi, era limitat la o valoare în jurul a 100 000.  Cu atîtea
tranzistoare puteai construi o maºinãrie RISC eficace, dar nu ºi
una CISC; puteai face CISC-uri doar lente, folosind micro-cod, pentru
cã sarcina decodificãrii ºi executãrii unui set de instrucþiuni
complex cerea mai multe resurse.  Dar avansul implacabil al
tehnologiei ºi-a spus cuvîntul, dimensiunea ºi viteza circuitelor
se dubleazã la fiecare 18 luni, deci în 1995 Intel a avut la
dispoziþie suficiente resurse pe pilula de siliciu pentru a lupta
cot-la-cot cu RISC-urile, folosind propriile lor idei, cu Pentium II.
ªi, cel puþin deocamdatã, Intel a cîºtigat, ajutatã fiind ºi de
formidabila economie de masã a PC-ului.

<P>

<H2><A NAME="SECTION00021000000000000000">
Compatibilitatea ºi regiºtrii</A>
</H2>

<P>
Desigur, asta este o poveste interesantã, dar ce are a face cu
arhitectura modernã a calculatoarelor?  Ei bine, deºi partea
economicã este cu certitudine incitantã, cuvîntul cheie asupra
cãruia o sã mã aplec pentru a construi acest articol este
``compatibilitatea''.

<P>
Pentium III poate încã executa cod scris pentru procesorul 8086.  De
fapt, majoritatea codului executat în lume pe procesoare Pentium a
fost scris cu procesoare mai slabe decît 80286 în minte (la ora
actualã cel mai rulat sistem de operare din lume este încã Windows
3.1).  În plus, foarte multã lume scrie încã software pentru
platforme vechi, pentru cã baza instalatã este uriaºã, ºi altfel
ar însemna sã dai cu piciorul unei mulþimi de potenþiali clienþi.
În plus, metoda obiºnuitã de distribuþie a software-ului este în
formã de programe executabile, gata compilate.  Asta înseamnã cã o
mulþime de programe folosesc numai facilitãþile vechi ale
procesorului, chiar dacã acesta are acum cu mult mai multe resurse.

<P>
De pildã, în mod esenþial numãrul de regiºtri de bazã la Pentium
este în continuare 4 (EAX, EBX, ECX ºi EDX), deºi costul unui
registru în hardware este nesemnificativ, iar performanþa obþinutã
din folosirea unui numãr mare de regiºtri este substanþialã.  Din
motive de compatibilitate însã, Intel nu poate schimba radical setul
de instrucþiuni, introducînd noi regiºtri.  Prin comparaþie,
procesoarele moderne RISC au cel puþin cîte 32 de regiºtri.

<P>
Regiºtrii sunt foarte importanþi pentru performanþã pentru cã accesul
la datele din regiºtri este foarte rapid (de fapt, ce sunt altceva
regiºtrii, decît o foarte micã memorie cache aflatã chiar pe procesor;
un cache al cãrui management este fãcut de compilator?).  Odatã cu
miniaturizarea ºi creºterea vitezelor de ceas, diferenþa de duratã
între accesele la regiºtri ºi cele la memorie creºte îngrijorãtor (de
exemplu am vãzut într-un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#masuri">articol</a>
din PC Report niºte mãsurãtori pentru un sistem Pentium 266Mhz, la
care accesul la memorie putea dura de 13 ori mai mult decît cel al un
registru!).  Diferenþa aceasta este de sute de cicli pentru cazul
multi-procesoarelor, care au nevoie de mecanisme complicate de
arbitrare a accesului la memorie.

<P>
Desigur, aici contrastãm viteza de acces la memoria principalã, dar
foarte adesea datele se vor afla de fapt în cache-ul
microprocesorului.  Chiar ºi aºa, cache-urile moderne L1 nu sunt
capabile sã þinã pasul cu viteza procesoarelor, oferind timpi de
acces de ordinul a 2-4 cicli, timpi care vor creºte în viitor
(pentru cã ciclul scade)<A NAME="tex2html3"
  HREF="#foot57"><SUP>1</SUP></A>.

<P>
Dacã are mulþi regiºtri la dispoziþie, un compilator poate aplica
o serie mai largã de optimizãri, ºi are mai multã libertate în
plasamentul valorilor, putînd optimiza mai eficace programele.  Un
singur registru în plus poate însemna foarte mult pentru eficienþa
codului compilat.  Vom vedea cã un numãr redus de regiºtri
forþeazã compilatorul sã reutilizeze aceiaºi regiºtri pentru
lucruri diferite.  Acesta reutilizare înseamnã dependenþe între
instrucþiuni, care la rîndul lor cauzeazã imposibilitatea de
execuþie a instrucþiunilor simultan.

<P>
Vom vedea în acest articol o soluþie foarte ingenioasã a acestei
probleme; vom vedea cum, dînd iluzia programelor cã au la
dispoziþie numai un numãr foarte redus de regiºtri, procesoarele
sunt capabile sã utilizeze intern mai multe, obþinînd majoritatea
beneficiilor descrise mai sus.

<P>

<H1><A NAME="SECTION00030000000000000000">
Paralelism ºi dependenþe</A>
</H1>

<P>
Dacã 50% din cre'sterea 'in performan't'a a procesoarelor
contemporane provine cu certitudine din aportul tehnologiei, care
permite folosirea unor ceasuri din ce în ce mai rapide, cealaltã
jumãtate trebuie sa fie atribuitã inovaþiilor hardware, ºi mai cu
seama, paralelismului exploatat.

<P>
Paralelism înseamnã cã mai multe activitãþi independente se
desfãºoarã simultan.  Nu prea este clar despre ce fel de paralelism
poate fi vorba în cazul procesoarelor: acestea primesc doar un singur
program, care este o secvenþã de instrucþiuni, pe care trebuie
sã-l execute.  Ce se poate face în paralel atunci?

<P>
Existã mai multe feluri de paralelism, de obicei categorisit dupã
granularitatea sarcinilor executate în paralel.  De pildã, un sistem
de operare este capabil sã execute simultan mai multe aplicaþii;
acesta este paralelismul la nivel de aplicaþie.  Procesoarele însã
acþioneazã la un nivel microscopic, privind doar la cîte o
instrucþiune din program.  Ele manipuleazã paralelism la o
granularitate infimã, comparat cu paralelismul proceselor.

<P>
Chiar dacã programele scrise de noi denotã o suitã de acþiuni care
trebuie efectuate într-o anumitã secvenþã, existã o cantitate
oarecare de libertate în ordinea în care acestea sunt îndeplinite.
Dacã, de pildã, iniþializãm mai multe variabile, adesea aceste
operaþii pot fi executate în orice ordine, obþinînd aceleaºi
efecte.

<P>
Desigur, douã instrucþiuni se pot executa simultan numai dacã nu
depind una de alta.  Douã instrucþiuni ca ``<TT>f=1; g=f+2</TT>'' nu se
pot executa simultan, pentru cã a doua are nevoie de rezultatul
primeia.  Spunem atunci cã a doua instrucþiune depinde de prima,
sau cã între ele existã o <EM>dependenþã</EM>.

<P>
Atunci cînd programele sunt traduse în cod-maºinã, între micile
instrucþiuni rezultate adesea se gãsesc unele care sunt <EM>independente</EM>, deci care se pot executa în orice ordine.  Aceste
instrucþiuni pot fi executate deci ºi în paralel, dacã avem
resursele necesare la dispoziþie.  Acest gen de paralelism este
extrem de important, ºi are propriul sãu nume: ``paralelism la nivel
de instrucþiune'', sau Instruction Level Parallelism, ILP.

<P>

<H1><A NAME="SECTION00040000000000000000">
Procesoare superscalare ºi LIW</A>
</H1>

<P>
Majoritatea procesoarelor moderne exploateazã ILP într-un mod foarte
natural: au mai multe unitãþi din fiecare fel, care le permit sã
execute mai multe instrucþiuni simultan.  Astfel, ele trebuie sã
aibã mai multe unitãþi care aduc instrucþiuni din memorie, care le
decodificã, care le executã ºi care stocheazã rezultatele.

<P>
Existã douã categorii mari de procesoare care exploateazã ILP
executînd instrucþiuni în paralel; ele se deosebesc dupã felul în
care se decide <EM>care</EM> instrucþiuni se pot simultaneiza.

<P>

<H4><A NAME="SECTION00040010000000000000">
LIW:</A>
</H4> Prima mare categorie de procesoare lasã decizia în
cîrca compilatorului; acesta are misiunea sã indice care
instrucþiuni sunt independente.  Hardware-ul doar ia instrucþiunile
indicate ºi le trimite unor unitãþi separate.  Hardware-ul este
simplu, iar compilatorul este complicat.  De fapt putem vedea
compilatorul ca oferind hardware-ului niºte ``super-instrucþiuni'',
formate din mai multe instrucþiuni elementare; din cauza asta astfel
de procesoare se numesc ``Long Instruction Word'' (LIW), sau
cîteodatã VLIW (Very LIW).  De exemplu procesorul de semnal Texas
Instruments TMS320C62x primeºte simultan pînã la 8 instrucþiuni.

<P>

<H4><A NAME="SECTION00040020000000000000">
Superscalare:</A>
</H4> A doua clasã de procesoare calculeazã
dependenþele în întregime în hardware, ºi decide la faþa locului
care instrucþiuni pot fi lansate în paralel<A NAME="tex2html4"
  HREF="#foot66"><SUP>2</SUP></A>.  Pentium II de pildã
citeºte, decodificã ºi încearcã sã execute cîte douã
instrucþiuni la fiecare bãtaie de ceas.  Aceste procesoare se numesc
<EM>superscalare</EM>.

<P>

<H1><A NAME="SECTION00050000000000000000">
Pipelines (conducte)</A>
</H1>

<P>
Pe lîngã aceastã metodã de a exploata ILP, existã o alta foarte
ingenioasã, numitã ``banda de asamblare'', sau ``conductã''.  Am
scris un articol întreg despre acest subiect, dar iatã ideile
esenþiale: dacã avem o suitã de acþiuni de efectuat ºi mai multã
forþã de muncã, ºi dacã putem descompune fiecare acþiune în mai
multe bucãþele, atunci putem construi o bandã de asamblare, în
care fiecare porþiune a benzii face o singurã parte.  La fel ca
zidarii: unul ia cãrãmidã, unul o întinde, unul pune mortar ºi
unul o înfige în perete.

<P>
La fel stau lucrurile ºi în cazul procesoarelor: citirea,
decodificarea, execuþia, stocarea rezultatelor, sunt tot atîtea
micro-acþiuni, care pot fi executate simultan pentru instrucþiuni
diferite: cînd o instrucþiune tocmai se terminã, cea de dupã ea
stocheazã rezultatele, urmãtoarea tocmai ºi le calculeazã în timp
ce a patra este decodificatã, etc.

<P>
Acest gen de paralelism se numeºte paralelism de pipeline.  La o
vedere superficialã paralelismul de pipeline nu este afectat de
dependenþe; în realitate acestea sunt la fel de importante ca ºi
în cazul superscalarelor.  Sã ne gîndim un pic: dacã avem cele
douã instrucþiuni de mai sus, dependente, ``<TT>f=1; g=f+2</TT>'',
atunci cînd <TT>f+2</TT> vrea sã citeascã valoarea lui <TT>f</TT> pentru
a face calcule cu ea, valoarea de fapt încã nu a fost calculatã,
ºi nici stocatã unde trebuie, pentru cã instrucþiunea <TT>f=1</TT> se
aflã încã în stagiul de execuþie.  În analogia cu zidarii, este
ca ºi cum un zidar fabricã chiar mortarul de care are nevoie unul
dinaintea lui; cel care pune mortar nu are cum sã acþioneze înainte
ca mortarul sã existe.

<P>

<H1><A NAME="SECTION00060000000000000000">
Dependenþele sub lupã</A>
</H1>

<P>
Dacã sunteþi nerãbdãtori sã aflaþi ce are asta a face cu
redenumirea regiºtrilor, o sã fac aici o scurtã avanpremierã.  Vom
vedea cã anumite dependenþe sunt de fapt artificial introduse, din
cauzã cã unii regiºtri trebuie refolosiþi pentru a stoca variabile
complet diferite; dacã am avea mai mulþi regiºtri, ca sã punem o
variabilã în fiecare, aceste dependenþe ar dispãrea.  Ei bine,
redenumirea regiºtrilor tocmai asta va face: va folosi o gãleatã cu
regiºtri ascunºi, pe care-i va folosi în astfel de cazuri,
eliminînd anumite dependenþe ºi mãrind gradul de paralelism de
care procesorul poate profita.

<P>
În general între douã instrucþiuni existã o dependenþã dacã
folosesc acelaºi registru sau aceeaºi adresã de memorie.  Acesta
însã nu este un criteriu suficient; conteazã ºi <EM>cum</EM> folosesc
acest registru comun.  De pildã dacã douã instrucþiuni citesc
dintr-un acelaºi registru, între ele nu existã nici o dependenþã,
pentru cã acþiunea de citire lasã registrul neschimbat, deci
ordinea instrucþiunilor nu influenþeazã rezultatul.  Dacã una din
instrucþiuni însã <EM>scrie</EM> în registru, atunci avem o
dependenþã.  Dependenþele se denoteazã cu 3 litere:
Acþiune-Dupã-Acþiune, de pildã Scrie-Dupã-Citire.  Denumirile
tradiþionale sunt în englezã:

<P>
<DL>
<DT><STRONG>RAW</STRONG></DT>
<DD>Read after write.  Avem o astfel de dependenþã 
în exemplul anterior, reprodus ºi în figura&nbsp;<A HREF="redenumire-html.html#raw">1</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="raw"></A><A NAME="230"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
O dependenþã RAW: <TT>f</TT> este citit de
instrucþiunea&nbsp;2 dupã ce ce este scris de cãtre instrucþiunea&nbsp;1.</CAPTION>
<TR><TD><IMG
 WIDTH="124" HEIGHT="48" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=3cm\epsffile{raw.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
A doua instrucþiune citeºte valoarea lui <TT>g</TT> dupã ce prima o
scrie.  Aceastã dependenþã se mai numeºte ºi ``dependenþã
adevãratã'' (true dependence).

<P>
</DD>
<DT><STRONG>WAR</STRONG></DT>
<DD>apare cînd o instrucþiune scrie într-un registru care
tocmai a fost citit, cum ilustreazã ºi figura&nbsp;<A HREF="redenumire-html.html#war">2</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="war"></A><A NAME="239"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
O dependenþã WAR: <TT>b</TT> este scris de
instrucþiunea 2, dupã ce a fost citit de instrucþiunea 1.</CAPTION>
<TR><TD><IMG
 WIDTH="442" HEIGHT="104" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{war.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Din nou, nu putem schimba ordinea instrucþiunilor, sau nu putem risca
sã le executãm în paralel, pentru cã, dacã a doua se terminã
înainte ca prima sã citeascã valoarea, rezultatul primeia va fi
greºit.  O astfel de dependenþã se mai numeºte <EM>anti-dependenþã</EM>.

<P>
</DD>
<DT><STRONG>WAW</STRONG></DT>
<DD>este ultimul tip, în care o douã instrucþiuni scriu în
aceeaºi valoare; vedeþi figura&nbsp;<A HREF="redenumire-html.html#waw">3</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="waw"></A><A NAME="247"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3:</STRONG>
O dependenþã WAW apare cînd douã instrucþiuni
au aceeaºi destinaþie.</CAPTION>
<TR><TD><IMG
 WIDTH="442" HEIGHT="103" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{waw.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Aceste dependenþe se mai numesc ºi <EM>output dependences</EM>.

<P>
Aparent dependenþele WAW nu trebuie sã aparã în programe: de ce
compilatorul ar indica o instrucþiune al cãrei efect sã fie imediat
distrus?  De ce ºi-ar bate proiectantul procesorului capul cu astfel
de instrucþiuni?  În realitate dependenþele WAW pot apãrea în mai
multe contexte:

<P>

<OL>
<LI>Între instrucþiuni nu neapãrat consecutive, cum este ilustrat
în figura&nbsp;<A HREF="redenumire-html.html#waw-ex">4</A>.  Aici avem o dependenþã WAW între prima
ºi a treia instrucþiune;

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="waw-ex"></A><A NAME="253"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 4:</STRONG>
O dependenþã WAW ºi una RAW la care
participã o singurã valoare.</CAPTION>
<TR><TD><IMG
 WIDTH="124" HEIGHT="70" BORDER="0"
 SRC="img4.png"
 ALT="\begin{figure}\centerline{\epsfxsize=3cm\epsffile{waw-ex.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
</LI>
<LI>Pe de altã parte, nu e treaba procesorului sã decidã dacã un
program are sau nu sens; poate cineva scrie de mînã un astfel de
program; procesorul tot trebuie sã dea rezultatele corecte;

<P>
</LI>
<LI>Un alt caz de acest gen poate apãrea dacã apare o
întrerupere; deºi nu existã nicãieri în program douã scrieri
consecutive în acelaºi registru, saltul la rutina de întrerupere
poate cauza apariþia unei astfel de secvenþe;

<P>
</LI>
<LI>În fine, procesoarele moderne folosesc o altã tehnicã,
numitã <EM>execuþie speculativã</EM>: executã cod chiar ne-necesar,
pentru cã nu sunt sigure ce trebuie sã facã, deci mai bine sã
facã ceva, orice, care s-ar putea dovedi util, decît sã stea
degeaba (intenþionez sã consacru un articol întreg acestui
subiect).  Ei bine, dacã ai executat cod speculativ ºi ai observat
cã de fapt nu trebuia, atunci poate vei dori sã ºtergi efectele
codului speculativ; în acest caz pot apãrea din nou dependenþe WAW.
</LI>
</OL>
</DD>
</DL>

<P>
Încã o datã: studiul dependenþelor este important, pentru cã
existenþa lor reduce posibilitatea de execuþie paralelã a mai
multor instrucþiuni din program (fie prin paralelism superscalar,
VLIW ori pipelined).  Din fericire, în anumite, cazuri putem face
ceva pentru a ameliora situaþia.

<P>

<H1><A NAME="SECTION00070000000000000000">
Redenumirea regiºtrilor</A>
</H1>

<P>
În realitate numai dependenþele ``adevãrate'' (RAW) sunt de
ne-evitat.  De celelalte putem scãpa redenumind regiºtri.
Observaþia cheie este cã programele în final vor stoca toate
rezultatele în memorie; pentru utilizator conþinutul regiºtrilor nu
este important.  Dacã programul foloseºte registrul <TT>x</TT> sau
<TT>y</TT>, nu are nici o importanþã atîta vreme cît obþinem
acelaºi rezultat.

<P>
Figurile&nbsp;<A HREF="redenumire-html.html#war-r">5</A> ºi&nbsp;<A HREF="redenumire-html.html#waw-r">6</A> aratã cum putem rescrie
dependenþele WAR ºi WAW de mai sus, obþinînd acelaºi efect.  Vom
presupune cã avem la dispoziþie în fiecare caz cîte un registru
nefolosit.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="war-r"></A><A NAME="261"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 5:</STRONG>
Dependenþa WAR este eliminatã înlocuind
apariþiile lui <TT>b</TT> cu un registru nou (<TT>f</TT>).</CAPTION>
<TR><TD><IMG
 WIDTH="442" HEIGHT="99" BORDER="0"
 SRC="img5.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{war-r.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="waw-r"></A><A NAME="271"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 6:</STRONG>
Dependenþa WAW este eliminatã înlocuind
apariþiile lui <TT>f</TT> cu un registru nou (<TT>a</TT>).</CAPTION>
<TR><TD><IMG
 WIDTH="442" HEIGHT="98" BORDER="0"
 SRC="img6.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{waw-r.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Observaþi cã ambele aceste programe produc exact acelaºi rezultat
ca programele iniþiale.

<P>
Cred cã acum începe sã devinã clar de fapt ce se întîmplã în
miezul procesorului:

<P>

<OL>
<LI>Microprocesorul are intern foarte mulþi regiºtri, dar expune
programatorului numai cîþiva;

<P>
</LI>
<LI>Cînd procesorul executã cod, detecteazã dependenþele care se
pot rezolva (anti- ºi output-).  Atunci cînd gãseºte astfel de
dependenþe, în cazul în care posedã un registru intern liber,
foloseºte acest registru în locul celui care provoca dependenþa.

<P>
</LI>
<LI>În felul acesta procesorul transformã instrucþiuni dependente
în instrucþiuni independente, care se pot apoi executa în paralel,
mãrind performanþa execuþiei.

<P>
</LI>
<LI>Procesorul þine minte regiºtrii redenumiþi, ºi apariþiile
lor ulterioare sunt de asemenea redenumite.
</LI>
</OL>

<P>

<H2><A NAME="SECTION00071000000000000000">
Un exemplu</A>
</H2>

<P>
În loc de a prezenta algoritmul detaliat folosit pentru a redenumi
regiºtri, voi ilustra funcþionarea sa cu un exemplu.
Figurile&nbsp;<A HREF="redenumire-html.html#film">7</A>-<A HREF="redenumire-html.html#film7">14</A> aratã ``filmul'' execuþiei unui
progrãmel mic de 5 instrucþiuni pe un procesor superscalar care
poate executa simultan adunãri ºi înmulþiri.  Presupunem cã
operaþia de adunare se poate efectua în 1 ciclu de ceas, iar cea de
înmulþire în 2.  Ilustrãm ºi structurile de date menþinute de
procesor pentru a þine cont de redenumiri.  Acest exemplu este
adaptat dupã un exemplu al domnului Randy Bryant, prezentat la un
curs de arhitectura calculatoarelor în toamna anului 1998 la Carnegie
Mellon.

<P>
Vom presupune cã procesorul nostru poate executa instrucþiuni în
orice ordine, dacã sunt independente.

<P>
Dacã urmãriþi filmul cu atenþie, veþi observa cã numai
dependenþele adevãrate apar, celelalte fiind eliminate de
redenumire.  Veþi vedea marcate instrucþiuni care aºteaptã una
dupã alta datoritã dependenþelor.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="film"></A><A NAME="281"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 7:</STRONG>
Programul de executat, valorile iniþiale ale
regiºtrilor, regiºtrii ascunºi ºi cozile de instrucþiuni gata de
execuþie.  Observaþi cã sãgeþile pentru dependenþe merg mereu
în acelaºi ``sens'': WAW pe verticalã, RAW de la stînga spre
dreapta, WAR de la dreapta spre stînga.  Cîmpul <EM>valid</EM> indicã
dacã acest registru ascuns are o valoare corectã în interior.</CAPTION>
<TR><TD><IMG
 WIDTH="587" HEIGHT="309" BORDER="0"
 SRC="img7.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{film.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="film1"></A><A NAME="288"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 8:</STRONG>
Ciclul 1: instrucþiunea <TT>a</TT> îºi
redenumeºte destinaþia din <TT>r5</TT> în <TT>x1</TT>, iar instrucþiunea
<TT>b</TT> îºi redenumeºte destinaþia <TT>x2</TT>.  Instrucþiunea de
înmulþire aºteaptã rezultatul din registrul <TT>x1</TT> (fostul
<TT>r5</TT>, acum redenumit), pentru a putea începe: avem aici o
dependenþã RAW, care nu poate fi eliminatã.  Observaþi cã
<TT>r5</TT> a fost deja redenumit de 2 ori.  Numele de <TT>x2</TT> este
stocat pentru <TT>r5</TT>, pentru ca urmãtoarele instrucþiuni care au
nevoie de <TT>r5</TT> sã ia de fapt de aici valorile lor.</CAPTION>
<TR><TD><IMG
 WIDTH="587" HEIGHT="309" BORDER="0"
 SRC="img8.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{film1.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="film2"></A><A NAME="316"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 9:</STRONG>
Ciclul 2: instrucþiunea <TT>a</TT> s-a terminat,
ºi a scris rezultatul în destinaþia ei, <TT>x1</TT>.  Instrucþiunea
de înmulþire poate începe, pentru cã acum registrul <TT>x1</TT> este
valid.  Instrucþiunea <TT>d</TT> este gata de execuþie, dar
instrucþiunea <TT>c</TT> nu a primit încã operandul din registrul
<TT>x2</TT>, care este calculat de înmulþire.  Instrucþiunea <TT>c</TT>
ºi-a redenumit destinaþia în <TT>x3</TT>, iar instrucþiunea <TT>d</TT>
în <TT>x4</TT>.</CAPTION>
<TR><TD><IMG
 WIDTH="587" HEIGHT="309" BORDER="0"
 SRC="img9.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{film2.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="film3"></A><A NAME="342"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 10:</STRONG>
Ciclul 3: instrucþiunea <TT>a</TT> s-a terminat
complet; cu toate acestea nu a schimbat registrul <TT>r5</TT>, pentru cã
acum acesta este redenumit în <TT>x2</TT>.  Instrucþiunea <TT>b</TT> îºi
începe execuþia pentru cã are toate valorile necesare, dar terminã
numai primul din cei doi cicli necesari pentru execuþie.
Instrucþiunea <TT>d</TT> o ia înaintea lui <TT>c</TT>.  Instrucþiunea
<TT>e</TT> este pregãtitã pentru execuþie ºi îºi redenumeºte
destinaþia din <TT>r5</TT> în <TT>x1</TT>.  Observaþi ca valoarea din
<TT>x1</TT> a fost distrusã; ea nu mai era necesarã, datoritã
output-dependenþei.  Puteam observa acest lucru, deoarece nici o
instrucþiune nu mai avea nevoie de registrul <TT>x1</TT> ca sursã, ºi
nici un registru nu mai era redenumit în <TT>x1</TT>.</CAPTION>
<TR><TD><IMG
 WIDTH="587" HEIGHT="309" BORDER="0"
 SRC="img10.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{film3.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="film4"></A><A NAME="372"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 11:</STRONG>
Ciclul 4: instrucþiunea de înmulþire <TT>b</TT>
se terminã ºi oferã valoarea necesarã executãrii instrucþiunii
<TT>c</TT>.  Instrucþiunea <TT>c</TT> începe execuþia.  Instrucþiunea
<TT>d</TT> nu poate fi consideratã terminatã, pentru cã este posibil
ca instrucþiunea dinaintea ei, <TT>x</TT> sã genereze o excepþie, deci
nu avem voie sã stocãm încã rezultatele lui <TT>d</TT>.</CAPTION>
<TR><TD><IMG
 WIDTH="587" HEIGHT="309" BORDER="0"
 SRC="img11.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{film4.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="film5"></A><A NAME="390"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 12:</STRONG>
Ciclul 5: Instrucþiunea <TT>b</TT> s-a terminat,
dar din nou, <TT>r5</TT> nu este schimbat.  Datoritã celei de-a doua
dependenþe WAW, valoarea calculatã este nu mai trebuie stocatã.
Încã nu putem termina <TT>d</TT>, pentru cã <TT>c</TT> nu e gata.
<TT>c</TT> tocmai se terminã.</CAPTION>
<TR><TD><IMG
 WIDTH="587" HEIGHT="309" BORDER="0"
 SRC="img12.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{film5.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="film6"></A><A NAME="406"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 13:</STRONG>
Ciclul 6: În fine, instrucþiunea <TT>c</TT> se
terminã, ºi ca atare se poate termina ºi <TT>d</TT>.  Regiºtrii
ascunºi îºi copiazã valorile înapoi în regiºtrii reali, iar
ultima instrucþiune intrã în execuþie.</CAPTION>
<TR><TD><IMG
 WIDTH="587" HEIGHT="309" BORDER="0"
 SRC="img13.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{film6.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="film7"></A><A NAME="416"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 14:</STRONG>
Ciclul 7: Ultima instrucþiune s-a terminat,
iar rezultatul ei este preluat dintr-un registru ascuns în cel real.</CAPTION>
<TR><TD><IMG
 WIDTH="587" HEIGHT="309" BORDER="0"
 SRC="img14.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{film7.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Desigur, exemplul acesta este pedagogic, pentru cã de fapt ºirul
instrucþiunilor nu se terminã niciodatã; acest algoritm incîlcit
este executat fãrã ostenealã de procesor, de 500 de milioane de ori
pe secundã!

<P>

<H1><A NAME="SECTION00080000000000000000">
De ce apar dependenþe inutile</A>
</H1>

<P>
Din moment ce procesorul are mulþi regiºtri, ºi din moment ce unele
dependenþe pot fi evitate, de ce apar ele totuºi în program?
Rãspunsul este acelaºi: din motive de compatibilitate.  

<P>
Setul de instrucþiuni al unui procesor trebuie sã ofere vederi
compatibile asupra procesorului, chiar dacã mãruntaiele acestuia se
schimbã foarte mult în timp.

<P>
De pildã, x86 are în continuare doar 4 regiºtri fundamentali;
compilatorul nu are cum sã foloseascã regiºtri diferiþi pentru
valori diferite, pentru cã nu are destui regiºtri la dispoziþie.
Din cauza asta va re-folosi regiºtri, cauzînd apariþia unor
dependenþe.

<P>
O problemã ºi mai mare a arhitecturii x86 este faptul cã regiºtrii
ei sunt <EM>asimetrici</EM>!  La x86, majoritatea operaþiilor aritmetice
trebuie sã aibã registrul <TT>eax</TT> ca destinaþie, chiar dacã
ceilalþi regiºtri sunt liberi.  Din cauza asta compilatorul este
forþat sã facã ºi mai multe jonglerii cu regiºtrii; probabil ca
intern Pentium este implementat ca un RISC simetric, în care toþii
regiºtrii pot fi destinaþia unei valori, ºi ca foloseºte din plin
redenumirea regiºtrilor pentru a lansa în execuþie mai multe
instrucþiuni aritmetice simultan.

<P>

<H2><A NAME="SECTION00081000000000000000">
Un panaceu?</A>
</H2>

<P>
Trebuie sã înþelegem cã, deºi salveazã din performanþã în mod
substanþial, redenumirea regiºtrilor nu este un panaceu pentru a
rezolva problema lipsei de regiºtri.  Ce se întîmplã: sã zicem
cã la un moment dat compilatorul are de manipulat 5 valori pentru un
sistem x86, care are doar 4 regiºtri fundamentali.

<P>
Ei bine, atunci compilatorul nu are altceva de fãcut decît sã
``verse'' (<EM>spill</EM>) o variabilã în memorie, de unde sã o
încarce într-un registru cînd e necesar.  Pentru astfel de cazuri,
mecanismul de redenumire este inutil.

<P>

<H1><A NAME="SECTION00090000000000000000">
Concluzii</A>
</H1>

<P>
În acest text am vãzut cum tensiunea dintre compatibilitate ºi
tehnologie împinge arhitecþii microprocesoarelor la soluþii
disperate, cum ar fi redenumirea regiºtrilor.  Aceastã tehnicã
permite procesorului sã menþinã valori diferite în regiºtrii
sãi ascunºi disponibili, chiar dacã compilatorului aceºtia îi
sunt invizibili.  Fãcînd acest lucru, procesorul reduce numãrul
dependenþelor dintre instrucþiuni, ºi face execuþia paralelã a
instrucþiunilor fezabilã, mãrind productivitatea.

<P>
S-ar zice cã Intel s-a sãturat de problemele lui x86; în viitoarea
arhitecturã anunþatã (de foarte, foarte multã vreme), IA64, Intel
va implementa un procesor RISC cu 128 de regiºtri.  Sã-i ajungã.

<P>
<BR><HR><H4>Note</H4>
<DL>
<DT><A NAME="foot57">... scade)</A><A NAME="foot57"
HREF="redenumire-html.html#tex2html3"><SUP>1</SUP></A> <DD>Despre
cache-uri am scris cu mai mult timp în urmã în PC Report mai multe <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#cache">articole</a>
ample.

<DT><A NAME="foot66">... paralel</A><A NAME="foot66"
HREF="redenumire-html.html#tex2html4"><SUP>2</SUP></A> <DD>Pentru o
comparaþie sumarã între expresivitatea metodelor statice (compilarea)
ºi a celor dinamice vedeþi ºi <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#ddd">articolul</a>
meu din PC Report din luna iunie 1999, despre debugger-e.

</DL>
<BR><HR>

</BODY>
</HTML>
