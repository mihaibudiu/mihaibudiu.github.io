<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Expresii Regulate</TITLE>
<META NAME="description" CONTENT="Expresii Regulate">
<META NAME="keywords" CONTENT="regex-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Expresii Regulate</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>martie 2000</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>expresii regulate ºi aplicaþiile lor
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare de programare a
calculatoarelor
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>expresie regulatã, automat finit, analizã
lexicalã
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html38"
  HREF="regex-html.html">Limbaje ºi calculatoare</A>
<LI><A NAME="tex2html39"
  HREF="#SECTION00030000000000000000">Analiza lexicalã</A>
<LI><A NAME="tex2html40"
  HREF="#SECTION00040000000000000000">Expresiile regulate: un limbaj pentru a descrie limbaje</A>
<UL>
<LI><A NAME="tex2html41"
  HREF="#SECTION00041000000000000000">Exemple de ER</A>
<LI><A NAME="tex2html42"
  HREF="#SECTION00042000000000000000">Limbaje regulate ºi limbaje neregulate</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION00043000000000000000">Aplicaþii ale limbajelor regulate</A>
</UL>
<BR>
<LI><A NAME="tex2html44"
  HREF="#SECTION00050000000000000000">Automate finite</A>
<LI><A NAME="tex2html45"
  HREF="#SECTION00060000000000000000">Programe care manipuleazã ER</A>
<UL>
<LI><A NAME="tex2html46"
  HREF="#SECTION00061000000000000000">Shell-ul Unix</A>
<LI><A NAME="tex2html47"
  HREF="#SECTION00062000000000000000"><TT>grep</TT></A>
<LI><A NAME="tex2html48"
  HREF="#SECTION00063000000000000000"><TT>awk</TT></A>
<LI><A NAME="tex2html49"
  HREF="#SECTION00064000000000000000"><TT>sed</TT></A>
<LI><A NAME="tex2html50"
  HREF="#SECTION00065000000000000000"><TT>vi</TT></A>
<LI><A NAME="tex2html51"
  HREF="#SECTION00066000000000000000"><TT>emacs</TT></A>
<LI><A NAME="tex2html52"
  HREF="#SECTION00067000000000000000"><TT>f?lex</TT></A>
<LI><A NAME="tex2html53"
  HREF="#SECTION00068000000000000000">Perl</A>
</UL>
<BR>
<LI><A NAME="tex2html54"
  HREF="#SECTION00070000000000000000">Alte surse de informaþie</A>
<LI><A NAME="tex2html55"
  HREF="#SECTION00080000000000000000">Concluzii</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
De la prima întîlnire cu calculatoarele am fost fascinat de ele.
Pentru mine întîlnirea asta s-a produs destul de tîrziu, dupã
standardele generaþiei actuale de elevi, prin clasa a opta.
Fireºte, primul lucru pe care l-am vãzut a fost un joc; calculatorul
cu pricina este o specie deja dispãrutã, numit Sinclair Spectrum ZX,
dupã care românii au fãcut o copie destul de reuºitã, numitã HC
85 (de fapt a existat o a doua copie, TIM-S, dar care s-a bucurat de
mai puþin succes).  Am avut imediat dorinþa de a construi ºi eu un
joc.

<P>
Realizez cã începutul ãsta poate induce în eroare cititorul,
pentru cã nu despre jocuri vreau sã vorbesc aici.  De fapt, dacã
aþi trecut peste dezamãgirea produsã de titlul anost, cred cã
veþi rezista ºi la restul textului.

<P>
De la început am fost fascinat de calculatoare, ºi fascinaþia mea a
rãmas neschimbatã, chiar dacã unele dintre motivele fascinaþiei
s-au modificat cu timpul.  La început am fost entuziasmat de faptul
cã exista o micã lume asupra cãruia sunt demiurg, stãpîn absolut,
o lume care se miºcã dupã legile pe care i le trasez eu.  Probabil
ca într-o oarecare mãsurã acest motiv este prezent ºi acum în
atracþia mea pentru calculatoare, dar într-o mãsurã mult
diminuatã.

<P>
Cu timpul am învãþat cã demiurgul-programator nu este de fapt
atotputernic; într-o serie de articole precedente din PC Report, am
încercat sã ilustrez unele dintre limitãrile calculatoarelor însele:
de exemplu am vãzut într-un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#complex">articol</a>
despre teoria complexitãþii ºi calculabilitate (PC Report din
Decembrie 1999, o copie fiind disponibilã din pagina mea de web) cã
existã lucruri pe care calculatoarele nu le pot calcula, ºi în trei
articole din octombrie, noiembrie ºi februarie am încercat sã <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#sat">arãt</a>
cã existã probleme care se pot rezolva, dar pentru care oricît de
multe resurse computaþionale am avea la dispoziþie, rãspunsuri
practice probabil nu vor putea fi obþinute vreodatã.

<P>
Acum calculatoarele sunt profesia mea ºi ca atare am de-a face cu ele
zi de zi.  De fapt studiez calculatoarele de 13 ani, în sensul cel
mai concret al cuvîntului: am fost elev la Liceul de Informaticã din
Bucureºti, student în calculatoare la Politehnica din Bucureºti
pentru ºase ani (din care unul de master), ºi acum sunt în al
treilea an de doctorat; cu toate acestea, mai am multe de învãþat!
Acum ºtiu cã de fapt calculatoarele nu sunt un haos primitiv, în
care eu, programatorul, atotputernic, pot face ordine, ci cã existã
multe limite peste care nu pot trece, cã unele lucruri se pot face
mai bine sau mai rãu, cîteodatã foarte bine ºi foarte rãu, ºi am
mai învãþat cã sunt enorm de multe lucruri pe care nimeni nu ºtie
încã sã le facã.  De fapt asta e o veste bunã pentru mine:
principala mea activitate este cercetarea, deci faptul cã sunt multe
lucruri de aflat înseamnã cã pentru o vreme o sã am ceva pîine pe
masã.

<P>
Am ajuns pe ocolite la ideea pe care vreau sã-mi bazez introducerea.
Dupã cum am spus ºi în alte articole, ºtiinþa calculatoarelor
(informatica în terminologie franco-românã) are douã ramuri mari:
partea teoreticã ºi cea aplicatã.  În general cercetãtorii pot fi
atribuiþi destul de clar uneia dintre ramuri.  Cei dintr-o ramurã
uneori îi privesc cu superioritate pe cei din cealaltã.  De fapt
ambele ramuri sunt extrem de importante, ºi deloc uºoare; efortul
intelectual depus în oricare dintre ele este substanþial, ºi
existã talent specific fiecãreia dintre ele.

<P>
Dar rezultatele cele mai spectaculoase se obþin atunci cînd teoria
ºi practica concurã; situaþia este oarecum asemãnãtoare cu
fizica, în care teoreticienii ºi experimentaliºtii sunt douã
triburi separate; dar revoluþiile sunt cele în care teoria ºi
practica explicã un acelaºi fenomen, confirmîndu-se ºi
întãrindu-se reciproc.

<P>
De fapt atunci cînd teoria concurã cu practica obþinem un al
treilea rezultat, cel mai palpabil, ºi cel care de fapt schimbã
societatea în mod dramatic: este vorba de tehnologie.  Cîþi dintre
cei care folosesc astãzi televizoarele sunt conºtienþi cã
existenþa lor se bazeazã pe teoria cîmpului electromagnetic a lui
Maxwell, ºi pe efectul fotoelectric descoperit experimental de Hertz
(ºi pentru a cãrei explicaþie Einstein a primit premiul Nobel)?

<P>
La fel stau lucrurile ºi în calculatoare: tehnologia la îndemîna
(aproape a) fiecãruia, care acum schimbã societatea într-un mod
fundamental (de exemplu prin Internet), nu ar fi fost posibilã fãrã
rezultate atît din teorie cît ºi din practicã.  De fapt acest
articol va ilustra o problemã foarte simplã, la care teoria a adus
niºte contribuþii majore, dar care are enorm de multe aplicaþii în
practicã.  De fapt, aceastã teorie are un succes atît de mare,
încît probabil cã nu existã calculator digital care sã nu o
foloseascã în mai multe feluri, de la cele din PC-uri pînã la
microcontrolerele care controleazã utilaje industriale sau regleazã
injecþia automobilelor.  Din necesitate însã, prezentarea noastrã
va fi foarte sumarã, ºi nu va acoperi decît puþine aspecte ale
problemei.

<P>

<H1><A NAME="SECTION00020000000000000000">
Limbaje ºi calculatoare</A>
</H1>

<P>
Un calculator abstractizat teoretic poate fi vãzut ca un aparat care
prelucreazã limbaje.  Toate informaþiile pe care le prelucreazã
sunt exprimate în semne discrete, pe care le vom numi ``<EM>litere</EM>'' (de exemplu în biþi, în zero ºi unu, sau dacã
preferaþi în octeþi).  Astfel, datele de la intrare ºi de la
ieºire sunt toate ºiruri de litere, pe care le numim ``<EM>cuvinte</EM>''.  Noþiunea aceasta de cuvînt este mai largã decît cea
obiºnuitã: în româna nu numim ºirul de litere ``jjj'' un cuvînt,
dar în terminologia calculatoarelor, da.  Fiecare program proceseazã
anumite cuvinte ºi dã ca rezultat alte cuvinte.  Adesea, pentru un
program nu orice cuvînt venit la intrare are sens: unele vor fi pur
ºi simplu eronate; de exemplu un program care sorteazã un ºir de
numere nu se aºteaptã sã primeascã alte simboluri.  Numim o
mulþime de cuvinte ``<EM>limbaj</EM>''.

<P>
De exemplu, limbajul Pascal constã în colecþia tuturor cuvintelor
care reprezintã programe corecte Pascal (observaþi cã un întreg
program Pascal este deci un singur cuvînt în aceastã
terminologie!).  O întrebare este cum poþi descrie în mod succint
un întreg limbaj?  De exemplu, cum poþi spune cuiva ce este un
program Pascal corect?  Pentru asta trebuie sã foloseºti reguli care
descriu cum se pot construi programele corecte.  Regulile care descriu
cum aratã un limbaj se numesc <EM>sintaxa</EM> limbajului.

<P>

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="313"></A>
<TABLE>
<CAPTION><STRONG>Tabela 1:</STRONG>
Un exemplu de program Pascal ºi un fragment (simplificat)
din notaþia Backus-Naur, care descrie toate programele Pascal
corecte.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><B>Program Pascal</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><B>Fragment din sintaxa
Pascal</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><PRE><TT>
program ridicol; <BR>
<BR>
var a:int, i:int; <BR>
<BR>
begin { main } <BR>
a = 0; <BR>
for i:= 1 to 10 do begin <BR>
a = a + i
<BR>
end;
<BR>
println a <BR>
end.
</TT></PRE></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>Program := <BR> <TT>program</TT> identificator <TT>;</TT> bloc <TT>.</TT>
<BR>
bloc := <BR>
declaraþii de etichete <BR>
declaraþii de constante <BR>
declaraþii de tipuri <BR>
declaraþii de variabile <BR>
declaraþii de funcþii ºi proceduri <BR> <TT>begin</TT> listã de instrucþiuni <TT>end</TT> <BR>
listã de instrucþiuni := <BR>
instrucþiune <BR>   <EM>sau</EM> <BR>
instrucþiune <TT>;</TT> listã de instrucþiuni</TD>
</TR>
</TABLE>

</DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Aceste reguli la rîndul lor trebuie scrise cumva.  Limbajul care
descrie regulile poate fi numit ``meta-limbaj'', pentru cã este un
limbaj care descrie alte limbaje.

<P>
Desigur, ne putem pune întrebarea: cum descriem un meta-limbaj?  În
mod tradiþional meta-limbajele erau descrise pe hîrtie, folosind o
notaþie simbolicã; prima probabil în ordine cronologicã a fost
notaþia Backus-Naur, care a fost printre altele folositã pentru a
descrie limbajul Pascal.  Un exemplu este prezent în
figura&nbsp;<A HREF="#sintaxa">1</A>.

<P>
Au apãrut apoi programe speciale, care permit descrierea structurii
altor limbaje; existã multe astfel de scule folosite pe scarã
largã; iatã cîteva dintre ele:

<P>

<UL>
<LI>Una dintre scule, de apariþie recentã, este limbajul XML
(eXtensible Meta-Language).  XML este un limbaj în care poate fi
descrisã sintaxa altor limbaje.

<P>
</LI>
<LI>Generatoare de parsere (ex: <TT>yacc</TT>, <TT>bison</TT>): un parser
este un program care verificã apartenenþa unui cuvînt la un limbaj
(de exemplu verificã dacã un text dat este un program Pascal).  Un
generator de parsere este un program care permite descrierea unui
parser într-un meta-limbaj.  Douã programe extrem de folosite în
lumea Unix permit descrierea de parsere arbitrare, ºi genereazã cod
pentru a implementa aceste parsere în C sau C++; acestea sunt
programele <TT>yacc</TT> (Yet Another Compiler-Compiler) ºi <TT>bison</TT>,
un animal asemãnãtor cu yak-ul<A NAME="tex2html4"
  HREF="#foot89"><SUP>1</SUP></A>.  Figura&nbsp;<A HREF="regex-html.html#yacc">1</A> aratã cum se foloseºte un
astfel de program.

<P>
</LI>
<LI>Chiar în acest articol vom prezenta pe scurt programul
<TT>lex</TT>, care este folosit pentru a descrie componentele elementare
folosite pentru a scrie programe într-un anumit limbaj.
</LI>
</UL>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="yacc"></A><A NAME="356"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
Yacc este un generator de parsere.  Utilizatorul
descrie sintaxa unui limbaj oarecare <I>L</I> (de exemplu Pascal), folosind
o notaþie asemãnãtoare cu notaþia Backus-Naur; utilizatorul
descrie ºi o serie de proceduri în C care trebuie sã fie executate
atunci cînd o anumitã construcþie sintacticã este întîlnitã (de
exemplu, ce trebuie fãcut cînd întîlnim un <TT>begin</TT>-<TT>end</TT>,
ce trebuie fãcut cînd întîlnim un <TT>for</TT>, etc.).  <TT>yacc</TT>
genereazã un program C care poate fi compilat ºi executat,
obþinînd un parser.  Acest program apoi primeºte la intrare
programe scrise în <I>L</I> ºi executã acþiunile indicate.  Acþiunile
pot descrie de exemplu cum se executã programul, sau cum trebuie
construitã o structurã de date care reprezintã programul (care de
obicei apoi este optimizatã pentru a face programul mai rapid).
Parserul de asemenea recunoaºte programe ilegale, în care caz
returneazã mesaje de eroare.</CAPTION>
<TR><TD><IMG
 WIDTH="543" HEIGHT="161" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{yacc.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Pare complicat?  Este, cel puþin pînã vã obiºnuiþi cu ideea
programelor care prelucreazã alte programe.  Despre XML au mai
apãrut articole în PC Report; poate în viitor o sã scriu un
articol despre <TT>yacc</TT> sau prietenul lui.  În textul de faþã o
sã vedem însã soluþia la o problemã mai simplã.

<P>

<H1><A NAME="SECTION00030000000000000000">
Analiza lexicalã</A>
</H1>

<P>
Atunci cînd eu vorbesc cu cineva, acel cineva desface textul spus de
mine în cuvinte, pe care le analizeazã.  Vorbitorul unei limbi
strãine are adesea probleme în a <EM>segmenta</EM> textul auzit în
cuvinte independente.  În scris problema este mai simplã, cel puþin
pentru limbile moderne care folosesc alfabetul latin: prin convenþie
punem între douã cuvinte un spaþiu.

<P>
Dacã ideea vi se pare evidentã, aflaþi cã lucrurile nu au stat
întotdeauna aºa: romanii ºi grecii nu foloseau spaþii (de asemenea
foloseau extrem de multe prescurtãri, pentru cã hîrtia era scumpã;
din lipsa tipografiilor, încã ne-inventate, copiºtii<A NAME="tex2html6"
  HREF="#foot103"><SUP>2</SUP></A> aveau probleme de segmentare, ºi fãceau
adesea erori de interpretare a textelor cînd le copiau).  Dacã vi se
pare floare la ureche aºa ceva,
atunciîncercaþisãcitiþipropoziþiaastaºivedeþicîtdeuºorvãeste.

<P>
Atunci cînd unui calculator<A NAME="tex2html7"
  HREF="#foot104"><SUP>3</SUP></A> îi este prezentat un program, el are de fãcut o
analizã similarã: trebuie sã despartã textul în bucãþele
separate ºi sã identifice semnificaþia fiecãreia; aceasta este
analiza lexicalã; bucãþelele obþinute sunt numite <EM>lexeme</EM>.
Dupã aceea calculatorul verificã dacã aceste bucãþele sunt
îmbinate corect (nu orice succesiune de cuvinte din românã
formeazã o propoziþie), folosind analiza sintacticã.
Figura&nbsp;<A HREF="regex-html.html#compilator">2</A> aratã cum aceste faze sunt folosite în
compilatoare.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="compilator"></A><A NAME="371"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
Plasamentul analizei lexicale într-un
compilator.  Analiza lexicalã este prima fazã a compilãrii, care
identificã componentele ``atomice'' ale programului, lexemele.
Analiza sintactica a fost descrisã pe scurt în acest text: ea
verificã dacã lexemele sunt îmbinate dupã regulile corecte ale
programãrii în limbajul compilat.  Celelalte faze analizeazã ºi
optimizeazã programul, ºi nu ne intereseazã prea mult în acest
text.</CAPTION>
<TR><TD><IMG
 WIDTH="543" HEIGHT="164" BORDER="0"
 SRC="img4.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{compilator.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Nici în calculatoare lucrurile nu au fost prea clare de la început:
limbajele primitive, ca Fortran-ul, nu aveau reguli complet ne-ambigue
pentru a discerne într-un text care este fiecare cuvînt.  De
exemplu, în Fortran spaþiile nu conteazã (din motive pragmatice:
aparatele de gãurit cartele nu erau prea fiabile în tastatul de
spaþii).  Folclorul spune cã americanii au pierdut un satelit din
cauza asta, pentru cã compilatorul de Fortran a interpretat un
program altfel decît utilizatorul care l-a scris.

<P>
Dacã acestea vi se par aberaþii îndepãrtate, aflaþi cã nici
limbajele cele mai folosite la ora actualã pe scarã largã nu sunt
lipsite de ele: de exemplu în C++ o problemã specialã apare din
cauza construcþiei <TT>template</TT>, care se scrie astfel <TT>a&lt;b&gt;</TT>.
Problema apare în cazul unor template imbricate (incluse una
într-alta), ca în <TT>a&lt;b&lt;c&gt;&gt;</TT>.  Problema e cu semnele <TT>&gt;&gt;</TT>:
reprezintã ele douã template închise, sau semnul ``shift-right''?
Analizorul lexical nu poate decide de unul singur ce înseamnã aceste
semne, are nevoie de ajutor din partea analizorului sintactic.

<P>

<H1><A NAME="SECTION00040000000000000000">
Expresiile regulate: un limbaj pentru a descrie limbaje</A>
</H1>

<P>
Am vãzut deci cã prima etapã în înþelegerea unui program este
descompunerea lui în lexeme.  Atunci cînd implementãm un limbaj nou
de programare, cum ar fi oare cel mai eficace sã descriem toate
lexemele posibile?  De exemplu, în C avem lexeme de forma <TT>for</TT>,
<TT>while</TT>, etc., dar nu lexeme de forma <TT>%$#@</TT>.  'In plus,
într-un program C putem întîlni lexeme de genul
<TT>variabila_cea_mare</TT>.  Existã deci un numãr potenþial infinit
de lexeme (dacã presupunem cã numele de variabile nu au nici o
limitã pentru lungime).  Totalitatea tuturor lexemelor legale este la
rîndul ei un limbaj; acesta nu trebuie confundat cu limbajul C: în
limbajul C ``cuvintele'' sunt programele corecte, în limbajul
lexemelor C, cuvintele legale sunt toate lexemele care pot apãrea în
vreun program C.

<P>
Teoreticienii au propus cu mult timp în urmã (în anii '60) un
meta-limbaj extrem de concis pentru a descrie lexeme.  Limbajul acesta
este limbajul <EM>expresiilor regulate</EM>.  O expresie regulatã este
un ºir de caractere care descrie o mulþime de cuvinte posibile
(poate chiar o mulþime infinitã).  Lexemele tuturor limbajele de
programare moderne pot fi descrise prin expresii regulate; vom folosi
de aici înainte abrevierea ER pentru ``expresii regulate''.

<P>
Cred cã cel mai simplu este sã vedem niºte exemple.  Pentru
început voi folosi notaþia cea mai economicã, care este folositã
de teoreticieni.  Vom vedea apoi tot felul de variante, folosite de
tot felul de ``scule'' de procesare de texte.

<P>
Sã zicem cã vrem sã descriem limbaje care folosesc litere din
alfabetul {a,b,c,d}, pentru a simplifica lucrurile.  Perfect.  ER
folosesc toate aceste caractere, plus o listã de caractere
suplimentare: <!-- MATH
 $\{a,b,c,d,*,\epsilon,\phi,|,\cdot,(,)\}$
 -->
<IMG
 WIDTH="183" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img5.png"
 ALT="$\{a,b,c,d,*,\epsilon,\phi,\vert,\cdot,(,)\}$">.  Voi explica
prin exemple ce înseamnã fiecare.  Observaþi cã scriu fiecare
expresie regulatã cu caractere cursive, iar cuvintele din limbajul pe
care-l descriem cu caractere drepte.  Asta pentru a preveni
confuziile, pentru cã existã caractere comune în cele douã
mulþimi.  (Voi abandona aceastã convenþie în secþiunile care
descriu ``sculele'', pentru cã acestea oricum folosesc alte notaþii.)

<P>

<UL>
<LI>Avem în primul rînd 4 ER extrem de simple, care constau
dintr-un singur caracter, una din litere.  De exemplu, expresia
regulatã ``<I>a</I>''.  Aceasta este o expresie foarte simplã, care
descrie un limbaj format dintr-un singur cuvînt, care are o singurã
literã; limbajul ``{a}''.

<P>
</LI>
<LI>Avem apoi expresia regulatã <IMG
 WIDTH="16" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img7.png"
 ALT="$\phi$">, care descrie limbajul...
care nu are nici un cuvînt!  Ce risipã!  Cui îi trebuie astfel de
limbaje?  Cu toate acestea, aceastã expresie regulatã se dovedeºte
cîteodatã utilã, chiar dacã majoritatea din programele care
manipuleazã ER nu o folosesc.

<P>
</LI>
<LI>O altã expresie regulatã este <IMG
 WIDTH="13" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.png"
 ALT="$\epsilon$">.  Aceasta descrie un
limbaj în care existã un singur cuvînt, dar care cuvînt nu are
nici o literã!  Altã prostie, nu?  Aceastã expresie regulatã este
însã foarte utilã.

<P>
</LI>
<LI>Parantezele le vom folosi ca în matematicã, pentru a indica
cãror expresii li se aplicã anumite operaþii.  Aºa cum <I>a * (b +
c)</I> aratã cã întîi facem adunarea ºi apoi înmulþirea, expresia
<!-- MATH
 $R \cdot (S | T)$
 -->
<IMG
 WIDTH="75" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img10.png"
 ALT="$R \cdot (S \vert T)$"> aratã cã întîi aplicãm operaþia <IMG
 WIDTH="11" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.png"
 ALT="$\vert$"> ºi abia
apoi pe <IMG
 WIDTH="11" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="$\cdot$">.

<P>
În fine, sã ne apucãm de ceva serios.  Celelalte trei semne care au
rãmas ne permit sã creãm limbaje mai complicate din limbaje simple.
Astea vor face ER o sculã foarte puternicã.

<P>
</LI>
<LI>Semnul | citit <EM>alternanþã</EM>, se pune între alte douã
ER.  Dacã <I>R</I> ºi <I>S</I> sunt astfel de expresii, putem scrie
<I>R|S</I>.
Dacã <I>R</I> descrie un limbaj R, iar <I>S</I> descrie un limbaj S,
atunci <I>R|S</I> descrie limbajul R <IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img16.png"
 ALT="$\cup$"> S, adicã limbajul format din toate
cuvintele care sunt fie în R fie în S.

<P>
De exemplu, expresia regulatã <IMG
 WIDTH="39" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$a\vert b\vert\epsilon$"><A NAME="tex2html9"
  HREF="#foot123"><SUP>4</SUP></A>  descrie
un limbaj cu trei cuvinte: { , a, b }.  Primul cuvînt este
cuvîntul fãrã nici o literã; mai avem apoi alte douã cuvinte, de
cîte o literã.  De îndatã ce vom vedea celelalte douã operaþii o
sã apreciaþi mai tare semnul |, pentru cã împreunã ele putem
exprima limbaje din ce în ce mai interesante.

<P>
</LI>
<LI>Semnul <IMG
 WIDTH="11" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="$\cdot$">, numit <EM>concatenare</EM>, se foloseºte la fel ca
|, între alte douã ER.  Fie R limbajul descris de <I>R</I> ºi S
limbajul descris de <I>S</I>.  Atunci <IMG
 WIDTH="44" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.png"
 ALT="$R \cdot S$"> este limbajul în care
fiecare cuvînt este compus dintr-un cuvînt din R ataºat în faþa
unui cuvînt din S.  Interesant, nu?

<P>
De exemplu, expresia regulatã <!-- MATH
 $(a|b) \cdot (a|c)$
 -->
<IMG
 WIDTH="89" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$(a\vert b) \cdot (a\vert c)$"> descrie un limbaj
compus din patru cuvinte: {aa, ac, ba, bc}.  Fiecare cuvînt este
compus dintr-un cuvînt din limbajul <IMG
 WIDTH="59" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img20.png"
 ALT="$(a\vert b)=$">{a,b} concatenat cu un
cuvînt din limbajul <IMG
 WIDTH="59" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img21.png"
 ALT="$(a\vert c)=$">{a,c}.

<P>
Deja putem folosi ER pentru a ne exprima foarte succint.  De pildã,
dacã limbajul <I>R</I> are 2 cuvinte, atunci <!-- MATH
 $R \cdot R \cdot R \cdot R$
 -->
<IMG
 WIDTH="97" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.png"
 ALT="$R \cdot R \cdot R \cdot R$">
are 2 x 2 x 2 x 2 = 16 cuvinte!

<P>
</LI>
<LI>În fine, semnul *, numit ºi operaþia ``star'', este
singurul semn care ne permite sã descriem limbaje infinite!
Operaþia * se aplicã unei singure ER, ºi se scrie astfel: <IMG
 WIDTH="27" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img25.png"
 ALT="$R^*$">.

<P>
Limbajul <IMG
 WIDTH="27" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img25.png"
 ALT="$R^*$"> este un limbaj ale cãrui cuvinte sunt formate dintr-un
numãr arbitrar (inclusiv zero!) de cuvinte din R, concatenate.  De
exemplu, limbajul descris de <IMG
 WIDTH="23" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.png"
 ALT="$a^*$"> este { , a, aa, aaa,
aaaa,...}, care conþine cuvîntul fãrã nici o literã (obþinut
din zero copii ale lui ``a''), cuvîntul a, cuvîntul aa, etc., ºi nu
vã puteþi aºtepta sã scriu aici toate cuvintele, pentru cã sunt
în numãr infinit, ºi PC Report recomandã o limitã de 3500 de
cuvinte pe articol (pe care oricum o sã o depãºesc, mi-e teamã).
</LI>
</UL>

<P>

<H2><A NAME="SECTION00041000000000000000">
Exemple de ER</A>
</H2>

<P>
Iatã deci cã fiecare expresie regulatã descrie un întreg limbaj,
poate chiar infinit.  Vom vedea aici mai multe exemple de expresii
regulate interesante.  De acum înainte voi folosi tot setul de
caractere ASCII, ºi nu mã voi mai limita la literele <I>a,b,c,d</I>.
Pentru eficienþã voi denumi ER care apar ºi pe care vreau sã le
refolosesc; voi folosi semnul egal =; acesta nu este un semn care
poate fi folosit pentru a scrie expresii regulate.

<P>
<DL>
<DT></DT>
<DD><!-- MATH
 $CF = 0|1|2|3|4|5|6|7|8|9$
 -->
<IMG
 WIDTH="187" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img29.png"
 ALT="$CF = 0\vert 1\vert 2\vert 3\vert 4\vert 5\vert 6\vert 7\vert 8\vert 9$">.  Aceastã expresie
regulatã descrie cifrele.  Nu e mare brînzã.
</DD>
<DT></DT>
<DD><!-- MATH
 $NN = CF \cdot (CF^*)$
 -->
<IMG
 WIDTH="149" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$NN = CF \cdot (CF^*)$">.  Aceasta este deja o expresie mai
interesantã, care descrie toate numerele naturale în notaþie
zecimalã: cel puþin o cifrã, urmatã de oricîte alte cifre.  Facem
convenþia cã operaþia <IMG
 WIDTH="15" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.png"
 ALT="$*$"> are prioritate mai mare decît <IMG
 WIDTH="11" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="$\cdot$">,
aºa cã putem scrie expresia precedentã ºi ca <IMG
 WIDTH="81" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$CF \cdot CF^*$">.
</DD>
<DT></DT>
<DD><!-- MATH
 $NZ = (\epsilon|-) \cdot NN$
 -->
<IMG
 WIDTH="142" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.png"
 ALT="$NZ = (\epsilon\vert-) \cdot NN$">.  Aceastã expresie descrie toate
numerele întregi, pozitive sau negative: un numãr precedat de nimic
sau de semnul minus.
</DD>
<DT></DT>
<DD><!-- MATH
 $CH = CF|a|b|c|d|e|f$
 -->
<IMG
 WIDTH="167" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.png"
 ALT="$CH = CF\vert a\vert b\vert c\vert d\vert e\vert f$">.  Aceastã expresie regulatã
descrie toate cifrele hexazecimale.
</DD>
<DT></DT>
<DD><!-- MATH
 $HX = 0 \cdot x \cdot CH \cdot CH^*$
 -->
<IMG
 WIDTH="184" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img34.png"
 ALT="$HX = 0 \cdot x \cdot CH \cdot CH^*$">.  Acestea sunt toate
numerele hexazecimale pozitive în notaþia acceptatã de limbajul C.
</DD>
<DT></DT>
<DD><!-- MATH
 $FP = (\epsilon|-) \cdot ((CF^* \cdot (.|\epsilon) \cdot CF
\cdot CF^*) | CF \cdot CF^* \cdot . \cdot CF^*)$
 -->
<IMG
 WIDTH="445" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$FP = (\epsilon\vert-) \cdot ((CF^* \cdot (.\vert\epsilon) \cdot CF
\cdot CF^*) \vert CF \cdot CF^* \cdot . \cdot CF^*)$"> Aceastã expresie
descrie toate numerele reale cu un numãr finit de zecimale, (în
limba englezã, cu punct în loc de virgulã).  Expresia a complicatã
pentru cã permite ca fie partea întreagã, fie partea zecimalã sã
lipseascã, dar nu amîndouã.
</DD>
<DT></DT>
<DD><IMG
 WIDTH="58" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img36.png"
 ALT="$LIT = $">literele mari ºi mici; mi-e lene sã scriu expresia
asta în detaliu, seamãnã cu <IMG
 WIDTH="33" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$CF$">.
</DD>
<DT></DT>
<DD><!-- MATH
 $ID = LIT \cdot (LIT | CF)^*$
 -->
<IMG
 WIDTH="186" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ID = LIT \cdot (LIT \vert CF)^*$">: identificatorii (numele de
variabile) acceptabili într-un program Pascal: o literã, urmatã de
litere ºi cifre.
</DD>
<DT></DT>
<DD><!-- MATH
 $b^* \cdot a\cdot(b^* \cdot a \cdot b^* \cdot a)^*$
 -->
<IMG
 WIDTH="163" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.png"
 ALT="$b^* \cdot a\cdot(b^* \cdot a \cdot b^* \cdot a)^*$">: toate
cuvintele formate din literele a ºi b în care apar un numãr impar
de a-uri.  Expresia asta am format-o astfel: ceva b-uri (poate
niciunul), cel puþin un a, apoi un numãr par de a-uri, cu ceva b-uri
între ele.
</DD>
</DL>

<P>
Pentru cei doritori de formalisme, existã tot felul de reguli care ne
permit sã simplificãm ER complicate.  Iatã cîteva dintre ele
(semnificaþia semnului egal este: limbajul descris de expresia din
stînga este acelaºi cu limbajul descris de expresia din dreapta):

<P>
<P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{eqnarray*}
R | R &=& R \\
R | S &=& S | R \\
(R | S) | R &=& R | (S | T) \\
(R \cdot S) \cdot T &=& R \cdot (S \cdot T) \\
R \cdot \epsilon = \epsilon \cdot R &=& R \\
R \cdot \phi = \phi \cdot R &=& \phi \\
R | \phi &=& R \\
R \cdot (S | T) &=& (R \cdot S) | (R \cdot T) \\
(R | S) \cdot T &=& (R \cdot T) | (S \cdot T) \\
\epsilon | RR^* &=& R^* \\
RR^* &=& R^*R \\
{R^*}^* &=& R^* \\
R^* \cdot R^* &=& R^* \\
R\cdot (S \cdot R)^* &=& (R \cdot S)^* \cdot R
\end{eqnarray*}
 -->
<IMG
 WIDTH="247" HEIGHT="377" BORDER="0"
 SRC="img40.png"
 ALT="\begin{eqnarray*}
R \vert R &amp;=&amp; R \\
R \vert S &amp;=&amp; S \vert R \\
(R \vert S) \v...
... R^* &amp;=&amp; R^* \\
R\cdot (S \cdot R)^* &amp;=&amp; (R \cdot S)^* \cdot R
\end{eqnarray*}">
<BR CLEAR="ALL"></DIV><P></P>
<BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>

<P>
Primele nouã din regulile acestea ne spun cã mulþimea tuturor
cuvintelor împreunã cu aceste operaþiile <IMG
 WIDTH="11" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.png"
 ALT="$\vert$"> ºi <IMG
 WIDTH="11" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="$\cdot$"> este un
semi-inel idempotent.  De aici un amator de algebrã poate deriva tot
felul de alte proprietãþi interesante, pe care acum o sã le trecem
cu vederea.

<P>

<H2><A NAME="SECTION00042000000000000000">
Limbaje regulate ºi limbaje neregulate</A>
</H2>

<P>
Am vãzut tot felul de ER, ºi o sã mai vedem ºi alte cîteva.  Cu
cîteva semne simple putem descrie într-un mod finit limbaje
complicate infinite.  Dar nu orice limbaj se poate descrie cu ER.
Limbajele care se pot descrie cu ER se numesc <EM>limbaje regulate</EM>.
Puterea ER este destul de limitatã, dar suficient de mare pentru a le
face extrem de utile.  Vom vedea mai jos cã sculele care folosesc ER
adaugã o serie de abrevieri utile, ºi cã uneori extind ER în
moduri care permit descrierea unor limbaje care nu sunt de fapt
regulate.

<P>
Iatã niºte exemple de limbaje care <EM>nu</EM> se pot descrie cu ER:

<P>

<UL>
<LI>Limbajul ``parantezelor potrivite'', care constã din ºiruri de
caractere ``(`` ºi ``)'' astfel încît parantezele se închid în
mod legal.
</LI>
<LI>Limbajul tuturor programelor Pascal.
</LI>
<LI>Limbajele formate din cuvinte care sunt palindroame (se pot citi
la fel de la cap la coadã ºi de la coadã la cap).
</LI>
<LI>Limbajul cuvintelor care sunt concatenarea a douã cuvinte
identice.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00043000000000000000">
Aplicaþii ale limbajelor regulate</A>
</H2>

<P>
Ce facem cu o expresie regulatã?  Problema principalã este cea de
<EM>recunoaºtere</EM>: dacã avem o expresie regulatã ºi un text,
reprezintã acel text un cuvînt din limbajul descris de expresia
regulatã?  Spunem cã expresia regulatã <EM>acceptã</EM> acel cuvînt.

<P>
De exemplu, cuvîntul ``141231'' este în limbajul descris de expresia
regulatã <I>NZ</I> de mai sus, dar cuvîntul ``-+-+131'' nu este.

<P>
O problemã înruditã este cea a <EM>analizei lexicale</EM>, pe care am
descris-o mai sus: dacã se dã un text (de exemplu în Pascal) ºi
mai multe ER (de exemplu <I>ID</I>, <I>NN</I>, etc.), sã-l descompunem într-o
secvenþã de cuvinte astfel încît fiecare cuvînt este acceptat de
una din expresii.  De exemplu textul <TT>acum := 51;</TT> este compus din
patru cuvinte: un identificator, acceptat de <I>ID</I>, semnul de
atribuire, acceptat de expresia <IMG
 WIDTH="39" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img44.png"
 ALT="$: \cdot =$">, pe care nu am descris-o,
numãrul 51, acceptat de expresia <I>NN</I> ºi semnul punct-ºi-virgulã,
care este acceptat de o expresie regulatã foarte simplã ``<I>;</I>''.

<P>
De fapt cele douã probleme de mai sus (acceptarea ºi analiza
lexicalã) se pot ambele rezolva cu aceeaºi tehnologie: dacã putem
recunoaºte un cuvînt, atunci putem ciopîrþi ºi textul în
bucãþi, recunoscînd primul cuvînt, ºi dupã aia continuînd
descompunerea cu restul textului.  Vestea cea bunã este cã putem
rezolva problema recunoaºterii limbajelor regulate în mod foarte
eficient!

<P>

<H1><A NAME="SECTION00050000000000000000">
Automate finite</A>
</H1>

<P>
Aparatele care recunosc limbaje regulate se numesc <EM>automate
finite</EM>.  Putem vedea aceste automate sub forma unor dispozitive
fizice, reale, sau sub forma unor programe extrem de simple.

<P>
Teoreticienii aratã (ºi studenþii învaþã la cursurile de teoria
limbajelor formale) cã o expresie regulatã se poate traduce într-un
automat finit, care opereazã asupra unui cuvînt, ºi care produce un
rezultat da/nu, dacã cuvîntul este sau nu în limbajul descris de
expresia regulatã.  În acest articol nu o sã ne preocupãm despre
cum se face asta, ºi nici despre tot felul de alte rafinamente, (cum
sunt automatele finite nedeterministe).  O sã vã arãt doar un
automat finit ºi sã vã explic cum funcþioneazã el.  Vom observa
cã automatul finit se uitã la fiecare literã din cuvîntul de
recunoscut o singurã datã, ºi face o singurã operaþie internã
pentru fiecare literã.  Asta înseamnã cã proceseazã fiecare
cuvînt în <EM>timp linear</EM>, ceea ce îl face foarte eficient. 

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="finit"></A><A NAME="386"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3:</STRONG>
Compilarea unei ER într-un automat finit.
Orice expresie regulatã <I>E</I> poate fi transformatã într-un automat
finit care recunoaºte orice cuvînt din limbajul descris de <I>E</I>, ºi
doar acele cuvinte.  Starea 1 este starea iniþialã, iar stãrile 1
ºi 2 sunt stãri finale.</CAPTION>
<TR><TD><IMG
 WIDTH="582" HEIGHT="194" BORDER="0"
 SRC="img46.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{finit.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
De fapt aºa procedeazã toate sculele pe care le expun mai jos: cînd
primesc o expresie regulatã, ``compileazã'' aceastã expresie
într-un automat finit.  Automatul este reprezentat sub forma unui
progrãmel foarte rapid.  Apoi acest progrãmel primeºte cuvîntul de
testat, îl studiazã, ºi produce diagnosticul.  Automatele folosite
în analizoarele lexicale indicã cum programul de la intrare poate fi
descompus în lexeme, ºi ce expresie regulatã s-a potrivit cu
fiecare lexemã.

<P>
Figura&nbsp;<A HREF="regex-html.html#finit">3</A> aratã un automat finit care opereazã cu cuvinte
peste alfabetul {a,b}.  Acest automat are o mulþime finitã de <EM>stãri</EM>, notate prin cercuri.  În fiecare clipã automatul se aflã
într-o unicã astfel de stare.  La începutul calculului automatul se
aflã în starea marcatã de o sãgeatã care vine ``de nicãieri''.

<P>
Între douã stãri existã sãgeþi etichetate cu litere; acestea se
numesc <EM>tranziþii</EM>.  De exemplu, între starea 1 ºi starea 2
existã o tranziþie etichetatã cu a: asta înseamnã cã automatul,
dacã vede litera a la intrare ºi se aflã în starea 1, va trece în
starea 2.

<P>
Unele dintre stãrile automatului sunt marcate cu douã cercuri;
astfel de stãri sunt numite <EM>stãri finale</EM>.  Un cuvînt este
prin definiþie acceptat dacã atunci cînd este prezentat la intrare
cauzeazã automatul sã treacã într-o stare finalã atunci cînd
cuvîntul a fost în întregime prelucrat.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="executie"></A><A NAME="392"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura:</STRONG>
Execuþia automatului din figura&nbsp;<A HREF="regex-html.html#finit">3</A>
cînd la intrare este prezentat cuvîntul ``abbab''.  Automatul face
cinci paºi, cîte unul pentru fiecare literã.  Starea curentã este
indicatã cu roºu, starea anterioarã cu roz, ºi poziþia curentã
în cuvîntul de la intrare printr-un dreptunghi albastru.  Sãgeþile
albastre indicã cum este ``consumat'' cuvîntul de la intrare.
Pentru cã dupã terminarea ºirului automatul nu este într-o stare
finalã, tragem concluzia cã acest cuvînt nu e descris de expresia
regulata din figura&nbsp;<A HREF="regex-html.html#finit">3</A>.</CAPTION>
<TR><TD><IMG
 WIDTH="586" HEIGHT="374" BORDER="0"
 SRC="img47.png"
 ALT="\begin{figure}\centerline{\epsfxsize=13cm\epsffile{executie.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
De exemplu, figura&nbsp;<A HREF="regex-html.html#executie">4</A> aratã evoluþia în timp a
automatului anterior.  

<P>

<H1><A NAME="SECTION00060000000000000000">
Programe care manipuleazã ER</A>
</H1>

<P>
În aceastã secþiune voi discuta pe scurt mai multe programe care
folosesc ER.  Fiecare din ele are notaþii puþin diferite de
celelalte, ceea ce e foarte neplãcut dacã doriþi sã folosiþi mai
multe dintre ele.

<P>
Toate aceste programe prelucreazã fiºiere text, adicã fiºiere în
care informaþia este într-o formã citibilã de cãtre oameni.  E o
tradiþie în lumea Unix ca datele sã fie menþinute în formã
textualã; Microsoft aparent ºi-a fãcut un scop sã creeze formate
binare (adicã ne-textuale) de stocare a datelor, care mai sunt ºi
secrete pe deasupra!  Din cauza asta, multe din aceste scule sunt de
utilitate redusã în lumea Windows.  Din fericire, una dintre formele
cele mai prevalente de prezentare a informaþiei este limbajul HTML,
care are o reprezentare pur textualã.  Pentru prelucrãri de HTML,
prelucrarea textelor de programe, programe automate de colectat
informaþii de pe Internet, sculele descrise de mai jos sunt extrem
de utile.

<P>
În acest text eu am folosit litere cursive pentru a scrie expresiile
regulate, ºi litere drepte pentru cuvinte.  Din pãcate în lumea
programelor se foloseºte un acelaºi set de caractere pentru a denota
literele ºi expresiile regulate.  Asta ridicã o problemã
suplimentarã, pentru cã nu avem noi semne, <!-- MATH
 $*, \cdot, |, (, )$
 -->
<IMG
 WIDTH="69" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img48.png"
 ALT="$*, \cdot, \vert, (, )$">
pentru a construi expresiile regulate, deci trebuie sã folosim tot
unele dintre litere.  Dar atunci e o ambiguitate între litera
<code>*</code> ºi semnul <IMG
 WIDTH="13" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="${}^*$"> folosit pentru expresii regulate.

<P>
Toate programele de mai jos rezolvã aceastã problemã în acelaºi
fel, ºi anume folosesc mai multe simboluri consecutive pentru una
dintre semnificaþii, ºi un singur simbol pentru cealaltã.  De
exemplu, primul program, <TT>grep</TT>, utilizeazã semnul <TT>*</TT> pentru
asterisc (operaþia) ºi <code>\*</code> pentru caracterul steluþã.

<P>

<H2><A NAME="SECTION00061000000000000000">
Shell-ul Unix</A>
</H2>

<P>
Am scris în iunie 1997 un articol despre shell-ul din Unix (mai
curînd ca sã explic ce este, decît ca sã arãt cum se foloseºte
un shell modern sofisticat).  Pe scurt, shell-ul este un program care
poate fi folosit pentru a da comenzi sistemului, de obicei în mod
interactiv.

<P>
Shell-ul Unix tradiþional recunoaºte niºte forme extrem de
primitive de expresii regulate, care sunt abreviate într-un mod nu
tocmai natural.  Pe de altã parte shell-ul permite doar forme
restrînse de expresii, aºa cã voi începe cu el, pentru cã e mai
simplu.

<P>
Urmãtoarele construcþii în shell sunt pe post de expresii regulate:

<P>

<UL>
<LI>Orice caracter este o expresie regulatã; excepþii sunt semnele
de mai jos.
</LI>
<LI>Semnul ``?'' þine locul unui singur caracter, oricare ar fi el.
Pentru a scrie chiar caracterul semn de întrebare trebuie sã scriem
<code>\?</code>.
</LI>
<LI>Pentru a scrie semnul <code>\</code> trebuie sã scriem <code>\\</code>.
</LI>
<LI>Semnul de concatenare este omis.  Aºa cum în matematicã
cîteodatã omitem semnul de înmulþire, în shell nu scriem <IMG
 WIDTH="11" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="$\cdot$">.
Astfel, ºirul <code>a???b</code> reprezintã toate cuvintele de cinci
litere care încep cu ``a'' ºi se terminã cu ``b''.
</LI>
<LI>Semnul ``*'' nu mai e un operator care se aplicã unei expresii;
el înseamnã un ºir oarecare de zero sau mai multe caractere.
Astfel, cînd scriem ``<code>a*b</code>'' asta înseamnã: toate ºirurile
care încep cu ``a'' ºi se terminã cu ``b''.
</LI>
<LI>Alternanþa se reprezintã în felul urmãtor: în loc de
<IMG
 WIDTH="53" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$R\vert S\vert T$"> se scrie <code>{R,S,T}</code>.  Astfel, expresia <code>{a,b}{c,d}</code>
reprezintã patru ºiruri: ac, bc, ad, bd.
</LI>
</UL>

<P>
În mod normal atunci cînd shell-ul primeºte o comandã de la
utilizator, încearcã sã expandeze expresiile regulate în toate
numele de fiºiere de pe disc care se potrivesc.  Astfel comanda:
<code>ls .??*</code> va afiºa (comanda <TT>ls</TT>) toate fiºierele al cãror
nume începe cu semnul punct ºi are cel puþin trei caractere.

<P>
Chiar ºi MS-DOS aparent oferea astfel de expresii, dar de fapt era
mult mai limitat: puteai avea cel mult o steluþã pentru numele
fiºierului ºi una pentru extensie.  În Unix poþi spune ceva de
genul <code>rm *a*b*</code>, care înseamnã ``ºterge toate fiºierele care
au un a ºi un b în nume, în ordinea asta''.  Deºi expresia
<code>*a*b*</code> pare mult mai complicatã, teoria automatelor finite ne
spune cã ea poate fi analizatã ºi folositã la fel de rapid ca
orice expresie mai simplã.

<P>
În Unix poþi spune chiar lucruri de genul: <code>wc -l */*/*.cc</code>,
pentru a numãra liniile (<TT>wc -l</TT> = word count lines) din toate
fiºierele C++ aflate la douã directoare adîncime.

<P>

<H2><A NAME="SECTION00062000000000000000">
<TT>grep</TT></A>
</H2>

<P>
<TT>grep</TT> este un utilitar extrem de util, care a fost proiectat
special pentru a manipula expresii regulate.  Numele sãu vine de la
Get Regular Expression Patterns, adicã ``cautã textele descrise de o
anumitã expresie regulatã''.  <TT>grep</TT> primeºte o expresie
regulatã ºi o listã de fiºiere, ºi cautã în acele fiºiere
liniile care conþin cuvinte descrise de acea expresie regulatã.

<P>
Existã mai multe specialitãþi de <TT>grep</TT>, ºi cel mai comun
dintre ele are tot felul de opþiuni (de genul: tipãreºte numerele
de linie, ignorã diferenþa între literele mari ºi mici,
tipãreºte numai ce <EM>nu</EM> se potriveºte, etc.).  Noi vom studia
doar funcþionalitatea de bazã.

<P>
<TT>grep</TT> oferã o paletã foarte largã de operaþii pentru a
descrie expresiile regulate, care se dovedesc a fi foarte utile.
Pentru cã unele semne sunt atît litere cît ºi operatori în ER,
regulile sunt cam încîlcite; le voi prezenta aici pe cele mai
importante:

<P>

<UL>
<LI>Semnul <code>.</code> (punct) þine locul oricãrui caracter, mai
puþin sfîrºitul de linie.  De exemplu, expresia ``<code>...</code>''
descrie orice cuvînt de trei litere.
</LI>
<LI>Semnul de concatenare se omite; ex. <code>a.b</code> înseamnã orice
cuvînt de trei litere care începe cu ``a'' ºi se terminã cu ``b''.
</LI>
<LI>Parantezele se scriu astfel: <code>\(</code> ºi <code>\)</code>, ºi se pot
folosi pentru a schimba ordinea de aplicare a operaþiilor.
</LI>
<LI>Semnul de alternanþã este <code>\|</code>, ex. <code>\(a\|b\)c</code>
reprezintã cuvintele ac ºi bc.
</LI>
<LI>Operatorul star se scrie chiar ca o steluþã: ex. <code>(ab)*</code>.
</LI>
<LI>Fiecare caracter, mai puþin cele speciale, este o expresie
regulatã.
</LI>
<LI>Unele caractere speciale se prefixeazã cu <code>\</code> pentru a fi
exprimate; de exemplu, <code>\*</code> reprezintã chiar o steluþã.
</LI>
<LI>Putem scrie <code>[a-f]</code> pentru a indica toate caracterele
între a ºi f, inclusiv (a,b,c,d,e,f).
</LI>
<LI>Putem scrie <code>[^a-f]</code> pentru toate caracterele care <EM>nu</EM>
sunt între a ºi f.
</LI>
<LI>Putem scrie <code>[acfz]</code> pentru unul dintre caracterele a, c, f
sau z.
</LI>
<LI>Semnul <code>^</code> este începutul de linie.
</LI>
<LI>Semnul <code>$</code> este sfîrºitul de linie. </LI>
<LI>Semnul <code>\?</code> se aplicã ca steluþa, dupã o expresie, ºi
înseamnã: ``expresia anterioarã de zero sau una ori''.  Cu alte
cuvinte, expresia <code>ab\(c\?\)</code> reprezintã cuvintele ab ºi abc.
</LI>
<LI>Putem spune: expresia R repetatã de douã, trei sau patru ori,
astfel: <code>R\{2,4\}</code>.  De exemplu, expresia <code>\(ab\)\{1,3\}</code>
descrie cuvintele ab, abab ºi ababab.
</LI>
</UL>

<P>
Dacã invocãm <TT>grep</TT> astfel: <TT>grep</TT> ER <TT>fisier</TT>, atunci
se întîmplã urmãtoarele lucruri:

<P>

<OL>
<LI><TT>grep</TT> transformã automat expresia regulatã ER în
<code>^.*</code>ER<code>.*$</code>.
</LI>
<LI>Expresia rezultatã obþinutã este compilatã într-un automat
finit.
</LI>
<LI>Fiºierul/ele indicate sunt parcurse, ºi fiecare linie care
este acceptatã de automatul finit este tipãritã.
</LI>
</OL>

<P>
De ce schimbã <TT>grep</TT> expresia regulatã în acest fel?  Prin
definiþie, <TT>grep</TT> tipãreºte toate liniile care <EM>conþin</EM> un
cuvînt care se potriveºte cu expresia regulatã.  Faptul cã linia
conþine un cuvînt potrivit este acelaºi lucru cu faptul cã linia
are niºte caractere oarecare, cuvîntul ºi apoi alte caractere.
Ceea ce e totuna cu a zice cã linia însãºi se potriveºte cu
expresia regulatã expusã mai sus!

<P>
Notaþia asta pare complicatã, ºi chiar este.  <TT>grep</TT> este
însã o sculã de neînlocuit, pe care eu o folosesc zilnic.

<P>
În realitate, problema este ºi mai complicatã: adesea tastãm
comanda grep chiar în linia de comandã a shell-ului.  De aceea,
shell-ul, înainte de a executa comanda, face anumite substituþii în
linia de comandã, ºi abia apoi paseazã programului <TT>grep</TT>
argumentele.

<P>
De exemplu, dacã tastãm în shell <code>grep a\* fisier</code>, shell-ul
va interpreta caracterele <code>\*</code> drept semnul steluþã (protejatã
pentru a nu fi interpretatã ca o expresie regulatã, ci ca un
caracter), ºi ca atare va trimite drept argumente lui <TT>grep</TT> doar
ºirul <code>a*</code>, care pentru grep înseamnã altceva decît
<code>a\*</code>.

<P>
Aceastã complicaþie suplimentarã face programarea în shell cu
expresii regulate o treabã foarte neplãcutã.  Existã însã o
soluþie simplã: întotdeauna înveliþi argumentele lui <TT>grep</TT>
cu ghilimele simple <code>''</code>, ºi atunci shell-ul nu se va mai atinge
de ele.  Veþi scrie deci
<code>grep 'a\*' fisier</code>.  

<P>
Dacã sunteþi amator de expresii încîlcite, puteþi scrie ºi
<code>grep a\\\* fisier</code>, pentru cã shell-ul va trimite lui
<TT>grep</TT> din <code>\\</code> doar un <code>\</code>, ºi din <code>\*</code> doar
steluþa.

<P>

<H2><A NAME="SECTION00063000000000000000">
<TT>awk</TT></A>
</H2>

<P>
<TT>awk</TT> este un limbaj de programare foarte simpatic, creat de trei
inºi celebri: Aho, Weinberger ºi Kernighan (ultimul autor a creat
ºi limbajul C); iniþialele celor trei au dat ºi numele limbajului.
<TT>awk</TT> seamãnã puþin cu <TT>grep</TT>, în sensul cã proceseazã
fiecare linie din fiºier separat.  Spre deosebire de <TT>grep</TT>,
<TT>awk</TT> este un limbaj complet de programare, cu variabile, bucle,
etc.

<P>
În prezent limbajul <TT>awk</TT> a fost subsumat complet de Perl, care
este mult mai eficient, aºa cã nu-l voi mai discuta aici.

<P>

<H2><A NAME="SECTION00064000000000000000">
<TT>sed</TT></A>
</H2>

<P>
<TT>sed</TT> înseamnã Stream EDitor, adicã un editor de texte
ne-interactiv.  În <TT>sed</TT> ``bagi'' un fiºier ºi un program cu
reguli de ``re-scriere''.  <TT>sed</TT> parcurge fiºierul de obicei
linie cu linie ºi îl rescrie conform cu aceste reguli.

<P>
Ca ºi <TT>awk</TT>, <TT>sed</TT> este complet surclasat de limbajul Perl.
Voi indica aici doar una din trãsãturile lui, care este foarte
folositã în Perl: comanda <code>s///</code>.  Aceastã comandã are forma
<code>s/ER/inlocuire/</code>.  <TT>s</TT> vine de la <EM>substituþie</EM>.
Expresiile regulate sunt foarte asemãnãtoare cu cele ale lui
<TT>grep</TT>.

<P>
Iatã algoritmul dupã care opereazã <TT>sed</TT>:

<P>

<OL>
<LI>Fiecare linie din textul de la intrare este comparatã cu
expresia regulatã indicatã.

<P>
</LI>
<LI>Fiecare linie care se potriveºte seteazã niºte variabile.

<P>
</LI>
<LI>Fiecare linie care se potriveºte este apoi înlocuitã conform
cu <TT>inlocuire</TT>.  <TT>inlocuire</TT> poate folosi variabilele setate.
Liniile care nu se potrivesc rãmîn neschimbate.

<P>
</LI>
<LI>Linia rezultatã este tipãritã ºi ciclul continuã cu
urmãtoarea linie.
</LI>
</OL>

<P>
Iatã un exemplu, pentru clarificare:
<code>sed 's/\([^ ]*\)[ ]*\(.*\)/\2 \1#/' fisier</code>.  Asta
se citeºte aºa:

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="sed"></A><A NAME="438"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 5:</STRONG>
Cum interpreteazã <TT>sed</TT> comanda din textul
articolului.</CAPTION>
<TR><TD><IMG
 WIDTH="355" HEIGHT="190" BORDER="0"
 SRC="img51.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{sed.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<UL>
<LI>Cautã sã gãseºti de la începutul liniei (<code>^</code>) o
secvenþã de caractere care nu sunt spaþii (<code>[^ ]*</code>).

<P>
</LI>
<LI>Aceste caractere vor deveni prima variabilã (lucru indicat de
parantezele <code>\( \)</code>).

<P>
</LI>
<LI>Apoi trebuie sã urmeze un numãr de spaþii <code>[ ]*</code>.

<P>
</LI>
<LI>Apoi urmeazã un numãr oarecare de caractere <code>.*</code>.

<P>
</LI>
<LI>Aceste ultime caractere devin variabila a douã (<code>\( \)</code>).

<P>
</LI>
<LI>Dupã ce o linie se potriveºte, ea este transformatã astfel:
<code>\2 \1#</code>.  Adicã a doua variabilã este pusã la început,
urmatã de un spaþiu, urmatã de prima, urmatã de semnul <code>#</code>.
</LI>
</UL>

<P>
Dacã aplicãm acest program urmãtorului fiºier:
<PRE>
Acesta este un mic
fisier pe care incercam
un mic program sed
</PRE>
obþinem
<PRE>
este un mic Acesta#
pe care incercam fisier#
mic program sed un#
</PRE>

<P>
Am mutat astfel primul din linie cuvînt la sfîrºitul liniei!

<P>

<H2><A NAME="SECTION00065000000000000000">
<TT>vi</TT></A>
</H2>

<P>
<TT>vi</TT> este un editor de texte primitiv, probabil primul editor de
texte vizual (numele înseamnã VIsual editor).  <TT>vi</TT> a fost
conceput ºi implementat de Bill Joy, care este unul dintre fondatorii
companiei Sun Microsystems, pe vremea cînd era încã student la
Universitatea din California Berkeley.

<P>
Cu toate cã este relativ primitiv, <TT>vi</TT> oferã o serie de
prelucrãri cu expresii regulate extrem de puternice, care într-o
anumitã mãsurã nu mai sunt oferite de nici un editor actual!

<P>
Expresiile regulate ºi comenzile în <TT>vi</TT> sunt foarte
asemãnãtoare cu cele din <TT>sed</TT>.  Iatã doar un exemplu:

<P>
<PRE>
:/Introducere/,/Capitolul/s/&lt;I&gt;\(.*\)&lt;\/I&gt;/&lt;B&gt;\1&lt;\/B&gt;/g
</PRE>

<P>
Aceastã comandã complicatã trebuie cititã dupã cum urmeazã:

<P>

<OL>
<LI><code>:/Introducere/,/Capitolul/</code> Pentru toate liniile între
cea care conþine cuvîntul ``Introducere'' ºi cea care conþine
cuvîntul ``Capitolul'' aplicã comanda care urmeazã fiecãrei linii.

<P>
</LI>
<LI>Comanda este o substituþie <code>s</code>

<P>
</LI>
<LI><code>/&lt;I&gt;\(.*\)&lt;\/I&gt;</code> se citeºte astfel: orice ºir de forma
<code>&lt;I&gt;ceva caractere&lt;/I&gt;</code><A NAME="tex2html13"
  HREF="#foot240"><SUP>5</SUP></A> este salvat în
variabila 1, lucru indicat de paranteze <code>\( \)</code>.

<P>
</LI>
<LI>Apoi porþiunea care se potriveºte este înlocuitã cu
<code>&lt;B&gt;\1&lt;\/B&gt;</code>, adicã: pãstreazã textul neschimbat (variabila
<code>\1</code>) însã înlocuieºte I-ul cu un B<A NAME="tex2html14"
  HREF="#foot241"><SUP>6</SUP></A>.
</LI>
</OL>

<P>
Figura&nbsp;<A HREF="#vi">2</A> aratã un exemplu de text înainte ºi dupã prelucrare.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="321"></A>
<TABLE>
<CAPTION><STRONG>Tabela 2:</STRONG>
Modificãrile fãcute asupra unui text de comanda <TT>vi</TT>
din text.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT"><B>Inainte</B></TD>
<TD ALIGN="LEFT"><B>Dupã</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>
Un text &lt;I&gt;inainte&lt;/I&gt; de introducere. <BR></TT>
<P>
<TT>
Introducere <BR></TT>
<P>
<TT>
Un text in &lt;I&gt;interiorul&lt;/I&gt; &lt;B&gt;introducerii&lt;/B&gt;.
Foarte &lt;I&gt;scurt&lt;/I&gt;. <BR></TT>
<P>
<TT>
Capitolul 1 <BR></TT>
<P>
<TT>
Un text in &lt;I&gt;interiorul&lt;/I&gt; capitolului 1.</TT></TD>
<TD ALIGN="LEFT"><TT>
Un text &lt;I&gt;inainte&lt;/I&gt; de introducere. <BR></TT>
<P>
<TT>
Introducere <BR></TT>
<P>
<TT>
Un text in &lt;B&gt;interiorul&lt;/B&gt; &lt;B&gt;introducerii&lt;/B&gt;.
Foarte &lt;B&gt;scurt&lt;/B&gt;. <BR></TT>
<P>
<TT>
Capitolul 1 <BR></TT>
<P>
<TT>
Un text in &lt;I&gt;interiorul&lt;/I&gt; capitolului 1. </TT></TD>
</TR>
</TABLE>
</DIV>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>

<H2><A NAME="SECTION00066000000000000000">
<TT>emacs</TT></A>
</H2>

<P>
Editorul de texte <TT>emacs</TT> este un editor non-wyswyg extrem de
puternic, ºi editorul meu favorit<A NAME="tex2html16"
  HREF="#foot261"><SUP>7</SUP></A>; acest text a fost
scris cu <TT>emacs</TT>; Ca ºi <TT>vi</TT>, <TT>emacs</TT> oferã expresii
regulate puternice în comenzi de genul search-and-replace.  Nu le voi
discuta aici, însã; sintaxa ºi expresivitatea sunt foarte
asemãnãtoare cu <TT>vi</TT>.

<P>

<H2><A NAME="SECTION00067000000000000000">
<TT>f?lex</TT></A>
</H2>

<P>
<TT>lex</TT> ºi <TT>flex</TT> sunt douã generatoare de analizoare lexicale
pentru construcþia de compilatoare.  <TT>flex</TT> este o generaþie mai
nouã.  Aceste programe primesc un fiºier cu descrieri de expresii
regulate, ºi cu acþiuni asociate fiecãrei expresii.  Apoi aceste
programe genereazã programe C sau C++ (existã ºi <TT>jflex</TT> pentru
Java mai nou) care implementeazã automatele finite care recunosc
aceste expresii regulate, ºi executã acþiunile indicate de fiecare
datã cînd întîlnesc una din ele.

<P>
Dar aceste programe se pot folosi ºi în alte scopuri pentru
prelucrarea de texte; de pildã eu am scris un program în întregime în
<TT>flex</TT> care translateazã texte scrise într-un subset al
limbajului L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X(un limbaj
pentru typesetting -- aranjare în paginã) în text chior.  Eu îmi scriu
toate articolele pentru PC Report în
L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X, dar le transform în
text înainte de a le trimite revistei.

<P>
Iatã un exemplu de program simplu scris în <TT>lex</TT> adunã toate
numerele naturale dintr-un fiºier, indiferent unde apar ele:

<P>
<PRE>
%{
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int suma=0;
%}

CIFRA   [0-9]
NUMAR   {CIFRA}+
%%

{NUMAR} { suma += atoi(yytext); }
.       /* ignora orice nu e un numar */
%%
int yywrap() { return 1;}

int main() 
{
    yylex();
    printf("Suma %d\n", suma);
    return 0;
}
</PRE>

<P>

<H2><A NAME="SECTION00068000000000000000">
Perl</A>
</H2>

<P>
În fine, voi încheia cu o sumarã prezentare a expresiilor regulate
în Perl.  PC Report a publicat cel puþin un articol despre acest
interesant limbaj, ºi poate va continua seria.

<P>
Perl vine de la Practical Extraction and Report Language: un limbaj
pentru extras date ºi produs rapoarte.  Este un limbaj minunat pentru
a procesa fiºiere text ºi a face transformãri sofisticate.  Pînã
de curînd era limbajul preferat pentru a genera pagini dinamice la
serverele de web, deºi în ultima vreme are concurenþi serioºi în
limbaje ºi sisteme ca Python, PHP, Visual Basic, Zope, etc.

<P>
Perl este departe de a fi un limbaj ideal, dar reparã cu succes
problemele expresiilor regulate din celelalte limbaje ºi scule în
mod normal folosite.  Perl are urmãtoarele avantaje:

<P>

<UL>
<LI>Oferã toate capabilitãþile celorlalte sisteme; în mod
intenþionat integreazã tot ce pot face <TT>awk</TT>, shell-ul,
<TT>grep</TT> ºi <TT>sed</TT>.

<P>
</LI>
<LI>Oferã o sintaxã unicã pentru a descrie expresiile regulate;
fiecare din programele de mai sus are reguli puþin diferite de
celelalte.

<P>
</LI>
<LI>Oferã o gamã foarte amplã de operatori cu expresii regulate.
Foarte multe abrevieri practice sunt pre-definite.  

<P>
</LI>
<LI>Perl oferã chiar o extensie care de fapt <EM>nu este</EM> o
expresie regulatã, în sensul teoretic al cuvîntului, pentru cã
poate fi folositã pentru a descrie limbaje neregulate.

<P>
</LI>
<LI>Cînd scrieþi programe Perl nu mai aveþi problema cã semnele
scrise sunt interpretate întîi de shell ºi abia dupã aia de
program.  În felul acesta, ce scrieþi, asta ajunge la compilatorul
Perl.

<P>
</LI>
<LI>Perl poate prelucra cuvinte care se întind pe mai multe linii
(celelalte programe, mai puþin <TT>f?lex</TT> se limiteazã la o
singurã linie de text pentru fiecare expresie regulatã!).

<P>
</LI>
<LI>În fine, sintaxa Perl este mult mai omogenã.  De exemplu,
niciodatã nu se pune semnul <code>\</code> în faþa unui operator pentru
expresii regulate.  Dacã puneþi acest semn, caracterul devine un
caracter obiºnuit, ºi nu un operator.
</LI>
</UL>

<P>
Voi menþiona o construcþie Perl care depãºeºte puterea
expresiilor regulate.  Din aceastã cauzã, algoritmii eficienþi
cunoscuþi, care genereazã automate finite, nu mai funcþioneazã
pentru astfel de expresii.  Ele trebuie deci folosite cu cumpãtare,
pentru cã anumite cazuri patologice vor necesita extrem de mult timp.

<P>
Perl ne permite sã scriem ceva de genul: <code>(.*)\1</code>; asta
înseamnã un ºir de caractere urmat de el însuºi, deci un cuvînt
care este format din concatenarea a douã ºiruri identice.  Aceastã
exprimare simplificã multe operaþii, dar nu este o ER în sensul
strict al cuvîntului, deºi manualul Perl o numeºte aºa.

<P>
Închei acest paragraf cu o listã a operatorilor ºi prescurtãrilor
cele mai importante din Perl (nu toate!).  ER din Perl sunt extrem de
bogate, dar învãþate încetul cu încetul sunt foarte abordabile.
Dacã faceþi multe prelucrãri pe fiºiere, Perl este o sculã
absolut necesarã în arsenalul dumneavoastrã.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Expresie</TD>
<TD ALIGN="LEFT">Semnificaþie</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\</code></TD>
<TD ALIGN="LEFT">Urmãtorul meta-caracter devine un caracter obiºnuit</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>^</code></TD>
<TD ALIGN="LEFT">Început de linie</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>.</code></TD>
<TD ALIGN="LEFT">Orice caracter în afarã de newline</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>$</code></TD>
<TD ALIGN="LEFT">Sfîrºit de linie</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>|</code></TD>
<TD ALIGN="LEFT">Alternanþã (<IMG
 WIDTH="27" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="$a\vert b$">)</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>()</code></TD>
<TD ALIGN="LEFT">Indicã precedenþa operaþiilor</TD>
</TR>
<TR><TD ALIGN="LEFT"><code></code></TD>
<TD ALIGN="LEFT">Concatenarea este implicitã (nu folosim nici un semn)</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>[]</code></TD>
<TD ALIGN="LEFT">O mulþime de caractere (ca la <TT>grep</TT>)</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>*</code></TD>
<TD ALIGN="LEFT">Operatorul star: R* = R de zero sau mai multe ori la rînd</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>+</code></TD>
<TD ALIGN="LEFT">R+ = RR* (R cel puþin o datã)</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>?</code></TD>
<TD ALIGN="LEFT">R+ = <IMG
 WIDTH="31" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img53.png"
 ALT="$\epsilon\vert R$"> (R de zero sau una ori)</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>{n}</code></TD>
<TD ALIGN="LEFT">R{n} = R exact de n ori</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>{n,}</code></TD>
<TD ALIGN="LEFT">R{n,} = R de cel puþin n ori</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>{n,m}</code></TD>
<TD ALIGN="LEFT">R{n,m} = R de cel puþin n dar cel mult m ori la rînd</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\t</code></TD>
<TD ALIGN="LEFT">Caracterul tab</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\n</code></TD>
<TD ALIGN="LEFT">Caracterul sfîrºit de linie</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\r</code></TD>
<TD ALIGN="LEFT">Caracterul retur de car</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\x1B</code></TD>
<TD ALIGN="LEFT">Caracter descris în hexazecimal</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\l</code></TD>
<TD ALIGN="LEFT">Urmãtorul caracter micºorat (majuscule devin minuscule)</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\u</code></TD>
<TD ALIGN="LEFT">Urmãtorul caracter majorat (minusculele devin majuscule)</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\w</code></TD>
<TD ALIGN="LEFT">Orice caracter care formeazã ``cuvinte'' (alfanumerice ºi _)</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\W</code></TD>
<TD ALIGN="LEFT">Orice caracter care nu formeazã cuvinte</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\s</code></TD>
<TD ALIGN="LEFT">Orice spaþiu</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\S</code></TD>
<TD ALIGN="LEFT">Orice caracter care nu e spaþiu</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\d</code></TD>
<TD ALIGN="LEFT">Orice cifrã</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\D</code></TD>
<TD ALIGN="LEFT">Orice caracter care nu e cifrã</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\b</code></TD>
<TD ALIGN="LEFT">O poziþie dintre un cuvînt ºi un non-cuvînt (zero caractere)</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>\B</code></TD>
<TD ALIGN="LEFT">O poziþie care nu este între un cuvînt ºi un non-cuvînt</TD>
</TR>
</TABLE>
</DIV>

<P>

<H1><A NAME="SECTION00070000000000000000">
Alte surse de informaþie</A>
</H1>

<P>
Existã o grãmadã de informaþie despre aceste programe.  Pentru
utilitarele descrise (<TT>grep</TT>, <TT>sh</TT>, <TT>sed</TT>,
<TT>awk</TT>), paginile de manual interactiv (<TT>man</TT>) au o
grãmadã de informaþii.  De asemenea, implementãrile ``free'' din
proiectul GNU (menþionat adesea în PC Report, vedeþi de pildã <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#open">articolul</a>
meu din iunie 1998) ale acestor utilitare vin cu documentaþii
excelente în formã electronicã.

<P>
Limbajul Perl are o mulþime de informaþii interesante on-line, la
<TT><A NAME="tex2html17"
  HREF="www.perl.com">www.perl.com</A></TT>; toate manualele de bazã sunt acolo în formã
electronicã.

<P>
Dacã vreþi sã învãþaþi mai mult despre expresii regulate,
existã o grãmadã de cãrþi utile.  De exemplu ``Cartea Dragon'', a
lui Aho, Sethi ºi Ullman ``Compilers : Principles, Techniques, and
Tools'', de la Addison-Wesley din 1985, care este o carte clasicã
despre teoria ºi construcþia calculatoarelor.  Un tratament foarte
teoretic ºi elegant puteþi gãsi în cartea lui Dexter Kozen
``Automata and Computability'', de la Springer Verlag, 1999.

<P>
Echivalentul lui <TT>lex</TT> pentru Java are o pagina de web la
<TT><A NAME="tex2html18"
  HREF="http://www.jflex.de/">http://www.jflex.de/</A></TT>, cu tot cu documentaþie.

<P>

<H1><A NAME="SECTION00080000000000000000">
Concluzii</A>
</H1>

<P>
Textul asta prezintã o grãmadã de detalii; mã ºi întreb dacã vor
fi folositoare cuiva...Cred ca unele dintre lucrurile de aici
sunt însã demne de reþinut:

<P>

<UL>
<LI>O expresie regulatã este o metodã de a descrie o mulþime
potenþial infinitã de cuvinte printr-un singur ºir de caractere;

<P>
</LI>
<LI>Expresiile regulate sunt extrem de folosite în prelucrarea de
texte, scrierea de programe, generarea de pagini de web, ºi multe
alte domenii;

<P>
</LI>
<LI>Existã metode practice extrem de eficiente de a genera din
expresiile regulate automate mici ºi rapide care pot verifica în
timp linear dacã un cuvînt dat este generat de expresia regulatã;

<P>
</LI>
<LI>N-am spus-o explicit, dar teoria automatelor finite are enorm de
multe aplicaþii în afara limbajelor, mai ales în hardware.  Dacã
veþi citi despre arhitectura sistemelor de calcul veþi vedea cã
practic <EM>toate microprocesoarele moderne sunt automate finite</EM>.
</LI>
</UL>

<P>
Orice programator poate deci folosi expresiile regulate, fãrã sã
ºtie tot ce se ascunde în spatele lor.  Nici articolul acesta nu
face decît sã ridice puþin voalul, fãcînd aluzie la o combinaþie
de solide rezultate teoretice ºi inginereºti.  Fundamentele solide
sunt cele care de fapt fac aceastã ``tehnologie'' atît de eficace.

<P>
<BR><HR><H4>Note</H4>
<DL>
<DT><A NAME="foot89">... yak-ul</A><A NAME="foot89"
 HREF="regex-html.html#tex2html4"><SUP>1</SUP></A>
<DD>ªi Java are un astfel de
generator lexical.

<DT><A NAME="foot103">... stii</A><A NAME="foot103"
 HREF="regex-html.html#tex2html6"><SUP>2</SUP></A>
<DD>Un
fel de Xerox primitiv.

<DT><A NAME="foot104">... calculator</A><A NAME="foot104"
 HREF="regex-html.html#tex2html7"><SUP>3</SUP></A>
<DD>Mai exact, unui interpretor sau
unui compilator.

<DT><A NAME="foot123">...<IMG
 WIDTH="39" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$a\vert b\vert\epsilon$"></A><A NAME="foot123"
 HREF="regex-html.html#tex2html9"><SUP>4</SUP></A>
<DD>Operaþia <IMG
 WIDTH="11" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.png"
 ALT="$\vert$">
este asociativã, aºa cã o putem folosi fãrã paranteze.

<DT><A NAME="foot240">...
<code>&lt;I&gt;ceva caractere&lt;/I&gt;</code></A><A NAME="foot240"
 HREF="regex-html.html#tex2html13"><SUP>5</SUP></A>
<DD><code>&lt;I&gt;</code> în HTML descrie
cuvinte scrise cu litere cursive (I = italic).

<DT><A NAME="foot241">... B</A><A NAME="foot241"
 HREF="regex-html.html#tex2html14"><SUP>6</SUP></A>
<DD>În HTML
<code>&lt;B&gt;</code> indicã caractere grase (B = bold).

<DT><A NAME="foot261">... favorit</A><A NAME="foot261"
HREF="regex-html.html#tex2html16"><SUP>7</SUP></A> <DD>Am scris un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#emacs">articol</a>
întreg în PC Report despre el în mai 1997.

</DL>
<BR><HR>

</BODY>
</HTML>
