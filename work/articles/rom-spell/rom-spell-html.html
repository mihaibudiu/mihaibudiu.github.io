<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>``Corect'' -- un ``spell-check''-er pentru limba românã</TITLE>
<META NAME="description" CONTENT="``Corect'' -- un ``spell-check''-er pentru limba românã">
<META NAME="keywords" CONTENT="rom-spell-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">``Corect'' -- un ``spell-check''-er pentru limba românã</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- mihaib+ at cs.cmu.edu, <TT>http://www.cs.cmu.edu/~mihaib</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>16 mai 1997</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>un corector de texte pentru limba românã
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>familiaritate cu sisteme de prelucrare a
textelor
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>spell-check, emacs, ispell, standard,
inernaþionalizare
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html23"
  HREF="rom-spell-html.html">Programul <TT>ispell</TT></A>
<LI><A NAME="tex2html24"
  HREF="#SECTION00030000000000000000">Un principiu de Design</A>
<LI><A NAME="tex2html25"
  HREF="#SECTION00040000000000000000">Pachetul pentru limba românã</A>
<UL>
<LI><A NAME="tex2html26"
  HREF="#SECTION00041000000000000000">Fiºierele de prefixe/sufixe</A>
<LI><A NAME="tex2html27"
  HREF="#SECTION00042000000000000000">Problema internaþionalizãrii</A>
<LI><A NAME="tex2html28"
  HREF="#SECTION00043000000000000000">Dicþionarele</A>
<LI><A NAME="tex2html29"
  HREF="#SECTION00044000000000000000">Interfaþa cu emacs</A>
<LI><A NAME="tex2html30"
  HREF="#SECTION00045000000000000000">Fiºierul de stil pentru L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION00046000000000000000">Interfaþa corectorului de limba românã cu utilizatorul</A>
</UL></UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>

<P>
Folosind programul <TT>ispell</TT> am construit un pachet de utilitare
care uºureazã scrierea ºi corectarea textelor în limba românã.
Pachetul este, sper, relativ uºor de instalat ºi folosit pe
platforme Unix, ºi este disponibil oricui fãrã restricþii.  

<P>
Poate fi obþinut prin web de la <a
href="http://www.cs.cmu.edu/~mihaib/ftp/rom-spell.taz">http://www.cs.cmu.edu/~mihaib/ftp/rom-spell.taz</a>.
În acest articol discut în oarece detaliu despre una dintre sculele pe
care pachetul se bazeazã (excelentul program <TT>ispell</TT>) ºi
justific unele dintre deciziile pe care le-am luat cînd am construit
pachetul.  Pe alocuri divaghez despre importanþa unui design clar
separat, ºi despre funcþia standardelor în ziua de azi.

<P>

<H1><A NAME="SECTION00020000000000000000">
Programul <TT>ispell</TT></A>
</H1>

<P>
<TT>ispell</TT> este software ``free'', deci accesibil oricui.  Rolul lui
este destul de simplu: analizeazã texte ºi indicã cuvintele a
cãror grafie nu o cunoaºte, permiþînd în felul acesta corectarea
unora dintre erorile de dactilografie.  <TT>ispell</TT> vine de la
``fabricanþi'' cu o întreagã suitã de programe care permit
construirea, manipularea ºi întreþinerea de dicþionare.

<P>
<TT>ispell</TT> este prin natura lui un program nu prea inteligent: are
la îndemînã un dicþionar cu <EM>toate</EM> cuvintele corecte, iar
ceea ce face este sã caute fiecare cuvînt din textul de corectat
în dicþionar.  Dacã gãseºte cuvîntul îl socoteºte bun, dacã
nu, se uitã în dicþionar dupã cuvinte care sunt ``apropiate'' ca
scriere de cel absent, pe care apoi le propune spre înlocuire,
presupunînd ca acel cuvînt a fost greºit scris.

<P>
Ce înseamnã cã ``douã cuvinte sunt aproape'' pentru <TT>ispell</TT>?  
Un cuvînt este aproape de altul dacã se poate obþine printr-una din 
urmãtoarele operaþii:

<P>

<UL>
<LI>Adãugarea unei litere;
</LI>
<LI>ªtergerea unei litere;
</LI>
<LI>Transpunerea a douã litere consecutive.
</LI>
</UL>

<P>
De asemenea, <TT>ispell</TT> poate identifica lipsa unui spaþiu dintre
douã cuvinte.

<P>
Deºi un astfel de program nu poate oferi nici o garanþie în
producerea de texte corecte, este extrem de eficace în a elimina o
mare parte dintre erorile tipografice.

<P>
Chiar faptul cã <TT>ispell</TT> nu are nici o cunoºtinþã despre
limbã îl face foarte util, pentru cã permite folosirea lui cu texte
scrise în orice limbã, cu condiþia posedãrii unui dicþionar
potrivit.

<P>

<H1><A NAME="SECTION00030000000000000000">
Un principiu de Design</A>
</H1>

<P>
Programe de genul <TT>ispell</TT> existã de multã vreme în lumea Unix
(de ex. programul <TT>spell</TT>; to spell = a scrie literã cu literã).
Ceea ce face <TT>ispell</TT> atrãgãtor este universalitatea lui.
<TT>ispell</TT> este un exemplu tipic de program care
încarneazã un foarte important principiu de proiectare în
calculatoare.  Acest principiu se manifestã în separarea dintre <EM>mecanism</EM> ºi <EM>politicã</EM> (policy/mechanism).  Principiul indicã
faptul cã un aparat trebuie sã fie cît mai universal, ca sã nu
oblige pe cel care îl foloseºte la anumite feluri de manipulare,
care sã îi reducã utilitatea.

<P>
Tehnica este extrem de importantã în proiectarea sistemelor de
operare, ºi în general a programelor care servesc drept unelte<A NAME="tex2html1"
  HREF="#foot69"><SUP>1</SUP></A>(de exemplu bibliotecile).  Un sistem de operare trebuie de exemplu
sã-þi ofere toate metodele prin care sã poþi controla <EM>cînd</EM>
se vor executa programele tale, dar sã nu impunã o anumitã ordine
de execuþie a lor.  Sistemul de operare este cel care executã
programele, dar utilizatorul este cel care indicã ordinea ºi
prioritãþile.

<P>
Un alt exemplu interesant este în reþelele de calculatoare: protocoalele
de transmisiune a datelor ºtiu sã mute biþi de la un calculator la
altul, chiar foarte îndepãrtat.  În acest caz mecanismul este cel
care transportã datele.  Politica de alegere a traseului pe care le
urmeazã datele este însã complet separatã de mecanismul de transport;
ea este decisã de un set complet separat de protocoale, numite 
protocoale de rutare.  Aceastã flexibilitate permite construirea de
protocoale de rutare noi ºi înlocuirea celor vechi ``din mers'',
fãrã a întrerupe funcþionarea reþelei în vreun fel.

<P>
Pe scurt: dacã faci un aparat complicat, nu restrînge modul în care
poate fi folosit, ci construieºte-i suficiente mînere cît sã
poatã fi controlat în cît mai multe feluri.

<P>

<H1><A NAME="SECTION00040000000000000000">
Pachetul pentru limba românã</A>
</H1>

<P>
Unde trebuie puse mînerele nu este întotdeauna evident.
Proiectantul variantei internaþionale a lui <TT>ispell</TT>, Geoff
Kuenning, a studiat cu atenþie locurile în care politica era
îngropatã în interiorul programului, ºi a încercat sã o extragã
în afarã.  Acest lucru este vizibil utilizatorului prin faptul cã
pentru a folosi <TT>ispell</TT> trebuie sã scrii o grãmadã de fiºiere
auxiliare, care controleazã modul în care lucreazã.  Ceea ce am
ºi fãcut, pentru a putea face <TT>ispell</TT> utilizat cu texte
româneºti.

<P>
În cele ce urmeazã voi descrie pe scurt conþinutul pachetului;
aceastã descriere îmi va prilejui identificarea porþiunilor din
<TT>ispell</TT> care sunt supuse controlului utilizatorului.

<P>

<H2><A NAME="SECTION00041000000000000000">
Fiºierele de prefixe/sufixe</A>
</H2>

<P>
Principala piesã din configurarea <TT>ispell</TT> este fiºierul de
afixe.  Numele nu este foarte fericit ales, pentru cã funcþiunea
acestuia este, pe lîngã de a indica metode de derivare cu prefixe
ºi sufixe (care pot fi folosite pentru a comprima dicþionarele), ºi
descrierea parametrilor funcþionãrii lui <TT>ispell</TT>.

<P>
O primã alegere cu care m-am confruntat a fost dacã dicþionarele
vor conþine semne diacritice sau nu.  Pentru cã nu m-am putut
hotãrî, pînã la urmã am construit douã configuraþii ºi douã
dicþionare, pentru ambele cazuri.

<P>
Pentru cazul semnelor diacritice a trebuit sã fac faþã
urmãtoarelor douã decizii:

<P>

<UL>
<LI>Dacã folosesc sau nu noile reguli de scriere ale Academiei cu
â;  rezultatul îl ghiciþi din textul de faþã, care este corectat
cu <TT>ispell</TT>;

<P>
</LI>
<LI>Cum voi reprezenta semnele diacritice.  Aceastã problemã este
extrem de spinoasã, ºi îmi va da prilejul sã fac o lungã digresiune:
</LI>
</UL>

<P>

<H2><A NAME="SECTION00042000000000000000">
Problema internaþionalizãrii</A>
</H2>

<P>
Calculatoarele depind într-o sumedenie de moduri subtile de faptul
cã au fost concepute de oameni care foloseau mai ales limba englezã
(orice istorie a calculatoarelor va recunoaºte rolul americanilor
ºi, ceva mai puþin, al englezilor).  Modul în care sunt prelucrate
textele, în care sunt afiºate ºi citite este adesea strîns legat
de caracteristicile speciale ale limbii engleze.  De acest lucru
ºi-au dat seama cei care au încercat sã universalizeze folosirea
calculatoarelor, pentru a le adapta ºi altor naþii.

<P>
Fãrã a avea pretenþia de a trata exhaustiv aceastã problemã, sã
aruncãm o privire asupra influenþei limbii asupra programelor.

<P>

<H3><A NAME="SECTION00042100000000000000">
Traseul informaþiei</A>
</H3>

<P>
Pentru a prelucra texte avem trei categorii mari de operaþii:

<P>

<UL>
<LI>Citirea textelor de la tastaturã;
</LI>
<LI>Prelucrarea textelor prin feluriþi algoritmi;
</LI>
<LI>Afiºarea (vizualizarea) textelor.
</LI>
</UL>

<P>
Pentru fiecare din aceste activitãþi este responsabil un program
distinct.  De citirea tastaturii se ocupã ``driver''-ul de terminal.
Acesta are de obicei mai multe funcþiuni:

<P>

<UL>
<LI>Deduce combinaþia de taste apãsatã; o reprezintã printr-un
ºir de coduri;
</LI>
<LI>Traduce codurile la o reprezentare ``standard''; de exemplu
cînd apeºi tasta pe care scrie ``A'' returneazã codul ASCII al lui
``a'', care e 97.
</LI>
<LI>Cîteodatã face o minimã editare a textului: de exemplu dacã
apeºi pe DELETE ºterge un caracter.
</LI>
</UL>

<P>
În funcþie de sistemul de operare, utilizatorul are mai multe
opþiuni la-ndemînã pentru a influenþa driverul: poate sã
citeascã direct codurile, sã influenþeze modul în care se face
traducerea, sã evite editarea automatã textului.

<P>
Dacã lucrezi pe un calculator la distanþã, de exemplu conectat prin
<TT>telnet</TT> prin reþea, lucrurile se complicã, pentru cã între driver-ul 
care citeºte tastatura (aflat pe calculatorul local) ºi aplicaþia ta
(aflatã la distanþã) se mai interpun încã douã programe care
codificã fiecare tastã apãsatã:

<P>

<UL>
<LI>Programul local de <TT>telnet</TT>, citeºte tastele de la driver ºi le
traduce într-un mod standardizat pentru comunicaþia prin reþea;
</LI>
<LI>Programul de la distanþã, demonul <TT>telnetd</TT>, care primeºte de 
la <TT>telnet</TT> codurile standard ale tastelor ºi le traduce pentru maºina 
de acolo.
</LI>
</UL>

<P>
Afiºarea textelor este iarãºi de obicei sarcina unui ``driver''.
Dacã avem de-a face cu un terminal alfa-numeric (sau o fereastrã
care emuleazã un astfel de terminal prin software), atunci de obicei
driver-ului i se dau secvenþe de caractere ASCII, pe care ºtie el
cum sã le afiºeze; din cînd în cînd i se dau ºi coduri numite
``caractere de control'', care de obicei nu lasã urme pe ecran, ci
îi spun terminalului <EM>cum</EM> sã manipuleze caracterele ce urmeazã.  
De exemplu putem indica, folosind caractere de control, în
ce loc pe ecran sã se scrie urmãtorul caracter ASCII.  Care este
secvenþa de caractere de control care spune acest lucru depinde
de terminal; fiecare fabricant a inventat propriile convenþii.

<P>
De cînd firma Xerox a inventat ecranul grafic (``bitmapped screen''), 
a deveni un lucru comun ca interfaþa dintre aplicaþie ºi utilizator sã 
nu fie un simplu ºir de caractere pe care terminalul le afiºeazã, ci o
matrice mare de punctuleþe care pot fi controlate individual.
Aplicaþiilor li se pune la îndemînã posibilitatea de a desena
orice formã doresc; foarte frecvent însã sistemul de operare pune
la dispoziþie funcþii de bilbiotecã pentru a desena caractere cu
felurite forme (``fonturi'').

<P>
În fine, ultimul aspect al prelucrãrii de texte este procesarea lor cu
feluriþi algoritmi: cãutãri, sortãri, tehnoredactare, corecturã, editare,
transmitere de poºtã electronicã, etc.  Vom reveni pe scurt asupra fazei
de prelucrare dupã ce discutãm despre standardizare.

<P>

<H3><A NAME="SECTION00042200000000000000">
Standardizarea</A>
</H3>

<P>
Un element cheie în interacþiunea între aceste pãrþi (drivere,
aplicaþii, biblioteci, sistemul de operare) este faptul cã <EM>toate folosesc aceeaºi metodã de codificare</EM>.  Cînd apãsaþi tasta
``A'', driverul de tastaturã întoarce 97, iar aplicaþia ºtie cã a
primit un ``A'', pe care îl poate da bibliotecii de afiºare, care
ºtie cã trebuie sã deseneze o astfel de literã.

<P>
Oricine a lucrat pe o tastaturã prost configuratã, sau a încercat
sã acceseze de la distanþa o aplicaþie care decodificã ciudat
tastatura, sau a manipulat tabele de translatare ale codurilor, sau a
primit mail cu caractere internaþionale va înþelege importanþa
acestei convenþii.  Literei ``A'' i se asociazã codul 97 de cãtre
codul ASCII (American Standard Code for Information Interchange), care
este standardizat de ANSI (American National Standard Institute); e un
fel de STAS local.  Din fericire, datoritã dominaþiei SUA în arena
calculatoarelor, ASCII este practic implementat de toatã lumea.  ªi
organizaþia mondialã a standardelor ISO (International Standards
Organization) a acceptat ASCII sub numele ISO 646.  Codificarea ASCII
însã recomandã numai 128 de simboluri (din care 32 nici mãcar nu
sunt vizibile, ci sunt ``caractere de control'').  De îndatã ce
ieºim din perimetrul acestora, domneºte haosul.

<P>
Pentru caractere pe 8 biþi existã standardul ISO-8859, care oferã o
duzinã de interpretãri pentru caracterele cu coduri peste 128.
Pentru limba românã cea mai interesantã interpretare este cea datã
de ISO-8859-2, numitã ºi Latin-2, care conþine toate semnele
speciale cu diacritice româneºti.  Problema acum este însã:
înainte de a cãdea de acord ce semn este cel cu codul 200, trebuie
sã cãdem de acord ce cod folosim din duzina de variante ISO sau alte
variante.  Plus cã fiecare aplicaþie trebuie sã fie capabilã sã 
interpreteze toate variantele, etc.

<P>
Tentative de standardizare ºi mai îndrãzneþe s-au fãcut: un
consorþiu gigant, din care fac parte Microsoft, IBM, Xerox, Sun ºi
alte (zeci) de firme din lumea calculatoarelor, a fost înfiinþat, pe
nume Unicode.  Acesta, cu ajutorul a zeci de experþi lingviºti a
propus o standardizare uniformã a tuturor caracterelor, din toate
limbile lumii, folosind pentru aceasta 16 biþi pe caracter.  Fiecare
caracter ar avea astfel o reprezentare unicã ºi ne-ambiguã.
Dificultãþile de înfrînt sunt enorme; de exemplu trebuie cumva
luate în considerare standardele naþionale (cum ar fi cel elaborat
de Japonezi) ºi reconciliate.

<P>
Din pãcate concordia nu este încã realizatã, pentru cã ISO a
propus în acelaºi scop propriul ei standard, diferit de Unicode, 
pe 32 de biþi, numit ISO DIS 10646.

<P>
Dificultatea la ora asta este deci nu cã nu existã standarde, ci cã
existã prea multe.  O aplicaþie poate folosi propriile ei convenþii
interne pentru citirea tastaturii/modificare/afiºare, dar de îndatã
ce se pune problema <EM>schimbului</EM> de informaþii, absenþa unui
standard unic (sau a unui numãr mic de standarde) face problema intratabilã.

<P>
În general, viaþa noastrã de toate zilele depinde enorm de
standarde, într-un fel pe care nici nu-l realizãm.  Dacã nu am avea
standarde trenurile nu ar pute circula pentru cã ecartamentul ar fi
diferit în þãri diferite (de altfel, la ruºi chiar este mai mare),
aparatele electrice nu ar funcþiona decît unde au fost proiectate
(ºi aºa americanii merg la 110V), maºinile ar trebui sã care
benzina de acasã ca sã se potriveascã cifra octanicã, am vedea la 
televizor numai ce ar transmite bunica, cu care folosim aceeaºi codificare, 
etc, etc.

<P>

<H3><A NAME="SECTION00042300000000000000">
Prelucrãrile pe texte</A>
</H3>

<P>
Înainte de a ne îndepãrta de zona standardelor internaþionale, sã
mai aruncãm o privire asupra unor întrebãri care sunt legate de
reprezentarea caracterelor, ºi al cãror rãspuns influenþeazã modul 
în care algoritmii vor procesa textele:  

<P>

<UL>
<LI>Nu toate limbile se scriu în aceeaºi direcþie; ebraica se
scrie de la dreapta la stînga, iar japoneza pe verticalã.  Cînd am
un text englezesc cu citate din vechiul testament în ebraicã, cum
reprezint textul în calculator, în ce ordine?

<P>
</LI>
<LI>Literele se pot scrie adesea în felurite moduri; chiar lãsînd
la o parte informaþia legatã de font, dimensiune ºi orientare.  În
arabã unele litere se scriu diferit în funcþie de vecinii lor;

<P>
</LI>
<LI>Voi reprezenta ã ca douã semne (a ºi cãciula) -- din care
cãciula este un semn care ``nu ocupã spaþiu'', deci se scrie peste
cel anterior -- sau ca o singurã literã?

<P>
</LI>
<LI>Reprezint ``A'' ºi ``a'' ca pe o aceeaºi literã, într-un caz
modificatã (mãritã), sau ca pe douã litere deosebite?

<P>
</LI>
<LI>În anumite limbi un semn se comportã ca mai multe litere (în
germanã ß se sorteazã ca ºi cum s-ar scrie ``ss''), dar se scrie
ca una singurã.  În alte limbi e invers: în Spaniolã ``ll'' este
consideratã o singurã literã la sortare.  Algoritmii de sortare
devin deci mult mai complicaþi, pentru cã nu mai pot face simple
comparaþii literã cu literã (o simplã sortare lexicograficã).

<P>
</LI>
<LI>În limba chinezã literele nu sunt ordonate alfabetic, ci dupã
numãrul de liniuþe cu care se deseneazã.

<P>
</LI>
<LI>Informaþii ca: sfîrºitul de paragraf, de paginã, indentarea,
numãrul de spaþii albe sunt sau nu reprezentabile prin caractere
(cum sunt de exemplu în setul ASCII ``New-Line'' sau ``Tab'')?

<P>
</LI>
<LI>Cînd scriu programe în C, cum reprezint caractere
internaþionale pentru mesaje date utilizatorului?

<P>
</LI>
<LI>Cum pot crea un fiºier cu nume în Swahili?

<P>
</LI>
<LI>Cum se scrie o expresie regulatã în Kanji?
</LI>
</UL>

<P>
Oricare din aceste probleme poate fi rezolvatã, dar pînã cînd nu
toatã lumea le va rezolva pe toate în acelaºi fel (prin intermediul
unui standard), programele riscã sã manipuleze obiecte pe care nu le
mai înþelege nimeni în afarã de autori.

<P>
Probabil cã învingãtor în lupta standardelor va ieºi pînã la
urmã Unicode, datoritã suportului unor firme extrem de mari, ºi
datoritã calitãþilor sale tehnice.  Standardul este descris în 8
cm<A NAME="tex2html2"
  HREF="#foot101"><SUP>2</SUP></A> de hîrtie la ora actualã, ºi mai creºte.

<P>
Sistemul de operare Windows NT de la Microsoft este construit
integral cu Unicode în interior; totul, de la nume de fiºiere la
mesaje de eroare este construit pe 16 biþi.  Biblioteci speciale
transformã datele manipulate de programele ``vechi'' (care lucreazã
cu caractere pe 8 biþi) în Unicode înainte de a ruga driverele din
nucleu sã le afiºeze.  Chiar faptul ca Windows NT dominã piaþa
sistemelor de operare la ora actualã este un motiv major pentru ca
Unicode sã învingã.

<P>

<H3><A NAME="SECTION00042400000000000000">
Reprezentarea diacriticelor</A>
</H3>

<P>
Închei aici digresiunea mea despre standarde ºi reprezentarea
caracterelor internaþionale, ºi revin la pachetul meu mult mai
modest, care încearcã sã rezolve unele dintre problemele limbii
române.

<P>
Hotãrîrea mea finalã a fost sã reprezint absolut tot textul
folosind semne ASCII, lucru care o sã mã scuteascã de o sumedenie
de probleme de portabilitate, pentru cã virtual toate terminalele din
lume recunosc setul de caractere ASCII.  În schimb mi-am propus sã
folosesc o convenþie care sã aibã urmãtoarele proprietãþi:

<P>

<UL>
<LI>Sã foloseascã semnele ASCII într-un mod ne-ambiguu (de
exemplu dacã aº fi folosit semnul <TT>a+</TT> pentru ã, aº fi avut
mari dificultãþi în a distinge formulele matematice de texte cu
diacritice; convenþia pe care am aleas-o în final nu e perfect 
ne-ambiguã, dar e tolerabil de neambiguã, cred;

<P>
</LI>
<LI>Ca o consecinþã a ne-ambiguitãþii, ar trebui sã fie foarte
uºor de scris un program care sã converteascã un text scris cu
diacritice folosind convenþia mea, în orice altã convenþie de 
reprezentare.  Practic dacã fac un <EM>search-and-replace</EM> pe un text 
pot obþine orice altã convenþie.  Par-examplu, dacã dvs. folosiþi pentru 
ã semnele /a, ºi eu folosesc {a}, atunci înlocuind uniform {a} cu /a
convertesc un text din reprezentarea mea în a dumneavoastrã.

<P>
</LI>
<LI>Semnele pe care le folosesc sã fie uºor de tastat.  În limba
românã existã o sumedenie de cuvinte cu semne diacritice, deci
mîna mea va trebui sã nu se deplaseze prea mult pe tastaturã pentru a
scrie semnele însoþitoare; de preferabil sã nu folosesc SHIFT sau
ceva înrudit.

<P>
</LI>
<LI>Metoda sã se împace bine cu alte programe care manipuleazã texte.
De exemplu eu scriu texte folosind editorul Emacs (vedeþi ºi <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#emacs">articolul</a>
meu din PC-Report pe Mai 1997), iar în Emacs tasta <TT>M-f</TT> se
deplaseazã peste un cuvînt.  Aº fi vrut ca semnele diacritice pe care
le folosesc sã nu fie considerate de Emacs ca fiind înafara
cuvintelor.
</LI>
</UL>

<P>
Pînã la urmã alegerea s-a oprit asupra semnului apostrof: ' .  De
aceea voi scrie acum literele astfel: <code>'a 'i 's 't</code>
 pentru ã, î, º, þ.

<P>
Probabil cã alegerea pentru â a fost mai puþin fericitã: am ales
<code>"a</code>. <!--"-->

<P>
Dar sã revenim la fiºierele de configurare pentru <TT>ispell</TT><A NAME="tex2html3"
  HREF="#foot110"><SUP>3</SUP></A>.

<P>
Odatã ce am hotãrît ce litere voi folosi, am purces la a scrie un
fiºier de configurare pentru <TT>ispell</TT>.  Formatul fiºierului este
documentat în paginile de manual ale programului <TT>ispell</TT>.  Acesta este
conþinutul fiºierului <TT>rom.signs.aff</TT>: fiºierul de afixe pentru
limba românã cu semne diacritice (cel pentru configuraþia fãrã 
diacritice este mai simplu).

<P>
<PRE>
nroffchars    ().\\*
texchars      ()\[]{}&lt;\>\\$*.%
stringchar    "'a" "'A"
stringchar    "'i" "'I"
stringchar    "'s" "'S"
stringchar    "'t" "'T"
stringchar    "\"a" "\"A"
wordchars     [a-z] [A-Z]
</PRE>

<P>
Folosind un limbaj foarte simplu îi descriu lui <TT>ispell</TT> care
caractere au semne speciale în fiºierele scrise pentru <TT>nroff</TT>
ºi T<SMALL>E</SMALL>X (acestea sunt douã programe foarte rãspîndite în
lumea Unix pentru tehnoredactarea de texte, care au folosesc niºte
limbaje speciale pentru a descrie aranjarea în paginã a textului.
Practic eu trebuie sã îi spun lui <TT>ispell</TT> cã atunci cînd
manipulez un text scris pentru <TT>nroff</TT>, respectiv T<SMALL>E</SMALL>X, trebuie
sã ignore cuvintele care descriu aranjarea în paginã, ºi sã
corecteze numai restul textului.)

<P>
Apoi îi indic lui <TT>ispell</TT> cã voi interpreta perechile de semne
apostrof-a, apostrof-A, etc. drept o singurã literã în textele
mele.  Asta este foarte important pentru cã îi spune lui <TT>ispell</TT> cã ``fîº'' este obþinut din ``fºî'' prin schimbarea a
douã litere (deci este ``aproape''), ºi nu prin permutarea unui ºir 
de 4 caractere (cuvintele se vor scrie cu convenþia mea astfel:
<code>f'i's    f's'i</code>).

<P>
În fine, indic faptul cã semnele ASCII obiºnuite pentru litere sunt
componente ale cuvintelor.  <TT>ispell</TT> permite reguli ºi mai
rafinate, pentru a indica de pildã cã anumite caractere sunt
considerate litere numai dacã apar în interiorul unui cuvînt (cum
ar fi de pildã liniuþa de unire -), sau pentru a indica faptul cã
<TT>nroff</TT> sau T<SMALL>E</SMALL>X denotã altfel un acelaºi caracter.

<P>
Observaþi cît de flexibil este <TT>ispell</TT>: comportarea programului
este influenþatã de o grãmadã de parametri dinafarã, din fiºierul
de configurare.  Aceasta este separarea de politicã ºi mecanism de
care vorbeam, care îi permite lui <TT>ispell</TT> sã fie simultan
folosit în condiþii atît de diferite.

<P>

<H2><A NAME="SECTION00043000000000000000">
Dicþionarele</A>
</H2>

<P>
A doua problemã spinoasã era: de unde dicþionare?  La aceastã
întrebare am rãspuns imediat.  

<P>

<H3><A NAME="SECTION00043100000000000000">
Achiziþia de date</A>
</H3>

<P>
<TT>ispell</TT> este un program interactiv, care este suficient de
înþelept sã fie de acord cã nu ºtie totul.  De fiecare datã
cînd <TT>ispell</TT> gãseºte un cuvînt necunoscut, pe lîngã faptul
cã îmi oferã o listã de posibile corecturi, îmi oferã
posibilitatea de a introduce cuvîntul în dicþionar.  Exact pe asta
m-am bazat ºi eu: voi construi dicþionarul incremental, rulînd 
<TT>ispell</TT> pe texte (cît se poate de) corecte.  Dupã o fazã 
plictisitoare în care mã va întreba mai toate cuvintele, va învãþa 
vocabularul meu de bazã ºi va deveni eficace.

<P>
Construcþia dicþionarelor este în plinã desfãºurare, deºi
ambele (cel cu diacritice ºi cel fãrã) au cîte 40 de mii de
cuvinte la ora actualã.  Principala mea sursã de vocabular este
ediþia pe Internet a ziarelor ``România Literarã'' ºi ``Dilema'',
plus, mai puþin, textele pe care le scriu eu însumi.

<P>

<H3><A NAME="SECTION00043200000000000000">
Analiza statisticã</A>
</H3>

<P>
Dupã ce am strîns cîteva mii de cuvinte, am folosit celelalte
programe din pachetul cu care vine <TT>ispell</TT> pentru a face o
analizã statisticã a dicþionarelor.  Analiza este utilã pentru cã
în fiºierele de configurare îi pot descrie lui <TT>ispell</TT> simple
reguli de derivare cu prefixe ºi sufixe, pe care apoi el le
foloseºte pentru a reduce mãrimea dicþionarelor, memorînd o
singurã datã rãdãcinile comune.  Pachetul care conþine programul <TT>ispell</TT> oferã pentru acest scop programele <TT>findaffix</TT>, care
analizeazã exhaustiv un dicþionar, generînd informaþii despre
potenþialele derivãri, ºi <TT>tryaffix</TT>, care evalueazã economia
care se poate obþine folosind un anumit affix.

<P>

<H3><A NAME="SECTION00043300000000000000">
Compresia prin prefixe ºi sufixe</A>
</H3>

<P>
Cum se folosesc afixele pentru a reduce mãrimea dicþionarului?
Pentru fiecare afix se defineºte (manual) cîte o prescurtare de o
literã.  De exemplu, pentru prefixul ``re-'' am alocat litera E.
Atunci, în loc ca în dicþionar sã aparã cuvintele ``educare'' ºi
``reeducare, va apãrea doar o înregistrare de forma ``educare/E''.
Practic am înlocuit un cuvînt întreg cu douã litere (/ ºi E).

<P>
Pachetul <TT>ispell</TT> vine împreunã cu un alt program numit <TT>munchlist</TT>, care, dîndu-i-se un dicþionar ºi o listã de afixe,
comprimã dicþionarul la o reprezentare minimã.  Rezultatul este
foarte eficace; chiar cu fiºierele relativ primitive de afixe pe care
le-am fãcut am reuºit sã reduc mãrimea dicþionarelor la
aproximativ 50-55%.

<P>
Restul fiºierelor de configurare a afixelor este ocupat cu regulile
prin care afixele se ataºeazã cuvintelor.  <TT>ispell</TT> ºtie sã
opereze mici modificãri asupra rãdãcinilor; asta creºte enorm
utilitatea afixelor.  Iatã un fragment tipic dintr-o descriere a unui
``flag'' din <TT>rom.signs.aff</TT>:

<P>
<PRE>
suffixes

flag *I:
    U           &gt;       LUI             # bou  &gt; boului
    [^UA]       &gt;       ULUI            # porc &gt; porcului
    [GC] A      &gt;       -A,II           # vaca &gt; vacii
    [^CG] A     &gt;       -A,EI           # baba &gt; babei
</PRE>

<P>
Traducere: indicatorul I va funcþiona în 4 feluri, depinzînd de forma
rãdãcinii cuvîntului la care se aplicã:

<P>

<OL>
<LI>Dacã rãdãcina se terminã în ``U'', atunci indicatorul I va
cauza concatenarea ºirului ``lui''.  De exemplu, în dicþionar
cuvîntul ``bou/I'' va genera simultan ``bou'' ºi ``boului'';

<P>
</LI>
<LI>Dacã rãdãcina <EM>nu</EM> (negaþia este indicatã de semnul 
<code>^</code>) se terminã în ``U'' sau ``A'', atunci adaug ºirul ``ului'';

<P>
</LI>
<LI>Dacã rãdãcina se terminã în ``ga'' sau ``ca'', atunci
regula va ºterge ``A''-ul de la coadã ºi va concatena un ``ii'';

<P>
</LI>
<LI>În fine, dacã rãdãcina se terminã în ``a'', dar nu în 
``ca'' sau ``ga'', atunci ºterg ``A''-ul ºi adaug ``ei''.
</LI>
</OL>

<P>
Observaþi cã aceste reguli nu sunt folosite pentru a <EM>genera</EM>
noi cuvinte din cele existente, ci doar pentru a comprima un set de
cuvinte dat, deci nu pot greºi dacã avem de-a face cu o excepþie
(de exemplu cuvîntul ``poarta'', care dupã regulile de mai sus ar
deveni ``poartei'').  Singura consecinþã este cã ambele cuvinte 
vor apãrea în dicþionar, pentru cã nu se poate aplica compresia 
(voi avea ºi ``poarta'' ºi ``porþii'' în dicþionar).

<P>

<H2><A NAME="SECTION00044000000000000000">
Interfaþa cu emacs</A>
</H2>

<P>
<TT>ispell</TT> este prin construcþie un program interactiv: analizeazã
textul, ºi la prima eroare scrie pe ecran porþiunea de text
suspicioasã, indicînd posibile corecturi, ºi aºteptînd ca
utilizatorul sã ia mãsuri.

<P>
Dl. Kuenning însã a fost suficient de înþelept pentru a înzestra
<TT>ispell</TT> cu un mod de funcþionare ``batch'': ne-interactiv.
Dacã <TT>ispell</TT> este pornit cu modificatorul <TT>-a</TT> atunci nu mai
scrie nimic pe ecran ºi nu mai citeºte tastatura, ci scrie ºi
citeºte de la intrarea ºi ieºirea sa standard.  Practic de la
intrare <TT>ispell</TT> citeºte un cuvînt, iar la ieºire trimite
ºiruri de caractere care descriu pãrerea lui despre acel cuvînt (dacã
e corect, dacã nu ce variante sunt, etc).  De exemplu, (de data asta
în englezã):

<P>
<PRE>
$ echo helo | ispell -a 
@(#) International Ispell Version 3.1.20 10/10/95
&amp; helo 9 0: halo, held, hell, hello, helm, help, hero, he lo, he-lo
$
</PRE>

<P>
Convenþiile prin care <TT>ispell</TT> rãspunde sunt uºor complicate;
pe scurt, în linia de mai sus a spus cã nu crede cã acel cuvînt e
corect, (prin semnul &amp;), ºi a indicat apoi 9 posibilitãþi corecte,
separate prin virgule.

<P>
Aceasta este o altã instanþã a faimoasei separaþii dintre
politicã ºi mecanism: mecanismul de corectare nu implementeazã ºi
politica de interacþiune.

<P>
Asta permite interfaþarea altor programe cu <TT>ispell</TT>.  De exemplu
editorul de texte Emacs ºtie sã converseze cu <TT>ispell</TT>,
bagîndu-i pe gît (intrarea standard) cuvintele dintr-un buffer unul
cîte unul. În funcþie de rãspuns discutã el însuºi cu utilizatorul,
pentru a înlocui cuvintele greºite.

<P>

<H2><A NAME="SECTION00045000000000000000">
Fiºierul de stil pentru L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</A>
</H2>

<P>
Pentru cã îmi tehnoredactez fiºierele în L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X, era natural sã
caut o metodã de a folosi convenþia de scriere cu apostroafe direct
în L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X.  Nu a fost prea dificil, pentru cã am dat peste un
fiºier de stil construit de Alexandru ºi Dan Corlan pe care mi l-am
însuºit, ºi în care am operat niºte minuscule
modificãri.  Fiºierul pune la-ndemînã un nou ``environment'', numit
<TT>romana</TT>, în interiorul cãruia semnul apostrof ºi respectiv
ghilimelele produc diacritice.  Practic pot scrie acum texte astfel:

<P>

<P></P>
<DIV ALIGN="CENTER">
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=179><TABLE  WIDTH="277">
<TR><TD>
<PRE>
\documentstyle[romana-]{article}
\begin{document}
'In aceast'a parte apostroful
nu are nici o influen't'a.
\begin{romana}
Dar 'in aceast'a parte se 
transform'a 'in diacritice.
\end{romana}
\end{document}
</PRE></TD></TR>
</TABLE></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><P>
ºi voi genera urmãtorul document:

<P></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=179><TABLE  WIDTH="277">
<TR><TD>
'In aceast'a parte apostroful nu are nici o influen't'a.

<P>
Dar în aceastã parte se transformã în diacritice.

<P>
</TD></TR>
</TABLE></TD>
</TR>
</TABLE>
</DIV>
</DIV>
<P></P>

<P>
Fiºierul de stil ar putea beneficia de mici îmbunãtãþiri, pentru
cã anumite combinaþii se comportã ciudat (de exemplu nu se mai pot
scrie acolade dupã ghilimele), dar este mai adesea util decît
dãunãtor.

<P>

<H2><A NAME="SECTION00046000000000000000">
Interfaþa corectorului de limba românã cu utilizatorul</A>
</H2>

<P>

<H3><A NAME="SECTION00046100000000000000">
Instalare</A>
</H3>

<P>
Pentru a putea folosi <TT>corect</TT>, trebuie întîi sa aveþi pachetul
cu <TT>ispell</TT>.  Necesare sunt fiºierele <TT>buildhash</TT> ºi
<TT>ispell</TT>; de celelalte vã puteþi lipsi.  Dacã aveþi un sistem
Unix, le puteþi lua de la <a
href="ftp://prep.ai.mit.edu/pub/gnu">ftp://prep.ai.mit.edu/pub/gnu</a></TT>.

<P>
Pagina lui <TT>ispell</TT> este la <a href="http://fmg-www.cs.ucla.edu/fmg-members/geoff/ispell.html">http://fmg-www.cs.ucla.edu/fmg-members/geoff/ispell.html</a>; acolo mai
puteþi afla o grãmadã de lucruri utile despre acest program.

<P>
Cel care instaleazã pachetul de fiºiere are o misiune relativ
simplã: trebuie sã decidã locul unde fiºierele se vor plasa ºi
cum ajung utilizatorii la ele.  Existã douã variante de bazã:

<P>

<OL>
<LI>Instalarea este fãcutã pentru întregul sistem (de
administrator, în aºa fel încît toþi utilizatorii sã poatã
beneficia);
</LI>
<LI>Un utilizator fãrã privilegii îºi instaleazã pachetul
pentru uzul personal în contul lui.
</LI>
</OL>

<P>
Cel care instaleazã va trebui sã citeascã <TT>Makefile</TT>-ul ºi sã
modifice cîteva variabile.  Valorile care ar fi interesante sunt <TT>ROMSPELLBASE</TT> ºi <TT>LATEXDIR</TT>, ºi indicã unde se vor plasa
dicþionarele, respectiv fiºierul de stil pentru L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X.

<P>
Pentru ca utilizatorii sã poatã accesa fiºierul de stil, el trebuie
sã fie într-un loc în care L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>Xsã-l poatã cãuta.
Administratorul îl poate pune acolo unde sistemul local are toate
celelalte fiºiere de stil.  Un utilizator obiºnuit îl poate pune
oriunde, ºi apoi poate indica lui L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>Xacel loc folosind variabila
<TT>TEXINPUT</TT>.  De exemplu, eu mi-am pus fiºierul <TT>romana-.sty</TT>
în <TT>$HOME/data/tex</TT> ºi am pus variabila astfel: 

<P>
<PRE>
export TEXINPUTS=".:$HOME/data/tex:"
</PRE>

<P>
În plus, pentru ca Emacs sã poatã invoca <TT>ispell</TT> pentru a
corecta texte româneºti, fiºierul <TT>for-emacs</TT>, care este
generat automat, ar trebui executat de Emacs-ul tuturor utilizatorilor
care scriu în românã.  Iarãºi, existã douã variante: fiecare
utilizator poate concatena acest fiºier la propriul fiºier de
iniþializare <TT>.emacs</TT>, sau acest fiºier poate fi pus de
administrator într-un fiºier global de iniþializare al lui Emacs
(de exemplu <TT>site-start.el</TT>).

<P>

<H3><A NAME="SECTION00046200000000000000">
Utilizare</A>
</H3>

<P>
Dupã ce administratorul a fãcut treburile murdare de instalare,
folosirea corectorului ar trebui sã fie banalã.  Datoritã unui mic
script, tot ce trebuie fãcut pentru a corecta un text este de a tasta:

<P>
<PRE>
corect fisier-de-corectat
</PRE>

<P>
Simplu ca bunã ziua!

<P>
(Dacã fiºierul este scris în românã cu diacritice, tastaþi <TT>corect -s fisier</TT>.)

<P>
Pentru a corecta din Emacs folosiþi comenzile Emacs:

<P>
<PRE>
M-x ispell-change-dictionary
</PRE>

<P>
La întrebarea care urmeazã, rãspundeþi <TT>romana</TT>, respectiv <TT>rom-diacritice</TT>, dupã cum doriþi.  Apoi tastaþi:

<P>
<PRE>
M-x ispell-buffer
</PRE>

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot69">... unelte</A><A NAME="foot69"
 HREF="rom-spell-html.html#tex2html1"><SUP>1</SUP></A>
<DD>
Prin antitezã cu programele care fac ceva util ele însele: aplicaþiile.

<DT><A NAME="foot101">...
cm</A><A NAME="foot101"
 HREF="rom-spell-html.html#tex2html2"><SUP>2</SUP></A>
<DD>grosime.

<DT><A NAME="foot110">...<TT>ispell</TT></A><A NAME="foot110"
 HREF="rom-spell-html.html#tex2html3"><SUP>3</SUP></A>
<DD>Ca dovadã cã principiile enumerate mai sus au fost bune,
iniþial alesem semnul \ pentru diacritic; schimbarea la
apostrof a fost însã foarte simplã, ºi a fost cauzatã de dorinþa
de a inter-opera cu L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X
 pentru care semnul \ are o semnificaþie specialã.

</DL>
<BR><HR>

</BODY>
</HTML>
