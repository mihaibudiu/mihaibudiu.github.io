<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Problema satisfiabilitãþii</TITLE>
<META NAME="description" CONTENT="Problema satisfiabilitãþii">
<META NAME="keywords" CONTENT="sat-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Problema satisfiabilitãþii</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>18 august 1999</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>problema satisfiabilitãþii boolene, aplicaþiile ei
ºi soluþii practice
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare despre
funcþionarea calculatoarelor; funcþii boolene
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>boolean, satisfiabilitate, clasele P ºi NP,
algoritm, verificare a soluþiei
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html51"
  HREF="sat-html.html">Probleme, instanþe ºi algoritmi</A>
<LI><A NAME="tex2html52"
  HREF="#SECTION00030000000000000000">Problema satisfiabilitãþii boolene</A>
<UL>
<LI><A NAME="tex2html53"
  HREF="#SECTION00031000000000000000">Funcþii boolene</A>
<LI><A NAME="tex2html54"
  HREF="#SECTION00032000000000000000">SAT</A>
</UL>
<BR>
<LI><A NAME="tex2html55"
  HREF="#SECTION00040000000000000000">Reduceri între probleme</A>
<UL>
<LI><A NAME="tex2html56"
  HREF="#SECTION00041000000000000000">O reducere</A>
<LI><A NAME="tex2html57"
  HREF="#SECTION00042000000000000000">Probleme reductibile la SAT</A>
</UL>
<BR>
<LI><A NAME="tex2html58"
  HREF="#SECTION00050000000000000000">Complexitatea algoritmilor ºi a problemelor; clasele P ºi NP</A>
<UL>
<LI><A NAME="tex2html59"
  HREF="#SECTION00051000000000000000">O soluþie simplã</A>
<LI><A NAME="tex2html60"
  HREF="#SECTION00052000000000000000">Complexitatea unui algoritm</A>
<LI><A NAME="tex2html61"
  HREF="#SECTION00053000000000000000">Complexitatea unei probleme</A>
</UL>
<BR>
<LI><A NAME="tex2html62"
  HREF="#SECTION00060000000000000000">NP</A>
<UL>
<LI><A NAME="tex2html63"
  HREF="#SECTION00061000000000000000">Teorema lui Cook</A>
</UL>
<BR>
<LI><A NAME="tex2html64"
  HREF="#SECTION00070000000000000000">Va urma</A>
<LI><A NAME="tex2html65"
  HREF="#SECTION00080000000000000000">Recapitulare</A>
<UL>
<LI><A NAME="tex2html66"
  HREF="#SECTION00081000000000000000">Satisfiabilitate</A>
<LI><A NAME="tex2html67"
  HREF="#SECTION00082000000000000000">Importanþa practicã; NP</A>
</UL>
<BR>
<LI><A NAME="tex2html68"
  HREF="#SECTION00090000000000000000">Alte clase de complexitate</A>
<LI><A NAME="tex2html69"
  HREF="#SECTION000100000000000000000">Auto-reducere</A>
<LI><A NAME="tex2html70"
  HREF="#SECTION000110000000000000000">Despre creativitate</A>
<UL>
<LI><A NAME="tex2html71"
  HREF="#SECTION000111000000000000000">Matematica trivialã</A>
<LI><A NAME="tex2html72"
  HREF="#SECTION000112000000000000000">Criptografia inexistentã</A>
</UL>
<BR>
<LI><A NAME="tex2html73"
  HREF="#SECTION000120000000000000000">Densitatea soluþiilor ºi dificultatea problemelor</A>
<UL>
<LI><A NAME="tex2html74"
  HREF="#SECTION000121000000000000000">Criptografia ºi NP-completitudinea</A>
<LI><A NAME="tex2html75"
  HREF="#SECTION000122000000000000000">CNF-SAT ºi k-CNF-SAT</A>
<LI><A NAME="tex2html76"
  HREF="#SECTION000123000000000000000">Tranziþii de fazã</A>
</UL>
<BR>
<LI><A NAME="tex2html77"
  HREF="#SECTION000130000000000000000">Soluþii practice pentru SAT</A>
<UL>
<LI><A NAME="tex2html78"
  HREF="#SECTION000131000000000000000">Algoritmul Putnam-Davis</A>
<LI><A NAME="tex2html79"
  HREF="#SECTION000132000000000000000">Algoritmul Walk-SAT</A>
</UL>
<BR>
<LI><A NAME="tex2html80"
  HREF="#SECTION000140000000000000000">Încheiere</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Articolul de faþã atacã o problemã foarte importantã în
informaticã, din mai multe puncte de vedere (din mai multe puncte de
vedere este atît importanþa cît ºi atacul meu).  Problema aceasta
este extrem de importantã pentru practicieni, pentru cã apare în
extrem de multe contexte în viaþa ``realã'', sau foarte multe alte
probleme reale se pot reduce la ea (definim precis noþiunea de
``reducere'' undeva mai jos).

<P>
Problema este însã ºi mai importantã pentru teoreticieni, din mai
multe motive.  În primul rînd, nu se cunoaºte nici o soluþie
eficace pentru aceastã problemã, în cazul ei cel mai general.
Toate metodele de calcul sunt extrem de costisitoare, fãcînd
imposibilã rezolvarea unor instanþe de dimensiuni mari.  Pe de altã
parte, complexitatea algoritmilor cunoscuþi îndepãrteazã speranþa
cã vreodatã vom avea suficiente resurse pentru a rezolva instanþe
mari ale acestei probleme; chiar creºteri ale performanþei
calculatoarelor de milioane de ori ar permite creºterea numãrului de
variabile din cu doar cîteva zeci de unitãþi (iar problemele
practice pot avea zeci de mii de variabile).

<P>
În fine, mult mai interesant, problema aceasta este într-un anume
sens ``cea mai grea problemã din clasa ei de probleme''.  Sunt extrem
de multe alte probleme practice care sunt echivalente, sau mai
uºoare, decît aceastã problemã.  Teoreticienii au demonstrat cã
dacã, putem soluþiona problema de faþã în mod eficient, atunci
toate celelalte probleme echivalente sau mai uºoare se pot rezolva
extrem de eficient, în mod imediat.  O consecinþã surprinzãtoare a
acestui fapt ar fi cã criptografia ar fi inexistentã, pentru cã
<EM>orice metodã de criptare ar putea fi spartã în mod eficient</EM>.

<P>
În fine, problema aceasta are implicaþii interesante pentru
filozofie, pentru cã, într-un anume sens, ne ajutã sã mãsurãm
diferenþa dintre geniu ºi normalitate, dintre creativitate ºi
simpla înþelegere pasivã.  Existenþa unei soluþii eficace pentru
aceastã problemã ar avea de pildã consecinþa surprinzãtoare cã
pentru fiecare teoremã din matematicã existã o metodã foarte
eficace de a o demonstra cu calculatorul; asta ar transforma întreaga
muncã de creaþie a matematicienilor într-o treabã de rutinã, pe
care o poate face o maºinã de calcul.

<P>
Problema aceasta este piatra de temelie a unei ramuri a informaticii
numitã ``teoria complexitãþii'', cãreia intenþionez sã-i
consacru în viitor un întreg articol.  Existenþa unei soluþii
eficace pentru problema din acest articol este consideratã aproape
unanim <EM>cea mai importantã problemã nerezolvatã din ºtiinþa
calculatoarelor</EM>.

<P>
ªi acum, cã v-am trezit curiozitatea, sã purcedem sã vedem cum se
înlãnþuie toate aceste fapte.

<P>

<H1><A NAME="SECTION00020000000000000000">
Probleme, instanþe ºi algoritmi</A>
</H1>

<P>
Trebuie dintru început sã facem distincþie dintre o <EM>clasã de
probleme</EM> ºi <EM>instanþele problemei</EM>.  O clasã de probleme este
o colecþie de instanþe înrudite.

<P>
În general, un program pentru calculator (un algoritm) rezolvã orice
instanþã dintr-o clasã.  De exemplu, în procesorul Pentium se
aflã o unitate aritmeticã folositã pentru a efectua adunãri.
Aceastã unitate aritmeticã rezolvã urmãtoarea clasã de probleme:
``care este rezultatul adunãrii a douã numere mai scurte de 32 de
biþi?''  O instanþã a acestei probleme este ``cît face 3+7?''.
Observaþi cã unitatea aritmeticã poate rezolva <EM>orice</EM>
instanþã.  Nu ar fi foarte folositor dacã ar putea rezolva numai
întrebarea ``cît e 3+7?''.

<P>
În general nu avem nevoie sã rezolvãm chiar <EM>toate</EM>
instanþele, dar pentru cã e prea complicat sã construim maºini
speciale pentru fiecare instanþã (ºi nu prea practic), facem
maºini care rezolvã clase întregi de probleme (adicã pot rezolva
orice instanþã).

<P>
Observaþi cã clasa de probleme: ``fiind dat un numãr n, care este
rezultatul adunãrii a oricare douã numere de n biþi'' este o
clasã mai largã decît cea rezolvatã de Pentium, pentru care
n=32.  Putem scrie un program care sã calculeze în principiu suma
oricãror douã numere, oricît de lungi ar fi ele.  Cum aratã
programul, am învãþat cu toþii în ºcoala primarã, folosind
tabla adunãrii.  Folosind aceastã tablã putem aduna numere oricît
de lungi (dacã nu obosim).

<P>
În general, teoreticienii studiazã astfel de clase de probleme, în
care ``dimensiunea'' datelor de intrare nu este limitatã apriori de
nici o valoare.  Ei sunt interesaþi sã afle dacã putem scrie
programe care sã funcþioneze ºi atunci cînd nu se cunoaºte
aceastã dimensiune dinainte.

<P>
Este de altfel o idee foarte bunã ca algoritmii pe care îi
implementaþi sã fie proiectaþi în aºa fel încît sã poatã
trata probleme oricît de mari.  Orice limitare arbitrarã impusã
datelor de intrare se poate dovedi extrem de neplãcutã mai tîrziu;
în definitiv din asta a ºi provenit celebrul bug Y2K: programatorii
nu au permis programelor sã manipuleze decît date într-un interval
de 100 de ani, ceea ce are consecinþe economice uriaºe la ora
actualã (companiile cheltuiesc acum zeci de miliarde de dolari sã
descopere ºi corecteze astfel de imperfecþiuni).

<P>
Definim un algoritm astfel: o procedurã de calcul efectiv, care
rezolvã orice instanþã dintr-o anumitã clasã de probleme.  Nu
uitaþi cã întotdeauna algoritmul este legat de clasã; pentru clase
diferite putem avea algoritmi diferiþi, chiar dacã clasele sunt
înrudite.  De exemplu, pentru clasa de probleme: ``care este suma a
douã numere mai mici ca 100?'' putem face un algoritm foarte simplu,
care pre-calculeazã toate sumele posibile, dupã care cautã
rezultatul într-o tabelã bidimensionalã de 100*100 de numere.
Desigur, algoritmul risipeºte o mulþime de spaþiu, dar rãspunde
practic instantaneu.  Este clar cã acest algoritm nu se poate
generaliza pentru a face orice adunare, în care lungimea numerelor nu
este limitatã dinainte.

<P>

<H1><A NAME="SECTION00030000000000000000">
Problema satisfiabilitãþii boolene</A>
</H1>

<P>
Voi introduce acum clasa de probleme care constituie subiectul
principal al acestui articol.  Pentru început însã voi trece în
revistã rapid funcþiile boolene, pentru cã problema noastrã este
legatã de ele.

<P>

<H2><A NAME="SECTION00031000000000000000">
Funcþii boolene</A>
</H2>

<P>
Georges Boole a trãit între 1815 ºi 1864.  În istoria ºtiinþei
el este cunoscut mai ales prin rezultatele sale matematice, ca creator
al algebrei boolene (numitã, evident, în cinstea sa).  Aceasta este
o algebrã extrem de simplã, care opereazã cu numai douã valori, 0
ºi 1.

<P>
Dar Boole este extrem de important ºi în istoria filozofiei, pentru
cã algebra lui a fost creatã în încercarea de a formaliza în
limbajul matematicii logica aristotelicã clasicã.  Georges Boole
este considerat de unii pãrintele logicii matematice.  Boole era
interesat sã reformuleze legile gîndirii umane în termeni
matematici.  

<P>
Algebra booleanã opereazã cu valori de adevãr, din care avem numai
douã: adevãrat ºi fals.  Orice variabilã are la un moment dat
exact una dintre aceste douã valori.  0 este folosit pentru a denota
falsul, iar 1 pentru adevãrat.

<P>
Boole a introdus anumite operaþii pentru manipularea valorilor
boolene: operaþiile de ``ºi'' logic (<IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$\land$">), ``sau'' logic
(<IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="$\lor$">) ºi negaþie logicã (<IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="$\lnot$">).  (Putem introduce ºi alte
operaþii, dar acestea sunt cele mai importante.)

<P>
Putem combina valori boolene folosind aceste operaþii, ºi putem
calcula valoarea de adevãr a unor propoziþii complicate într-un mod
foarte limpede.

<P>
De exemplu, dacã avem douã propoziþii logice oarecare, a ºi b,
putem vorbi de propoziþia <IMG
 WIDTH="42" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="$a \land b$"> (a ºi b), care este
adevãratã numai cînd ambele propoziþii sunt adevãrate.  Modul de
operare al lui <IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$\land$"> poate astfel fi descris în acelaºi fel ca cel
al operaþiilor aritmetice obiºnuite, cu o tabelã (cum e tabla
adunãrii), aºa cum aratã figura&nbsp;<A HREF="#operatii">1</A>.

<P>
De exemplu, dacã avem propoziþiile ``Afarã plouã'' ºi ``E ora
7'', propoziþia formatã din <EM>conjuncþia</EM> acestora (adicã
legarea celor douã cu ``ºi'') este ``E ora 7 ºi afarã plouã''.
În mod evident, aceastã propoziþie este adevãratã doar dacã
ambele enunþuri mai simple sunt adevãrate, justificînd tabela
operaþiei ``ºi''.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="211"></A>
<TABLE>
<CAPTION><STRONG>Tabela 1:</STRONG>
Tabelele operaþiilor logice fundamentale. </CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3>
<TR><TD ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=3>Operaþia ``ºi''</TD>
</TR>
<TR><TD ALIGN="RIGHT"><IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$\land$"></TD>
<TD ALIGN="RIGHT">0</TD>
<TD ALIGN="RIGHT">1</TD>
</TR>
<TR><TD ALIGN="RIGHT">0</TD>
<TD ALIGN="RIGHT">0</TD>
<TD ALIGN="RIGHT">0</TD>
</TR>
<TR><TD ALIGN="RIGHT">1</TD>
<TD ALIGN="RIGHT">0</TD>
<TD ALIGN="RIGHT">1</TD>
</TR>
</TABLE></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=3>Operaþia ``sau''</TD>
</TR>
<TR><TD ALIGN="RIGHT"><IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="$\lor$"></TD>
<TD ALIGN="RIGHT">0</TD>
<TD ALIGN="RIGHT">1</TD>
</TR>
<TR><TD ALIGN="RIGHT">0</TD>
<TD ALIGN="RIGHT">0</TD>
<TD ALIGN="RIGHT">1</TD>
</TR>
<TR><TD ALIGN="RIGHT">1</TD>
<TD ALIGN="RIGHT">1</TD>
<TD ALIGN="RIGHT">1</TD>
</TR>
</TABLE></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=3>Operaþia ``nu''</TD>
</TR>
<TR><TD ALIGN="RIGHT"><IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="$\lnot$"></TD>
<TD ALIGN="RIGHT">0</TD>
<TD ALIGN="RIGHT">1</TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="RIGHT">1</TD>
<TD ALIGN="RIGHT">0</TD>
</TR>
</TABLE></TD>
</TR>
</TABLE>
</DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
O altã operaþie logicã este cea numitã ``sau'': rezultatul este
adevãrat dacã mãcar una dintre valorile combinate este
adevãratã<A NAME="tex2html4"
  HREF="#foot91"><SUP>1</SUP></A>.

<P>
În fine, avem operaþia de negare (``nu''), care inverseazã valoarea
de adevãr a unei propoziþii<A NAME="tex2html5"
  HREF="#foot92"><SUP>2</SUP></A>.

<P>
Operaþiile boolene sunt asociative ºi comutative.  Putem astfel
scrie prescurtat formule boolene complicate, de genul: 

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
(a \land b \land c) \lor (\lnot b \land c) \lor \lnot a.
\end{displaymath}
 -->

<IMG
 WIDTH="198" HEIGHT="34" BORDER="0"
 SRC="img11.png"
 ALT="\begin{displaymath}(a \land b \land c) \lor (\lnot b \land c) \lor \lnot a.\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
Algebra booleanã este enorm de importantã în calculatoare;
componentele electronice de bazã din care este construit un
calculator sunt ``porþile logice'', care implementeazã exact aceste
operaþii, manipulînd curenþi electrici pentru a reprezenta valori
boolene (anumite potenþiale fiind alese în mod convenþional pentru
a reprezenta valorile 0 ºi 1).  Altfel de dispozitive sunt foarte
uºor de construit din tranzistoare, care apoi se pot construi la o
scara minusculã, înghesuind milioane pe o pilulã de siliciu.

<P>

<H2><A NAME="SECTION00032000000000000000">
SAT</A>
</H2>

<P>
Dacã ni se dã o formulã booleanã ºi o serie de valori pentru
variabilele care o compun, putem scrie un algoritm foarte simplu ºi
eficient care evalueazã formula.  Acesta este chiar algoritmul
bine-cunoscut folosit pentru evaluarea expresiilor aritmetice, cu
diferenþa cã opereazã doar cu valori boolene.

<P>
Acum suntem în mãsurã sã formulãm problema care ne intereseazã,
numitã problema <EM>satisfiabilitãþii</EM>, (<EM>satisfiability</EM>), pe
scurt SAT: ``fiind datã o formulã booleanã, existã o atribuire a
variabilelor care o compun care face formula adevãratã?''.

<P>

<H1><A NAME="SECTION00040000000000000000">
Reduceri între probleme</A>
</H1>

<P>
Îmi aduc aminte de un banc: ``Cicã un inginer ºi un matematician
dimineaþa îºi fãceau ceaiul, aplicînd urmãtorul algoritm: &lt;&lt;Ia
ibricul, umple-l cu apa, pune-l pe foc, fierbe apa, pune plicul,
toarnã în canã&gt;&gt;.  Dar într-o zi, nevestele lor le lasã ibricul
cu apã înauntru.  Ce fac cei doi?  Ei bine, inginerul aplicã
algoritmul de la al doilea pas: pune-l pe foc, fierbe apa, pune
plicul, toarnã în canã.  În schimb matematicianul varsã apa în
chiuvetã ºi reduce problema la cea precedentã.''

<P>
Bancul este amuzant (gãsesc eu), dar conceptul de reducere este cu
adevãrat util.  Cel puþin în calculatoare, are extrem de multe
aplicaþii.  Aici ne vom uita la doar una dintre ele.

<P>
Adesea putem abstractiza o problemã ºi o putem enunþa într-un alt
fel; de fapt, chiar pentru a rezolva probleme practice, în general le
abstractizãm în termeni matematici, dupã care aplicãm tehnici din
domeniul matematicii.

<P>
Figura&nbsp;<A HREF="sat-html.html#reducere">1</A> ilustreazã noþiunea de reducere pentru
probleme în teoria complexitãþii.

<P>
Ei bine, se întîmplã cã problema SAT este o problemã extrem de
<EM>expresivã</EM>; putem enunþa o mulþime de alte probleme sub forma
SAT.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="reducere"></A><A NAME="221"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
O reducere între problema P1 ºi problema P2
transformã fiecare instanþã a unei probleme din P1 într-o
problemã din P2.  Nu orice instanþã din P2 este neapãrat
rezultatul transformãrii unei instanþe din P1 (partea nehaºuratã
în figurã).  Reducerea este deci o funcþie nu neapãrat
surjectivã.  Reducerea pãstreazã proprietatea cã fiecare
instanþã din P1 pentru care soluþia este ``da'' este transformatã
într-o instanþã din problema P2 pentru care soluþia este tot
``da'' ºi invers (adicã instanþele ``nu'' devin rãmîn ``nu''
dupã transformare).</CAPTION>
<TR><TD><IMG
 WIDTH="268" HEIGHT="181" BORDER="0"
 SRC="img14.png"
 ALT="\begin{figure}\centerline{\epsfxsize=6cm\epsffile{reducere.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00041000000000000000">
O reducere</A>
</H2>

<P>
Voi ilustra aici aici o reducere foarte simplã, între o problemã
numitã ``colorarea unei hãrþi cu douã culori'' ºi SAT.

<P>
Sã presupunem cã avem o hartã pe care vrem sã o colorãm în aºa
fel încît oricare douã þãri alãturate sã aibã culori
diferite.  

<P>
Asociem fiecãrei þãri o variabilã booleanã.  Apoi pentru fiecare
vecinãtate dintre douã þãri creãm o clauzã<A NAME="tex2html7"
  HREF="#foot104"><SUP>3</SUP></A>:
dacã þara A este vecinã cu þara B, atunci creãm clauza <!-- MATH
 $A \land
\lnot B$
 -->
<IMG
 WIDTH="64" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img15.png"
 ALT="$A \land
\lnot B$">.  Vom folosi valoarea 0 pentru a denota o culoare, ºi
valoarea 1 pentru cealaltã.  Formula de mai sus spune cã þãrile
A ºi B nu pot avea aceeaºi culoare simultan, pentru cã dacã
variabilele A ºi B au aceeaºi valoare, atunci clauza de mai sus
va fi falsã.

<P>
Formula booleanã pe care vrem s-o satisfacem este conjuncþia tuturor
acestor clauze.

<P>
Dacã formula este satisfiabilã, culorile þãrilor corespund
valorilor variabilelor boolene respective.  Dacã formula nu este
satisfiabilã, atunci nici problema originalã nu are soluþie.

<P>
Deci dacã rezolvãm problema satisfiabilitãþii, atunci putem
rezolva ºi problema colorãrii unei hãrþi cu douã culori.  Aceasta
este deci o reducere de la una la cealaltã.

<P>

<H2><A NAME="SECTION00042000000000000000">
Probleme reductibile la SAT</A>
</H2>

<P>
Iatã niºte exemple de probleme cu însemnãtate foarte mare pentru
activitatea umanã, care se pot reduce la SAT cu uºurinþã:

<P>

<UL>
<LI>Dacã avem o hartã ºi niºte oraºe, existã un drum care
trece prin fiecare oraº o singurã datã? (aceasta se numeºte
problema ciclului hamiltonian);

<P>
</LI>
<LI>Dacã avem o întreprindere ºi niºte maºini unelte,
împreunã cu o listã de activitãþi de fãcut, fiecare activitate
avînd nevoie de unele dintre maºini pentru un oarecare timp, care
este modul cel mai eficace în care trebuie sã planificãm
activitãþile?  (aceasta este problema planificãrii (scheduling),
care are foarte multe variante; ea are aplicaþii enorme, de la
fabrici, pînã la planificarea executãrii unor procese de cãtre
sistemul de operare al unui calculator);

<P>
</LI>
<LI>Dacã avem un rucsac ºi niºte obiecte de diferite greutãþi
ºi valori, care obiecte trebuie alese pentru a cãra în rucsac
valoarea maximã fãrã a rupe rucsacul (numitã problema rucsacului);

<P>
</LI>
<LI>Dacã avem un circuit imprimat pe care am aºezat tranzistoare
pe care vrem sã le legãm cu sîrme, care este modul cel mai eficace
în care o putem face?

<P>
</LI>
<LI>Dacã avem un compilator care genereazã cod pentru un program,
care este modul în care folosim cel mai eficient regiºtrii
microprocesorului?
</LI>
</UL>

<P>
ªi lista ar putea continua cu multe alte probleme.

<P>
Vedeþi, faptul cã aceste probleme sunt toate reductibile la SAT ne
spune douã lucruri:

<P>

<OL>
<LI>Dacã rezolvãm SAT<A NAME="tex2html8"
  HREF="#foot109"><SUP>4</SUP></A>, am rezolvat imediat toate aceste probleme
într-un mod foarte eficace;

<P>
</LI>
<LI>Dacã nu putem rezolva SAT, nu e neapãrat ca aceste probleme
sã nu aibã o soluþie eficace.
</LI>
</OL>

<P>
Din pãcate, vom vedea puþin mai jos cã speranþele noastre de a
rezolva aceste probleme sunt foarte reduse.

<P>

<H1><A NAME="SECTION00050000000000000000">
Complexitatea algoritmilor ºi a problemelor; clasele P ºi NP</A>
</H1>

<P>

<H2><A NAME="SECTION00051000000000000000">
O soluþie simplã</A>
</H2>

<P>
Aparent SAT este o problemã banalã, ºi algoritmul pentru a o
rezolva este foarte simplu:

<P>

<OL>
<LI>Parcurgem formula ºi facem o listã cu toate variabilele care apar;

<P>
</LI>
<LI>Dupã aceea punem toate variabilele pe ``0'' ºi evaluãm
formula.  Am vãzut cã asta putem face destul de repede;

<P>
</LI>
<LI>Dacã formula dã ca rezultat ``1'' am terminat rezolvarea, ºi
putem da rãspunsul ``da'';

<P>
</LI>
<LI>Dacã nu, facem prima variabilã 1 ºi o luãm de la pasul 3;

<P>
</LI>
<LI>Mergem tot înainte, încercînd toate combinaþiile posibile de
  valori; (în general, dacã ne uitãm la un contor în baza 2 cu
  atîtea cifre cîte variabile avem, la fiecare pas o variabilã are
  valoarea bitului corespunzãtor din contor.)
</LI>
</OL>

<P>
Într-adevãr, algoritmul de mai sus este corect; dacã existã o
distribuþie de valori pentru care formula este adevãratã, o va
gãsi.  Dacã nu este nici una, atunci va da corect rãspunsul ``nu''
odatã ce a examinat toate posibilitãþile.  Acest algoritm este
corect, dar nu este ºi eficient.  Dacã nu credeþi acest lucru,
atunci încercaþi sã executaþi algoritmul pentru o formulã cu 64
de variabile.

<P>
Din modul în care am expus algoritmul deficienþa este vizibilã:
dacã avem k variabile, atunci trebuie sã incrementãm de la 0 la
valoarea maximã un contor cu k cifre.  Ori acest contor trebuie
incrementat de 2<sup>k</sup> ori.  Pentru 64 de pildã putem aproxima
2<sup>10</sup> = 10<sup>3</sup>, deci 2<sup>64 = 10<sup>18</sup> * 16
= 10<sup>19</sup>. Dacã un calculator executã o instrucþiune la o
nanosecundã (adicã are un ceas de un gigahertz), îi vor trebui
10<sup>19</sup>/10<sup>9</sup> = 10<sup>10</sup> secunde pentru a
efectua doar incrementarea.  Un an are cam 3 * 10<sup>7</sup> secunde,
deci durata calculului ar fi de circa 30 de ani! 
<P>
Dacã asta vi se pare o bagatelã, atunci încercaþi sã rezolvaþi o
problemã doar puþin mai mare, sã zicem cu 70 de variabile (10% mai
mare).  Ei bine, asta o sã dureze de 64 de ori mai mult, adicã 1800
de ani!

<P>
Desigur, timpul acesta de rulare va fi petrecut doar dacã formula pe
care o verificaþi nu este satisfiabilã, pentru cã atunci contorul
trebuie sã treacã prin toate valorile.

<P>

<H2><A NAME="SECTION00052000000000000000">
Complexitatea unui algoritm</A>
</H2>

<P>
Teoria complexitãþii mãsoarã timpul de execuþie al unui algoritm
ca o funcþie de cantitatea de date oferite spre prelucrare.  Dacã
mãsurãm formula SAT de la intrare dupã numãrul de variabile n,
atunci algoritmul de mai sus se poate executa pentru o duratã
proporþionalã cu 2<sup>n</sup>, pentru anumite formule.

<P>
Cea mai ades folositã metodã de mãsurare a complexitãþii unui
algoritm considerã cel mai defavorabil caz posibil.  De exemplu,
printre formulele SAT de lungime 2 exista multe care se pot rezolva
imediat, pentru cã din prima încercare putem spune cã formula este
satisfiabilã (de exemplu formula <!-- MATH
 $a \lor \lnot a$
 -->
<IMG
 WIDTH="55" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.png"
 ALT="$a \lor \lnot a$">).  Dar existã cel
puþin o formulã de lungime 2 pentru care algoritmul trebuie sã
facã toate cele 4 încercãri posibile.  Din cauza aceasta, spunem
cã complexitatea algoritmului de mai sus este de ordinul 2<sup>n</sup>, unde
în mod implicit cu n se noteazã dimensiunea datelor de
intrare<A NAME="tex2html9"  HREF="#foot122"><SUP>5</SUP></A>.

<P>
Vedeþi, am spus cã complexitatea este ``proporþionalã cu'', ºi nu
``exact'' 2<sup>n</sup>.  Aceastã caracterizare este destul de precisã,
însã, pentru cã, indiferent care este coeficientul de
proporþionalitate, (care de altfel depinde de viteza procesorului ºi
de alþi factori), modul în care acest algoritm se comportã pentru
probleme foarte mari este acelaºi: este complet ne-practic.

<P>
Teoria complexitãþii considerã cã orice clasã de probleme pentru
care complexitatea unui algoritm este proporþionalã cu un o funcþie
polinomialã este eficace; prin contrast, atunci cînd complexitatea
este proporþionalã cu o funcþie exponenþialã (ca mai sus),
problema este consideratã nerezolvabilã.

<P>
Pentru ilustraþie, algoritmii cei mai buni care sorteazã în ordine
crescãtoare un ºir de n numere, au un timp de execuþie
proporþional cu n log n, care este o funcþie mai micã decît
polinomul n<sup>2</sup> (pentru cã funcþia logaritmicã creºte mai încet
decît orice polinom).  Problema sortãrii are deci o soluþie
eficace.

<P>

<H2><A NAME="SECTION00053000000000000000">
Complexitatea unei probleme</A>
</H2>

<P>
Deci algoritmul de mai sus pentru SAT nu este prea eficace, cel puþin
dacã avem intenþia de a rezolva probleme foarte mari.  Înseamnã
asta cã problema este practic nerezolvabilã?

<P>
Desigur, nu.  Dacã am face aceastã afirmaþie, ar fi ca ºi cum am
zice cã nu putem ajunge la Ploieºti de la Bucureºti decît dupã 10
zile, pentru cã aºa am ajuns la un moment dat mergînd prin Japonia.

<P>
Faptul cã avem un algoritm lent pentru o problemã nu înseamnã cã
problema este grea.  Poate existã un alt algoritm, care rezolvã
problema mult mai bine!

<P>
Algoritmul de mai sus nu exploateazã în nici un fel înfãþiºarea
formulei.  De pildã, dacã formula conþine urmãtoarele douã
clauze: a ºi <IMG
 WIDTH="27" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.png"
 ALT="$\lnot a$">, putem spune imediat cã formula nu este
satisfiabilã, pentru cã, orice valoare ar avea a, ºi independent
de valorile tuturor celorlalte variabile, rezultatul formulei va fi
tot 0.

<P>
E adevãrat cã putem scrie tot felul de algoritmi mai inteligenþi,
dar pînã la ora actualã nimeni nu a reuºit sã gãseascã un
algoritm eficace pentru SAT, care, pentru orice instanþã a problemei
sã ofere rãspunsul într-un timp mai scurt decît cel exponenþial.

<P>
Mai mult decît atît, sunt dovezi foarte convingãtoare (dar nu ºi o
demonstraþie exactã) cã SAT nu admite o soluþie eficientã.  Poate
sã parã intuitiv clar cã SAT are nevoie de foarte mult timp, dar nu
existã nici demonstraþia inversã, cum cã SAT nu poate fi
rezolvatã rapid.

<P>

<H1><A NAME="SECTION00060000000000000000">
NP</A>
</H1>

<P>
``Ei, ºi ce?''  o sa întrebaþi.  Cine are nevoie de SAT?  Din
pãcate, foarte multã lume.  

<P>
Am vãzut mai sus cã foarte multe probleme se pot reduce la SAT.
Asta înseamnã cã dacã am gãsi o soluþie eficientã pentru SAT,
am putea rezolva eficace ºi aceste probleme practice. 

<P>
Toate problemele de mai sus au o trãsãturã foarte interesantã: nu
ºtie nimeni cum sã le gãseascã o soluþie, dar de îndatã ce
cineva ne-ar da un rãspuns pentru o instanþã, am putea verifica
foarte repede dacã acela este rãspunsul corect.

<P>
Teoria complexitãþii defineºte astfel o mulþime de probleme
numitã NP (de la Nedeterminist-Polinomial, o denumire tradiþionalã,
care are o justificare despre care nu vom discuta acum): clasa NP este
compusã din toate problemele pentru care putem verifica foarte
eficient dacã un anumit rãspuns este o soluþie corectã (eficient
înseamnã, din nou, cã verificarea dureazã un timp polinomial în
mãrimea problemei pe care o avem de rezolvat).  SAT ºi toate
problemele de mai sus fac parte din NP.

<P>
Se defineºte de asemenea clasa tuturor problemelor pentru care ºtim
sã calculãm <EM>rãspunsul exact</EM> într-un timp scurt, polinomial
în lungimea datelor de la intrare.  Aceastã clasã este denumitã
simplu, P<A NAME="tex2html10"
  HREF="#foot212"><SUP>6</SUP></A>.

<P>
De exemplu, problema circuitului hamiltonian este în clasa NP pentru
cã, dacã cineva ne dã o listã de oraºe putem verifica foarte
rapid dacã aceastã listã formeazã sau nu un circuit hamiltonian.
Pentru a face asta verificãm cã fiecare oraº apare o singurã datã
în listã, cã toate oraºele de pe hartã apar, ºi cã între
fiecare douã oraºe consecutive din listã chiar existã un drum
direct.  Prin definiþie deci, aceastã problemã este în clasa NP.
Nimeni nu cunoaºte însã un algoritm eficient pentru a decide dacã
un ciclu hamiltonian existã, deci nu ºtim dacã aceastã problemã
este în clasa P.

<P>
Ei bine, toate problemele din P fac parte ºi din clasa NP.  Asta
pentru cã dacã ni se dã rãspunsul la o problemã din P, pentru a
verifica dacã este corect nu facem decît sã executãm algoritmul
eficace pentru a gãsi soluþia, ºi sã comparãm soluþia oferitã
cu cea calculatã.  Figura&nbsp;<A HREF="sat-html.html#np">2</A> rezumã
starea cunoºtinþelor noastre la ora actualã.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="np"></A><A NAME="227"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
ªtim cã toate problemele din clasa P, care se pot
rezolva în timp polinomial, sunt de asemenea în clasa NP, adicã
existã metode pentru a verifica corectitudinea unei ipotetice
soluþii în timp polinomial.  Pe de alta parte nu se ºtie dacã
existã probleme în NP care nu sunt în P (adicã dacã partea
haºuratã este vidã sau nu).</CAPTION>
<TR><TD><IMG
 WIDTH="271" HEIGHT="168" BORDER="0"
 SRC="img28.png"
 ALT="\begin{figure}\centerline{\epsfxsize=6cm\epsffile{np.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00061000000000000000">
Teorema lui Cook</A>
</H2>

<P>
Ar fi minunat dacã am putea gãsi soluþii eficiente pentru toate
problemele care sunt în NP, mai ales cã multe dintre ele sunt
probleme de o mare importanþã economicã ºi practicã.

<P>
În 1971 Stephen Cook a demonstrat<A NAME="tex2html12"
  HREF="#foot213"><SUP>7</SUP></A> o teoremã celebrã, care aratã cã <EM>orice problemã din NP se reduce la SAT</EM>.  Am vãzut mai sus cã
anumite probleme sunt reductibile la SAT; Cook a arãtat printr-un
argument ingenios cã <EM>orice altã problemã am avea</EM> (chiar cele
ne-formulate încã), dacã putem verifica soluþiile acelei probleme
într-un mod eficace (deci dacã problema este în clasa NP), atunci
problema este reductibilã la SAT.

<P>
Asta înseamnã cã, dacã ni se dã o instanþã a unei probleme
oarecare din NP, putem construi în mod automat o instanþã a unei
probleme SAT.  Construcþia aceasta însãºi se poate face într-un
mod foarte eficace (adicã putem face construcþia în timp
polinomial).  Construcþia garanteazã faptul cã orice soluþie a
problemei SAT construite corespunde unei soluþii a problemei reale.
Astfel, putem acum rezolva problema SAT în locul problemei originale,
ºi apoi putem ``decodifica'' rãspunsul.

<P>
Ce ne spune teorema lui Cook?

<P>
Ne spune în primul rînd cã SAT este problema ``cea mai
importantã'' din clasa NP, pentru cã, dacã o putem rezolva
eficient, putem rezolva toate celelalte probleme din NP.  De fiecare
datã cînd gãsim o problemã în NP, nu avem decît sã facem o
reducere a problemei la SAT, sã rezolvãm problema SAT, ºi apoi sã
convertim înapoi rãspunsul în termenii problemei originare.  Acest
lucru este întotdeauna posibil.

<P>
Pe de altã parte, dificultatea gãsirii rãspunsului la problema
originarã este clar mai micã decît dificultatea rezolvãrii
problemei SAT (avînd un rãspuns la SAT obþinem un rãspuns la
problema originarã, dar nu neapãrat ºi invers).

<P>
Putem deci considera în acest sens SAT ca fiind <EM>cea mai grea
  problemã din NP</EM>.  Din aceste motive, SAT este numitã o problemã
<EM>NP-completã</EM>.  Acesta este un rezultat deosebit de important,
pentru cã ne spune cã mai curînd vom gãsi algoritmi eficienþi
pentru oricare altã problemã din NP decît pentru SAT.  Pentru cã
foarte multe din celelalte probleme sunt încã nerezolvate, nu sunt
prea multe ºanse sã rezolvãm SAT.

<P>
Deci SAT este cea mai grea problemã.  Partea proastã este cã în
decursul vremii oamenii au reuºit sã arate cã existã o sumedenie
de alte probleme din NP care... sunt mai grele ca SAT!

<P>
Pentru a demonstra cã o problemã este ``mai grea'' ca SAT nu trebuie
decît sã facem lucrul invers: sã reducem pe SAT la acea problemã.
Asta ne permite sã codificãm orice instanþã SAT ca pe o instanþã
a acelei probleme, ºi ne permite sã rezolvãm SAT punînd
întrebãri despre instanþe ale celeilalte probleme.

<P>
Dacã o problemã este mai grea decît SAT, din moment ce SAT este
deja cea mai grea problemã, ajungem la concluzia cã acea problemã
este <EM>la fel de grea ca SAT</EM>; dificultatea ambelor probleme este
aceeaºi.  Cele douã probleme sunt practic echivalente.

<P>
Demonstrarea cã o problemã este mai grea decît SAT nu este în
general o treabã uºoarã.  Cu toate acestea, toate problemele
enunþate în lista de mai sus (circuitul hamiltonian, problema
planificãrii, problema rucsacului, etc.), repet, probleme de o
deosebitã importanþã practicã, sunt demonstrate a fi mai grele
decît SAT.

<P>
Toate aceste probleme sunt deci la rîndul lor NP-complete!

<P>

<H1><A NAME="SECTION00070000000000000000">
Va urma</A>
</H1>

<P>
Închei aici prima parte a prezentãrii mele despre SAT; acesta este
partea cea mai tehnicã, deºi evitã orice demonstraþie.  În
realitate teorema lui Cook nu este prea complicatã, ºi în afarã de
noþiunile expuse în acest text nu mai este nevoie de mare lucru
pentru a o înþelege.  Cititorul interesat este trimis de pildã la
cartea lui Papadimitriou ``Computational Complexity'', sau la cartea
lui Weinker &amp; Davis ``Computability, Complexity and Languages''.

<P>
În partea a doua a acestui text (în numãrul viitor) voi discuta
despre alte implicaþii ale problemei SAT, despre interpretarea
filozoficã a clasei NP, despre soluþiile practice euristice care
s-au gãsit pentru a rezolva unele dintre instanþele acestei
probleme, ºi despre niºte proprietãþi statistice interesante ale
densitãþii soluþiilor problemei.

<P>
Mesajul cel mai important al acestui text se aflã însã în partea
de faþã.  Am vãzut în acest text cã între anumite probleme
computaþionale putem face reduceri, astfel încît sã transformãm
soluþiile uneia în soluþiile celeilalte.  Am vãzut de asemenea cã
existã o clasã foarte interesantã de probleme (numitã NP) pentru
care ºtim sã verificãm eficient dacã ceva este o soluþie, dar nu
avem nici o idee despre cum sã gãsim o soluþie.  Am vãzut ºi cã
SAT este o astfel de problemã, ºi cã orice altã problemã din NP
se poate reduce la SAT, fãcînd din SAT o problemã NP-completã.

<P>
Dacã cel puþin un cititor gãseºte aceste fapte demne de interes,
sunt satisfãcut; mai satisfãcut decît probabil SAT va fi vreodatã.

<P>

<H1><A NAME="SECTION00080000000000000000">
Recapitulare</A>
</H1>

<P>
În numãrul anterior din PC Report am consacrat un articol unei
probleme pe care am numit-o cu emfazã ``cea mai importantã problemã
nerezolvatã din informaticã''.  Textul de faþã este o continuare;
cititorii care nu posedã primul episod sunt invitaþi sã obþinã o
copie a textului din pagina mea de web.

<P>

<H2><A NAME="SECTION00081000000000000000">
Satisfiabilitate</A>
</H2>

<P>
Problema de care vorbim se numeºte problema ``satisfiabilitãþii'',
notatã pe scurt cu SAT.  Un enunþ foarte intuitiv, pentru cei cu
oarecare noþiuni despre arhitectura calculatoarelor, este urmãtorul:
``Fie un circuit digital combinaþional (adicã fãrã cicluri),
construit din porþi logice ``sau'', ``ºi'', ``nu'', care are o
singurã valoare la ieºire.  Existã o combinaþie de valori la
intrarea circuitului care cauzeazã ieºirea circuitului sã fie 1?''.

<P>
În textul anterior am formulat aceastã întrebare pentru o formulã
booleanã (o formulã care opereazã cu operatorii algebrei boolene,
introdusã de George Boole); cele douã formulãri sunt echivalente,
deoarece porþile logice ale unui circuit combinaþional corespund
operaþiilor boolene, în aºa fel încît fiecare formulã corespunde
unui circuit ºi invers.

<P>
De fapt gãsirea unui algoritm care sã ofere rãspunsul corect la
aceastã problemã nu este un lucru prea greu; neplãcerea constã în
faptul cã nu se cunoaºte nici un algoritm <EM>eficace</EM>, care sã
fie capabil sã rezolve probleme mari într-un timp scurt.  Toþi
algoritmii cunoscuþi, inclusiv cei prezentaþi ceva mai jos, au
trãsãtura indezirabilã cã existã instanþe ale problemei pentru
care timpul de execuþie este exponenþial în dimensiunea problemei.
Asta înseamnã cã, dacã adãugãm o singurã variabilã în plus,
timpul necesar rezolvãrii se dubleazã.  Este uºor de vãzut cã
acest ritm de creºtere este covîrºitor, ºi cã întreaga
capacitate de calcul a omenirii nu este suficientã pentru a trata
probleme de dimensiuni nu prea mari (zeci de mii de variabile).

<P>

<H2><A NAME="SECTION00082000000000000000">
Importanþa practicã; NP</A>
</H2>

<P>
Existenþa unei soluþii eficace pentru problema satisfiabilitãþii
nu este consideratã cea mai importantã din întreaga informaticã
doar de cãtre niºte teoreticieni amatori de curiozitãþi.
Importanþa practicã a acestei probleme este enormã: foarte foarte
multe probleme practice sunt echivalente ca dificultate cu problema
satisfiabilitãþii.  Michael Garey ºi David Johnson au alcãtuit în
1979 o culegere de probleme, toate echivalente cu SAT: ``Computers and
Intractability: A Guide to the Theory of NP-Completeness'', publicatã
de editura W. H. Freeman.  Între timp lista aceasta a crescut mult;
la ora aceasta cuprinde cîteva mii de exemple.

<P>
Toate aceste probleme au o trãsãturã foarte interesantã în comun:
pentru nici una nu se cunoaºte o soluþie eficientã (adicã un
algoritm eficient care sã rezolve toate instanþele acestor
probleme), dar nici nu existã argumente cã astfel de soluþii nu ar
exista.  Dacã mãcar am ºti cã nu existã soluþii eficiente, poate
am fi mai împãcaþi, chit cã aflarea soluþiei ar putea avea
importanþã economicã de miliarde de dolari.  Dar nu ºtim cã nu
putem, aºa cã suntem nervoºi.

<P>
Mai mult decît atît: dacã noi cãutãm soluþia ºi cineva vine ºi
zice: ``ºtiu rãspunsul: formula ta nu este satisfiabilã''.  Noi îl
putem provoca: ``dovedeºte''.  Ei bine, atunci acel cineva poate
produce o dovadã simplã cã are dreptate ºi cã ºtie într-adevãr
soluþia.  Cu alte cuvinte, pentru aceste probleme existã dovezi
simple ºi uºor de verificat cã ceva este o soluþie<A NAME="tex2html13"
  HREF="#foot145"><SUP>8</SUP></A>.

<P>
Existã o denumire specialã pentru problemele pentru care putem
verifica imediat dacã o pretinsã soluþie este corectã: toate
aceste probleme formeazã aºa numita clasã NP, de la
nedeterminist-polinomial.  SAT este o astfel de problemã, pentru cã
dacã cineva ne aratã intrãrile unui circuit putem imediat vedea
dacã circuitul va obþine un ``1'' la ieºire.  

<P>
În prima parte a acestui articol menþionam cã în 1971 Cook a
demonstrat cã SAT este cea mai grea problemã din clasa NP, în
sensul cã orice altã problemã din NP se reduce la SAT.  Din cauza
asta SAT este numitã o problemã NP-completã, la fel ca toate
celelalte probleme echivalente prezentate în culegerea lui Garey ºi
Johnson.

<P>
Prin contrast, clasa tuturor problemelor pe care le putem rezolva
eficient (care sunt definite ca probleme pentru care cunoaºtem
algoritmi al cãror timp de rulare este proporþional cu o funcþie
polinomialã în dimensiunea problemei) se numeºte P.

<P>

<H1><A NAME="SECTION00090000000000000000">
Alte clase de complexitate</A>
</H1>

<P>
NP nu este nici pe departe clasa problemelor celor mai dificile pe
care le cunoaºtem; existã clase de complexitate mult mai grele, ca
de pildã EXP, clasa problemelor pentru care cu siguranþã nu existã
soluþii ne-exponenþiale ca timp.  Existã chiar clasa problemelor
nedecidabile, pentru care nu existã... nici un fel de
soluþie<A NAME="tex2html14"
  HREF="#foot214"><SUP>9</SUP></A>!

<P>
De fapt teoria complexitãþii demonstreazã existenþa a tot felul de
ierarhii de clase de complexitate ºi studiazã relaþiile dintre
feluritele clase.  Adesea relaþiile sunt de incluziune, aºa cum avem
între P ºi NP: orice problemã P este ºi una NP; uneori însã
relaþiile sunt mai bizare, sau sunt condiþionate de alte relaþii
(ceva de genul: dacã clasa A e diferitã de clasa B, atunci clasa D e
tot una cu clasa C).  Teoria complexitãþii clasificã problemele în
funcþie nu neapãrat de <EM>timpul</EM> necesar soluþionãrii, ci ºi
în funcþie de alte resurse necesare, cum ar fi: cantitate de memorie
necesarã (numitã ºi <EM>spaþiu</EM>), numãr de biþi aleatori,
porþi logice, ``adîncimea'' unui circuit care rezolvã problema,
etc.

<P>
Lumea face atît de mult tam-tam vis-a-vis de NP nu numai pentru cã
existã în NP multe probleme practice importante (cãci ºi celelalte
clase de complexitate conþin probleme practice importante), ci ºi
pentru cã pentru problemele din NP existã <EM>speranþa</EM> cã ar
putea fi rezolvate rapid, dar nimeni nu ºtie cum.  Dacã am ºti cã
nu se poate, am fi probabil mai relaxaþi, dar aºa e ca ºi cum
soluþia ne scapã printre degete.

<P>

<H1><A NAME="SECTION000100000000000000000"></A><A NAME="auto-reducere"></A>
<BR>
Auto-reducere
</H1>

<P>
În acest paragraf vom discuta o trãsãturã foarte interesantã a
lui SAT.  SAT, aºa cum este ea formulatã, este o ``problemã de
decizie''; acest nume tehnic înseamnã doar cã rãspunsul trebuie
sã fie doar ``DA'' sau ``NU'': dacã ni se dã un circuit, trebuie
sã spunem doar dacã circuitul este satisfiabil sau nu, dar nu ºi
<EM>cum</EM> este satisfiabil.

<P>
Aparent capacitatea de a rezolva o problemã de decizie nu e prea
utilã: dacã un profesor la ºcoalã are voie sã punã numai
întrebãri la care studentul sã rãspundã numai cu ``DA'' sau
``NU'', nu pare sã poatã verifica prea bine cunoºtinþele
studenþilor în acest fel (în definitiv dacã aceºtia dau cu banul
au ºansa de a rãspunde 50% corect, deci s'a ia not'a de trecere
fãrã nici un efort).

<P>
În realitate însã aceastã limitare la probleme de decizie nu este
o constrîngere prea severã.  Folosind un procedeu numit
auto-reducere putem transforma mai multe rãspunsuri DA-NU într-o
soluþie completã (adicã putem afla ºi <EM>cum</EM> circuitul poate fi
fãcut satisfiabil, pentru care intrãri).  Iatã cum:

<P>
<B>Sã presupunem</B> cã avem la dispoziþie un algoritm care rezolvã
rapid ºi corect SAT, în sensul cã rãspunde întotdeauna ``DA''
cînd i se dã o formulã SAT care poate genera ``1'' ºi ``NU'' cînd
pentru toate intrãrile posibile ale circuitului rezultatul este
``0''.

<P>
<B>Vrem</B> sã gãsim o serie de intrãri pentru care rezultatul este
``1'', dacã acestea existã.

<P>
Putem atunci <B>proceda</B> în acest fel :

<P>

<OL>
<LI>Întrebãm algoritmul ``este formula satisfiabilã''?  Dacã
rãspunsul este ``NU'' am terminat. 

<P>
</LI>
<LI>Altfel ºtim cã existã o valoare a primei variabile, fie 0,
fie 1, pentru care circuitul genereazã un ``1''.  Atunci punem prima
variabilã pe ``0'', dupã care simplificãm formula, folosind
regulile algebrei boolene.  Obþinem o nouã formulã de tip SAT, mai
simplã.

<P>
</LI>
<LI>Pentru noua formulã întrebãm din nou algoritmul.

<P>

<OL>
<LI>Dacã rãspunsul este ``DA'', lãsãm prima variabilã pe
``0''.

<P>
</LI>
<LI>Dacã rãspunsul este ``NU'', atunci ºtim cã prima variabilã
nu poate fi ``0'', deci trebuie sã fie ``1''.  Punem prima variabilã
pe ``1''.
</LI>
</OL>

<P>
</LI>
<LI>Repetãm algoritmul de la pasul 2, cu formula rezultatã, care
este mai micã.
</LI>
</OL>

<P>
Dupã atîþia paºi cîte variabile avem, obþinem pentru fiecare
variabilã o valoare.  

<P>
(Putem apoi verifica dacã algoritmul nu a minþit, testînd valoarea
formulei cu valorile obþinute.  Acelaºi truc îl poate face ºi
profesorul pentru a testa un student numai cu rãspunsuri ``DA'' ºi
``NU'': întreabã în felul urmãtor: ``este prima literã din
capitala Braziliei <B>A</B>'', apoi, dacã rãspunsul studentului este
``da'', întreabã de a doua literã, altfel încearcã <B>B</B> pentru
prima, etc.  Deºi metoda este incomodã, este pe deplin în
concordanþã cu regulile jocului, ºi aproape infailibilã:
profesorul obþine cîte un bit de la student prin fiecare întrebare.
Dacã studentul ºtie rãspunsul, profesorul trebuie sã obþinã <EM>toþi</EM> biþii corecþi, ºi nu numai unul.)

<P>
Metoda auto-reducerii este extrem de puternicã: ne permite sã
folosim un potenþial algoritm pentru a rezolva SAT pentru a rezolva o
sumedenie de alte probleme, aparent mult mai complicate (de exemplu,
chiar problema de a gãsi valorile care fac o formulã satisfiabilã).

<P>

<H1><A NAME="SECTION000110000000000000000">
Despre creativitate</A>
</H1>

<P>
Suntem înclinaþi sã afirmãm cã existã o diferenþã
substanþialã între (1) a înþelege ceva ºi (2) a crea ceva nou.
Aceste douã feluri de activitate sunt net diferite: spectatorul unei
opere de artã apreciazã rezultatul, dar efortul artistului pentru a
crea acea operã pare mult mai impresionant.  Putem spune cã
aprecierea este un algoritm de clasã P, dar creaþia este unul de
clasã NP: putem aprecia rezultatul, dar nu ºtim cum sã-l producem.

<P>
Dacã vã deranjeazã excursul într-un domeniu care este rezervat
subiectivitãþii totale (arta), atunci putem face exact aceeaºi
analogie în matematicã: între (1) a demonstra o teoremã ºi (2) a
citi o demonstraþie fãcutã de altcineva ºi a ne convinge de
corectitudinea ei, pare sã fie din nou o diferenþã de naturã.
Actul (1), al demonstratorului este un act creativ, de cãutare
într-o enormã masã de posibilitãþi, pe cînd actul (2), al
discipolului, care reciteºte demonstraþia, este relativ simplu,
constînd în a verifica faptul cã fiecare pas logic fãcut în
demonstraþie respectã regulile de inferenþã ale logicii.

<P>
Din nou avem aceeaºi antitezã, între actul de a genera (care poate
fi asimilat cu clasa NP) ºi actul de a verifica (care poate fi
asimilat cu clasa P)<A NAME="tex2html15"
  HREF="#foot215"><SUP>10</SUP></A>.

<P>
Cum spuneam, nu existã o demonstraþie riguroasã cã P <IMG
 WIDTH="19" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\not=$"> NP,
dar nici una cã P=NP.  Suntem supuºi unei tensiuni dureroase:

<P>

<UL>
<LI>Pe de o parte ne-ar plãcea ca P=NP, pentru cã atunci ar
însemna cã toate problemele acelea practice importante, în frunte
cu SAT, pot fi rezolvate foarte eficient;

<P>
</LI>
<LI>Pe de altã parte, dacã P=NP, nu ar mai exista nici o
diferenþã practicã între creator ºi admirator; efortul
amîndurora ar fi deopotrivã de mare.
</LI>
</UL>

<P>
Dacã P=NP, am avea ºi alte consecinþe extrem de importante, în
oarecare mãsurã devastatoare:

<P>

<H2><A NAME="SECTION000111000000000000000">
Matematica trivialã</A>
</H2>

<P>
Pentru orice teoremã din matematicã am putea scrie un program care
sã gãseascã o demonstraþie într-un timp nu mult mai mare decît
lungimea celei mai scurte demonstraþie posibile (ar exista un polinom
P(x) astfel încît, dacã cea mai scurtã demonstraþie posibilã
este de lungime x, algoritmul am gãsi una în timp cel mult
P(x).).

<P>
Un astfel de algoritm ar folosi tehnica auto-reducerii pentru a deriva
o demonstraþie corectã (ceva de genul: existã o demonstraþie care
începe cu litera ``A''?  etc.)

<P>
Importanþa acestei tehnici pentru demonstrarea automatã a teoremelor
din matematicã a fost observatã de cãtre logicianul Kurt Gödel
înca din 1956, într-o scrisoare adresatã marelui matematician John
von Neumann, cu mult înainte ca teoria NP-complexitãþii sã existe
(ºi cu mult înainte sã existe calculatoare de uz comun).

<P>

<H2><A NAME="SECTION000112000000000000000">
Criptografia inexistentã</A>
</H2>

<P>
<EM>Decriptarea</EM> este la rîndul ei o problemã NP, dacã o formulãm
în felul urmãtor: ``este acest ºir de caractere criptarea unui text
cu sens''?  Decriptarea este în NP, pentru cã dacã cineva ne oferã
cheia de decriptare, putem obþine textul criptat cu un algoritm
rapid; putem astfel verifica în timp polinomial cã mesajul criptat
este într-adevãr rezultat din sursã.

<P>
Dar dacã P=NP, înseamnã cã existã un algoritm de timp polinomial
pentru SAT; îl putem folosi împreunã cu metoda auto-reducerii
pentru a ``sparge'' orice mesaj!  Deci, dacã P=NP, nu existã
criptografie!  Dintr-o datã, lumea aratã cu totul altfel.

<P>

<H1><A NAME="SECTION000120000000000000000">
Densitatea soluþiilor ºi dificultatea problemelor</A>
</H1>

<P>

<H2><A NAME="SECTION000121000000000000000">
Criptografia ºi NP-completitudinea</A>
</H2>

<P>
Pentru cã SAT este o problema atît de dificilã multã lume s-a
strãduit sã creeze algoritmi de criptare bazaþi pe probleme
NP-complete.  Din nefericire pînã la urmã toate metodele de
criptare bazate pe probleme NP-complete s-au dovedit a fi foarte uºor
de spart!

<P>
Asta e chiar o surprizã: creãm probleme dintr-o clasã reputat
dificilã, dar în practicã reuºim foarte des sã le rezolvãm!  Nu
e ceva putred la mijloc?

<P>
De fapt nimic nu ne garanteazã cã NP este o clasã potrivitã pentru
criptografie, pentru cã ``tãria'' oferitã de NP nu este aceeaºi cu
``tãria'' necesarã criptografilor.  Iatã de ce: dacã ne ducem la
prima parte a acestui articol, vedem cã complexitatea unei clase de
probleme este datã de <EM>cea mai grea</EM> problemã din clasã.
Astfel, dacã toate problemele din NP ar fi foarte uºoare, dar una
singurã ar fi extrem de grea, noi tot am declara clasa NP ca fiind
grea.  Asta se numeºte ``complexitatea în cazul cel mai rãu''
(worst-case complexity).

<P>
Criptografii pe de altã parte nu vor ca unele probleme sã fie grele
ºi altele uºoare; ei vor ca o problemã aleasã <EM>la
întîmplare</EM> sã fie dificilã: nu ai nici un avantaj dacã existã o
singurã cheie care nu poate fi ``spartã'', pentru cã este nevoie de
multe chei.  Complexitatea ``medie'' a unei probleme trebuie sã fie
ridicatã pentru ca acea problemã sã fie potrivitã pentru
criptografie.

<P>
Clasa problemelor NP-complete nu pare sã fie densã în probleme
grele; ea constã în probleme <EM>expresive</EM>: vã reamintiþi cã o
problemã este NP-completã dacã putem reduce orice altã problemã
din NP la ea; asta înseamnã cã ``limbajul'' problemelor NP-complete
este foarte expresiv: ne permite sã codificãm orice altã problemã.

<P>
La ora asta cei mai rezilienþi algoritmi criptografici se bazeazã pe
probleme care nu sunt demonstrate a fi NP-complete, ºi care foarte
probabil nici nu sunt (dar, din nou, nu existã încã nici o
demonstraþie în acest sens).  Cele mai bune candidate s-au dovedit
unele probleme de teoria numerelor.  De fapt niºte probleme absolut
banale (în sensul cã pot fi explicate ºi unui ºcolar):
criptosistemul cu cheie publicã RSA se bazeazã pe problema <EM>factorizãrii</EM>: dacã am un numãr, cum sã-l descompun într-un
produs de factori (primi).

<P>
Dacã vã grãbiþi sã sugeraþi algoritmul învãþat la ºcoalã
pentru descompunere în factori primi, vã invit sã-i analizaþi
complexitatea.  Acel algoritm trebuie sã încerce toate numerele
prime mai mici decît numãrul pe care vreþi sã-l descompuneþi.
Ori, pentru numãrul n, existã aproximativ
2<sup>n</sup>/log(2<sup>n</sup>) astfel de numere, adicã un numãr
exponenþial.  Asta înseamnã cã algoritmul, deºi funcþioneazã biniºor
pentru numerele oferite în  clasã ca exerciþiu, este absolut
inaplicabil, chiar cu cele mai performante calculatoare, atunci cînd
avem de-a face cu numere de sute de cifre.

<P>

<H2><A NAME="SECTION000122000000000000000">
CNF-SAT ºi k-CNF-SAT</A>
</H2>

<P>
O întrebare legitimã pe care ne-o putem pune este ``cînd este o
instanþã a lui SAT dificilã''?  Pentru a putea rãspunde la
aceastã întrebare, vom introduce niºte noi elemente de
terminologie.

<P>
Dupã cum am spus, o problemã din SAT constã într-o formulã
booleanã (sau un circuit logic) care aplicã operaþiile ``sau'',
``ºi'' ºi ``nu'' logic unor variabile pentru a obþine o singurã
valoare, de un bit.  Ce vrem sã ºtim este dacã existã valori ale
variabilelor manipulate care sã facã formula ``1''.

<P>
Algebra booleanã ne învaþã cã fiecare formulã logicã se poate
rescrie într-o formã mai simplã, în care:

<P>

<UL>
<LI>Aplicãm semnul <IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="$\lnot$"> (nu) numai unor variabile individuale
(ºi niciodatã unor expresii); o variabilã sau o variabilã negatã
se numeºte un <EM>literal</EM>;

<P>
</LI>
<LI>Construim <EM>clauze</EM> care constau din succesiuni de literali
legaþi cu semnul <IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="$\lor$"> (sau);

<P>
</LI>
<LI>Întreaga formulã este o serie de clauze legate cu semnul
<IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$\land$"> (ºi).
</LI>
</UL>

<P>
O astfel de formã se numeºte ``forma normalã conjunctivã'', sau
CNF (Conjunctive Normal Form), pentru cã formula este o conjuncþie
(ºi) de disjuncþii (sau).  De exemplu <!-- MATH
 $(a \lor b \lor \lnot c) \land
(\lnot a \lor \lnot b)$
 -->
<IMG
 WIDTH="186" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$(a \lor b \lor \lnot c) \land
(\lnot a \lor \lnot b)$"> este în forma CNF, pe cînd <!-- MATH
 $\lnot (a \land
b)$
 -->
<IMG
 WIDTH="67" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$\lnot (a \land
b)$"> nu este, pentru cã avem o negaþie aplicatã unei formule.

<P>
Se poate arãta cã, chiar dacã formula este exprimatã în forma
CNF, asta nu simplificã cu nimic sarcina lui SAT, problema
rãmînînd NP-completã.  Poate sã vi se parã ciudat cã s-ar putea
întîmpla altfel: în definitiv orice formulã poate fi scrisã sub
forma CNF; aparent noi rezolvãm aceeaºi problemã, doar scrisã
diferit: de ce ne-am aºtepta ca complexitatea rezolvãrii sã fie
alta dacã exprimãm formula altfel?

<P>
Ei bine, clasa de probleme depinde foarte mult ºi de felul în care
enunþãm problema; clasa SAT este diferitã de clasa CNF-SAT: prima
clasã conþine orice formulã logicã, a doua numai formulele logice
care sunt scrise în forma normalã conjunctivã.  E adevãrat cã
orice formulã din prima clasã este absolut echivalentã cu una din a
doua clasã (în sensul cã calculeazã aceeaºi funcþie booleanã),
dar cele douã formule nu sunt identice.  

<P>
Pentru a ne convinge cã este important modul de exprimare, sã notãm
cã existã ºi o formã de scriere a formulelor boolene, numitã
``normalã disjunctivã'', notatã DNF, care e la fel cu CNF, dar la
care se schimbã semnele ``sau'' ºi ``ºi'' între ele.  Se poate de
asemenea arãta cã de asemenea orice formulã booleanã se poate pune
în forma normalã disjunctivã.  Dar orice întrebare din DNF-SAT se
poate rezolva în timp polinomial!  DNF-SAT este o clasã de probleme
mult mai uºoare decît cele din SAT sau CNF-SAT.

<P>
De ce stau lucrurile aºa?  Pentru cã atunci cînd transcriem o
formulã din SAT în formã DNF-SAT, lungimea ei poate creºte foarte
mult; dacã lungimea iniþialã a formulei era x ºi complexitatea
algoritmului era 2<sup>x</sup>, ºi dacã dupã traducere avem lungimea
n=2<sup>x</sup> ºi complexitatea n<sup>2</sup> =
2<sup>x<sup>2</sup></sup>, care este exponenþialã în x dar polinomialã în n.

<P>
Iatã încã un exemplu: problema de a gãsi divizorii unui numãr
este foarte grea dacã numãrul este scris în baza 2 (sau orice altã
bazã mai mare ca 2), dar este foarte simplã dacã numãrul este
scris în baza 1.  Dacã scriem numãrul 100 folosind 100 de
beþiºoare, atunci putem exhiba un algoritm de complexitate n<sup>2</sup>
care gãseºte toþi divizorii lui 100 (de pildã algoritmul
învãþat în ºcoala primarã).  Dar, scriind un numãr în baza 2,
folosim mult mai puþine cifre (mai exact, pentru n folosim log n
cifre), deci chiar dacã aplicãm acelaºi algoritm, într-un caz
mãsurãm timpul algoritmului relativ la n, iar în altul relativ la
log n$.

<P>
Din motive tehnice adesea cercetãtorii lucreazã cu o versiune a
problemei CNF-SAT, descrisã printr-un numãr k: k-CNF-SAT.  Avem
astfel 2-CNF-SAT, 3-CNF-SAT, etc.  Clasa k-CNF-SAT constã din
formulele boolene scrise în formã CNF dar pentru care orice clauzã
are cel mult k literali.  De exemplu formula <!-- MATH
 $(a \lor b \lor \lnot
c) \land (\lnot a \lor \lnot b)$
 -->
<IMG
 WIDTH="186" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$(a \lor b \lor \lnot c) \land
(\lnot a \lor \lnot b)$"> este în 3-CNF-SAT, ºi în
4-CNF-SAT, dar nu în 2-CNF-SAT.

<P>
Se aratã de asemenea, fãrã prea multã dificultate, cã, pentru
orice k întreg, orice formulã booleanã se poate aduce în forma
k-CNF-SAT.

<P>
Avem însã de a face cu un fenomen interesant: 1- ºi 2-CNF-SAT sunt
clase de probleme foarte uºoare: se cunoaºte chiar un algoritm de
timp linear care rezolvã aceste probleme.  Pe de altã parte toate
clasele CNF-SAT cu mai mult de doi literali pe clauzã sunt
NP-complete!

<P>
Ce straniu!  O diferenþã atît de mare de complexitate, ºi o
diferenþã atît de micã de formã.  Acest fenomen se întîlneºte
foarte adesea în teoria NP-complexitãþii; sunt foarte multe
probleme pentru care o anumitã variantã este simplã, dar de
îndatã ce schimbi un pic enunþul o transformi într-o variantã
foarte dificilã.  (De exemplu, întrebarea dacã putem colora o
hartã cu douã culori, în aºa fel încît þari vecine sã nu fie
colorate la fel, este banalã, dar aceeaºi întrebare cu numãrul
trei este NP-completã.  ªtim cã putem oricînd colora o hartã cu 4
culori, dintr-o teoremã extrem de celebrã.)

<P>

<H2><A NAME="SECTION000123000000000000000">
Tranziþii de fazã</A>
</H2>

<P>
Dupã cum am spus mai sus, nu toate instanþele unor probleme
NP-complete sunt la fel de grele: numai cele mai dificile sunt foarte
grele; unele pot fi foarte uºoare.  Un articol extrem de interesant,
care a fãcut vîlvã, a asimilat comportarea formulelor boolene cu
fenomenele fizice care se petrec cînd un material face o tranziþie
de fazã, de exemplu de la lichid spre solid.  Acest articol este o
colaborare între fizicieni ºi informaticieni, ºi a fost publicat
în revista Nature.  Articolul este scris de Rémi Monasson, de la
laboratorul CNRS de fizicã teoreticã de la Paris, Riccardo Zecchina,
de la Centrul internaþional pentru fizicã teoreticã de la Trieste,
Scott Kirkpatrick, de la laboratoarele T. J. Watson ale lui IBM, Bart
Selman, profesor la departamentul de calculatoare de la Universitatea
Cornell ºi Lidror Troyansky, de la departamentul de calculatoare al
universitãþii evreieºti din Ierusalim.

<P>
Articolul a fãcut atîta vîlvã încît a apãrut ºi în ziare; o
versiune de popularizare despre aceastã temã puteþi gãsi de
exemplu în New York Times la 
<BR><TT><A NAME="tex2html16"
  HREF="http://www.nytimes.com/library/national/science/071399sci-satisfiability-problems.html">
http://www.nytimes.com/library/national/science/071399sci-satisfiability-problems.html</A></TT>.

<P>
Articolul studiazã care dintre problemele SAT sunt grele ºi care
sunt uºoare.  Cantitatea aflatã sub studiu este <EM>constrîngerea</EM>: cît de multe condiþii sunt puse asupra unei
formule.  Dacã o formulã este prea puþin constrînsã, are o
multitudine de soluþii.  Dacã formula este foarte constrînsã,
atunci nu are nici o soluþie.  Astfel de formule sunt foarte uºor de
rezolvat: pentru cele puþin constrînse putem gãsi soluþii aproape
la întîmplare, pe cele supra-constrînse le putem uºor demonstra ca
ne-avînd nici o soluþie.  Noþiunea de constrîngere poate fi
asimilatã cu rangul unui sistem de ecuaþii lineare din algebrã: un
sistem de ecuaþii care are mai multe variabile decît
ecuaþii<A NAME="tex2html17"
  HREF="#foot187"><SUP>11</SUP></A> are o
infinitate de soluþii, un sistem care are mai multe ecuaþii decît
variabile nu are nici o soluþie.  Articolul asimileazã
constrîngerea cu gradul de libertate al moleculelor dintr-un lichid,
respectiv solid: solidul este mult mai constrîns.
<P>
Constrîngerea poate fi mãsuratã pentru probleme k-CNF-SAT prin
raportul dintre numãrul de clauze din formulã ºi numãrul de
variabile.  Iatã intuitiv de ce lucrurile stau aºa: sã luãm o
clauzã izolatã ºi sã o facem adevãratã selectînd un literal
anume ca adevãrat (sã zicem ca acesta este literalul a).  Dacã ne
uitãm acum la toate celelalte clauze care conþin <IMG
 WIDTH="27" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.png"
 ALT="$\lnot a$">, ele vor
fi forþate sã aleagã un alt literal sã fie adevãrat.  Aceste
clauze sunt <EM>constrînse</EM> de prima, pentru cã au mai puþine
alegeri de fãcut.  Cu cît avem mai multe clauze, cu atît avem mai
multe constrîngeri reciproce.
<P>
Articolul citat face un studiu experimental asupra raportului <IMG
 WIDTH="17" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.png"
 ALT="$\alpha$">
dintre numãrul de clauze ºi numãrul de variabile, folosind formule
generate aleator pe care le rezolvã prin forþã brutã.  Graficul
din figura&nbsp;<A HREF="sat-html.html#alfa">3</A> aratã dependenþa dificultãþii unei probleme
de acest numãr.  Cînd <IMG
 WIDTH="17" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.png"
 ALT="$\alpha$"> este un numãr mic, problemele au
multe soluþii, ºi sunt uºor de rezolvat.  Cînd <IMG
 WIDTH="17" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.png"
 ALT="$\alpha$"> este mare
problemele nu au nici o soluþie, ºi acest lucru este iarãºi foarte
uºor de descoperit.  Cînd <IMG
 WIDTH="17" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.png"
 ALT="$\alpha$"> atinge o valoare criticã, (care
depinde de k), nu e clar dacã problemele au sau nu soluþii, iar
determinarea acestui lucru este extrem de dificil.  Pentru aceste
instanþe, algoritmi cunoscuþi calculeazã foarte mult.
<P>
 </FONT></FONT>
<P></P>
<DIV ALIGN="CENTER"><A NAME="alfa"></A><A NAME="233"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3:</STRONG>
Efortul computaþional necesar pentru a rezolva o
instanþã aleatoare a 3-CNF-SAT în funcþie de constrîngerea
formulei <IMG
 WIDTH="36" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$\alpha =$"> (numãrul de clauze)/(numãrul de variabile).
Aceastã figurã este extrasã din pagina de web de la Cornell a lui
Bart Selman.</CAPTION>
<TR><TD><IMG
 WIDTH="221" HEIGHT="273" BORDER="0"
 SRC="img41.png"
 ALT="\begin{figure}\centerline{\epsfxsize=5cm\epsffile{alfa.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>
<P>
<H1><A NAME="SECTION000130000000000000000">
Soluþii practice pentru SAT</A>
</H1><P>
Voi încheia excursia în domeniul SAT prin expunerea soluþiilor
folosite pentru a rezolva aceste probleme în practicã.  Faptul cã
nu putem sã rezolvãm problemele în general nu înseamnã cã nu
avem nevoie sã o facem, ba chiar, aºa cum am arãtat, probleme
NP-complete apar adesea în practicã.  Aºa cã tot ce putem face
este sã facem tot felul de trucuri care mãcar rezolvã rapid
cazurile uºoare.
<P>
În mod paradoxal, cei mai eficace algoritmi din ziua de azi sunt doar
variante ale unor algoritmi deosebit de simpli.  Trimitem cititorul
interesat la articolul lui Stephen Cook<A NAME="tex2html19"
  HREF="#foot195"><SUP>12</SUP></A> ºi David Mitchell ``Finding Hard Instances of the
Satisfiability Problem: A Survey'', publicatã în DIMACS Series in
Discrete Mathematics and Computer Science în 1997.
<P>
<H2><A NAME="SECTION000131000000000000000">
Algoritmul Putnam-Davis</A>
</H2>
<P>
Cel mai eficace algoritm general pentru SAT rãmîne un algoritm
propus de M. Davis ºi H. Putnam în 1960!  Algoritmul lor alege
succesiv un literal pe care îl face adevãrat, dupã care ºterge
toate clauzele care conþin acel literal, pentru cã aceste clauze
sunt deja satisfãcute.  În plus, literalul negat este eliminat de
peste tot din celelalte clauze, pentru cã este deja fals.
<P>
Crucialã este alegerea literalului, iar algoritmul lor sugereazã
niºte <EM>euristici</EM> care duc la rezultate foarte bune în
practicã.  Euristicile sunt reguli care fac un algoritm mai eficient
în general, dar despre care nu se poate demonstra cã sunt
întotdeauna alegerea corectã; sunt deci ``ghiciri înþelepte''.
<P>
Metoda lor începe prin a elimina întotdeauna cele mai constrînse
clauze, adicã cele care conþin un singur literal: este clar cã
acesta trebuie sã fie adevãrat pentru a face formula adevãratã.
Datoritã eliminãrilor, astfel de clauze apar ºi în cursul
evoluþiei algoritmului.  Dacã nu sunt astfel de clauze, atunci un
literal este ales la întîmplare ºi se încearcã pe rînd ambele
valori posibile, 0 ºi 1, fãcînd backtracking dacã o încercare
eºueazã.

<P>
<FONT SIZE="-1"></FONT>
<H2><A NAME="SECTION000132000000000000000">
Algoritmul Walk-SAT</A>
</H2><FONT SIZE="-1"></FONT>
<P>
Acest algoritm face parte din ceea ce se numesc ``metode incomplete de
rezolvare'', pentru cã nu funcþioneazã pe probleme care nu sunt
satisfiabile, dar funcþioneazã excelent pe cele care au soluþii,
gãsind foarte repede soluþii.  Acest algoritm a fost propus de Bart
Selman, acum la Universitatea Cornell (ºi unul dintre autorii
articolului de mai sus despre tranziþiile de fazã).

<P>
Acest algoritm este foarte surprinzãtor pentru cã este un algoritm
aleator: dã cu banul pentru a decide ce valoare trebuie sã aibã
fiecare variabilã.  De fapt acest algoritm este reprezentativ pentru
cercetarea curentã în teoria algoritmilor aleatori (pe care i-am
menþionat pe larg într-un <a href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#algoritmi">articol</a> în PC Report din august 1997).

<P>
Algoritmul este urmãtorul:

<P>
<FONT SIZE="-1"></FONT>
<OL>
<LI>Generãm la întîmplare atribuiri 0 ºi 1 pentru fiecare
variabilã.

<P>
</LI>
<LI>Dacã nu sunt clauze nesatisfãcute, am terminat ºi am gãsit o
soluþie.

<P>
</LI>
<LI>Alegem o clauzã nesatisfãcutã la întîmplare.

<P>
</LI>
<LI>Dãm cu banul. 

<P>

<OL>
<LI>Dacã iese cap, atunci schimbãm valoarea unei variabile alese
la întîmplare (în opusul ei).

<P>
</LI>
<LI>Dacã a ieºit pajurã, alegem variabila din clauzã a cãrei
schimbare ar maximiza numãrul de alte clauze care devin satisfãcute.
Alegem la întîmplare dacã avem mai multe variabile la fel de bune.
</LI>
</OL>

<P>
</LI>
<LI>Dacã nu ne-am ``plictisit'' reluãm de la pasul (2).
</LI>
</OL><FONT SIZE="-1"></FONT>
<P>
<FONT SIZE="-1"></FONT>
<H1><A NAME="SECTION000140000000000000000">
Încheiere</A>
</H1><FONT SIZE="-1"></FONT>
<P>
Am vãzut în acest articol cã existã probleme al cãror enunþ este
banal, dar care sunt de fapt foarte greu de rezolvat în practicã în
mod eficient.  Aceastã stare de fapt simultan ne bucurã ºi ne
întristeazã: ne bucurã pentru cã dacã am putea rezolva aceste
probleme uºor, ar rezulta cã unele din îndeletnicirile umane pe
care le preþuim cel mai mult, de exemplu creativitatea
matematicienilor, pot fi reduse la simple manipulãri mecaniciste.
Ne-am întrista, pentru cã de fapt ne dorim foarte mult sã rezolvãm
aceste probleme, fiindcã importanþã lor practicã este enormã.

<P>
Dacã vã doriþi un drum rapid spre faimã mondialã, atunci una
dintre soluþii este sã rezolvaþi aceastã întrebare: se pot sau nu
rezolva aceste probleme în mod eficient, sau, tehnic vorbind, este P
tot una cu NP?  Dar, fiþi preveniþi, multe capete luminate s-au
luptat cu aceastã enigmã ºi au fost toate înfrînte!

<P>
<FONT SIZE="-1"></FONT>
<BR><HR><H4>Note</H4>
<DL>
<DT><A NAME="foot91">... a</A><A NAME="foot91"
 HREF="sat-html.html#tex2html4"><SUP>1</SUP></A>
<DD>Operaþia aceasta nu coincide neapãrat cu sensul
cuvîntului ``sau'' din limba vorbitã, care este cîteodatã folosit
în sensul exclusiv: în limba vorbitã folosim uneori ``sau'' pentru
a zice cã ``una sau alta se întîmplã, dar nu amîndouã''.

<DT><A NAME="foot92">... tii</A><A NAME="foot92"
 HREF="sat-html.html#tex2html5"><SUP>2</SUP></A>
<DD>Iarãºi avem o oarecare
discrepanþã cu sensul negaþiei în limba vorbitã, deoarece în
româna o dublã negaþie (``n-am mîncat nimic'') nu este o
afirmaþie, pe cînd în logicã <!-- MATH
 $\lnot \lnot a = a$
 -->
<IMG
 WIDTH="71" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="$\lnot \lnot a = a$">.

<DT><A NAME="foot104">... a</A><A NAME="foot104"
 HREF="sat-html.html#tex2html7"><SUP>3</SUP></A>
<DD>O clauzã
este definitã ca o conjuncþie de variabile sau variabile negate.

<DT><A NAME="foot109">... SAT</A><A NAME="foot109"
 HREF="sat-html.html#tex2html8"><SUP>4</SUP></A>
<DD>Desigur, e vorba de o rezolvare
eficientã; vom vedea cã SAT poate fi rezolvatã, dar într-un mod
foarte costisitor.

<DT><A NAME="foot122">...
intrare</A><A NAME="foot122"
 HREF="sat-html.html#tex2html9"><SUP>5</SUP></A>
<DD>În general cea mai bunã mãsurãtoare pentru
dimensiunea datelor de intrare este numãrul de biþi de care avem
nevoie pentru a le descrie, dar în acest caz folosim o altã
mãsurã, ºi anume numãrul de variabile.  De fapt ambele mãsuri ar
oferi acelaºi rezultat.

<DT><A NAME="foot212">... P</A><A NAME="foot212"
 HREF="sat-html.html#tex2html10"><SUP>6</SUP></A>
<DD>Strict vorbind, clasele P ºi NP, riguros definite,
conþin numai probleme de <EM>decizie</EM>, deci probleme la care
rãspunsul poate fi numai ``da'' sau ``nu''.  Aºa cum arãtãm pe
scurt în secþinea&nbsp;<A HREF="sat-html.html#auto-reducere">9</A>, între probleme de
optimizare, de genul ``care e cel mai mic X'' ºi probleme de decizie
de tipul ``existã un X'' este o legãturã strînsã, care le face la
fel de grele (în sensul cã atunci cînd putem rezolva una o putem
rezolva ºi pe cealaltã).  În acest text ignorãm deci distincþia
dintre problemele de decizie ºi cele de optimizare.

<DT><A NAME="foot213">... demonstrat</A><A NAME="foot213"
 HREF="sat-html.html#tex2html12"><SUP>7</SUP></A>
<DD>Stephen Cook: <EM>The
Complexity of Theorem-Proving Procedures</EM>, în 3rd ACM Symposium on
the Theory of Computation.

<DT><A NAME="foot145">... tie</A><A NAME="foot145"
 HREF="sat-html.html#tex2html13"><SUP>8</SUP></A>
<DD>Prin
contrast, existã probleme la care nu existã dovezi scurte cã ceva
este o soluþie corectã; de pildã nu existã o dovadã scurtã care
sã demonstreze cã o anumitã strategie de a juca un joc gen ºah
este optimalã.

<DT><A NAME="foot214">... tie</A><A NAME="foot214"
 HREF="sat-html.html#tex2html14"><SUP>9</SUP></A>
<DD>De exemplu, nu existã un algoritm care sã
rãspundã la întrebarea ``dat fiind programul P ºi datele de
intrare x, se va termina vreodatã P?''; aceastã problemã este
<EM>indecidabilã</EM>

<DT><A NAME="foot215">... P)</A><A NAME="foot215"
 HREF="sat-html.html#tex2html15"><SUP>10</SUP></A>
<DD>În realitate aceste asociaþii nu sunt
prea precise, pentru cã clasele P ºi NP sunt definite relativ la
comportarea <EM>asimptoticã</EM> a algoritmilor; un algoritm este în P
dacã complexitatea lui creºte ca un polinom cînd problema pe care o
rezolvã devine din ce în ce mai mare.

<DT><A NAME="foot187">... tii</A><A NAME="foot187"
 HREF="sat-html.html#tex2html17"><SUP>11</SUP></A>
<DD>De fapt decît ecuaþii independente linear.

<DT><A NAME="foot195">... Cook</A><A NAME="foot195"
 HREF="sat-html.html#tex2html19"><SUP>12</SUP></A>
<DD>Acelaºi care a
demonstrat teorema lui Cook menþionatã în prima parte a acestui
articol

</DL>
<BR><HR>

</BODY>
</HTML>
