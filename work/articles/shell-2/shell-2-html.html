<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Elemente de programare în Shell-ul Unix</TITLE>
<META NAME="description" CONTENT="Elemente de programare în Shell-ul Unix">
<META NAME="keywords" CONTENT="shell-2-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Elemente de programare în Shell-ul Unix</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>noiembrie 2000</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>programare în Bourne Shell
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare de programare;
familiaritate cu Unix
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>shell, proces, variabilã, comandã, script
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html32"
  HREF="shell-2-html.html">Shell-ul: un limbaj de programare</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION00030000000000000000">Shell-uri interactive ºi neinteractive</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION00040000000000000000">Familii de shell-uri</A>
<LI><A NAME="tex2html35"
  HREF="#SECTION00050000000000000000">Elemente fundamentale de programare în Shell</A>
<UL>
<LI><A NAME="tex2html36"
  HREF="#SECTION00051000000000000000">Comenzi externe</A>
<LI><A NAME="tex2html37"
  HREF="#SECTION00052000000000000000">Variabile shell</A>
<LI><A NAME="tex2html38"
  HREF="#SECTION00053000000000000000">Comenzi interne importante</A>
<LI><A NAME="tex2html39"
  HREF="#SECTION00054000000000000000">Expansiunea expresiilor regulate</A>
<LI><A NAME="tex2html40"
  HREF="#SECTION00055000000000000000">Comenzi paralele</A>
<LI><A NAME="tex2html41"
  HREF="#SECTION00056000000000000000">Redirectare ºi conducte (pipes)</A>
<LI><A NAME="tex2html42"
  HREF="#SECTION00057000000000000000">Accentul grav</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION00058000000000000000">Alte comenzi</A>
</UL>
<BR>
<LI><A NAME="tex2html44"
  HREF="#SECTION00060000000000000000">Încheiere</A>
<LI><A NAME="tex2html45"
  HREF="#SECTION00070000000000000000">Alte surse de informaþie</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Aveþi adesea de manipulat multe fiºiere?  Procesaþi frecvent texte?
Sunteþi un administrator de sistem?  Dacã intraþi într-una din
aceste categorii, atunci scula software pe care o voi descrie în
continuare se poate dovedi exact obiectul de care aveþi nevoie.

<P>
În acest articol voi discuta despre ``shell'', într-una din
înfãþiºãrile pe care le are în sistemul de operare Unix.  Am mai scris
articole despre shell în PC Report; le recomand cititorilor cãrora
articolul de faþã le stîrneºte interesul sã se uite ºi peste cele mai
vechi; un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#shell">articol</a>
în PC Report din iunie 1997 discutã despre cum este implementat un
shell.  <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#nucleu">Articolul</a>
meu din decembrie 1996 discutã despre sistemele de operare ºi
menþioneazã în treacãt ºi rolul shell-ului.  Dacã între timp aþi fãcut
curat în bibliotecã ºi nu mai aveþi numerele vechi, puteþi gãsi
on-line articolele scrise de mine în pagina mea de web.

<P>
Chiar dacã 95% din umanitate folose'ste sistemul de operare Windows,
de data aceasta nu mai pot fi acuzat cã ignor marea audienþã cu
bunã intenþie: sistemele create de Microsoft oferã doar
facilitãþi rudimentare în aceastã privinþã.  Existã
într-adevãr mai multe pachete software pentru Windows oferite de
terþi care implementeazã funcþionalitãþi de shell, dar shell-ul
standard rãmîne cel DOS.

<P>

<H1><A NAME="SECTION00020000000000000000">
Shell-ul: un limbaj de programare</A>
</H1>

<P>
Dacã nu vreþi sã vã osteniþi prea tare sã cãutaþi articolele
mele mai vechi, voi rezuma aici cîteva din informaþiile mai
importante de care avem nevoie.

<P>
În primul rînd, ``shell'' înseamnã cochilie sau carapace.  Numele
acestui program vine din faptul cã ``înveleºte'' nucleul sistemului
de operare, precum cochilia miezul moale al melcului: utilizatorul nu
are de-a face cu nucleul ci interacþioneazã prin intermediul
shell-ului.  Pentru cã nu îmi vine în minte nici o traducere
potrivitã, voi continua sã folosesc cuvîntul englezesc.

<P>
Shell-ul este un program care permite utilizatorilor sã tasteze ºi
execute comenzi.  Una din funcþiile foarte importante ale shell-ului
este de a permite utilizatorilor sã porneascã în execuþie <EM>alte</EM> programe.  Numim un program în curs de execuþie <EM>proces</EM>.
Toate procesele utilizatorilor pe un sistem Unix descind dintr-un
shell.

<P>
În Unix shell-ul oferã mai mult decît abilitatea de a lansa procese
în execuþie: oferã o sumedenie de comenzi ºi facilitãþi
suplimentare, care-l fac un mediu ideal pentru a activitãþi de
administrare a sistemului.  Toate aceste comenzi formeazã un <EM>limbaj de programare</EM> deosebit de puternic; shell-ul este deci un <EM>interpretor</EM>, care citeºte ºi executã comenzi.

<P>

<H1><A NAME="SECTION00030000000000000000">
Shell-uri interactive ºi neinteractive</A>
</H1>

<P>
Putem deci distinge douã utilizãri separate ale shell-ului: prima
utilizare constã în a executa comenzi simple, în general pentru a
lansa în execuþie alte programe.  În acest caz shell-ul prezintã
utilizatorului un <EM>prompt</EM>, o invitaþie de a primi o comandã.
Dupã ce utilizatorul tasteazã comanda, shell-ul o executã imediat,
iar cînd comanda îºi terminã execuþia (sau chiar mai înainte,
dacã este instruit în acest sens), shell-ul oferã din nou un
prompt.  Acest mod de utilizare, în care fiecare comandã este
cititã de la utilizator ºi executatã se numeºte <EM>interactiv</EM>.
În acest text vom folosi semnul procent <code>%</code> pentru a indica
prompt-ul.

<P>
A doua utilizare a shell-ului este pentru execuþia unor programe mai
complicate, scrise dinainte ºi depozitate în fiºiere.  Un fiºier
cu comenzi pentru shell se numeºte în englezã <EM>shell script</EM>
(adicã un ``scenariu pentru cochilie''), sau pe scurt ``script''.
Executarea unui script se mai numeºte ``procesare în vrac'', <EM>batch processing</EM>, pentru cã shell-ul nu se mai opreºte dupã
fiecare comandã cu un prompt.

<P>
Ca orice alt limbaj de programare, cunoaºterea doar a unei fracþiuni
din elementele de bazã se dovedeºte perfect satisfãcãtoare pentru
nevoile de zi cu zi.  Voi ilustra aici numai comenzile cele mai
puternice, ºi pe acestea le voi descrie mai mult prin exemple decît
riguros.  Pentru cei doritori de aprofundarea subiectului, secþiunea
finalã despre surse de informaþii suplimentare se poate dovedi un
punct bun de plecare.

<P>

<H1><A NAME="SECTION00040000000000000000">
Familii de shell-uri</A>
</H1>

<P>
Dacã Windows NT nu are un shell decent, în lumea Unix situaþia este
chiar pe dos; un scurt istoric este necesar pentru a lãmuri babilonia
de opþiuni existente.

<P>
Primul shell tradiþional pentru Unix a fost scris în 1976 de Steve
Bourne, care pe vremea aceea lucra la laboratoarele Bell ale companiei
AT&amp;T.  În onoarea creatorului sãu, shell-ul acesta este numit
``Bourne shell''.  Programul cu pricina se numeºte simplu ``sh'', ºi
se aflã de obicei în directorul <TT>/bin</TT> pe un sistem Unix
(<TT>/bin/sh</TT>).  Sã nu uitãm cã sistemul de operare Unix însuºi
fusese creat cu puþin timp în urmã în acelaºi loc, inspirat de
sistemul de operare Multics (vedeþi ºi articolul meu despre istoria
Unix-ului).  Shell-ul Bourne introducea o mulþime de concepte
revoluþionare, care fãceau viaþã utilizatorilor ºi
administratorilor mult mai simplã decît în sistemele de operare
precedente.  Shell-ul Bourne era mai curînd proiectat pentru
utilizarea sub formã de interpretor, ºi mai puþin pentru cea
interactivã.

<P>
Cînd la începutul anilor '80 la universitatea Berkeley din
California a fost dezvoltatã varianta localã de Unix, numitã BSD,
Bill Joy, un talentat programator, a scris un nou shell numit C Shell,
sau <TT>csh</TT> (pronunþat de guru în englezã ``siºi'').  (Bill Joy
este unul dintre fondatorii companiei Sun, la care actualmente este
Chief Scientist.)  Acest shell introduce facilitãþi foarte utile
pentru execuþia interactivã, dar din pãcate nu este compatibil cu
Bourne, ºi suferã de o mulþime de neajunsuri.

<P>
În 1984 David Korn, tot de la Bell Labs ale lui AT&amp;T, ºi-a propus
sã modernizeze shell-ul Bourne adãugîndu-i facilitãþi interactive
a la <TT>csh</TT>.  Astfel s-a nãscut shell-ul Korn <TT>ksh</TT>, care
este excelent realizat ºi compatibil cu Bourne.

<P>
Din pãcate <TT>ksh</TT> iniþial nu era software ``free''; aºa cã unul
din primele proiecte ale fundaþiei Free Software Foundation (vedeþi <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#open">articolul</a>
meu despre Open Source din PC Report din iunie 1998) a fost sã
implementeze un nou shell, de data asta complet ``liber''.  Acest
shell moºteneºte din ideile lui <TT>ksh</TT>, dar ia cîteva lucruri
bune de la <TT>csh</TT>.  Noul shell a fost implementat original de
Brian Fox, care era plãtit de FSF; numele shell-ului este ``Bourne
Again SHell'' (``din nou Bourne''), sau <TT>bash</TT> (citit
aproximativ ``beº'').  Acesta este shell-ul standard pe sistemele
GNU/Linux.

<P>
O miºcare paralelã a transformat substanþial <TT>csh</TT> în ceea ce
a devenit <TT>tcsh</TT>, sau ``tisiºel''.  <TT>tcsh</TT> este compatibil
cu <TT>csh</TT>, dar nu cu <TT>sh</TT>.

<P>
Prin 1981 Microsoft a lansat sistemul de operare MS-DOS.  Acesta era
echipat cu un shell foarte primitiv, numit <TT>COMMAND.COM</TT>.  Deºi
creat ulterior Unix-ului, ºi inspirat de acesta, shell-ul MS-DOS este
extrem de primitiv, inconsistent ºi greu de folosit.  Din pãcate a
rãmas, cu minore îmbunãtãþiri, shell-ul standard chiar ºi sub
Windows2000.

<P>
În Windows însã multe dintre funcþiunile unui shell sunt luate de
un program grafic, numit Command Manager sub Windows 3.1.  Pentru
utilizatori novici un shell grafic oferã o interfaþã mult mai
simplã ºi intuitivã, dar pentru un ins experimentat sau pentru un
administrator facilitãþile acestuia (ºi ale altor programe de
administrare) sunt adesea frustrante.

<P>
De aici încolo avem de a face cu o explozie de noi shell-uri, care
aduc tot felul de înflorituri ºi varietãþi; voi cita astfel: 
<TT>ash</TT>, <TT>zsh</TT>, <TT>scsh</TT>, <TT>rc</TT>, <TT>bsh</TT>,
<TT>pdksh</TT>, <TT>es</TT>.

<P>
În articolul de faþã voi vorbi despre Bourne Shell; acest shell a
evoluat ºi el de-a lungul timpului, ºi a fost ºi standardizat de
comitetul POSIX, care a standardizat Unix.  De aceea, <TT>sh</TT> este de
departe alternativa cea mai sigurã: chiar dacã nu aveþi alte
shell-uri la dispoziþie, <TT>sh</TT> este sigur disponibil (pe sisteme
gen GNU/Linux se aflã <TT>bash</TT>, care are un mod de funcþionare în
compatibilitate 100% cu <TT>sh</TT>).

<P>

<H1><A NAME="SECTION00050000000000000000">
Elemente fundamentale de programare în Shell</A>
</H1>

<P>
În restul acestui articol voi discuta doar despre programarea în
shell.  Elementele shell-ului legate de utilizarea interactivã vor fi
trecute sub totalã tãcere (cum ar fi editorul liniilor de comandã,
mecanismul de re-execuþie a comenzilor (history), controlul
job-urilor lansate în execuþie).

<P>

<H2><A NAME="SECTION00051000000000000000">
Comenzi externe</A>
</H2>

<P>
Shell-ul este un program ale cãrui capacitãþi pot fi înzecite de
faptul cã poate controla toate celelalte programe.  Am spus deja cã
shell-ul poate porni în execuþie orice alt program; în plus,
shell-ul poate influenþa în mai multe moduri mediul în care
programul respectiv este executat.  Vom vedea mai jos cîteva exemple.

<P>
Cel mai important de ºtiut pentru moment este faptul numele oricãrui
fiºier executabil (adicã un fiºier care conþine o aplicaþie) este
o comandã shell.  Astfel, fiºierul ``netscape'' conþine imaginea
executabilã a browser-ului Internet; cînd shell-ului îi este
oferitã spre execuþie comanda <TT>netscape</TT>, el va lansa în
execuþie programul acesta.  Un fiºier executabil mai este de aceea
numit ``comandã externã''.

<P>
Capacitatea de a controla alte programe dã shell-ului alura unui
limbaj extensibil; creind noi programe de fapt creãm noi ``comenzi''
pentru shell.  Shell-ul poate combina execuþia mai multor programe
controlînd comunicaþia dintre ele, creînd astfel cu uºurinþã
programe mai complicate din bucãþi simple.

<P>
Pentru ilustraþie vom folosi în acest text cu precãdere cîteva
comenzi externe simple; iatã-le rezumate aici:

<P>
<DL>
<DT><STRONG>ls:</STRONG></DT>
<DD>Programul <TT>ls</TT> se citeºte ``list'', ºi este
echivalentul lui ``dir'' din DOS.  Este urmat de o listã de nume de
fiºiere, iar efectul lui este de a afiºa chiar numele acestor
fiºiere.  Urmat de un director, afiºeazã fiºierele din acel
director.  (Fãrã argumente opereazã pe directorul ``curent''.)
Iatã un exemplu:

<P>
<PRE>
% ls
Mail  bin  data  lib  man  src  tmp
% ls src
Makefile  hello.c   
%
</PRE>

<P>
Am ilustrat aici funcþionarea interactivã a shell-ului, pe care o
vom folosi pînã avem destule elemente pentru a scrie programe mai
mari.  Caracterul <code>%</code> a fost scris de shell, fiind prompt-ul.
utilizatorul a tastat apoi <TT>ls</TT>; shell-ul a identificat acest ºir
de caractere ca fiind numele unui fiºier executabil, care a executat.
Cînd se executã, <TT>ls</TT> afiºeazã conþinutul directorului curent
(<TT>Mail</TT>, <TT>bin</TT>, etc.).  Dupã ce <TT>ls</TT> s-a terminat,
shell-ul afiºeazã din nou prompt-ul, cu promptitudine.

<P>
</DD>
<DT><STRONG>wc:</STRONG></DT>
<DD>Programul Word Count numãra liniile, cuvintele ºi
caracterele din fiºierele care-i sunt date ca argumente.  Iatã un
exemplu:

<P>
<PRE>
% wc src/hello.c
      6      9     74 src/hello.c
%
</PRE>

<P>
Vedem mai sus cã fiºierul <TT>hello.c</TT> din directorul <TT>src</TT>
are 6 linii, 9 cuvinte ºi 74 caractere.

<P>
</DD>
<DT><STRONG>cat:</STRONG></DT>
<DD>deºi înseamnã ``pisicã'', programul <TT>cat</TT> de fapt
tipãreºte conþinutul fiºierelor care-i sunt oferite drept argument
(echivalent cu <TT>type</TT> din DOS).  Numele lui vine de la
``CATalogue''.

<P>
<PRE>
% cat src/hello.c
#include &lt;stdio.h&gt;

main() {
    printf("Hello world\n");
    return 0;
}
%
</PRE>

<P>
</DD>
</DL>

<P>

<H3><A NAME="SECTION00051100000000000000">
Succes ºi eroare</A>
</H3>

<P>
În Unix, cînd un proces se terminã returneazã procesului sãu
pãrinte<A NAME="tex2html3"
  HREF="#foot115"><SUP>1</SUP></A> un cod de eroare, care permite
pãrintelui sã detecteze dacã odrasla-i s-a executat cu succes sau a
întîmpinat niºte probleme.

<P>
În mod surprinzãtor, cel puþin pentru un programator C, 0 este
codul pentru succes, ºi orice valoare nenulã indicã o eroare.  Vom
vedea mai încolo cum aceste valori pot fi folosite de shell pentru a
crea programe complicate.

<P>

<H2><A NAME="SECTION00052000000000000000">
Variabile shell</A>
</H2>

<P>
Ca orice limbaj de programare, limbajul shell-ului conþine
variabile.  În mod tradiþional, variabilele shell sunt scrise numai
cu majuscule, pentru cã în Unix programele executabile au nume
scrise cu minuscule; în felul acesta se evitã confuziile.  Valoarea
unei variabile shell este un ºir arbitrar de caractere.  Numele
variabilelor sunt aceleaºi ca în limbajul C: o literã urmatã de
litere, cifre ºi semnul ``subliniat'' <code>_</code>.

<P>
Principala limitare a shell-ului, care îl face nepractic pentru
scrierea de programe mari, constã în sãrãcia tipurilor de date
disponibile: existã un singur tip de date, ºirul de caractere.  Nu
existã numere, structuri, matrici, liste, arbori, etc.  Pentru a
scrie programe mai complicate, aceste structuri de date trebuie
implementate pornind de la ºiruri, ceea ce e complicat ºi adesea
ineficient.  Dar asta nu ne va îndepãrta de la scopul de a vedea ce
putem face totuºi folosind shell-ul.

<P>

<H3><A NAME="SECTION00052100000000000000">
Atribuiri</A>
</H3>

<P>
Cea mai simplã comandã a shell-ului este cea de atribuire; ea are
forma:

<P>
<PRE>
variabila=valoare
</PRE>

<P>
Efectul acestei comenzi este de a atribui valoarea din dreapta
variabilei din stînga.  <B>Atenþie:</B> nu puteþi pune spaþii la
stînga ºi la dreapta semnului egal.

<P>

<H3><A NAME="SECTION00052200000000000000">
Valoarea unei variabile</A>
</H3>

<P>
<TT>sh</TT> este un limbaj straniu prin faptul cã pentru a accesa
valoarea unei variabile trebuie s-o prefixãm cu semnul dolar.  Deci
atribuirea ºi citirea folosesc nume diferite!  O eroare comunã este
de a folosi dolar la atribuire sau de a uita dolarul la citire.
Atenþie, deci:

<P>
<PRE>
[1] % DIR=src
[2] % ls $DIR
[3] Makefile  hello.c
[4] % ls DIR
ls: DIR: No such file or directory
[5] % $DIR=bin
sh: src=bin: command not found
[6] % DIR=ls
[7] % $DIR src
Makefile  hello.c
[8] % DIR=$DIR$DIR
[9] % ls $DIR
ls: lsls: No such file or directory
[10] % DIR=src/
[11] % ls ${DIR}Makefile
Makefile
</PRE> 
<P>
În linia [2] variabila <TT>DIR</TT> este substituita cu valoarea sa,
<TT>src</TT>.  În linia [4], <TT>DIR</TT> este chiar numele directorului
cãutat.  Iar în linia [5], în loc sã se facã o atribuire
variabilei <TT>DIR</TT>, valoarea acesteia este substituitã, generînd
comanda <TT>src=bin</TT>, care <EM>nu</EM> este interpretatã la rîndul ei
ca o atribuire, ci este direct executatã, ºi care, fiind
inexistentã, genereazã un mesaj de eroare.  Dacã atribuim lui
<TT>DIR</TT> valoarea <TT>ls</TT>, ca în linia [6], executînd linia [7]
executãm de fapt <TT>ls&nbsp;src</TT>.  În linia [8] observãm cum putem
concatena valoarea a douã variabile juxtapunîndu-le.  În fine,
linia [11] aratã cum procedãm dacã vrem sã concatenãm valoarea
unei variabile <TT>DIR</TT> cu un alt ºir de caractere: trebuie sã
folosim acolade pentru a delimita numele variabilei.

<P>

<H3><A NAME="SECTION00052300000000000000">
Ghilimele</A>
</H3>

<P>
Shell-ul permite construirea de ºiruri de caractere folosind douã
tipuri de ghilimele: apostroful&nbsp;(<TT>&#8217;</TT>)
ºi ghilimelele duble&nbsp;(<code>"</code>).
Diferenþa între cele douã tipuri este cã între apostrofuri
valorile variabilelor <EM>nu</EM> sunt substituite, pe cînd între
ghilimele sunt.  (La fel ºi pentru expresiile regulate, despre care
nu am vorbit încã).  Ghilimelele sunt utile cînd vrem sã includem
spaþii în valorile variabilelor.

<P>

<H3><A NAME="SECTION00052400000000000000">
Variabile interne</A>
</H3>

<P>
Shell-ul însuºi foloseºte unele variabile pentru nevoile sale
interne.  Schimbînd valoarea acestor variabile putem afecta
comportarea sa.  De exemplu, variabila numitã <TT>PS1</TT> este chiar
prompt-ul.  Variabila internã <TT>PWD</TT> este directorul curent.

<P>
<PRE>
% PS1="ordonati, stapine: "
ordonati, stapine: ls
Mail  bin  data  lib  man  src  tmp
ordonati, stapine:
</PRE>

<P>
Unele din variabilele interne nu pot fi atribuite, ci pot fi doar
citite.  Unele din acestea au nume stranii, formate din alte caractere
decît litere ºi cifre; de exemplu variabila <code>$?</code> conþine
rezultatul cu care s-a terminat ultima comandã (0 pentru succes).
<P>

<H2><A NAME="SECTION00053000000000000000">
Comenzi interne importante</A>
</H2>

<P>
Unele comenzi ar putea fi implementate atît sub formã de comenzi
interne cît ºi externe.  Dar altele trebuie neapãrat sã fie
implementate de cãtre shell.  De exemplu comanda <TT>cd</TT>, care
schimbã directorul curent: aceasta nu poate fi o comandã externã;
dacã <TT>cd</TT> ar fi implementatã de un program separat, atunci cînd
shell-ul ar porni programul numit <TT>cd</TT>, acesta s-ar executa, ar
schimbã directorul sãu curent dupã care s-ar terminã.  Dar
schimbãrile fãcute de un proces fiu nu se propagã la pãrinþii lui
(ci doar invers), deci shell-ul rãmîne în directorul iniþial.

<P>
În aceastã secþiune vom vedea alte cîteva comenzi interne
importante.

<P>
<DL>
<DT><STRONG>cd:</STRONG></DT>
<DD>(change directory) este urmatã de numele unui director ºi
schimbã directorul curent în acel director;

<P>
</DD>
<DT><STRONG>exit:</STRONG></DT>
<DD>este urmatã de o valoare numericã; shell-ul îºi
terminã execuþia cu valoarea indicatã.  Deci <TT>exit&nbsp;0</TT>
înseamnã ``succes''.  Adesea programatorii utilizeaza acest cod
pentru a transmite procesului-pãrinte informaþii despre eroarea
petrecutã;

<P>
</DD>
<DT><STRONG>echo:</STRONG></DT>
<DD>(ecou) îºi tipãreºte argumentele.  Este o comandã
deosebit de utilã:

<P>
<PRE>
[1] % DIR=src
[2] % echo DIR $DIR
DIR src
[3] % echo DIR         DIR
DIR DIR
[4] % echo "DIR         DIR"
DIR         DIR
[5] % echo "$DIR         $DIR"
src         src
[6] % echo '$DIR         $DIR'
$DIR         $DIR
</PRE>
 
<P>
Observaþi diferenþa între liniile [3] ºi [4]; în linia [3]
<TT>echo</TT> primeºte douã argumente, iar în linia [4] primeºte
unul singur, un ºir care conþine ºi spaþii.

<P>
</DD>
<DT><STRONG>eval:</STRONG></DT>
<DD>Aceasta este o comandã extrem de puternicã.  Argumentul
ei este un ºir de caractere, care este executat ca ºi cum ar fi o
comandã shell.

<P>
<PRE>
[1] % DIR=src
[2] % COMANDA=ls
[3] % echo "$COMANDA $DIR"
ls src
[4] % eval "$COMANDA $DIR"
Makefile  hello.c
</PRE>

<P>
</DD>
<DT><STRONG>test:</STRONG></DT>
<DD>e foarte utilã pentru a evalua expresii boolene (care
adicã genereazã un rezultat ``adevãrat'' sau ``fals'').  Ca ºi
codurile de eroare ale proceselor, ``adevãrat'' este 0, iar fals este
orice valoare diferitã de 0.  

<P>
<TT>test</TT> poate face patru feluri de teste diferite:

<P>

<UL>
<LI>Teste asupra fiºierelor; de exemplu:

<P>

<UL>
<LI><TT>test -f fisier</TT> returneazã ``adevãrat'', adicã 0
(zero), dacã fiºierul indicat existã ºi este un fiºier ordinar
(adicã nu un director).
</LI>
<LI><TT>test -d director</TT> testeazã existenþa unui director
</LI>
<LI><TT>test -r fisier</TT> vede dacã fiºierul poate fi citit
(permisiunile de citire dau dreptul acestui utilizator)
</LI>
<LI><TT>fisier1 -nt fisier2</TT> e adevãrat dacã primul fiºier este
mai nou decît al doilea (newer than).
</LI>
</UL>

<P>
</LI>
<LI>Teste pentru ºiruri de caractere:

<UL>
<LI><TT>test -z sir</TT> testeazã dacã ºirul conþine vreun
caracter (e nenul)
</LI>
<LI><TT>test sir1 = sir2</TT> testeazã dacã cele douã ºiruri sunt
egale
</LI>
<LI><TT>test sir1 != sir2</TT> testeazã dacã ºirurile sunt diferite
</LI>
</UL>

<P>
</LI>
<LI>Teste pentru valori numerice: se pot folosi operaþiile
<TT>-eq,-ne,-le,-lt,-gt,-ge</TT> pentru egal (equal), inegal (not equal),
mai mic sau egal (less or equal), mai mic (less than), mai mare
(greater than) sau mai mare sau egal (greater or equal), respectiv.

<P>
Nu folosiþi <TT>=</TT> sau <TT>==</TT> pentru a compara numere!

<P>
</LI>
<LI>Teste pentru valori boolene: puteþi folosi <TT>-a</TT> pentru
``ºi'' (and), <TT>-o</TT> pentru ``sau'' (or) ºi <TT>!</TT> pentru
negaþie.

<P>
Din pãcate nu puteþi folosi paranteze; pentru expresii mai
complicate vedeþi mai jos comanda <TT>expr</TT>.
</LI>
</UL>

<P>
<PRE>
% DIR=src; FILE=Makefile
% test -f $DIR/$FILE
% echo $?
0
%
</PRE>

<P>
În exemplul anterior ilustrãm mai multe concepte noi: în prima
linie punem douã comenzi pe aceeaºi linie, separîndu-le cu
punct-ºi-virgulã.  În linia a doua testãm existenþa unui
fiºier.  În linia a treia tipãrim rezultatul testului anterior
(vã amintiþi cã variabila <code>$?</code> conþine rezultatul ultimei
comenzi executate, ºi cã 0 reprezintã succes). 
<P>
Pentru convenienþa utilizatorului, existã o comandã cu numele
<TT>[</TT> (parantezã dreaptã deschisã), care este echivalentã cu
<TT>test</TT>.  Astfel în loc de: <TT>test&nbsp;-f&nbsp;fisier</TT> putem scrie:
<TT>[&nbsp;-f&nbsp;fisier&nbsp;]</TT>.  Observaþi cã paranteza trebuie închisã, ºi
în plus <EM>trebuie lãsate spaþii în jurul parantezelor</EM>.

<P>
</DD>
<DT><STRONG>if:</STRONG></DT>
<DD>Putem face tot felul de teste, dar cum putem beneficia de
rezultatul lor?  Folosind instrucþiunea de execuþie condiþionalã,
ca în urmãtorul exemplu:

<P>
<PRE>
% DIR=src; FILE=Makefile
% if [ -f $DIR/$FILE ]; then echo "Exista"; else echo "Nu exista"; fi
Exista
%
</PRE>

<P>
Aici am combinat douã comenzi: <TT>if</TT> ºi <TT>test</TT>.  Comanda
internã <TT>if</TT> este urmatã de o altã comandã.  Dacã cea din
urmã se terminã cu succes (returneazã 0), atunci comanda de dupã
<TT>then</TT> este executatã; altfel ramura de dupã <TT>else</TT>.  Nu-l
uitaþi pe <TT>fi</TT> la sfîrºit.

<P>
Cînd compunem un script putem separa pãrþile unui <TT>if</TT> pe mai
multe linii.  Iatã un exemplu de script:

<P>
<PRE>
#!/bin/sh

# acest script tipareste fisierul argument, sau un mesaj de 
# eroare daca acesta nu exista

if [ $# != 1 ]; then
        echo "Imi trebuie un argument"
        exit 1
elif [ -f $1 ]; then
        cat $1
else
        echo "$1 nu exista"
fi
</PRE>

<P>
Acesta este deja un script interesant, care introduce cîteva elemente
noi:

<P>

<UL>
<LI>Comentariile în shell sunt introduse de semnul diez (<code>#</code>)
ºi se terminã odatã cu linia;
</LI>
<LI>Prima linie este o convenþie Unix: dacã un fiºier începe cu
semnele <code>#!/</code>, atunci urmeazã numele unui interpretor care
trebuie sã execute acest program;
</LI>
<LI>Variabila internã <code>$#</code> conþine numãrul de argumente
primite de shell în linia de comandã; </LI>
<LI>Observaþi folosirea lui <TT>elif</TT> în loc de <TT>else&nbsp;if</TT>;
</LI>
<LI>Variabilele <code>$1</code>, <code>$2</code>, ..., <code>$9</code> conþin
argumentele însele. </LI>
</UL>

<P>
Dacã punem script-ul anterior în fiºierul numit ``arata.sh'', putem
sã-l executãm cu secvenþa de comenzi:

<P>
<PRE>
% chmod a+x arata.sh
% ./arata.sh
Imi trebuie un argument
% ./arata.sh bibi
bibi nu exista
% ./arata.sh src/hello.c
#include &lt;stdio.h&gt;

main() {
    printf("Hello world\n");
    return 0;
}
%
</PRE>

<P>
Comanda <TT>chmod a+x arata.sh</TT> are drept efect de a face fiºierul
<TT>arata.sh</TT> executabil în aºa fel încît oricine sã-l poatã executa
(CHange the MODe for All to add (+) eXecutable).

<P>
Observaþi cã pornim script-ul în execuþie indicînd directorul
unde se aflã (<TT>./arata.sh</TT>).  Dacã un program nu este indicat
exact prin directorul sãu, shell-ul foloseºte o variabilã numitã
<TT>PATH</TT> care indicã o serie de directoare (separate cu semnul
douã puncte) unde acest script trebuie cãutat.  Încercaþi ºi
<code>echo $PATH</code>. 
<P>
</DD>
<DT></DT>
<DD>read: citeºte cuvinte într-una sau mai multe variabile:

<P>
<PRE>
% read a b c
tastez multe cuvinte sa vedem cum merg
% echo ":$a:$b:$c:"
:tastez:multe:cuvinte sa vedem cum merg:
%
</PRE>
 
<P>
Read citeºte de la intrare o linie (linia care apare dupã comandã a
fost introdusã de la tastaturã, ºi nu tipãritã de shell); apoi
<TT>read</TT> sparge linia în cuvinte separate de spaþii, ºi fiecare
cuvînt este atribuit unei variabile; ultima variabilã primeºte
restul liniei pînã la sfîrºit.

<P>
</DD>
<DT><STRONG>for:</STRONG></DT>
<DD>permite sã executãm un ciclu într-o listã de cuvinte,
astfel:

<P>
<PRE>
for i in hello goodbye ok; do
    for j in .o .c~; do
        if [ -f $i$j ]; then 
            echo "Sterg $i$j"
            rm $i$j
        fi
    done
done
</PRE>

<P>
Acest program cautã fiºierele <TT>hello</TT>, <TT>goodbye</TT> sau
<TT>ok</TT> urmate de sufixul <TT>.o</TT> sau <code>.c~</code> (ceea ce în
genere înseamnã fiºier obiect, respectiv o versiune veche a unui
fiºier C) ºi le ºterge.  Observaþi douã bucle imbricate.
</DD>
</DL>

<P>
Înainte de a prezenta alte cîteva comenzi interne foarte utile, vom
discuta sumar despre alte funcþiuni foarte importante ale shell-ului.

<P>

<H2><A NAME="SECTION00054000000000000000">
Expansiunea expresiilor regulate</A>
</H2>

<P>
O trãsãturã extrem de puternicã a shell-ului este cã poate expanda
<EM>expresii regulate</EM> care descriu succint nume de fiºiere.
Pentru cã am scris de curînd un <a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#regex">articol</a>
despre acest subiect (în PC Report din aprilie 2000), voi fi foarte
sumar aici, prezentînd doar cîteva exemple:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>Expresie</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340><B>Semnificaþie</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>a*</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>Toate fiºierele al cãror nume începe cu <TT>a</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>*.c</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>Toate fiºierele al cãror nume se terminã cu <TT>.c</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>.??*</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>Toate fiºierele al cãror nume începe cu punct ºi
               conþine cel puþin 3 caractere</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>*/src/*.c</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>Toate fiºierele terminate cu <TT>.c</TT> aflate în
	           subdirectorul <TT>src</TT> al oricãrui director din
		   directorul curent.</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>*[0-3]*</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>Toate fiºierele care conþin una din cifrele 0,1,2 sau 3
                 în nume</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>{ab,cd}.{c,h}</code></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=340>fiºierele existente în mulþimea
		       <TT>ab.c</TT>, <TT>ab.h</TT>, <TT>cd.c</TT>,
	               <TT>cd.h</TT></TD>
</TR>
</TABLE>
</DIV>

<P>
Iatã ºi un program care foloseºte expresiile regulate:

<P>
<PRE>
#!/bin/sh

ACEST_SCRIPT=$0

for i in *.c; do
        if [ -f $i ]; then echo $i; fi
done

for i in *; do
        if [ -d $i ]; then 
                cd $i; $ACEST_SCRIPT; cd ..
        fi
done
</PRE>

<P>
Dacã script-ul anterior este în undeva într-un director indicat de
variabila <TT>PATH</TT>, atunci execuþia lui va cauza tipãrirea
tuturor fiºierelor C dintr-o ierarhie de directoare.  Observaþi cum
script-ul foloseºte variabila <code>$0</code>, care conþine propriul lui
nume, pentru a se auto-executa în toate sub-directoarele. 
<P>

<H2><A NAME="SECTION00055000000000000000">
Comenzi paralele</A>
</H2>

<P>
Am vãzut cã putem folosi semnul punct-ºi-virgulã pentru a lansa
în execuþie mai multe comenzi succesiv.  Dacã vrem sã lansãm în
execuþie douã comenzi simultan, punem între ele semnul <code>&amp;</code>:

<P>
<PRE>
% netscape &amp; xterm &amp;
%
</PRE>

<P>
Aceastã comandã va lansa în execuþie programul netscape, ºi
fãrã a aºtepta terminarea sa va lansa ºi programul xterm.  Semnul
<code>&amp;</code> de la sfîrºit îi spune shell-ului sã nu aºtepte nici
terminarea lui xterm, ci sã ofere un nou prompt.

<P>
Se pot de asemenea folosi semnele <code>&amp;&amp;</code> ºi <code>||</code>.  Dacã
scriem <TT>c1&nbsp;&amp;&amp;&nbsp;c2</TT>, înseamnã cã vrem ca <TT>c2</TT> sã se
execute dacã ºi numai dacã <TT>c1</TT> se terminã cu succes.
Dimpotrivã, <code>c1 || c2</code> înseamnã cã <TT>c2</TT> se executã dacã
ºi numai dacã <TT>c1</TT> a eºuat.

<P>

<H2><A NAME="SECTION00056000000000000000">
Redirectare ºi conducte (pipes)</A>
</H2>

<P>
Cînd shell-ul lanseazã un proces are posibilitatea de a cupla
intrarea ºi ieºirea acestuia în diferite moduri.  În Unix fiecare
proces la pornire are 3 canale de comunicaþie deschise: un canal de
la care primeºte date (intrarea), unul la care scrie date (ieºirea)
ºi unul la care scrie erori.  Pentru shell în mod normal aceste
canale sunt cuplate la tastatura ºi respectiv ecran.  Ele pot fi
însã redirecþionate spre fiºiere foarte simplu:

<P>
<PRE>
% ls &gt;lista
% cat lista
Mail  bin  data  lib  man  src  tmp
% 
</PRE>

<P>
Semnul <code>&gt;</code> este urmat de un fiºier; ieºirea comenzii executate
este ``depusã'' atunci în acel fiºier.

<P>
Mai spectaculos este cã putem cupla ieºirea unui proces la intrarea
altuia folosind un singur caracter, scris <code>|</code> ºi citit
``þeavã'' (pipe).  Pentru a afla de exemplu cîte fiºiere sunt în
directorul curent, putem folosi:

<P>
<PRE>
% ls | wc -w
7
% ls &gt;lista
% wc -w lista
7
% rm lista
</PRE>

<P>
<TT>wc -w</TT> numãra doar cuvintele (words).  Pentru a numãra
fiºierele putem fie trimite rezultatul lui <TT>ls</TT> într-un fiºier
<TT>lista</TT> folosind redirectare, dupã care putem numãra cuvintele,
sau, mult mai eficient ºi rapid, putem cupla ieºirea lui <TT>ls</TT> la
intrarea lui <TT>wc</TT> cu o þeavã, ca în prima linie.

<P>
Un idiom ades folosit este de a redirecta erorile spre un dispozitiv
fictiv numit <TT>/dev/null</TT>, care este gãleata de gunoi pe un
sistem Unix:

<P>
<PRE>
% wc -l *.c */*.c 2&gt;/dev/null
</PRE>

<P>
Aceastã comandã numãrã liniile din toate fiºierele care se
terminã cu <TT>.c</TT> în directorul curent ºi în toate
subdirectoarele sale.  Dacã unele din fiºiere sunt însã ilizibile
(de exemplu pentru cã avem directoare al cãror nume se terminã cu
<TT>.c</TT>), atunci <TT>wc</TT> va tipãri niºte erori, care însã vor fi
trimise spre ``null'' datoritã redirectãrii canalului de eroare,
designat de <code>2&gt;</code>.

<P>

<H2><A NAME="SECTION00057000000000000000">
Accentul grav</A>
</H2>

<P>
O facilitate extrem de puternicã a shell-ului este oferitã de
semnele de accent grav <code>`</code>.  Orice este cuprins între semne de
accent grav este executat ca o comandã; rezultatul acelei comenzi
devine un ºir de caractere, care înlocuieºte comanda între accente
grave.

<P>
<PRE>
% wc -w src/hello.c
9 src/hello.c
% a=`wc -w src/hello.c`
% echo $a
9 src/hello.c
%
</PRE> 
<P>

<H2><A NAME="SECTION00058000000000000000">
Alte comenzi</A>
</H2>

<P>
<DL>
<DT><STRONG>while:</STRONG></DT>
<DD>ne permite sã ciclãm în mod repetat.  În script-ul
de mai jos, <TT>while</TT> se executã atîta timp cît comanda
<TT>read</TT> funcþioneazã cu succes; astfel citim fiecare linie din
fiºierul <TT>text-de-prelucrat</TT>.  Tipãrim apoi numai liniile care
au mai mult de 10 cuvinte.

<P>
<PRE>
#!/bin/sh

cat text-de-prelucrat | while read linie; do
    cuvinte=`echo $linie | wc -w`
    if [ $cuvinte -ge 10 ]; then
        echo $linie
    fi
done
</PRE> 
<P>
</DD>
<DT><STRONG>expr:</STRONG></DT>
<DD>permite shell-ului sã opereze ºi cu numere.  Am vãzut
cã singurul tip de date al shell-ului sunt ºirurile de caractere.
Cum putem atunci face ceva aritmeticã?  Comanda <TT>expr</TT> este
urmatã de o expresie aritmetica a cãrei valoare o tipãreºte la
ieºire.  E o metodã un pic cam complicatã pentru a evalua simple
expresii aritmetice, dar dacã faceþi puþine calcule, e foarte
practicã.  Trebuie sã fiþi atenþi sã separaþi <EM>toate</EM>
argumentele lui <TT>expr</TT> cu spaþii.

<P>
<PRE>
#!/bin/sh

contor=0
while [ $contor -le 100 ]; do
        echo $contor
        contor=`expr $contor + 1`
done
</PRE>
</DD>
</DL>

<P>

<H1><A NAME="SECTION00060000000000000000">
Încheiere</A>
</H1>

<P>
Aici pun capãt acestei incursiuni blitz în programarea în shell.
Sper sã vã fi pus la-ndemînã suficiente scule ca sã puteþi sã
scrieþi programe utile.  Shell-urile moderne sunt foarte sofisticate,
oferã o sumedenie de facilitãþi suplimentare, ºi pot fi
configurate ºi adaptate în mii de moduri.  Dar 90% din problemele
întîlnite în practicã pot fi rezolvate folosind cele 10% din
limbaj pe care le-am prezentat.

<P>
Oricum, nu puteþi sã vã perfecþionaþi decît folosind limbajul;
m-aº bucura dacã v-am dat motive sã încercaþi.

<P>

<H1><A NAME="SECTION00070000000000000000">
Alte surse de informaþie</A>
</H1>

<P>

<UL>
<LI>S-au publicat o mulþime de cãrþi despre programarea în
shell; din cauzã ca eu însumi nu am citit nici una, mã voi feri sã
recomand ceva; un manual tipãrit de referinþã cu exemple bune este
însã foarte util;

<P>
</LI>
<LI>În general pe grupurile de discuþii Usenet se vehiculeazã
multe gunoaie; de departe însã cel mai bun grup la care am fost
vreodatã abonat este <TT><A NAME="tex2html4"
  HREF="news:comp.unix.shell">news:comp.unix.shell</A></TT>.  O sumedenie de
experþi vor rãspunde imediat la orice întrebare legatã de shell
aþi avea; în plus discuþiile sunt uneori foarte interesante;

<P>
</LI>
<LI>Foarte multe informaþii interesante sunt în fiºiere de tip
FAQ: Frequently Asked Questions, arhivate în multe locuri pe
Internet, de pildã la <TT><A NAME="tex2html5"
  HREF="faqs.org">faqs.org</A></TT>.  Recomand urmãtoarele
fiºiere:

<P>

<UL>
<LI><TT><A NAME="tex2html6"
  HREF="http://www.faqs.org/faqs/unix-faq/shell/bash">http://www.faqs.org/faqs/unix-faq/shell/bash</A></TT>:
întrebãri frecvente despre Bash;

<P>
</LI>
<LI><TT><A NAME="tex2html7"
  HREF="http://www.faqs.org/faqs/unix-faq/faq/part5">http://www.faqs.org/faqs/unix-faq/faq/part5</A></TT>:
partea a cincea a acestei ``Unix FAQ'' discutã în mod special despre
shell-uri;

<P>
</LI>
<LI><TT><A NAME="tex2html8"
  HREF="http://www.faqs.org/faqs/unix-faq/shell/shell-differences">http://www.faqs.org/faqs/unix-faq/shell/shell-differences</A></TT> 
discutã despre istoricul shell-ului ºi despre diferenþele între shell-uri.
</LI>
</UL>

<P>
</LI>
<LI>O paginã interesantã aflatã la
<TT><A NAME="tex2html9"
  HREF="http://www.fi.uib.no/~btk/data/shell-100.BetaA.html">http://www.fi.uib.no/~btk/data/shell-100.BetaA.html</A></TT> discutã
echivalenþele comenzilor din diferitele shell-uri;

<P>
</LI>
<LI>Dacã aveþi un sistem Linux, atunci paginile de manual
<TT>man&nbsp;bash</TT> ºi <TT>man&nbsp;tcsh</TT> sunt probabil instalate.  Am
apelat la ele adesea în cursul scrierii acestui articol;

<P>
</LI>
<LI>Pagina shell-ului <TT>bash</TT> la <TT><A NAME="tex2html10"
  HREF="http://www.gnu.org/software/bash/bash.html">http://www.gnu.org/software/bash/bash.html</A></TT>;

<P>
</LI>
<LI>Tcsh este disponibil (cod ºi manuale) la <TT><A NAME="tex2html11"
  HREF="ftp://ftp.gw.com/pub/unix/tcsh">ftp://ftp.gw.com/pub/unix/tcsh</A></TT>.
</LI>
</UL>

<P>
<BR><HR><H4>Note</H4>
<DL>
<DT><A NAME="foot115">... pãrinte</A><A NAME="foot115"
 HREF="shell-2-html.html#tex2html3"><SUP>1</SUP></A>
<DD>Acesta este procesul care l-a pornit în execuþie, în
cazul nostru shell-ul însuºi.

</DL>
<BR><HR>

</BODY>
</HTML>
