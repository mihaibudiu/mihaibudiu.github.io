<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Shell-ul; cazul Unix</TITLE>
<META NAME="description" CONTENT="Shell-ul; cazul Unix">
<META NAME="keywords" CONTENT="shell-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Shell-ul; cazul Unix</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- mihaib+@cs.cmu.edu 
<BR><TT>http://www.cs.cmu.edu/~mihaib</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>11 aprilie 1997</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Ce este un shell; un exemplu pentru Unix.
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>Programare în C sub Unix de cel puþin
un 1 an vechime.
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>proces, apel de sistem, shell, biblioteci,
interpretor.
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html17"
  HREF="shell-html.html">Ce este un shell?</A>
<UL>
<LI><A NAME="tex2html18"
  HREF="#SECTION00021000000000000000">Bucla principalã</A>
</UL>
<BR>
<LI><A NAME="tex2html19"
  HREF="#SECTION00030000000000000000">Cel mai simplu exemplu</A>
<UL>
<LI><A NAME="tex2html20"
  HREF="#SECTION00031000000000000000">Cãrãmizile: funcþiile de bibliotecã</A>
<LI><A NAME="tex2html21"
  HREF="#SECTION00032000000000000000">Apeluri de sistem</A>
<LI><A NAME="tex2html22"
  HREF="#SECTION00033000000000000000">Ansamblul</A>
</UL>
<BR>
<LI><A NAME="tex2html23"
  HREF="#SECTION00040000000000000000">Recompensã</A>
<LI><A NAME="tex2html24"
  HREF="#SECTION00050000000000000000">Rezumat</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>
Orice utilizator al unui calculator interacþioneazã la un moment dat
cu shell-ul.  Fie cã apare sub forma unor iconiþe mititele, fie sub
forma unui <EM>prompt</EM> care invitã la tastarea unor comenzi, shell-ul
este prima interfaþã pe care un sistem de operare o oferã
utilizatorilor sãi.  În acest articol ne propunem sã arãtãm cã
shell-ul este un program ca oricare altul ºi sã arãtãm cum poate
fi construit unul în cazul sistemului de operare Unix.

<P>

<H1><A NAME="SECTION00020000000000000000">
Ce este un shell?</A>
</H1>

<P>
Cuvîntul <EM>shell</EM> înseamnã în limba englezã <EM>scoicã</EM> sau
carapace.  Asta este ºi programul care se numeºte shell pentru
sistemul de operare: un înveliº care îmbracã sistemul, primul
lucru pe care îl vedem dintr-un sistem de operare, ºi pe care
trebuie sã-l dãm la o parte pentru a zãri mãruntaiele moluºtei.

<P>
Pentru a fi concreþi ne vom plasa în contextul sistemului de operare
Unix.  Ideile prezentate sunt însã valabile ºi pentru alte sisteme
de operare, deºi corespondenþa poate sã nu fie evidentã.

<P>
Teza centralã a acestui articol este urmãtoarea: un nucleu de sistem
de operare este o bibliotecã de funcþii, care pune la dispoziþia
utilizatorului o serie de operaþii, numite ``apeluri de sistem''
(vedeþi ºi articolul ``<a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#nucleu">Nucleul</a>''
din PC Report Decembrie 1996).  Shell-ul este un simplu program care
foloseºte aceste operaþii pentru a oferi o primã interfaþã cu
utilizatorul.

<P>

<PRE>
                            utilizator
                            |       ^
                     comenzi|       |rezultate
                    --------v-------|---------
                    |    shell  |  proces    |
                    |           |            |
                    |---v----------------^---|
                    |    \_creaza_proces_/   |
                    |                        |
                    |         nucleu         |
                    --------------------------
                    |       hardware         |
                    --------------------------
</PRE>

<P>

<H2><A NAME="SECTION00021000000000000000">
Bucla principalã</A>
</H2>

<P>
Misiunea unui shell este de a citi de la utilizator comenzi pe care
apoi le interpreteazã ºi le executã.  Executarea comenzilor se face
folosind apelurile de sistem.  Pe scurt, orice shell are structura
urmãtoare:

<P>
<PRE>
while (1) {
/* 1 */   scrie_prompt();
/* 2 */   linie = citeste_linie_de_la_utilizator();
/* 3 */   comanda = identifica_comanda(linie);
/* 4 */   argumente = identifica_argumente(linie);
/* 5 */   executa_comanda(comanda, argumente);
/* 6 */   asteapta_terminarea_comenzii();
}
</PRE>

<P>
Apelurile de sistem sunt folosite pentru:

<P>

<UL>
<LI>A scrie utilizatorului mesaje (prompt);
</LI>
<LI>a citi tastele apãsate de utilizator;
</LI>
<LI>a ruga nucleul sã execute o comandã;
</LI>
<LI>a aºtepta executarea acesteia sã se termine.
</LI>
</UL>

<P>
Observaþi cã shell-ul <EM>nu</EM> scrie nici un fel de rezultate pe
ecran (poate doar cînd s-a produs o eroare)!  Shell-ul citeºte un
nume de comandã, pe care o executã ca un proces separat.  Acest
proces este cel care tipãreºte rezultatele vãzute de utilizator.

<P>
De exemplu, cînd folosiþi un sistem Unix, o interacþiune tipicã
este:

<P>
<PRE>
UNIX(r) System V Release 4.0 (hoho.cs.cornell.edu)

login: budiu
Password:
Last login: Thu Apr 10 17:42:44 from hyndla.cs.cornel
[budiu]:/home/budiu $ /bin/id
uid=831(budiu) gid=831(budiu)
[budiu]:/home/budiu $ /bin/ls /
cdrom       etc         lib         usr         export      lost+found
var         mnt         proc        bin         dev         home
net         sbin        devices     kernel      tmp
</PRE>

<P>
Textul <TT>login:</TT> este scris de programul <TT>getty</TT>, care
aºteaptã sã vinã cineva la terminal.  Textul <TT>Password:</TT> este
scris de programul <TT>login</TT>, care vrea sã mã identifice.  Dupã
ce am fost identificat, porneºte shell-ul.  (Paragraful acesta se
poate dovedi eliptic; vom reveni poate cu altã ocazie despre sistemul
de autentificare din Unix; vedeþi ºi articolul din PC Report ``<a
href="http://www.cs.cmu.edu/~mihaib/articles/articles.html#usa">Uºa
din spate</a>'' din aprilie 1997 pentru informaþii).

<P>
În fine, textul <TT>[budiu]:/home/budiu $</TT> este scris de shell-ul
meu.  Acesta este <EM>prompt</EM>-ul, prin care shell-ul mã invitã sã
tastez o comandã pentru el.  Dacã ne referim la pseudo-codul de mai
sus, (din secþiunea ``bucla principalã'') acum s-a executat linia
<TT>/* 1 */</TT>.

<P>
Eu tastez întîi <TT>/bin/id</TT> ca sã vãd cine sunt eu.  Shell-ul
executã linia <TT>/* 2 */</TT>, captînd caracterele apãsate de mine
ºi strîngîndu-le la un loc.

<P>
Cînd tastez ENTER, shell-ul pricepe cã am terminat o comandã, ºi
trece la liniile <TT>/* 3 */</TT> ºi apoi <TT>/* 4 */</TT>.  Descifreazã
cuvîntul <TT>/bin/id</TT>, care este numele unui fiºier.  Acest fiºier
este codul executabil al comenzii <TT>id</TT>, pe care eu o doresc
executatã.  Pentru cã nu mai existã alte cuvinte dupã <TT>/bin/id</TT>, aceastã comandã nu are argumente.  (Sintaxa comenzilor
este o convenþie impusã de cel care a scris shell-ul).

<P>
Acum shell-ul meu trece la faza <TT>/* 5 */</TT>, rugînd nucleul
sistemului de operare sã execute fiºierul <TT>/bin/id</TT>.  Shell-ul
între timp aºteaptã terminarea ei, în faza <TT>/* 6 */</TT>.  Comanda
<TT>/bin/id</TT> este executatã ºi provoacã scrierea pe ecran a
textului <TT>uid=831(budiu) gid=831(budiu)</TT>.

<P>
Pentru cã <TT>id</TT> s-a terminat, shell-ul o ia de la capãt în bucla
<TT>while</TT>, citind o nouã comandã.

<P>
Pentru cã voi tasta de data asta <TT>/bin/ls /</TT>, shell-ul va
interpreta asta ca o comandã <TT>/bin/ls</TT> urmatã de un argument,
directorul rãdãcinã, <TT>/</TT>, ºi va ruga nucleul sã execute
comanda <TT>ls</TT> cu argumentul <TT>/</TT>.  Rezultatul executãrii se
vede pe ecran: <TT>ls</TT> scrie conþinutul directorului rãdãcinã.

<P>
Observaþi cum pe ecran alterneazã texte scrise de shell ºi de
comenzile executate de el.

<P>

<H1><A NAME="SECTION00030000000000000000">
Cel mai simplu exemplu</A>
</H1>

<P>
ªi ca sã nu rãmînem în abstract, iatã probabil cel mai simplu
exemplu posibil de shell pentru sistemul Unix, care este pe deplin
funcþional!  (Încercaþi-l!)  Shell-urile moderne oferã o grãmadã
de funcþionalitãþi suplimentare care fac viaþã utilizatorului mai
simplã, dar la rigoare exemplul din codul de mai jos este perfect
suficient, deºi nu întotdeauna foarte convenabil de folosit.  O
virtute incontestabilã însã are, ºi anume simplitatea, lucru care
îl ºi face subiectul nostru de studiu.

<P>
Acest program este luat de pe Internet, din grupul de discuþii <TT>comp.unix.shell</TT>, unde eu l-am vãzut trimis de Brian S. Hiles
(bsh20858@news.fhda.edu).

<P>
<PRE>
/* smallest shell */
a,b[99],*c,d[99];main(){while(printf("&gt;"),c=d,*c=a=gets(b)){
for(;*++c=strtok(a," ");a=0);fork()?wait(0):execvp(*d,d+1);}}
</PRE>

<P>
Puteþi compila ºi executa acest program pe orice platformã Unix
care posedã un compilator de C.  Dacã fiºierul se numeºte <TT>shell.c</TT>, puteþi sa o faceþi în urmãtorul fel:

<P>
<PRE>
$ cc shell.c -o shell
"shell.c", line 2: warning: old-style declaration or incorrect type for: a
"shell.c", line 2: warning: old-style declaration or incorrect type for: b
"shell.c", line 2: warning: old-style declaration or incorrect type for: c
"shell.c", line 2: warning: old-style declaration or incorrect type for: d
$ ./shell
&gt;
</PRE>

<P>
(Nu trebuie sã vã îngrijoreze eventuale <EM>warning</EM>-uri;
programul este corect.)

<P>
Semnul <TT>&gt;</TT> este prompt-ul.  Puteþi tasta orice comandã:

<P>
<PRE>
&gt; /bin/ls /
cdrom       etc         lib         usr         export      lost+found
var         mnt         proc        bin         dev         home
net         sbin        devices     kernel      tmp
&gt; /bin/id
uid=831(budiu) gid=831(budiu)
&gt;
</PRE>

<P>
Puteþi tasta CONTROL-d pentru a termina interacþiunea cu el.

<P>
Sã vedem cum funcþioneazã aceastã miniaturã.  Dacã aþi
înþeles totul sunteþi un expert, atît în C, cît ºi în Unix.
Este remarcabil cîte tehnici interesante de programare se aflã
într-un program atît de scurt...

<P>

<H2><A NAME="SECTION00031000000000000000">
Cãrãmizile: funcþiile de bibliotecã</A>
</H2>

<P>
Înainte de a încerca sã înþelegem cum procedeazã, sã analizãm
fiecare din funcþiile C folosite.  O parte din funcþii sunt C
standard, si este oferitã de orice compilator civilizat (<TT>printf(), gets(), strtok()</TT>), altele sunt apeluri de sistem Unix (<TT>fork(), execvp(), wait()</TT>).

<P>

<H3><A NAME="SECTION00031100000000000000">
<TT>printf()</TT></A>
</H3>

<P>
Prima ºi cea mai simplã funcþie folositã este <TT>printf()</TT>.  Ea
este folositã pentru a tipãri prompt-ul.  Aceastã funcþie este o
funcþie de bibliotecã, dar care este implementatã la rîndul ei în
termenii apelului de sistem <TT>write()</TT>, cu care în Unix se pot
trimite date spre un periferic (în acest caz ecranul).

<P>
Deºi este extrem de interesantã în sine, nu-i vom consacra lui <TT>printf()</TT> mai multe rînduri, ca sã nu ne îndepãrtãm de scopul
nostru declarat.

<P>

<H3><A NAME="SECTION00031200000000000000">
<TT>gets()</TT></A>
</H3>

<P>
Funcþia <TT>gets()</TT> este ``opusa'' lui <TT>printf()</TT>: este
folositã pentru a citi o linie de la utilizator.  Argumentul ei este
un array de caractere, unde va pune rezultatul citirii (un ºir de
caractere).  Rezultatul apelului funcþiei este chiar argumentul ei
(sau 0 dacã s-a întîlnit ``sfîrºitul de fiºier'', ceea ce în
cazul utilizatorului în general înseamnã cã acesta a apãsat
CONTROL-d).  În plus, <TT>gets()</TT> schimbã sfîrºitul de linie
(<code>\n</code>) cu un sfîrºit de ºir (<code>\0</code>).

<P>
Ca ºi <TT>printf()</TT>, <TT>gets()</TT> este o construitã din cãrãmizi
mai mici, din care principala este apelul de sistem <TT>read()</TT>, care
(opusul lui <TT>write()</TT>), citeºte date de la un periferic sau
fiºier.

<P>

<H3><A NAME="SECTION00031300000000000000">
<TT>strtok()</TT></A>
</H3>

<P>
Exotica funcþie <TT>strtok()</TT> este standard C, deºi probabil
doar programatorii experimentaþi ºtiu de ea.  Declaraþia ei se
gãseºte în headerul <TT>&lt;string.h&gt;</TT>.  Numele ei înseamnã
``string tokenize'', adicã ``împarte ºir în cuvinte''.
Funcþionarea ei este relativ complexã.

<P>
Ea are douã argumente, ambele ºiruri de caractere, ºi întoarce un
pointer spre un ºir de caractere:

<P>
<PRE>
char *strtok(char * text, const char * separatori);
</PRE>

<P>
Funcþionarea ei este specialã dacã <TT>text == NULL</TT>.  Scopul ei
este de a împãrþi ºirul <TT>text</TT> în bucãþele care sunt
despãrþite de caractere din ºirul <TT>separatori</TT>.  Ca sã
înþelegem mai bine, iatã întîi un exemplu care o foloseºte
într-un mod tipic.

<P>
<PRE>
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
main()
{
   char * text = "sir  de separat   in bucati";
   char * separator = " ";
   char * cuvint;

   cuvint = strtok(text, separator);
   while (cuvint != NULL) {
        printf("%s\n", cuvint);
        cuvint = strtok(NULL, separator);
   }
}
</PRE>

<P>
Dacã executaþi acest program veþi obþine:

<P>
<PRE>
sir
de
separat
in
bucati
</PRE>

<P>
Prima oarã cînd chem <TT>strtok(text, separator)</TT>, aceasta observã
cã <TT>text</TT> nu e 0 (<TT>NULL</TT>), deci îl memoreazã undeva
într-un buffer intern funcþiei.  Dupã aceasta cautã prima
apariþie a unui caracter din <TT>separator</TT>, pe care o înlocuieºte
cu un caracter 0 (sau <code>\0</code>), care în C înseamnã ``sfîrºit de
ºir''.

<P>
Lucrurile aratã cam aºa la intrare:

<P>

<PRE>
text = |s|i|r| | |d|e| |s|e|p|a|r|a|t| | | |i|n| |b|u|c|a|t|i|\0|
       ----------------------------------------------------------
</PRE>

<P>
ºi cam aºa la ieºire:

<P>

<PRE>
text = |s|i|r|\0| |d|e| |s|e|p|a|r|a|t| | | |i|n| |b|u|c|a|t|i|\0|
       -----------------------------------------------------------
        ^          ^
        cuvint     am ramas aici
</PRE>

<P>
Cu alte cuvinte ºirul <TT>text</TT> a fost modificat, rezultatul <TT>cuvint</TT> puncteazã la primul cuvînt, care a fost separat cu un 0 de
restul ºirului, iar <TT>strtok()</TT> þine minte unde a rãmas.

<P>
A doua oarã cînd îl chem pe <TT>strtok()</TT> îi dau un argument 0
în locul lui <TT>text</TT>.  Asta înseamnã: ``continuã de unde ai
rãmas''.  Aºa cã rezultatul va fi:

<P>

<PRE>
text = |s|i|r|\0| |d|e|\0|s|e|p|a|r|a|t| | | |i|n| |b|u|c|a|t|i|\0|
       ------------------------------------------------------------
                   ^      ^
              cuvint      am ramas aici
</PRE>

<P>
Data viitoare voi obþine:

<P>

<PRE>
text = |s|i|r|\0| |d|e|\0|s|e|p|a|r|a|t|\0| | |i|n| |b|u|c|a|t|i|\0|
       -------------------------------------------------------------
                          ^                    ^
                          cuvint               am ramas aici
</PRE>

<P>
Dupã încã douã apeluri voi obþine rezultat 0, pentru cã s-a
ajuns la sfîrºitul ºirului:

<P>

<PRE>
text = |s|i|r|\0| |d|e|\0|s|e|p|a|r|a|t|\0| | |i|n|\0|b|u|c|a|t|i|\0|
       --------------------------------------------------------------
                                                                   ^
cuvint=0                                                am ramas aici
</PRE>

<P>
Iatã deci cum <TT>strtok()</TT> hãcuieºte un ºir de caractere.  <TT>strtok()</TT> este o funcþie care poate fi implementatã fãrã ajutorul
vreunui apel de sistem, pentru cã manipuleazã simple array-uri de
caractere.

<P>

<H2><A NAME="SECTION00032000000000000000">
Apeluri de sistem</A>
</H2>

<P>
Ultimele 3 funcþii sunt apeluri de sistem tipice Unix, care au de-a
face cu crearea de noi procese.

<P>

<H3><A NAME="SECTION00032100000000000000">
<TT>fork()</TT></A>
</H3>

<P>
<TT>fork()</TT> este singura metodã prin care în Unix se poate crea un
nou proces (vã reamintesc cã un proces este un program în curs de
execuþie).  Cînd un proces executã <TT>fork()</TT>, el dã naºtere
unui alt proces absolut identic cu el însuºi, care se numeºte
``fiul'' lui, ºi care îºi continuã execuþia în paralel cu
tatãl.<A NAME="tex2html1"
  HREF="#foot165"><SUP>1</SUP></A>
<P>
Amîndouã procesele îºi continuã execuþia ca ºi cum tocmai ar fi
executat instrucþiunea <TT>fork()</TT>; singura diferenþã dintre ele
este cã tatãl va primi ca rezultat al executãrii lui <TT>fork()</TT>
un numãr nenul, care identificã fiul, iar fiul va primi un 0.

<P>
Figura explicã ºi numele: ``fork'' înseamnã ``furculiþã''.

<P>

<PRE>
            --------------
            |            | proces=12
inainte     | r = fork() |
de          |            |
fork()      -------------- ___________
                 |                    \
                 v                     v
            --------------              --------------
            |            | proces=12    |            | proces=13
dupa        | r = fork() | (tata)       | r = fork() | (fiu)
fork()      | (r=13)     |              | (r=0)      |
            --------------              --------------
</PRE>

<P>
În figura de mai sus, pãrintele (cu numãrul de proces 12) creazã
un copil, care întîmplãtor capãtã numãrul 13.  Dupã
instrucþiunea <TT>fork()</TT> avem 2 procese, 12 ºi 13, care se
executã în paralel.  Cel cu numãrul 12 (pãrintele), va avea <TT>r=13</TT>, numãrul copilului, iar copilul, deºi va executa acelaºi cod,
din acelaºi punct, va avea <TT>r=0</TT>.

<P>

<H3><A NAME="SECTION00032200000000000000">
<TT>wait()</TT></A>
</H3>

<P>
Cu apelul de sistem <TT>wait()</TT> un proces pãrinte aºteaptã
terminarea unui copil.  Pãrintele este blocat din execuþie pînã
unul dintre copii lui rãposeazã, dupã care <TT>wait()</TT> returneazã
pãrintelui niºte informaþii despre cauza decesului (nu ne preocupã
aici).  (Argumentul lui <TT>wait()</TT> este un pointer spre un loc unde
se vor pune aceste informaþii; in programul nostru pointerul este 0;
rezultatul lui <TT>wait()</TT> este numãrul de proces copilului.)

<P>

<H3><A NAME="SECTION00032300000000000000">
<TT>execvp()</TT></A>
</H3>

<P>
Rezultatul compilãrii unui program este un fiºier executabil (de
exemplu, mai sus cînd aþi compilat <TT>shell.c</TT> aþi obþinut <TT>shell</TT>).  Apelul de sistem <TT>exec()</TT> roagã nucleul sã citeascã
un fiºier executabil în memorie, sã-l transforme în imaginea unui
proces ºi sã-l execute, furnizînd ºi argumentele care vor fi
pasate noului proces.  Procesul care executã apelul acesta de sistem
este complet înlocuit cu imaginea din fiºier.

<P>
Existã mai multe variante ale apelului de sistem <TT>exec()</TT> care
fac cam acelaºi lucru, dar care împacheteazã altfel argumentele.
Cea de faþã se numeºte <EM>execvp</EM> pentru cã este ``exec'' cu un:
``Vector de Pointeri'' spre argumentele procesului.  Declaraþia din
<TT>&lt;unistd.h&gt;</TT> aratã aºa:

<P>
<PRE>
int execvp(const char *fisier, char * const argumente[]);
</PRE>

<P>
Primul parametru este numele fiºierului executabil.

<P>
Al doilea parametru este un array în care fiecare obiect este un
pointer la un argument pasat procesului.  Argumentele sunt simple
ºiruri de caractere.  Argumentele sunt primite de funcþia <TT>main()</TT> a procesului exec-utat în parametrul <TT>argv</TT>:

<P>
<PRE>
int main(int argc, char * argv[])
                          ^^^^^^
                         argumentele transmise de exec
</PRE>

<P>
Acum ºtim toate bucãþile.  Poate doar anumite caracteristici mai
stranii ale C-ului mai stau în calea înþelegerii întregului
program.

<P>

<H2><A NAME="SECTION00033000000000000000">
Ansamblul</A>
</H2>

<P>
Iatã încã odatã programul de mai sus, cu headerele incluse,
indentat ºi comentat:

<P>
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int a,                          /* char * plimbat pe sirul citit */
    b[99],                      /* comanda tastata; folosit ca un char [] */
    *c,                         /* pointer spre argumentul curent */
    d[99];                      /* pointeri spre lista de argumente */

int main()
{
  while(printf("&gt;"),            /* prompt */
        c=d,                    /* argumentele vor fi plasate in vectorul d */
        *c=a=gets(b)) {         /* citeste prima linie; a = b */
    for( ;
        *++c=strtok(a," ") ;    /* separa urmatorul cuvint; pune-l in d */
        a=0);                   /* a = NULL -&gt; folosim acelasi buffer */
    fork() ?                    /* eu sunt tatal? */
      wait(0) :                 /* da, asteapta copilul! */
      execvp(*d,d+1);           /* nu: executa comanda data cu argumente */
}}
</PRE>

<P>
În primul rînd programul foloseºte numere întregi pentru a memora
atît caractere cît ºi pointeri.  Standardul C spune cã asta e
perfect legal: ``existã un tip întreg în care un pointer încape''.

<P>
Operatorul <TT>,</TT> este folosit cum scrie la carte: ``evaluarea
expresiei <TT>e1,e2</TT> înseamnã cã:

<P>

<UL>
<LI>se evalueazã <TT>e1</TT>;
</LI>
<LI>se evalueazã <EM>dupã aceea</EM> <TT>e2</TT>;
</LI>
<LI>rezultatul final este rezultatul evaluãrii lui <TT>e2</TT>''.
</LI>
</UL>

<P>
Variabila <TT>a</TT> puncteazã la ºirul citit de la utilizator, pentru
a-l împãrþi în felii cu <TT>strtok()</TT>.  Variabila <TT>b</TT>
conþine chiar comanda tastatã (e folositã ca un array de
caractere).  Variabila <TT>d</TT> va conþine la sfîrºitul executãrii
lui <TT>strtok()</TT> pointerii cãtre argumente daþi lui <TT>execvp()</TT>.  În fine, variabila <TT>c</TT> se plimbã printre cãsuþele
lui <TT>d</TT>, arãtînd care vine la rînd.

<P>
Situaþia la început aratã astfel:

<P>

<PRE>
| | | | | | | | | | | | | .... | b    | | | | | | | | | | | | | .... | d
--------------------------------      --------------------------------   
 ^                                     ^                                 
 a                                     c
</PRE>

<P>
Sã presupunem cã utilizatorul tasteazã la prompt textul <TT>echo
a1 a2</TT>.  Atunci dupã executarea <TT>for</TT>-ului situaþia va fi
urmãtoarea:

<P>

<PRE>
|e|c|h|o|\0|a|1|\0|a|2|\0| | | | .... |  b
---------------------------------------
 ^          ^      ^
 |  ________|      |
 | |  _____________/
 | | |
|*|*|*|0| | | | | | | | | | | .... |  d
------------------------------------
       ^
       c
</PRE>

<P>
Din cauza asta, dupã ce copilul e fãcut ºi pãrintele doarme,
copilul executã comanda indicatã de primul parametru al lui <TT>execvp()</TT>, <TT>*d</TT>, (care puncteazã spre ºirul <TT>echo</TT>), iar
argumentele lui <TT>echo</TT> sunt cuprinse în vectorul <TT>d</TT>,
începînd de la cãsuþa 1 (<TT>d+1</TT>).

<P>

<H1><A NAME="SECTION00040000000000000000">
Recompensã</A>
</H1>

<P>
Dacã aþi înþeles totul, vã propun spre ``dezlegare'' încã un
cod de shell, de data asta mai sofisticat.  Acesta poate recunoaºte
mai multe comenzi pe aceeaºi linie, pipe-uri (<TT>comanda1&nbsp;|&nbsp;comanda2</TT>), redirectãri în fiºiere (<TT>comanda
&gt;fisier1 &lt;fisier2</TT>), comanda internã <TT>cd</TT>.  Programul este
perfect funcþional!

<P>
Pentru cã sunt convins cã nu veþi putea tasta o asemenea oroare,
fiºierul cu sursa este disponibil în pagina mea de web; luaþi-l ºi
compilaþi-l.  Poate cu sprijinul redacþiei instaurãm ºi un premiu
pentru cel care reuºeºte sã decodifice ºi sã comenteze programul
într-un fel care sã-l facã inteligibil.  (Eu am reuºit parþial
abia dupã douã zile de lucru.)

<P>

<PRE>
#define D ,close(

char              *c,q              [512              ],m[              256
],*v[           99], **u,        *i[3];int         f[2],p;main       (){for
 (m[m        [60]=   m[62      ]=32   ]=m[*      m=124   [m]=       9]=6;
  e(-8)     ,gets      (1+(    c=q)     )||      exit      (0);     r(0,0)
   )for(    ;*++        c;);  }r(t,      o){    *i=i        [2]=    0;for
     (u=v  +98           ;m[*--c]         ^9;m [*c]          &amp;32  ?i[*c
       &amp;2]=                *u,u-             v^98              &amp;&amp;++u:

        3       )if(!m[*c]){for(*++c=0;!m[*--c];);
        *       --u= ++c;}u-v^98?strcmp(*u,"cd")?*c?pipe(f),o=f[
        1       ]:
        4       ,(p=fork())?e(p),o?r(o,0)D o)D*f):
        1       ,wait(0):(o?dup2(*f,0)D*f)D o):*i?
        5       D 0),e(open(*i,0)):
        9       ,t?dup2(t,1)D t):i[
        2       ]?
        6       D 1),e(creat(i[2],438)):
        5       ,e(execvp(*u,u))):e(chdir(u[1])*2):
        3       ;}e(x){x&lt;0?write(2,"?\n$ "-x/4,2),x+1||exit(1):
        5       ;}

/* from  bsh20858@news.fhda.edu (Brian S Hiles) */
</PRE>

Nota: iata o  <a href="explicat.txt">rezolvare</a> primita de la Ionut
Ichim.  Din pacate nu a primit nici un premiu de la PC Report, dar
satisfactia decodificarii e suficienta in sine ;-).

<P>

<H1><A NAME="SECTION00050000000000000000">
Rezumat</A>
</H1>

<P>
Observaþi cã, pentru nucleu, shell-ul este un proces ca toate
celelalte, care se executã fãrã nici un fel de privilegii ºi care
ocazional face cîte un apel de sistem.  Shell-urile citesc comenzi de
la utilizator, pe care apoi le ``interpreteazã'' ºi le transformã
într-o serie de apeluri de sistem, care în general culmineazã cu
executarea unuia sau mai multor fiºiere.

<P>
Limbajul C este de o conciziune ºi expresivitate admirabilã.  Nu-i aºa?

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot165">... al.</A><A NAME="foot165"
 HREF="shell-html.html#tex2html1"><SUP>1</SUP></A>
<DD>În Statele Unite aceastã terminologie (``father,
son'') este descurajatã, pentru cã face discriminare sexualã.  Se
recomandã folosirea termenilor ``parent'' and ``child''.  Ar trebui
deci sã spunem ``pãrinte'' ºi ``copil''.

</DL>
<BR><HR>

</BODY>
</HTML>
