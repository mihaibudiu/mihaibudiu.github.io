<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Sistemul de Fiºiere din Unix</TITLE>
<META NAME="description" CONTENT="Sistemul de Fiºiere din Unix">
<META NAME="keywords" CONTENT="sistem-f-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<H1 ALIGN="CENTER">Sistemul de Fiºiere din Unix</H1>
<P ALIGN="CENTER"><STRONG>Mihai BUDIU -- budiu+ at cs.cornell.edu, mihaib@pub.ro 
<BR>
http://www.cs.cornell.edu/Info/People/budiu/budiu.html</STRONG></P>
<P ALIGN="CENTER"><STRONG>iulie 1996</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect :</STRONG></DT>
<DD>Sistemele de fiºiere in Unix.
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>fiºier, partiþie, i-nod, director, legãturã.
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>noþiuni elementare despre: un sistem de operare,
structuri de date, shell-ul Unix.
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html40"
  HREF="sistem-f-html.html">Terminologia</A>
<LI><A NAME="tex2html41"
  HREF="#SECTION00030000000000000000">Cu ce obiecte lucrãm</A>
<UL>
<LI><A NAME="tex2html42"
  HREF="#SECTION00031000000000000000">Partiþia</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION00032000000000000000">Fiºierele</A>
</UL>
<BR>
<LI><A NAME="tex2html44"
  HREF="#SECTION00040000000000000000">Structura de date</A>
<UL>
<LI><A NAME="tex2html45"
  HREF="#SECTION00041000000000000000">Blocul de boot</A>
<LI><A NAME="tex2html46"
  HREF="#SECTION00042000000000000000">Superblocul</A>
<LI><A NAME="tex2html47"
  HREF="#SECTION00043000000000000000">I-nodurile</A>
<LI><A NAME="tex2html48"
  HREF="#SECTION00044000000000000000">Zona de date</A>
<LI><A NAME="tex2html49"
  HREF="#SECTION00045000000000000000">Lista de blocuri libere</A>
<LI><A NAME="tex2html50"
  HREF="#SECTION00046000000000000000">Crearea unui sistem de fiºiere</A>
</UL>
<BR>
<LI><A NAME="tex2html51"
  HREF="#SECTION00050000000000000000">Operaþiile pe fiºiere</A>
<LI><A NAME="tex2html52"
  HREF="#SECTION00060000000000000000">Directoarele</A>
<UL>
<LI><A NAME="tex2html53"
  HREF="#SECTION00061000000000000000">Linkurile <TT>.</TT> ºi <TT>..</TT></A>
<LI><A NAME="tex2html54"
  HREF="#SECTION00062000000000000000">Directorul rãdãcinã</A>
</UL>
<BR>
<LI><A NAME="tex2html55"
  HREF="#SECTION00070000000000000000">Operaþiile pe directoare</A>
<UL>
<LI><A NAME="tex2html56"
  HREF="#SECTION00071000000000000000">Gãsirea i-nodului unui fiºier</A>
<LI><A NAME="tex2html57"
  HREF="#SECTION00072000000000000000">Crearea ºi distrugerea fiºierelor</A>
</UL>
<BR>
<LI><A NAME="tex2html58"
  HREF="#SECTION00080000000000000000">Programul <TT>fsck</TT></A>
<LI><A NAME="tex2html59"
  HREF="#SECTION00090000000000000000">Un experiment</A>
<LI><A NAME="tex2html60"
  HREF="#SECTION000100000000000000000">Rãspuns:</A>
</UL>
<!--End of Table of Contents-->
<P>
Chiar ºi cei mai naivi utilizatori ai unui calculator au de a
face cu <EM>sistemul de fiºiere</EM> în majoritatea timpului (termenul
este consacrat în jargonul informatic); o mai apropiatã privire
asupra sa este salutarã.

<P>

<H1><A NAME="SECTION00020000000000000000">
Terminologia</A>
</H1>

<P>
``Sistem de fiºiere'' (filesystem sau file system) este un
termen folosit în mai multe accepþiuni distincte.  O preliminarã
revizie a acestora poate ajuta eliminarea unora din neclaritãþile
care ar surveni atunci cînd în discuþie sensurile se schimbã
ne-explicit.

<P>
O primã accepþiune a ``sistemului de fiºiere'' este cea a
unei <EM>structuri de date</EM> creatã pe un suport de memorie, de
obicei permanent, cum e discul, în care utilizatorii memoreazã
informaþii într-un mod care le face mai uºor de stocat, manipulat
sau regãsit.

<P>
O a doua accepþiune este cea a unui <EM>set de operaþii</EM>
care se pot face asupra structurilor de date de mai sus: crearea,
ºtergerea, scrierea ºi citirea de fiºiere.

<P>
În fine, ultima accepþiune într-un sens le înglobeazã pe
cele douã anterioare: astfel sistemul de fiºiere este o bucatã
dintr-un sistem de operare (adicã o parte dintr-un program, de fapt);
aceastã bucatã este vizibilã utilizatorului ca un set de <EM>proceduri</EM> (<EM>apeluri de sistem</EM>, pentru a fi mai preciºi) care
opereazã cu fiºiere, manipulînd o structurã de date pe un suport
permanent de memorie.

<P>
Sistemul de fiºiere vãzut ca o colecþie de proceduri nu
trebuie musai sã fie parte a unui sistem de operare, însã de obicei
sistemele moderne conþin un sistem de fiºiere, pentru cã este
extrem de util; chiar dacã în anumite sisteme ``micro-nucleu''
sistemul de fiºiere nu este parte a nucleului, el poate fi asimilat
în sistemul de operare.

<P>
Vom încerca în secþiunile urmãtoare sã vedem cum aratã
sistemul de fiºiere în Unix.  Pe cel de la MS-DOS îl vom folosi
cîteodatã pentru a exemplifica o vedere alternativã.

<P>

<H1><A NAME="SECTION00030000000000000000">
Cu ce obiecte lucrãm</A>
</H1>

<P>

<H2><A NAME="SECTION00031000000000000000">
Partiþia</A>
</H2>

<P>
Pentru a simplifica discuþia vom presupune cã sistemul de
fiºiere este plasat pe un disc.  Variantele pe bandã, în memorie
(Ram-Disk) sau prin reþea nu sunt neapãrat fundamental diferite.

<P>
Discul este la nivelul cel mai de jos pentru software o
instalaþie extrem de complexã: el este gestionat de un procesor
propriu, numit controler de disc, care ºtie sã facã oarece
operaþii, dar care trebuie programat pentru asta.  Controlerul vede
discul ca o sumã de <EM>partiþii</EM> independente.  (Vom folosi
cîteodatã termenul de ``disc'' pentru a înþelege ``partiþie'',
pentru cã partiþia este un ``disc logic''.)  Natura fizicã a unui
disc îl împarte în cilindrii, fiecare cilindru e împãrþit în
piste, fiecare pistã în sectoare, fiecare sector conþinînd mai
mulþi octeþi.

<P>
Pentru a fi utilizabil, un disc trebuie sã fie <EM>formatat</EM>.  Operaþia de formatare (realizatã de obicei cu programul
<TT>fdisk</TT>) înscrie pe o partiþie o sumedenie de informaþii: de
exemplu pe fiecare pistã este marcat numãrul ei de ordine; în acest
fel cînd se încearcã citirea uneia se poate verifica dacã se aflã
capul de citire unde trebuie (detectînd erorile datorate mecanicii
deficiente).

<P>
Deºi subiectul este realmente fascinant, nu vom insista
asupra relaþiilor între aceste pãrþi, pentru cã sistemul de
fiºiere se construieºte de obicei pe o structurã ceva mai simplã,
care este oferitã de <EM>driverul de disc</EM>.  Driverul este o
colecþie de proceduri care ºtie sã manipuleze partiþiile, pistele
ºi toate alea, însã transformã discul într-un <EM>vector de
blocuri</EM>, fiecare cu mai mulþi octeþi.  Pe scurt, driverului îi
indici un numãr de bloc iar el decide pe care sector, pistã,
cilindru se gãseºte acest bloc.  Dacã vrei sã citeºti ceva din
bloc, indici blocul ºi numãrul octetului din bloc iar driverul
gãseºte unde se aflã octetul pe discul fizic ºi îl ia de acolo.

<P>
De ce blocuri ºi nu octeþi?  Pentru cã raportul duratelor
între a citi un octet ºi a citi 100 de octeþi <EM>consecutivi</EM> nu
este de 100 la 1 ci undeva între 1 ºi 2.  Asta pentru cã foarte
mult dureazã sã gãseºti primul octet; citirea urmãtorilor este
destul de rapidã.  De asemenea, s-a observat cã lumea rareori
citeºte fiºierele complet aleator: un octet aici altul colea; in
general sunt accesaþi împreunã mai mulþi consecutivi.  De aceea
driverul face toate operaþiile pe disc în termeni de blocuri de
mãrime egalã.

<P>
Cît de mari?  Depinde de sistem.  De obicei între jumãtate
de kilo octet ºi 8k.

<P>
Iatã deci cum este plasat sistemul de fiºiere în cadrul
sistemului de operare:

<P>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fs_position"></A><A NAME="377"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Sistemul de Fisiere in Sistemul de Operare</CAPTION>
<TR><TD><IMG
 WIDTH="318" HEIGHT="250" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=7cm\epsffile{fs_position.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Sistemul de fiºiere are deci la dispoziþie mai multe
partiþii.  Fiecare partiþie este vãzutã ca un array de blocuri
independente.  Citirea/scrierea unui bloc este realizatã de driverul
de disc, de serviciile cãruia sistemul de fiºiere se foloseºte.
(În realitate din motive de eficienþã între sistemul de fiºiere
ºi driver de obicei se mai plaseazã un nivel: <EM>cache</EM>-ul de
disc, care memoreazã blocurile mai frecvent utilizate în memorie).
În mod normal pe fiecare partiþie se construieºte cîte un sistem
de fiºiere independent; din aceastã cauzã vom simplifica discuþia
presupunînd cã avem la dispoziþie una singurã.

<P>
În DOS partiþiile devin ``discuri logice'' distincte: C: D:
E:, etc.  În Unix ele sunt specificate prin ``fiºiere speciale''
aflate în directorul <TT>/dev</TT>, dar pentru folosire sunt <EM>montate</EM> una peste alta.  De ajuns pentru moment despre partiþii.

<P>

<H2><A NAME="SECTION00032000000000000000">
Fiºierele</A>
</H2>

<P>
Sistemul de fiºiere trebuie sã ne ofere operaþii de: creare
ºi distrugere a fiºierelor, numire a fiºierelor (de fiecare datã
cînd ai de-a face cu mai multe obiecte de acelaºi fel se pune
problema de a le distinge prin nume diferite), de modificare ºi
inspectare a conþinutului fiºierelor.

<P>
Modurile în care se pot realiza aceste operaþii sunt
nenumãrate, influenþate fiind de feluritele proprietãþi pe care le
dorim.  De exemplu sistemul de operare CP/M (din care a fost derivat
ºi MS/DOS 1.0) are un singur <EM>director</EM> (vom vedea mai jos un pic
ce este un director în realitate) în care se aflã toate fiºierele.
Din cauza asta oricare douã fiºiere sunt distinse numai prin numele
lor, deci nu putem avea pe acelaºi disc douã fiºiere cu nume
identice.

<P>
Unix, ºi MS-DOS (care a preluat de la el ideea) folosesc o
<EM>ierarhie</EM> (un arbore) de directoare, fiecare avînd un nume la
rîndul lui.  Fiecare fiºier ``se aflã'' într-un director, în
directoare diferite putînd exista fiºiere la fel numite.
Identificarea unui fiºier se face indicînd pe lîngã numele lui,
numele directoarelor prin care se ajunge la el (<EM>calea</EM> -- <EM>path</EM> pînã la el).

<P>
Am aflat cam cum <EM>numim</EM> fiºierele.  Mai trebuie sã
ºtim ce putem <EM>face</EM> cu ele.  Întrebarea nu e chiar banalã; de
exemplu limbajul Pascal oferã un model de fiºier ``structurat'':
fiecare fiºier este un array de lungime teoretic nelimitatã de
obiecte identice (record de obicei).  Se pot imagina cu uºurinþã
modele mai complicate de fiºiere (unele foarte utile în aplicaþii
de baze de date); de exemplu fiºiere de ``perechi'' în care fiecare
datã are o ``cheie'' iar accesele se fac dupã valorile cheii:
``gãseºte cîmpul cu cheia 100'', ``incrementeazã cîmpul cu cheia
<B>Bibi</B>''.

<P>
Unix oferã probabil cel mai simplu model de fiºier: un array
de octeþi arbitrari.  Acelaºi lucru îl face ºi DOS-ul, distingînd
cîteodatã între fiºiere text ºi fiºiere ``oarecare''.

<P>
Deºi ar mai fi multe de spus, sã ne concentrãm acum asupra
modului în care sunt realizate aceste operaþii.  Deºi felurite
versiuni ºi variante ale Unix-ului pot proceda în realitate în mod
diferit, vom vedea cum aratã implementãrile ``clasice''.  Mai
important decît sã ºtim cum se fac lucrurile în detaliu este sã
ºtim cum le-am putea face noi.

<P>
Cum s-a ajuns la structura pe care o vom desfãºura mai jos
din cerinþele pe care le-am schiþat mai sus, nu vã va fi foarte
limpede pînã nu veþi încerca sã rezolvaþi aceeaºi problemã în
alt fel: atunci veþi vedea cum se justificã unele construcþii care
par artificiale.

<P>
O ultimã observaþie preliminarã: din comunicãrile
prezentate la conferinþa USENIX (a utilizatorilor de Unix), peste
40% sunt legate de sisteme de fi'siere: implement'ari, optimiz'ari,
arhitecturi.  Deci domeniul este în plinã evoluþie.

<P>

<H1><A NAME="SECTION00040000000000000000">
Structura de date</A>
</H1>

<P>
Sistemul de fiºiere foloseºte ca unitate de bazã blocul de
pe partiþie.  Cînd este nevoie de spaþiu se alocã un bloc întreg,
chiar dacã e nevoie de mai puþin.  Asta simplificã gestiunea
spaþiului liber.  Iatã cum sunt folosite blocurile de pe o partiþie
pentru a crea un sistem de fiºiere:

<P>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fs_partition"></A><A NAME="383"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Structura unei partiþii Unix cu sistem de fiºiere</CAPTION>
<TR><TD><IMG
 WIDTH="635" HEIGHT="54" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=14cm\epsffile{fs_partition.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00041000000000000000">
Blocul de boot</A>
</H2>

<P>
Nucleul însuºi al sistemului de operare este de obicei
þinut sub forma unui fiºier.  Însã procedurile care manipuleazã
fiºiere sunt parte a nucleului, aºa cã pentru a porni (boot)
sistemul de operare însuºi nu se pot folosi operaþiile pe fiºiere,
cãci ele nu sunt încã citite de pe disc!  Din aceastã cauzã
nucleul trebuie sã fie accesibil ºi direct, fãrã a fi nevoie sã
fie citit ca fiºier.

<P>
Blocul de boot conþine tocmai informaþiile necesare pentru a
citi nucleul: de obicei o listã a blocurilor de pe disc ocupate de
fiºierul-nucleu.  Cînd calculatorul porneºte un program mic (din
ROM de exemplu) citeºte nucleul în memorie folosind aceste
informaþii.

<P>

<H2><A NAME="SECTION00042000000000000000">
Superblocul</A>
</H2>

<P>
Superblocul este rezervat pentru a descrie cum sistemul de
fiºiere foloseºte partiþia.  Informaþiile pe care le cuprinde
sunt:

<P>

<UL>
<LI>un <EM>numãr magic</EM> (o constantã rezervatã) pentru a indica tipul
sistemului de fiºiere (ex.: sistem de fiºiere SCO Unix);
</LI>
<LI>mãrimea partiþiei;
</LI>
<LI>numãrul de i-noduri (fiºiere);
</LI>
<LI>numãrul de i-noduri ocupate;
</LI>
<LI>numãrul de blocuri libere;
</LI>
<LI>lista blocurilor libere;
</LI>
<LI>starea partiþiei (este cache-ul salvat pe disc?);
</LI>
<LI>i-nodul directorului rãdãcinã;
</LI>
<LI>etc.
</LI>
</UL>

<P>
Superblocul dã o descriere a informaþiilor <EM>globale</EM>
referitoare la întreaga partiþie care conþine un sistem de
fiºiere.  Le vom pricepe cînd vom ºti de fapt despre ce este vorba.

<P>

<H2><A NAME="SECTION00043000000000000000">
I-nodurile</A>
</H2>

<P>
În Unix numãrul de fiºiere care se pot afla la un moment
dat pe un sistem de fiºiere este limitat precis, încã de la crearea
sistemului de fiºiere (vedeþi secþiunea despre <TT>mkfs</TT>)!
Fiecare fiºier are un <EM>i-nod</EM> (i-node sau inode în engleza,
abreviere de la Information Node) asociat, care conþine aproape toate
informaþiile legate de acel fiºier, mai puþin <EM>conþinutul</EM> ºi
<EM>numele</EM>.  Unele i-noduri sunt nefolosite la un moment dat.

<P>
Chiar dacã pe un disc mai existã blocuri libere, în
momentul cînd au fost folosite toate i-nodurile nu se mai pot crea
noi fiºiere.  Discul este plin.

<P>
Sã ne uitãm mai aproape la un i-nod:

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="107"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
Inod.</CAPTION>
<TR><TD><IMG
 WIDTH="447" HEIGHT="296" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}{h}
\begin{center}
\begin{tabular}{\vert c\vert} \hline
este i-nod...
...\lq leg\u aturi'' (reference count) \\ \hline
\end{tabular}\end{center}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H3><A NAME="SECTION00043100000000000000">
Cîmpurile i-nodului</A>
</H3>

<P>
Iatã o scurtã descriere a semnificaþiei fiecãruia din
cîmpurile de mai sus (nu uitaþi: anumite implementãri pot avea ºi
altele).  Cele mai multe cîmpuri pot fi vãzute cu ajutorul comenzii
<TT>ls</TT>.  <TT>ls</TT> are ca argumente nume de fiºiere, nu i-noduri, dar cum
fiecare fiºier are un singur i-nod (vom vedea cum se gãseºte ce
i-nod corespunde unui anumit nume mai încolo), <TT>ls</TT> ºtie de unde sã
ia informaþiile.

<P>
Pentru a vedea ce i-nod corespunde unui fiºier folosiþi <TT>ls
-i</TT>; de exemplu la mine acasã:

<P>
<PRE>
$ ls -i /bin/b*
 22363 /bin/bash      22905 /bin/binmail
</PRE>

<P>
Deci fiºierul <TT>/bin/bash</TT> are i-nodul cu numãrul 22363, iar fiºierul
<TT>/bin/binmail</TT> are i-nodul 22905.

<P>

<H3><A NAME="SECTION00043200000000000000">
este i-nodul liber?</A>
</H3>

<P>
Aici este marcat un i-nod liber.  La crearea unui nou fiºier
un i-nod liber este alocat, marcat ocupat, ºi cîmpurile celelalte
înscrise corespunzãtor.  La ºtergerea unui fiºier i-nodul devine
liber (atenþie: ``ºtergerea'' în Unix este un fenomen destul de
complicat!).

<P>

<H3><A NAME="SECTION00043300000000000000">
uid (User IDentifier)</A>
</H3>

<P>
Fiecare fiºier în Unix aparþine cuiva.  Un identificator
numeric asociat celui care posedã fiºierul (de obicei cel care l-a
creat) este marcat aici.  Al treilea cîmp de la <TT>ls -l</TT> indicã
utilizatorul.  Dacã vreþi valoarea numericã a UID daþi <TT>ls -ln</TT>.

<P>
Identificatorul acesta ridicã oarecari probleme cînd un
sistem de fiºiere este folosit în reþea (ca sistemul NFS -- network
file system), pentru cã pe un calculator utilizatorul cu codul 10
poate fi cineva, iar pe alt calculator altcineva!  (Aceasta este o
deficienþã a Unix-ului care nu a fost proiectat originar pentru a
opera în reþea -- cîrpelile nu merg prea bine.)

<P>
<PRE>
$ ls -l /bin/bash
-rwxr-xr-x   1 root     bin        279556 Feb  7  1994 /bin/bash
               ^^^^     ^^^
               UID      GID
</PRE>

<P>

<H3><A NAME="SECTION00043400000000000000">
gid (Group ID)</A>
</H3>

<P>
În Unix utilizatorii fac parte din unul sau mai multe <EM>grupuri</EM>.  Fiecare fiºier aparþine ºi el unui anume grup, care este
indicat aici.  Consideraþii asemãnãtoare cu cele de la UID se
aplicã ºi aici.  Al patrulea cîmp din <TT>ls -ln</TT> este GID, sub
formã numericã.

<P>

<H3><A NAME="SECTION00043500000000000000">
drepturile</A>
</H3>

<P>
Puteþi vedea drepturile în coloanele 2-10 din ceea ce
tipãreºte <TT>ls -l</TT>.

<P>
<PRE>
$ ls -l /bin/bash
-rwxr-xr-x   1 root     bin        279556 Feb  7  1994 /bin/bash
 ^^^^^^^^^
 drepturile
</PRE>

<P>
Drepturile vin sub forma a trei triplete de valori Da/Nu.
Primul triplet aratã ce poate face cu fiºierul <EM>posesorul</EM> lui
(un proces al unui utilizator cu UID egal cu cel al fiºierului).  Al
doilea aratã ce pot face utilizatorii din grupul fiºierului.  Al
treilea triplet aratã ce poate face restul lumii.

<P>
Fiecare grup de trei valori Da/Nu aratã aºa:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">r</TD>
<TD ALIGN="LEFT">w</TD>
<TD ALIGN="LEFT">x</TD>
</TR>
<TR><TD ALIGN="LEFT">Read</TD>
<TD ALIGN="LEFT">Write</TD>
<TD ALIGN="LEFT">eXecute</TD>
</TR>
<TR><TD ALIGN="LEFT">Citeºte</TD>
<TD ALIGN="LEFT">Scrie</TD>
<TD ALIGN="LEFT">Executã</TD>
</TR>
</TABLE>
</DIV>

<P>
Ele aratã dacã fiºierul poate fi citit, modificat sau
respectiv executat (pentru fiºiere de tip director <EM>cãutat</EM>) de
persoana respectivã.  Pentru un exemplu concret sã luãm un fiºier
cu drepturile:

<P>
<PRE>
r-x-w---x
\_/\_/\_/
  \  \  \ restul lumii
   \  \__grupul
    \___posesorul
</PRE>

<P>
Asta înseamnã cã:

<P>

<UL>
<LI>posesorul fiºierului poate: citi ºi executa acest fiºier, dar
<EM>nu</EM> modifica;

<P>
</LI>
<LI>cei din grupul fiºierului: pot modifica acest fiºier, dar <EM>nu</EM>-l pot citi sau executa;

<P>
</LI>
<LI>ceilalþi: pot doar executa fiºierul, dar <EM>nu</EM> citi sau
modifica.
</LI>
</UL>

<P>

<H3><A NAME="SECTION00043600000000000000">
atributele tss</A>
</H3>

<P>
Fiºierele mai au trei atribute de forma Da/Nu (biþi).
Acestea se numesc: bitul SUID, bitul SGID ºi bitul <EM>sticky</EM>
(lipicios).  Multã informaþie este condensatã în aceºti trei
biþi.

<P>

<UL>
<LI>bitul SUID (Set User ID): un fiºier cu acest bit pus pe Da
aratã faptul cã un execuþia acestui fiºier dã naºtere unui
proces care este posedat de posesorul <EM>fiºierului</EM> ºi nu de
posesorul <EM>procesului</EM> care executã fiºierul (discuþia
depãºeºte cadrul sistemelor de fiºiere aºa cã ne oprim aici cu
explicaþiile; poate vom reveni cu o altã ocazie).  Un bit SUID este
indicat la <TT>ls -l</TT> printr-un <TT>s</TT> în loc de <TT>x</TT>:

<P>
<PRE>
$ ls -l /bin/mount
-rwsr-xr-x   1 root     bin         21508 Jan 28  1994 /bin/mount
   ^
   SUID
</PRE>

<P>
Cînd utilizatorul <TT>mihai</TT> va executa acest fiºier, procesul va
avea UID <TT>root</TT>, ºi nu <TT>mihai</TT>, din cauza bitului SUID.

<P>
</LI>
<LI>bitul SGID (Set Group ID) are o funcþie similarã, acþionînd
asupra grupului procesului:

<P>
<PRE>
$ ls -l /usr/bin/convfont
-rwsr-sr-x   1 root     root         2272 Mar 16  1994 convfont
   ^  ^
   SUID si SGID
</PRE>

<P>
Cum se vede ºi din descriere, aceºti biþi nu au sens decît
dacã fiºierul este executabil.  Pentru fiºiere ne-executabile ei
sunt folosiþi pentru a indica faptul cã folosirea fiºierului se
poate face <EM>numai</EM> dupã <EM>încuierea (lock)</EM> lor.  (Acesta
este un mecanism care nu permite accesul simultan a douã procese la
un singur fiºier.)  Aceºti biþi se vad cu litere mari <TT>S</TT>.

<P>
Biþii SUID la directoare indicã faptul cã toate fiºierele
create în acele directoare moºtenesc drepturile de la director ºi
nu de la procesul care le creazã.

<P>
Ar mai fi cîte ceva de spus despre lock-uri, dar ar merita un
articol în sine.  Sã mergem mai departe cu i-nodul.

<P>
</LI>
<LI>bitul Sticky (lipicios), notat cu <TT>t</TT>

<P>
La fiºiere executabile iniþial acest bit indica nucleului
sã optimizeze folosirea fiºierului: odatã executat (deci citit în
memorie) nu mai trebuie scos de acolo, chiar dacã procesul se
terminã, pentru cã probabil va fi folosit din nou în curînd.

<P>
Pentru directoare el indicã o calitate foarte interesantã:
în directoarele în care oricine poate scrie (<TT>----w-</TT>), cum e
<TT>/tmp</TT>, teoretic oricine poate ºterge orice fiºier (dupã cum
vom vedea un pic mai jos).  Un bit lipicios pe un astfel de director
va permite însã ºtergerea unui fiºier <EM>numai</EM> de cãtre
posesorul lui (de cãtre un proces avînd acelaºi UID cu i-nodul).

<P>
<PRE>
$ ls -ld /tmp
drwxrwxrwt   3 root     root         1024 Jul 26 00:10 /tmp/
         ^
         bit sticky
</PRE>
</LI>
</UL>

<P>
Modificatorul <TT>d</TT> al lui <TT>ls</TT> este necesar pentru a lista
drepturile directorului tmp ºi nu ale tuturor fiºierelor cuprinse
în el.

<P>

<H3><A NAME="SECTION00043700000000000000">
tipul fiºierului</A>
</H3>

<P>
<TT>ls -l</TT> va scrie tipul unui fiºier în prima literã
afiºatã.  Aceasta poate fi într-un Unix normal:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">d</TD>
<TD ALIGN="LEFT">pentru un director</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-</TT></TD>
<TD ALIGN="LEFT">pentru un fiºier ordinar</TD>
</TR>
<TR><TD ALIGN="LEFT">l</TD>
<TD ALIGN="LEFT">pentru o legãturã simbolicã (<EM>symbolic link</EM>)</TD>
</TR>
<TR><TD ALIGN="LEFT">s</TD>
<TD ALIGN="LEFT">pentru o <EM>mufã (socket)</EM></TD>
</TR>
<TR><TD ALIGN="LEFT">c</TD>
<TD ALIGN="LEFT">pentru un fiºier special de tip caracter</TD>
</TR>
<TR><TD ALIGN="LEFT">b</TD>
<TD ALIGN="LEFT">pentru un fiºier special de tip bloc</TD>
</TR>
<TR><TD ALIGN="LEFT">p</TD>
<TD ALIGN="LEFT">pentru o <EM>þeavã cu nume (named pipe)</EM></TD>
</TR>
</TABLE>
</DIV>

<P>
Cele mai multe dintre aceste tipuri de fiºiere sunt de fapt
doar niºte nume asociate unor pãrþi ale nucleului, ºi nu vor fi
discutate în acest articol.  Primele trei au într-adevãr legãturã
cu sistemele de fiºiere, dar numai despre primele douã vom vorbi în
acest articol, pentru cã altfel iese prea mare.

<P>

<H3><A NAME="SECTION00043800000000000000">
timpii</A>
</H3>

<P>
Fiecare i-nod înregistreazã în formatul tipic Unix (numit
<TT>time_t</TT>, de obicei un întreg lung reprezentînd numãrul de
secunde scurse de la 1 ianuarie 1970) data (ºi ora) creãrii,
accesului ºi modificãrii fiºierului.  Timpii se pot obþine astfel
cu <TT>ls</TT>:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><TT>ls -l</TT></TD>
<TD ALIGN="LEFT">timpul creãrii</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ls -ul</TT></TD>
<TD ALIGN="LEFT">timpul ultimului acces</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ls -lc</TT></TD>
<TD ALIGN="LEFT">timpul ultimei modificãri</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00043900000000000000">
lungimea fiºierului</A>
</H3>

<P>
în octeþi este indicatã de asemenea de <TT>ls -l</TT>:

<P>
<PRE>
$ ls -l /bin/bash -rwxr-xr-x 1 root bin 279556 Feb 7 1994 /bin/bash
                                        ^^^^^^ bash are 273K
</PRE>

<P>

<H3><A NAME="SECTION000431000000000000000">
lista blocurilor folosite</A>
</H3>

<P>
nu poate fi vãzutã cu <TT>ls</TT>.  Ea este þinutã într-o formã foarte
ingenioasã care permite accesul extrem de rapid în orice punct al
fiºierului.  Aceastã listã indicã pentru fiecare bloc din fiºier
ce bloc din partiþie corespunde (fiecare prim bloc din fiecare
fiºier ocupã alt loc în partiþie, fireºte).

<P>
Pentru a indica ce blocuri compun un fiºier se folosesc
<EM>pointeri</EM> la blocuri.  Un pointer la un bloc este pur ºi simplu
numãrul de pe partiþie al unui bloc.  Pentru cã blocul 0 nu poate
fi al vreunui fiºier (fiind blocul de boot) avem la dispoziþie ºi o
valoare care poate indica <EM>lipsa</EM> unui bloc.  (Vom vedea cã in
Unix un fiºier poatã avea ``gãuri'': blocuri lipsã în mijloc!)

<P>
Schema este extrem de ingenioasã, dar un pic mai complicat de
descris în cuvinte.  Pe scurt i-nodul conþine:

<P>

<UL>
<LI>pointeri spre primele 10 blocuri ale fiºierului;

<P>
</LI>
<LI>dacã fiºierul e mai lung de 10 blocuri, un pointer spre un bloc
(numit <EM>blocul simplu indirect</EM>) în care se pun pointerii spre
urmãtoarele blocuri.  Cît de mulþi pointeri sunt în acest bloc
depinde de mãrimea blocului ºi de mãrimea pointerului (de obicei 32
de biþi, dar poate mai mult!).

<P>
</LI>
<LI>dacã fiºierul are mai multe blocuri decît se pot reprezenta
astfel, urmeazã un pointer la un bloc în care sunt pointeri la
blocuri care þin pointeri la blocurile fiºierului: indirectare
dublã.

<P>
</LI>
<LI>în fine, dacã nici atît nu ajunge, urmeazã o indirectare
triplã.
</LI>
</UL>

<P>
O schemã aproximativã ar arãta aºa:

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fs_blocklist"></A><A NAME="389"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4:</STRONG>
Pointerii spre blocuri</CAPTION>
<TR><TD><IMG
 WIDTH="451" HEIGHT="507" BORDER="0"
 SRC="img4.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{fs_blocklist.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Cîte blocuri se pot indica astfel?  Dacã într-un bloc
încap X pointeri avem lungimea maximã pentru un fiºier:

<P>
10 + X + X*X + X*X*X blocuri

<P>
Pentru niºte valori tipice: bloc de 1024 octeþi ºi pointer
pe 4 octeþi avem X=1024/4=256.  Atunci valoarea de mai sus devine

<P>
(10 + 256 + 256*256 + 256*256*256) * 1K = 
(10 + 256 + 65536 + 16777216) K &gt;= 16 Giga octeþi.

<P>
Pînã de curînd asta era destul de mult pentru un singur
fiºier.  Oricum, introducerea unui al patrulea nivel de indirectare
ar ridica valoarea la 4 Tera octeþi, ceea ce ar trebui sã ajungã
pentru o vreme...

<P>
Din virtuþile acestei scheme: fiºiere scurte rapide ºi
compacte (oricare din primele 10 blocuri se acceseazã imediat),
dimensiune maximã foarte mare, acces rapid la orice bloc (maximum
trei blocuri citite de pe disc pentru indirectãri), fiºiere care pot
avea gãuri.

<P>

<H3><A NAME="SECTION000431100000000000000">
numãrul de legãturi</A>
</H3>

<P>
În Unix un fiºier se poate ``afla'' simultan în mai multe directoare!
Cîte apariþii distincte are el este indicat de numãrul de
legãturi.  De exemplu:

<P>
<PRE>
$ ls -ld /usr/bin
drwxr-xr-x   2 root     bin          7168 Jul 23 12:45 /usr/bin
             ^
             numarul de legaturi este 2!
</PRE>

<P>
Cu alte cuvinte directorul <TT>/usr/bin</TT> este prezent în douã
directoare!  Vom vedea mai jos de ce.

<P>
Cu asta am epuizat structura i-nodului clasic.

<P>

<H2><A NAME="SECTION00044000000000000000">
Zona de date</A>
</H2>

<P>
Sã revenim la studiul partiþiei: organizarea ei în sistem
de fiºiere.  Dupã blocurile în care se þin i-nodurile toate
blocurile care urmeazã sunt alocate pentru a servi la memorarea
conþinutului fiºierelor.  Aceste blocuri sunt la început toate
libere: nici unul nu este indicat de i-nodul vreunui fiºier ca
aparþinînd acelui fiºier.  Pe mãsurã ce se scriu date în
fiºiere ºi acestea cresc, se iau blocuri libere ºi se adaugã
fiºierelor, fãcînd i-nodurile sã puncteze spre ele.

<P>
Cînd fiºierele sunt ºterse (sau trunchiate) blocurile revin
pe lista blocurilor libere.

<P>

<H2><A NAME="SECTION00045000000000000000">
Lista de blocuri libere</A>
</H2>

<P>
Sistemul de fiºiere þine ºi o listã a blocurilor libere,
pentru a se aproviziona rapid cînd are nevoie sã creascã
fiºierele.  Cînd lista este goalã discul este plin (în alt fel
decît atunci cînd nu mai sunt i-noduri).

<P>
Lista blocurilor libere este ºi ea structuratã într-un mod
inteligent: în superbloc existã un pointer la un prim bloc liber.
Acesta este plin cu pointeri la alte blocuri libere.  Ultimul dintre
blocurile arãtate de el conþine la rîndul lui pointeri spre blocuri
libere º.a.m.d.

<P>
<PRE>
superbloc---&gt;primul bloc liber /--&gt;bloc liber /--&gt;bloc liber
                     | | | | | |   | | | | |  |   | | | | |
                     v v v v \-/   v v v v \--/   v v v v ...
                    pointeri spre blocuri libere
</PRE>

<P>
Aceastã listã aratã ca un arbore dezechilibrat: numai
nodurile de pe ramura cea mai din dreapta au fii; toate celelalte sunt
frunze.  De ce schema asta?  Pentru cã modificarea listei se face de
la început: se iau din blocurile libere punctate de primul, iar cînd
toate s-au terminat mai puþin ultimul (din cele punctate de primul),
chiar primul bloc liber se alocã ºi superblocul puncteazã spre cel
care era ultimul.  Se procedeazã invers pentru eliberarea de blocuri.

<P>
Schema este mai eficientã decît o listã simplu
înlãnþuitã pentru cã nu trebuie citit decît un bloc liber
(primul) pentru a aloca X pointeri: cei pe care îi conþine.

<P>

<H2><A NAME="SECTION00046000000000000000">
Crearea unui sistem de fiºiere</A>
</H2>

<P>
Deºi utilizatorii de DOS pot avea aceastã impresie, nu orice
partiþie trebuie sã conþinã un sistem de fiºiere!  Ba chiar
Unix-ul foloseºte în mod curent o partiþie (de <EM>swap</EM>) pentru a
crea mecanismul de memorie virtualã.  Pe acea partiþie nu se aflã
fiºiere.

<P>
Operaþia prin care pe o partiþie formatatã se creazã un
sistem de fiºiere se numeºte în Unix <TT>mkfs</TT> (MaKe FileSystem) iar
în DOS <TT>format</TT> (dupã cum se vede în DOS distincþia între
partiþie ºi sistem de fiºiere nu este prea clarã nici la nivel de
nume al programelor utilitare).

<P>
Programul <TT>mkfs</TT> foloseºte driverul de disc pentru a crea
blocul de boot, superblocul ºi a iniþializa toate i-nodurile ºi
blocurile de date ca fiind goale.  Abia dupã ce el este executat
poate fi folosit sistemul de fiºiere de pe partiþie, <EM>montîndu</EM>-l
(cu comanda-apel de sistem <TT>mount</TT>).

<P>

<H1><A NAME="SECTION00050000000000000000">
Operaþiile pe fiºiere</A>
</H1>

<P>
Dupã ce am aflat atîtea despre structura de date cu care se
descrie un fiºier putem sã ne imaginãm cu uºurinþã cum se
implementeazã operaþiile de citire/scriere în fiºiere.  Sã
modelãm operaþia de scriere, care este mai complicatã.

<P>
Sã zicem cã vrem sã scriem octetul nr. 100000 cu valoarea 1
într-un anumit fiºier.

<P>
Prima etapã, de care încã n-am spus nimic, este de a gãsi
i-nodul fiºierului cînd i se dã numele.  (Secþiunea despre
directoare a articolului de faþã numai cu asta se ocupã.)  Aceastã
etapã verificã ºi dacã am permisiunea de a face operaþia cerutã
pe acest fiºier.  Dacã nu am voie, operaþia nu se face ºi apelul de
sistem care a invocat-o se terminã cu o eroare.

<P>
Dupã ce am gãsit i-nodul, trebuie sã gãsim blocul pe disc
în care e octetul nr. 100000.  ªtim cîþi octeþi sunt într-un
bloc, aºa cã aflãm al cîtulea bloc al fiºierului este cel care
are octetul 100000.  Presupunînd, ca mai sus, cã un bloc are 1024 de
octeþi, obþinem blocul 100000/1024 = 98 (rotunjind în sus).  Ca sã
ajung la blocul 98 trebuie sã citesc pointerii din blocul de pointeri
simplu indirecþi (el conþine pointerii pentru blocurile 11-266).
ªi anume trebuie sã caut al 88-lea pointer (nu uitaþi cã primele
10 blocuri au proprii pointeri).  Deci mã uit la blocul cu pointerii
spre blocuri.

<P>
Dacã fiºierul a fost mai scurt de 10 blocuri pînã acum,
acest bloc (cel simplu-indirect) nu exista!  În acest caz îl aloc de
pe lista de blocuri libere ºi îl umplu cu pointeri zero, ca sã
arãt cã e gol.

<P>
Dupã ce am gãsit blocul simplu-indirect mã uit la al 88-lea
pointer din el.  Dacã e nenul, înseamnã cã blocul 98, pe care
vreau sã-l modific, fãcea parte deja din fiºier.  Altfel trebuie
sã îl aloc tot eu.  O fac dacã e nevoie, înscriind în blocul
simplu-indirect la pointerul 88 adresa blocului 98, proaspãt alocat.
Blocul nou alocat îl umplu cu zerouri.

<P>
În fine, blocul la care am ajuns conþine octetul cu nr.
100000.  Al cîtulea este?  Aflu fãcînd restul împãrþirii 100000
la 1024 = 672.  Deci în acest bloc scriu în octetul 672 valoarea 1,
dupã care pun blocul la loc pe disc.

<P>
Dacã lungimea fiºierului era mai micã de 100000 (trecutã
în i-nod) o aduc la aceastã valoare.  Pun ºi timpul accesului ºi
modificãrii fiºierului la ora curentã.

<P>
Dacã a fost nevoie pe drum ºi nu s-a putut aloca un bloc
liber, operaþia iar a eºuat.

<P>
Aþi prins schema?  Încercaþi sã o urmãriþi pe hîrtie cu
creionul.

<P>
Observaþi cã nu este obligatoriu ca blocurile 1-97 sã
existe!  Un fiºier poate avea doar octetul 100000, ocupînd pe disc
doar douã blocuri (cel simplu indirect ºi cel cu octetul) în loc
sã aibã 99 de blocuri cu zerouri!

<P>
Aceasta este semantica operaþiei de scriere în fiºier în
Unix.  Citirea unui octet care nu existã se soldeazã cu citirea unui
zero.

<P>

<H1><A NAME="SECTION00060000000000000000">
Directoarele</A>
</H1>

<P>
Observaþi un lucru interesant: dacã ºtii i-nodul unui
fiºier ºtii toate informaþiile importante despre el ºi ai acces la
tot conþinutul lui.

<P>
Directoarele în Unix au un singur rol: sã asocieze fiecãrui
<EM>nume</EM> de fiºier un i-nod.  Se spune despre directoare cã
``leagã nume de i-noduri''.  Directoarele sunt din multe privinþe
niºte fiºiere.  Deosebirea esenþialã însã este cã directoarele
sunt niºte fiºiere care au <EM>o structurã</EM>: sistemul de fiºiere
interpreteazã el însuºi octeþii care formeazã conþinutul unui
director ºi nu permite utilizatorului manipularea lor arbitrarã.

<P>
Pe scurt un director este un vector de legãturi (links).
Orice director aratã aºa:

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fs_dir"></A><A NAME="395"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5:</STRONG>
Link ºi Director</CAPTION>
<TR><TD><IMG
 WIDTH="547" HEIGHT="133" BORDER="0"
 SRC="img6.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{fs_dir.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Pe lîngã un bit care distinge link-urile folosite de cele
libere (link-uri libere apar din cauza lui <TT>rm</TT> -- ºtergerea),
link-ul mai conþine doar douã cîmpuri: un nume de fiºier (care
poate conþine aproape orice caractere, cea mai notabilã excepþie
fiind <TT>/</TT>), ºi un numãr de i-nod.  O restricþie este ca toate
numele aflate în link-urile dintr-un director sa fie distincte.  Nici
unul din caracterele care compun numele unui fiºier nu are vreo
semnificaþie specialã (cum de exemplu în DOS are punctul).

<P>
Spunem cã fiºierul <TT>bash</TT> se aflã în directorul <TT>bin</TT>
dacã fiºierul <TT>bin</TT>, de tip director, conþine un link al cãrui
nume este <TT>bash</TT>.

<P>
Directoarele pot conþine la rîndul lor directoare: pur ºi
simplu i-nodul dintr-un link este un i-nod de tip director.

<P>
Dupã cum vedeþi de fapt fiºierele nu sunt <EM>incluse</EM> în
directoare, ci directoarele þin niºte <EM>pointeri</EM> (numãrul de
i-nod) spre fiºierele propriu-zise, asociindu-le ºi un nume.  O
primã întrebare care se poate ivi: nu poate un i-nod sã fie prezent
în douã linkuri diferite?  Rãspunsul este da: pot exista link-uri
multiple la un acelaºi i-nod, în acelaºi director sau în
directoare diferite!

<P>
Un director ar putea arãta aºa:

<P>
<PRE>
nume  | vi  | ex  |     |
i-nod | 100 | 100 | ... |
</PRE>

<P>
Asta înseamnã cã un <EM>acelaºi</EM> fiºier este prezent de
douã ori, odatã cu numele <TT>vi</TT>, altã datã cu numele <TT>ex</TT>.
Modificarea fiºierului numit <TT>vi</TT> se reflectã prin modificarea
fiºierului <TT>ex</TT>.

<P>

<H2><A NAME="SECTION00061000000000000000">
Linkurile <TT>.</TT> ºi <TT>..</TT></A>
</H2>

<P>
Observaþi cã datoritã faptului cã nu fiºierul este în
director ci un arãtãtor spre fiºier, <EM>arborele</EM> de directoare
devine un graf: putem avea cicluri (directoare care se conþin
reciproc) sau fiºiere în mai multe directoare simultan.

<P>
Prin definiþie un director nu este niciodatã gol (deºi la o
adicã putem sã-l forþãm), ci conþine întotdeauna cel puþin
douã link-uri.  Unul se numeºte <TT>.</TT> (punct) ºi este un link la
i-nodul directorului însuºi, iar altul se numeºte <TT>..</TT> (punct
punct) ºi este un link la directorul <EM>tatã</EM> (în care a fost
creat cel despre care vorbim).  Sã vedem un ipotetic exemplu:

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fs_dotlinks"></A><A NAME="401"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 6:</STRONG>
Legaturi intre directoare</CAPTION>
<TR><TD><IMG
 WIDTH="451" HEIGHT="299" BORDER="0"
 SRC="img7.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{fs_dotlinks.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Dupã cum vedeþi în directorul <TT>/usr</TT>, care are i-nodul 20,
se aflã un link cu numele <TT>bin</TT> ºi i-nodul 39.  Directorul cu
i-nodul 39 conþine un link cu numele <TT>.</TT> spre i-nodul 39 (el
însuºi) ºi un link cu numele <TT>..</TT> spre directorul cu i-nodul 20
(``tatãl'' lui).

<P>
Dacã mai þineþi minte, i-nodul are un cîmp care aratã
cîte link-uri aratã spre el însuºi.  Din cauza asta mai sus

<P>
<PRE>
$ ls -ld /usr/bin
drwxr-xr-x   2 root     bin          7168 Jul 23 12:45 /usr/bin
             ^
</PRE>

<P>
are douã legãturi: una aflatã în <TT>/usr</TT> (cu numele
<TT>bin</TT>) ºi una în el însuºi cu numele <TT>.</TT> (punct).

<P>
Dacã în <TT>/usr/bin</TT> ar mai fi fost subdirectoare, fiecare
din ele ar fi avut un link cu numele <TT>..</TT> spre <TT>/usr/bin</TT>.

<P>
Comanda <TT>pwd</TT> (print working directory), care afiºeazã
directorul curent al procesului care o executã, lucreazã astfel:
urmãreºte link-urile <TT>..</TT> pînã la directorul rãdãcinã ºi
cautã i-nodul de la link-ul <TT>.</TT> în directorul <TT>..</TT> pentru a afla
numele (mai citiþi odatã fraza, pe-ndelete).

<P>

<H2><A NAME="SECTION00062000000000000000">
Directorul rãdãcinã</A>
</H2>

<P>
Orice sistem de fiºiere are un director privilegiat, care are
link-ul <TT>..</TT> spre el însuºi.  Acesta este <EM>directorul
rãdãcinã</EM> al sistemului de fiºiere.  Toate cãutãrile de fiºiere
care încep cu semnul <TT>/</TT> cautã întîi în acest director.  Mai
exact, sa vedem cum se fac

<P>

<H1><A NAME="SECTION00070000000000000000">
Operaþiile pe directoare</A>
</H1>

<P>

<H2><A NAME="SECTION00071000000000000000">
Gãsirea i-nodului unui fiºier</A>
</H2>

<P>
Principala operaþie pentru care se folosesc directoarele este
pentru a gãsi i-nodul unui fiºier cînd ºtiu directoarele care
``duc'' la el (<EM>calea: path</EM>).

<P>
Orice proces în Unix are ceea ce se cheamã un <EM>director
curent</EM> (în MS-DOS existã un singur director curent pentru tot
sistemul de operare).  Acesta este cunoscut procesului prin i-nodul
sãu (ºi se poate schimba cu apelul de sistem <TT>chdir</TT>).  Cînd un
proces specificã o operaþie pe fiºiere el indicã <EM>întotdeauna</EM> un nume de fiºier ca o listã de directoare separate
prin semnul <TT>/</TT> (în MS-DOS acesta a fost înlocuit din motive
obscure cu <code>\</code>).  Dacã primul semn dintr-un path este <TT>/</TT>
atunci primul director în care se cautã este directorul rãdãcinã.
Altfel primul director în care se cautã este cel curent.

<P>
Sã vedem acum, pe un exemplu, cum nucleul gãseºte i-nodul
fiºierului <TT>/usr/bin/cc</TT>.

<P>
Primul semn este <TT>/</TT>, deci deschide directorul rãdãcinã.
I-nodul lui este marcat în superbloc, deci conþinutul lui este
accesibil.

<P>
Primul nume este <TT>usr</TT>.  Cautã deci printre toate link-urile
din directorul rãdãcinã unul cu numele <TT>usr</TT>.  Dacã l-a gãsit, se
uitã la numãrul de i-nod al lui <TT>usr</TT>.  Citeºte apoi acest i-nod.
Pentru cã mai existã nume în path dupã <TT>usr</TT>, i-nodul curent
trebuie sã aibã tipul director.

<P>
Presupunînd cã aºa este, nucleul deschide fiºierul aflat
(<TT>usr</TT>) ºi cautã un link cu numele <TT>bin</TT>.  Gãseºte i-nodul lui,
citeºte fiºierul (<TT>bin</TT>) ºi cautã link-ul <TT>cc</TT>.  Odatã gãsit, a
aflat i-nodul lui <TT>cc</TT>, deci poate face orice operaþie cu acesta.

<P>
Mai trebuie spus cã orice operaþie de deschidere a unui
director pentru cãutare este precedatã de verificarea dreptului de a
face aceastã cãutare.  Existã douã feluri de drepturi pentru
directoare:

<P>

<UL>
<LI>bitul <TT>r</TT> la un director aratã dreptul de a citi conþinutul
directorului (un array de link-uri).  Deci dreptul de a afla ce i-nod
corespunde la un nume.

<P>
</LI>
<LI>bitul <TT>x</TT> (em search!) aratã dreptul de a citi
conþinutul unui i-nod indicat de un link din acest director.
</LI>
</UL>

<P>
Dacã un director este accesibil are de obicei drepturi <TT>r-x</TT>.

<P>
Dacã are numai drepturi <TT>r-</TT> atunci se poate afla ce
fiºiere sunt în el, dar ele nu pot fi deschise prin aceste link-uri,
ºi nici i-nodurile lor nu pot fi accesate.  Puteþi face <TT>ls</TT> sau <TT>ls
-i</TT> dar nu <TT>ls -l</TT> pe un astfel de director.

<P>
Dacã are numai drepturi <TT>-x</TT> <EM>nu</EM> puteþi vedea ce
fiºiere conþine, dar dacã <EM>ºtiþi</EM> unul din nume, îl puteþi
deschide!

<P>
Dacã are drepturi <TT>--</TT> pentru dumneavoastrã, atunci
uitaþi de el.

<P>

<H2><A NAME="SECTION00072000000000000000">
Crearea ºi distrugerea fiºierelor</A>
</H2>

<P>
Pentru a crea un fiºier în primul rînd trebuie alocat un
i-nod ºi apoi construit un link.  În Unix <EM>toate</EM> operaþiile
asupra fiºierelor specificã numele fiºierului, ºi niciodatã
i-nodul.  Nu poþi accesa un fiºier al cãrui i-nod îl cunoºti:
trebuie sã ºtii un path spre el.  Din cauza asta funcþioneazã
securitatea în Unix: dacã nu existã nici un path în care un
utilizator sã aibã dreptul de a citi toate directoarele componente,
atunci el nu va putea ajunge niciodatã sã citeascã fiºierul
indicat de acel path.

<P>
Crearea fiºierelor se poate face prin mai multe apeluri de
sistem: <TT>open</TT>, <TT>creat</TT>, <TT>mknod</TT>, <TT>mkdir</TT>.  Toate specificã un path.
Dacã procesul care le executã are dreptul de scriere în penultima
componentã a path-ului (care este directorul în care se creazã
fiºierul) atunci fiºierul este creat, alocîndu-se un i-nod liber
ºi un link în acel director.

<P>
Fiºierele nu pot fi ºterse în Unix!  În Unix se pot doar
ºterge link-uri.  Singurul apel de sistem pentru aºa ceva este <TT>unlink</TT>.  Cînd este ºters un link, i-nodului spre care acesta
puncteazã i se decrementeazã numãrul de referinþe.  Dacã acest
numãr devine 0, înseamnã cã acest fiºier nu mai este legat în
nici un director.  <EM>Dacã</EM> acest fiºier nu este în acea clipã
deschis de nici un proces, atunci toate blocurile de date pe care el
le posedã sunt trecute pe lista de blocuri libere, iar i-nodul lui
este eliberat.  (Dacã este deschis, atunci el va fi eliberat numai
cînd toate procesele vor închide fiºierul).

<P>
Nu faceþi confuzie între operaþia de ºtergere a unui link,
care are nevoie de drept de scriere în directorul din care se ºterge
link-ul, ºi operaþia de <EM>trunchiere</EM> a unui fiºier (la lungime
zero, de pildã) care are nevoie de drept de scriere <EM>doar</EM> în acel
fiºier.

<P>
<PRE>
$ ls -la
drwxr-x--x   7 mihai    users        1024 Jul 29 21:46 ./
drwxr-xr-x   6 root     root         1024 Jul 26 22:50 ../
-rw-rw-rw-   1 mihai    users        3735 Jul 29 19:18 ss
</PRE>

<P>
Un alt utilizator decît <TT>mihai</TT> <EM>nu</EM> poate face <TT>rm ss</TT>,
dar poate face <TT>cp /dev/null ss</TT>, cu care îl ºterge!

<P>
În fine, o ultimã operaþie pe fiºiere pe care o discutãm
este cea de legare.  Se poate crea o legãturã nouã la un fiºier
existent, cu apelul de sistem <TT>link</TT> (sau comanda shell-ului <TT>ln</TT>,
care se foloseºte de acest apel).

<P>
<PRE>
$ ln /bin/bash ./bb
</PRE>

<P>
procedeazã astfel:

<P>

<OL>
<LI>aflã i-nodul lui <TT>/bin/bash</TT>;

<P>
</LI>
<LI>creazã în directorul <TT>.</TT> un link cu numele <TT>bb</TT> (dacã
are drept de scriere);

<P>
</LI>
<LI>pune în acest link i-nodul aflat mai-nainte.
</LI>
</OL>

<P>
În mod normal numai ``super-user-ul'' poate face legãturi la
un director.

<P>
Pentru cã o legãturã conþine un numãr de i-nod, iar
fiecare partiþie are propria ei numerotare independentã de a
celorlalte pentru i-noduri, nu se pot face legãturi pe o partiþie
care sã arate la un fiºier de pe alta.  Pentru asta au fost
inventate legãturile simbolice, despre care vom vorbi altãdatã.

<P>

<H1><A NAME="SECTION00080000000000000000">
Programul <TT>fsck</TT></A>
</H1>

<P>
Un sistem de fiºiere se poate strica din felurite motive (cel
mai comun fiind cã se stinge calculatorul printr-o procedurã
brutalã ºi anumite informaþii nu sunt salvate din cache).  Ca un
filesystem sã fie corect, anumite relaþii trebuie sã fie adevãrate
între componentele sale.  De exemplu un bloc nu trebuie sã fie
simultan în douã fiºiere.

<P>
Un program sofisticat este oferit pentru a verifica
integritatea unui sistem de fiºiere.  <TT>fsck</TT> (File System ChecK) este
rulat de obicei la fiecare pornire a calculatorului ºi încearcã sã
determine toate discrepanþele care aratã cã un sistem de fiºiere
nu este integru, ºi sã le repare cu minimum de alteraþii ghicind ce
s-a stricat de fapt.

<P>
Acest program <EM>nu</EM> lucreazã cu fiºiere ºi directoare,
ci analizeazã direct partiþia la nivel de bloc.  El nu trebuie sã
fie niciodatã executat cînd partiþia este ``montatã'' pentru cã
s-ar putea ca fiºierele sã fie modificate de procesele care ruleazã
în timp ce sunt verificate, deci verificarea sã iasã prost deºi
totul este în regulã.

<P>

<H1><A NAME="SECTION00090000000000000000">
Un experiment</A>
</H1>

<P>
Ca sã verificaþi cã aþi înþeles cum funcþioneazã
sistemul de fiºiere din Unix (deºi multe lucruri au fost lãsate în
suspensie, v-am dat toate informaþiile necesare), încercaþi sã
rezolvaþi urmãtorul exerciþiu pe un Unix care vã oferã mai multe
``ferestre'':

<P>

<OL>
<LI>Deschideþi cîte un shell în douã ferestre;

<P>
</LI>
<LI>În prima tastaþi:

<P>
<PRE>
$ sh
$ cd
$ mkdir bb
$ cd bb
$ ls
$ pwd
</PRE>

<P>
</LI>
<LI>În a doua fereastrã tastaþi:

<P>
<PRE>
$ cd
$ rm -r bb
$ ls -a
</PRE>

<P>
</LI>
<LI>Reveniþi în prima ºi tastaþi:

<P>
<PRE>
$ ls
$ pwd
$ cd ..
$ cd /
</PRE>
</LI>
</OL>

<P>
Explicaþi ce se întîmplã.

<P>

<H1><A NAME="SECTION000100000000000000000">
Rãspuns:</A>
</H1>

<P>

<UL>
<LI>un shell (sh) face din <TT>bb</TT> directorul sau curent.
</LI>
<LI>alt shell ºterge toate link-urile spre <TT>bb</TT> (cu <TT>rm -r</TT>)
</LI>
<LI>procesul <TT>sh</TT> nu poate face 

<UL>
<LI><TT>ls</TT> pentru cã acesta lucreazã cu link-ul <TT>.</TT> din directorul
curent (fost <TT>bb</TT>), care nu mai existã
</LI>
<LI><TT>pwd</TT> pentru cã acesta încearcã sã urmeze link-ul <TT>..</TT> din
<TT>bb</TT>, care nu mai existã
</LI>
<LI><TT>cd ..</TT> nu merge din aceleaºi motive
</LI>
</UL>
</LI>
</UL>

<P>
<BR><HR>

</BODY>
</HTML>
