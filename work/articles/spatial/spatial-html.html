<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Calculatoare ne-universale: implementarea programelor în hardware</TITLE>
<META NAME="description" CONTENT="Calculatoare ne-universale: implementarea programelor în hardware">
<META NAME="keywords" CONTENT="spatial-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Calculatoare ne-universale: 
<BR>
implementarea programelor în hardware</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>mai 2001</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>sintetizarea automatã de calculatoare specifice unei aplicaþii
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe elementare despre arhitectura
calculatoarelor ºi limbaje de programare, elemente de C
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>hardware, hardware reconfigurabil, compilare,
sinteza de circuite
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html41"
  HREF="spatial-html.html">Un excurs istoric</A>
<LI><A NAME="tex2html42"
  HREF="#SECTION00030000000000000000">Modelul spaþial de calcul</A>
<UL>
<LI><A NAME="tex2html43"
  HREF="#SECTION00031000000000000000">Hardware reconfigurabil</A>
<LI><A NAME="tex2html44"
  HREF="#SECTION00032000000000000000">Limbaje de descriere a hardware-ului (HDL)</A>
<LI><A NAME="tex2html45"
  HREF="#SECTION00033000000000000000">Hardware din limbaje de nivel înalt</A>
<LI><A NAME="tex2html46"
  HREF="#SECTION00034000000000000000">Apeluri de procedurã</A>
</UL>
<BR>
<LI><A NAME="tex2html47"
  HREF="#SECTION00040000000000000000">Rezultate preliminare</A>
<UL>
<LI><A NAME="tex2html48"
  HREF="#SECTION00041000000000000000">Un program desfãºurat</A>
<LI><A NAME="tex2html49"
  HREF="#SECTION00042000000000000000">Modelul computaþional</A>
<LI><A NAME="tex2html50"
  HREF="#SECTION00043000000000000000">Duplicarea codului</A>
<LI><A NAME="tex2html51"
  HREF="#SECTION00044000000000000000">Performanþã</A>
<LI><A NAME="tex2html52"
  HREF="#SECTION00045000000000000000">Cercetãri viitoare</A>
</UL>
<BR>
<LI><A NAME="tex2html53"
  HREF="#SECTION00050000000000000000">Alte surse de informaþie</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>

<H1><A NAME="SECTION00020000000000000000">
Un excurs istoric</A>
</H1>

<P>
Primele calculatoare construite erau foarte diferite de cele de
astãzi.  Nu mã refer aici la dimensiuni ºi capacitate (care depind
doar de tehnologie), ci la structura lor fundamentalã.  Acele
calculatoare erau construite pentru a rezolva o <EM>singurã
problemã</EM>; nu erau universale.  Ele constau dintr-o colecþie de
unitãþi funcþionale, care puteau face calcule simple.
``Programatorii'' aveau sarcina de a conecta unitãþile funcþionale
între ele cu sîrme, pe care le înfigeau manual în tot felul de
mufe.  De exemplu, dacã vroiau sã calculeze (a+b)<sup>2</sup>, programatorii
luau o unitate care fãcea adunãri ºi una care fãcea înmulþiri
ºi le cuplau ca în figura&nbsp;<A HREF="spatial-html.html#binom">1</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="binom"></A><A NAME="184"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
Implementarea în hardware a expresiei (a+b)<sup>2</sup>.  Variabilele
devin sîrme, iar operaþiile sunt executate de unitãþi funcþionale.</CAPTION>
<TR><TD><IMG
 WIDTH="135" HEIGHT="229" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=3cm\epsffile{binom.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
În anii '40 în domeniul calculatoarelor intrã în scenã un genial
matematician, pe nume John von Neumann.  von Neumann analizeazã
starea de fapt a calculatoarelor ºi scrie în 1945 un raport
intitulat ``First Draft of a Report on the EDVAC'' (Prima ciornã a
unui raport despre EDVAC), în care sugereazã o arhitectura
revoluþionarã.  În aceastã arhitecturã, programul nu mai este
reprezentat de felul în care sunt cuplate unitãþile funcþionale,
ci este stocat în memorie, fiind descris folosind un limbaj numit
cod-maºinã.  În cod-maºinã, operaþiile de executat sunt
codificate sub forma unor numere numite <EM>instrucþiuni</EM>.
Programul de executat este descris printr-un ºir de instrucþiuni,
care se executã consecutiv.

<P>
Pe lîngã unitãþile funcþionale care fac operaþii aritmetice,
calculatorul mai are o unitate de control, care citeºte
instrucþiunile programului ºi care trimite semnale între
unitãþile funcþionale pentru a executa aceste instrucþiuni.
Rezultatele intermediare sunt stocate în memorie.  Aceastã
arhitecturã se numeºte ``von Neumann''.  Dacã nu sunteþi
impresionaþi de aceastã viziune radicalã, este pentru cã marea
majoritate a calculatoarelor din ziua de azi sunt bazate pe aceastã
arhitecturã; noþiunea de limbaj-maºinã, ºi cea înruditã, de
limbaj de programare, folosite pentru descrierea programelor, sunt
concepte foarte naturale pentru toþi cei care manipuleazã
calculatoarele.

<P>
Se cuvine menþionat faptul cã ideea de a descrie un program folosind
un limbaj (ºi nu prin conexiuni între unitãþi funcþionale) este
mai veche; în 1936 Alan Turing folosise noþiunea de ``maºinã
Turing universalã'' pentru a descrie un calculator universal, care
poate executa orice program.  Programele erau stocate în memoria
calculatorului, reprezentate ca ºiruri de numere.

<P>

<H1><A NAME="SECTION00030000000000000000">
Modelul spaþial de calcul</A>
</H1>

<P>
Spuneam cã marea majoritate a calculatoarelor digitale construite
astãzi au o arhitecturã von Neumann.  Dar nu toate; existã încã
``calculatoare'' bazate pe arhitectura veche, în care unitãþile
funcþionale sunt legate între ele prin sîrme ºi nu existã un
program stocat în memorie.  

<P>
Modelul von Neumann are o virtute excepþionalã: flexibilitatea.
Folosind acelaºi hardware putem executa oricîte programe, toate
diferite între ele.  Preþul care trebuie însã plãtit este
performanþa: unele operaþiuni nu se pot descrie foarte eficient prin
instrucþiunile disponibile, ºi s-ar putea implementa mult mai bine
direct în hardware; figura&nbsp;<A HREF="spatial-html.html#inversare">2</A> prezintã un astfel de
exemplu extrem.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="inversare"></A><A NAME="190"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
Implementarea unui program care pune biþii
dintr-un octet în ordine inversã, în software (în limbajul C) ºi
respectiv hardware.  Execuþia în software necesitã cîteva zeci de
instrucþiuni, pe cînd cea în hardware se face practic instantaneu.</CAPTION>
<TR><TD><IMG
 WIDTH="453" HEIGHT="97" BORDER="0"
 SRC="img4.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{inversare.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Ca atare, atunci cînd este nevoie de performanþã deosebitã, sau
cînd flexibilitatea nu este foarte importantã, inginerii
construiesc în continuare calculatoare specializate.  De exemplu,
ruterele de mare vitezã de pe coloana vertebralã a Internetului
trebuie sã proceseze pachetele cu informaþii la viteze uluitoare (au
la dispoziþie doar cîteva zeci de nano-secunde pentru fiecare
pachet).  Ca atare, unele din funcþiile de clasificare ºi manipulare
ale pachetului sunt implementate direct în hardware, într-un
algoritm fixat.  Chiar dacã performanþa nu este criticã, atunci
cînd algoritmul de procesare este foarte bine standardizat, este
adesea mai ieftin de folosit un astfel circuit specializat, numit ASIC
(Application-Specific Integrated Circuit).  Chiar ºi într-un
calculator obiºnuit se gãsesc de obicei multe astfel de circuite
pentru manipularea perifericelor: plãci de reþea, controlere de
magistralã, etc.

<P>

<H2><A NAME="SECTION00031000000000000000">
Hardware reconfigurabil</A>
</H2>

<P>
În articolul meu anterior din NetReport am discutat despre o
posibilã evoluþie a tehnologiilor electronice, nanotehnologiile,
care ne vor permite sã construim circuite digitale cu miliarde de
porþi logice.  În acel articol am sugerat cã aceste circuite imense
vor putea fi folosite cel mai eficient sub formã de hardware
reconfigurabil.  Hardwareul reconfigurabil este un model de calcul
foarte asemãnãtor cu cel de acum cincizeci de ani: constã dintr-o
``mare'' de porþi logice universale, care pot fi programate
individual pentru a implementa orice funcþie logicã, ºi douã
reþele: una care leagã porþile între ele, ºi care poate fi
configuratã în felurite moduri pentru a lega ºi dezlega porþile,
ºi una de configuraþie, care este folositã pentru a transporta
informaþiile de configurare spre porþi ºi spre cealaltã reþea.

<P>
Folosind hardware reconfigurabil putem sintetiza circuite specifice
fiecãrei aplicaþii; de data asta, însã, în loc de a conecta
unitãþile funcþionale manual, le cuplãm în mod electronic,
schimbînd felul în care sunt cuplate porþile logice.

<P>
În articolul de faþã voi arãta discuta mai pe larg cum se poate
transforma un program într-un circuit ºi ce fel de proprietãþi are
acest nou model de execuþie.

<P>

<H2><A NAME="SECTION00032000000000000000">
Limbaje de descriere a hardware-ului (HDL)</A>
</H2>

<P>
Ideea de a descrie hardware folosind programe nu este de loc nouã; de
fapt circuitele integrate digitale sunt construite chiar în acest
fel: circuitul de construit este descris într-un limbaj special de
programare, numit Hardware Description Language.  Circuitul astfel
descris este apoi prelucrat de o suitã complicatã de programe CAD
(Computer-Aided Design), care optimizeazã circuitul, îl transformã
în operaþii elementare, le plaseazã pe o suprafaþã planã ºi le
conecteazã prin sîrme.  În faza de proiectare, circuitul descris
într-un HDL poate fi <EM>simulat</EM>, pentru testare ºi depanare.

<P>
La ora actualã existã douã limbaje foarte importante de descriere a
hardware-ului, care au fiecare susþinãtorii lor aprigi; unul dintre
ele se numeºte VHDL iar celãlalt Verilog.  VHDL este prescurtarea a
douã prescurtãri: Vhsic HDL, unde VHSIC înseamnã ``Very High Speed
Integrated Circuits''.  Verilog vine de la ``VERifying LOGic'', dar
limbajul este folosit nu numai pentru a simula ºi verifica circuite
logice (cum a fost conceput iniþial, ºi dupã cum aratã numele
sãu), ci ºi pentru a le proiecta ºi implementa (<EM>sinteza de
hardware</EM>; hardware synthesis).

<P>
Cele douã limbaje sunt relativ similare ca putere de expresie, dar
incompatibile între ele.  Sunt de asemenea destul de diferite de
celelalte limbaje obiºnuite de programare: în limbajele HDL
programatorul exprimã un circuit ca o colecþie de sub-circuite care
opereazã în paralel (paralelismul este explicit în program).
Variabilele sunt semnale electrice, iar operaþiile descriu unitãþi
funcþionale.  Nu existã funcþii recursive, structuri de date
complicate sau manipulare dinamicã a memoriei (<TT>malloc/new/free</TT>).

<P>

<H2><A NAME="SECTION00033000000000000000">
Hardware din limbaje de nivel înalt</A>
</H2>

<P>
Verilog ºi VHDL sunt foarte potrivite pentru a descrie circuite,
însã sunt puþin potrivite pentru felul în care gîndesc oamenii.
În general, oamenii au probleme în a-ºi imagina mai multe procese
care se petrec concurent ºi comunicã între ele; din cauza asta
calculatoarele paralele nu au avut prea mult succes, ºi tot din cauza
asta programarea aplicaþiilor cu mai multe fire de execuþie
(threads) este un exerciþiu de disciplinã ºi nervi de fier.

<P>
Ca atare, de multã vreme unele grupuri de cercetare încearcã sã
foloseascã limbaje mai simple ºi mai naturale (de genul Pascal/C)
pentru a descrie hardware.  (Dacã limbajele acestea nu vi se par
naturale, înseamnã cã nu aþi încercat sã descrieþi un sistem
complex în Verilog!).

<P>
Tentativa de a genera hardware din limbaje obiºnuite de programare se
loveºte de mai multe obstacole.  În primul rînd, tehnologia pentru
extragerea paralelismului dintr-un program scris într-un limbaj
``secvenþial'' (ca C sau Fortran) este nesatisfãcãtoare; ori
paralelismul este principalul avantaj al unui model de execuþie în
hardware.

<P>
În al doilea rînd, limbajele de genul C sau Fortran folosesc tot
felul de construcþii care nu au un corespondent direct în hardware,
cum ar fi funcþii recursive, memorie alocatã dinamic, sau structuri
de date complicate.  În ce fel se pot traduce acestea în hardware
într-un mod eficient este un subiect activ de cercetare.

<P>
În cele ce urmeazã voi ilustra cum se pot traduce în hardware
operaþiile fundamentale ale unui limbaj de programare.

<P>

<H3><A NAME="SECTION00033100000000000000">
O instrucþiune</A>
</H3>

<P>
Pentru a traduce o operaþiune simplã în hardware, asociem
variabilele cu ``sîrmele'', ºi operaþiile cu unitãþi
funcþionale, dupã cum am anticipat ºi mai devreme.
Figura&nbsp;<A HREF="spatial-html.html#binom">1</A> ilustreazã o astfel de transformare.

<P>

<H3><A NAME="SECTION00033200000000000000">
Un bloc de instrucþiuni</A>
</H3>

<P>
În limbajele de nivel înalt valorile sunt stocate în variabile; în
codul maºinã ele sunt atribuite unor regiºtri, sau sunt stocate în
memorie.  Cînd avem de-a face cu un bloc de instrucþiuni consecutive
care manipuleazã doar regiºtri, le putem traduce în hardware
transformînd fiecare registru într-o sîrmã, ca în
figura&nbsp;<A HREF="spatial-html.html#bloc">3</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="bloc"></A><A NAME="197"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura:</STRONG>
Un bloc de instrucþiuni ºi circuitul
corespunzãtor.  Observaþi cum variabilele devin sîrme.  Variabila
<TT>b</TT> este folositã de douã ori, deci devine douã sîrme
diferite, <TT>b</TT> ºi <TT>b&#8217;</TT>.  Observaþi de asemenea cum
operaþiile <TT>&amp;</TT> ºi <TT>+</TT> sunt executate simultan.</CAPTION>
<TR><TD><IMG
 WIDTH="316" HEIGHT="219" BORDER="0"
 SRC="img5.png"
 ALT="\begin{figure}\centerline{\epsfxsize=7cm\epsffile{bloc.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H3><A NAME="SECTION00033300000000000000">
Instrucþiuni de control</A>
</H3>

<P>
În limbajele de nivel înalt avem construcþii care selecteazã
între diferite instrucþiuni care urmeazã sã se execute, cum ar fi
<TT>if-then-else</TT>.  Pentru a le traduce pe acestea în hardware avem
mai multe alternative.  În figura&nbsp;<A HREF="spatial-html.html#control">4</A> ilustrãm o
posibilitate care exploateazã la maximum paralelismul dintre
instrucþiuni, executînd simultan pãrþile <TT>then</TT> ºi
<TT>else</TT>, ºi selectînd doar rezultatele necesare.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="control"></A><A NAME="216"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 4:</STRONG> Implementarea
instrucþiunilor de control al execuþiei în mod speculativ: executãm
simultan ramurile <TT>if</TT>, <TT>then</TT> ºi <TT>else</TT> ºi
pãstrãm numai rezultatul corect.  Trapezul este un multiplexor, cu
trei intrãri: un selector, desenat în lateral, ºi douã valori între
care se selecteazã.  Ieºirea multiplexorului este intrarea din stînga
dacã selectorul este 0 ºi intrarea din dreapta dacã selectorul este
1.</CAPTION> <TR><TD><IMG WIDTH="361" HEIGHT="239" BORDER="0"
SRC="img6.png"
ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{control.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Acest gen de execuþie se numeºte <EM>speculativã</EM>, pentru cã
executã mai mult decît este strict necesar ºi selecteazã numai
ceea ce e necesar la sfîrºit.  ªi microprocesoarele moderne
folosesc o formã de execuþie speculativã, pe care am descris-o mai
demult într-un articol din PC Report despre predicþia salturilor.

<P>

<H3><A NAME="SECTION00033400000000000000">
Accese la memorie</A>
</H3>

<P>
Una dintre cele mai puternice trãsãturi ale limbajelor de nivel
înalt este capacitatea de a manipula matrici, care se bazeazã pe
posibilitatea de a adresa memoria în mod <EM>indirect</EM>.  Cu alte
cuvinte, citim conþinutul unei celule de memorie a cãrei adresã a
fost calculatã.

<P>
Accesele indirecte nu pot fi transformate pur ºi simplu în sîrme;
trebuie sã folosim memorii hardware pentru a stoca matrici.  În
plus, atunci cînd avem cod executat în mod speculativ, trebuie sã
fim atenþi sã nu executãm decît accesele la memorie corecte,
pentru cã altfel vom ``strica'' conþinutul memoriei.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="memorie"></A><A NAME="228"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 5:</STRONG>
Pentru a implementa matrici folosim memorii
în care adresãm cu indicele din matrice.  Citirea din matrice este o
citire din memorie, iar scrierea în matrice este o scriere în
memorie.</CAPTION>
<TR><TD><IMG
 WIDTH="361" HEIGHT="203" BORDER="0"
 SRC="img7.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{memorie.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Figura&nbsp;<A HREF="spatial-html.html#memorie">5</A> ilustreazã implementarea unei bucãþi de cod
care conþine accese la memorie.

<P>

<H3><A NAME="SECTION00033500000000000000">
Bucle</A>
</H3>

<P>
Lucrurile devin mai interesante atunci cînd avem de executat bucle.
Circuitul pe care-l implementãm nu mai este un simplu circuit <EM>combinatorial</EM>, în care semnalul se propagã într-un singur sens.
El devine un circuit <EM>secvenþial</EM>, cu o buclã de feed-back.
Bucla de feed-back trebuie sã fie întreruptã de un registru
controlat de un ceas, care sincronizeazã propagarea tuturor
semnalelor din buclã.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="bucla"></A><A NAME="234"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 6:</STRONG>
Implementarea (uºor simplificatã) a unei
bucle.  Un <EM>registru</EM> citeºte noua valoare a lui <TT>i</TT> la
fiecare tact de ceas ºi o memoreazã pînã la urmãtorul tact.
Bucla este pornitã în execuþie punînd semnalul de iniþializare pe
0 (dupã aceea semnalul trebuie sã rãmînã 1 pînã la terminarea
buclei).  Semnalul de terminare a buclei indicã momentul cînd toate
iteraþiile s-au terminat.</CAPTION>
<TR><TD><IMG
 WIDTH="543" HEIGHT="254" BORDER="0"
 SRC="img8.png"
 ALT="\begin{figure}\centerline{\epsfxsize=12cm\epsffile{bucla.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Figura&nbsp;<A HREF="spatial-html.html#bucla">6</A> ilustreazã o posibilã implementare a unei
bucãþi de cod care conþine o buclã.

<P>

<H2><A NAME="SECTION00034000000000000000">
Apeluri de procedurã</A>
</H2>

<P>
Cînd avem un program compus din mai multe proceduri, fiecare
procedurã poate fi implementatã ca un circuit separat.  Procedura
curentã, în curs de execuþie, corespunde circuitului activ.
Controlul este transmis între proceduri prin semnale care activeazã
procedura chematã.

<P>
O problemã ceva mai complicatã este cã atunci cînd procedura
chematã se terminã, trebuie sã sarã la o bucatã de cod diferitã
de fiecare datã (la chemãtorul ei).  Acest lucru poate fi realizat
în mai multe feluri; de exemplu, fiecare procedurã primeºte un
parametru suplimentar, care este chemãtorul sãu; pentru terminarea
procedurii, se poate sintetiza o bucatã de hardware care selecteazã
dintre toþi chemãtorii posibili bazat pe valoarea acestui parametru
ºi-i trimite un mesaj cînd procedura curentã ºi-a terminat
execuþia.

<P>
Aceastã implementare nu funcþioneazã pentru procedurile recursive,
care mai au nevoie ºi de o stivã; deocamdatã nu avem la-ndemînã o
soluþie eficientã pentru a trata astfel de cazuri.

<P>

<H1><A NAME="SECTION00040000000000000000">
Rezultate preliminare</A>
</H1>

<P>
Pentru a estima impactul unui asemenea model de calcul asupra
performanþei am fãcut un studiu preliminar, care face o mulþime de
asumpþii simplificatoare.  Sperãm cã modelul real de calcul nu va
da rezultate substanþial diferite de idealizarea noastrã.

<P>
Cel mai ``idealizat'' aspect al analizei noastre constã în
cantitatea de informaþie pe care am folosit-o despre program ºi
zonele de memorie pe care le foloseºte: am presupus cã ºtim exact
ce adrese de memorie vor fi accesate de fiecare instrucþiune de
citire ºi scriere din memorie.  Aceastã informaþie a fost
colectatã executînd programul modificat pentru a colecta informaþii
despre propria sa comportare (un astfel de program se numeºte <EM>instrumentat</EM>).

<P>

<H2><A NAME="SECTION00041000000000000000">
Un program desfãºurat</A>
</H2>

<P>
Figura&nbsp;<A HREF="spatial-html.html#graf">7</A> aratã un astfel de program desfãºurat ºi aºezat
în plan.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="graf"></A><A NAME="243"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 7:</STRONG>
Un program aºezat în plan.  Fiecare pãtrat
reprezintã 100 de unitãþi, unde o instrucþiune aritmeticã simplã
sau un cuvînt de memorie ocupã 1 unitate.  Un pãtrat verde conþine
numai memorie, iar un pãtrat alb conþine numai instrucþiuni.
Nuanþe intermediare indicã mixturi de instrucþiuni ºi memorie.
Liniile roºii indicã transfer de control între blocuri consecutive
de instrucþiuni, iar liniile albastre indicã accese la memorie.
Grosimea unei linii este proporþionalã cu logaritmul frecvenþei cu
care acea linie este utilizatã.  De exemplu, o linie de 10 ``pixeli''
a fost utilizatã de program de 2<sup>10</sup> = 1024 de ori.  Liniile
groase sunt deci mult mai importante decît cele subþiri.</CAPTION>
<TR><TD><IMG
 WIDTH="452" HEIGHT="297" BORDER="0"
 SRC="img9.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{graf.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Fiecare program este reprezentat sub forma unui <EM>graf</EM>, în care
nodurile sunt instrucþiuni sau memorii ºi în care muchiile sunt
transfer de execuþie între instrucþiuni sau accese la memorie.
Toate programele pe care le-am analizat<A NAME="tex2html10"
  HREF="#foot124"><SUP>1</SUP></A> au trãsãturi
foarte similare:

<P>

<UL>
<LI>Numãrul de muchii este proporþional cu cel de noduri
(constanta de proporþionalitate este sub 10)<A NAME="tex2html11"
  HREF="#foot126"><SUP>2</SUP></A>.
</LI>
<LI>Gradul unui nod (numãrul de vecini) urmeazã o distribuþie
foarte inegalã: cîteva noduri au foarte multe muchii.
</LI>
<LI>În particular, existã un numãr foarte mic de noduri care
``atinge'' aproape toatã memoria folositã de program.  În figurã sunt
douã astfel de pãtrate, din care radiazã foarte multe muchii
albastre.  Numim astfel de noduri ``stele''.
</LI>
</UL>

<P>
Analizînd graful din figurã am descoperit cã una dintre cele douã
stele este în corpul funcþiei <TT>memcpy</TT>.  Dacã ne gîndim
puþin, vom realiza cã acest lucru este foarte natural: toate
structurile de date ale programului care sunt copiate vor fi atinse
de aceastã funcþie.  

<P>

<H2><A NAME="SECTION00042000000000000000">
Modelul computaþional</A>
</H2>

<P>
Dacã am luat un program ºi l-am ``întins'' pe o suprafaþã,
întrebarea urmãtoare este: ``cît de repede merge''?  Pentru a putea
rãspunde, trebuie sã precizãm alte cîteva lucruri despre modelul
nostru computaþional:

<P>

<UL>
<LI>Am transformat fiecare bloc de instrucþiuni aflate între douã
instrucþiuni de salt (jump/branch) consecutive într-un circuit; (nu
am folosit deci metoda descrisã mai sus pentru a genera cod
speculativ: un <TT>if</TT> va executa numai ramura corectã).

<P>
</LI>
<LI>Am presupus cã în interiorul fiecãrui bloc toate
instrucþiunile independente se vor executa în paralel.

<P>
</LI>
<LI>Am presupus cã timpul de transmisiune a unui semnal de-a lungul
unei muchii este proporþional cu lungimea muchiei.

<P>
</LI>
<LI>Am presupus cã un bloc este pornit în execuþie numai dupã ce
blocul anterior a terminat complet de calculat, ºi cã mesajul prin
care execuþia este pornitã este trimis împreunã cu datele de la
intrarea blocului.

<P>
</LI>
<LI>Nu am fãcut nici un fel de optimizãri specifice generãrii de
hardware (de exemplu, un circuit care adunã cu valoarea constantã 1
poate fi fãcut mult mai simplu ºi mai rapid decît un circuit
general de adunare).
</LI>
</UL>

<P>

<H2><A NAME="SECTION00043000000000000000">
Duplicarea codului</A>
</H2>

<P>
Pornind de la acest model am evaluat performanþa programelor.
Rezultatele au fost amestecate.  Am cãutat apoi metode de a
îmbunãtãþi performanþa prin transformãri simple.

<P>
Primul obiectiv asupra cãruia ne-am îndreptat atenþia au fost
``stelele''; acestea sunt detrimentale performanþei, pentru cã,
avînd mulþi vecini, unii dintre aceºtia vor fi în mod necesar
plasaþi la distanþã mare de centru, deci vor fi accesaþi foarte
greu.

<P>
Ne-am întrebat: nu am putea cumva sã ``spargem'' o stea în bucãþi, în
aºa fel încît sã facem douã stele mai mici?  Rãspunsul este: da, ºi
chiar foarte simplu.  Tot ce trebuie fãcut pentru programul din figurã
este sã duplicãm codul funcþiei <TT>memcpy</TT> ºi sã aranjãm ca din
locuri diferite sã fie chemate copii diferite.  O tehnicã foarte
simplã pentru a realiza acest lucru se numeºte în compilatoare
``inlining'', în care funcþia chematã este inseratã textual în codul
chemãtorului.

<P>
Dupã ce am aplicat aceastã transformare, am obþinut graful din
figura&nbsp;<A HREF="spatial-html.html#graf-inline">8</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="graf-inline"></A><A NAME="253"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 8:</STRONG>
Programul din figura&nbsp;<A HREF="spatial-html.html#graf">7</A> dupã ce
corpul funcþiei <TT>memcpy</TT> a fost duplicat prin <EM>inlining</EM>.
Observaþi cum stelele sunt mult mai mici ºi mai bine plasate.</CAPTION>
<TR><TD><IMG
 WIDTH="452" HEIGHT="309" BORDER="0"
 SRC="img10.png"
 ALT="\begin{figure}\centerline{\epsfxsize=10cm\epsffile{graf-inline.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00044000000000000000">
Performanþã</A>
</H2>

<P>
Rezultatele au fost destul de interesante.  Am comparat performanþa
acestor programe cu execuþia lor pe un microprocesor Alpha 21164 la
500 Mhz.  Am presupus cã în implementarea spaþialã vom putea
executa o operaþie pe ciclu de ceas ºi cã vom putea folosi aceeaºi
frecvenþã de ceas cu Alpha.

<P>
În medie programele noastre funcþioneazã ceva mai puþin de 2 ori
mai încet decît pe Alpha, dar unele dintre ele merg mai rapid, dupã
cum se vede în figura&nbsp;<A HREF="spatial-html.html#performanta">9</A>, în stînga.  Graficul din
dreapta aratã cum îºi petrece timpul fiecare din programe.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="performanta"></A><A NAME="263"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 9:</STRONG>
<B>În stînga</B> este raportul dintre
timpul de execuþie al programului executat pe un microprocesor Alpha
ºi pe un model spaþial de calcul.  Valoarea zero indicã egalitatea
timpului de execuþie.  O valoare negativã indicã execuþie mai
rapidã în hardware, pe cînd o valoare pozitivã indicã execuþie
mai rapidã pe Alpha.  <B>În dreapta</B> este ilustrat timpul de
execuþie al fiecãrui program.  Culoarea verde indicã timp petrecut
aºteptînd ca citiri din memorii de la distanþã sã returneze
rezultatul.  Albastru este pentru timp în care se executã calcule
utile.  Negru aratã timpul petrecut transferînd control între
blocuri consecutive, ºi galben mãsoarã timpul de transfer al
datelor între blocuri consecutive.  Porþiunile verde ºi negru pot fi
probabil reduse prin optimizãri mai agresive, cum ar fi folosirea de
cache-uri ºi respectiv execuþie speculativã.</CAPTION>
<TR><TD><IMG
 WIDTH="722" HEIGHT="297" BORDER="0"
 SRC="img11.png"
 ALT="\begin{figure}\centerline{\epsfxsize=16cm\epsffile{performanta.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>

<H2><A NAME="SECTION00045000000000000000">
Cercetãri viitoare</A>
</H2>

<P>
Acest text ilustreazã cercetãrile noastre preliminare în domeniul
modelului spaþial de execuþie; foarte multe lucruri mai rãmîn de
fãcut.  Rezultatele noastre sunt însã încurajatoare: avem o
metodologie care ne permite sã compilãm programe destul de
complicate iar performanþa nu este substanþial degradatã faþã de
modelele de calcul convenþionale.

<P>
Va trebui însã sã dezvoltãm o grãmadã de tehnici noi, plecînd
de la construcþia hardware-ului reconfigurabil însuºi, trecînd
prin metode de compilare ºi scule de simulare mai sofisticate, care
iau în considerare mai multe detalii despre arhitectura realã a unui
astfel de sistem.

<P>

<H1><A NAME="SECTION00050000000000000000">
Alte surse de informaþie</A>
</H1>

<P>

<UL>
<LI>Pagina Alan Turing: <TT><A NAME="tex2html14"
  HREF="http://www.turing.org.uk/turing">http://www.turing.org.uk/turing</A></TT>.

<P>
</LI>
<LI>O scurtã introducere în VHDL:
<TT><A NAME="tex2html15"
  HREF="http://www.eej.ulst.ac.uk/tutor/vhdnotes.html">http://www.eej.ulst.ac.uk/tutor/vhdnotes.html</A></TT>.

<P>
</LI>
<LI>Un site despre Verilog: <TT><A NAME="tex2html16"
  HREF="http://www.verilog.com">http://www.verilog.com</A></TT>.

<P>
</LI>
<LI>Articolul din conferinþa ISCA 2001 care prezintã rezultatele
descrise în acest articol este disponibil la
<TT><A NAME="tex2html17"
  HREF="http://www.cs.cmu.edu/~mihaib/research/isca01.ps">http://www.cs.cmu.edu/~mihaib/research/isca01.ps</A></TT>.

<P>
Articole ale mele anterioare din PC Report:

<P>

<UL>
<LI>august 1999, despre predicþia salturilor

<BR><TT><A NAME="tex2html18"
  HREF="http://www.cs.cmu.edu/~mihaib/articles/complex/articles.html#predictie">http://www.cs.cmu.edu/~mihaib/articles/complex/articles.html#predictie</A></TT>.

<P>
</LI>
<LI>luna decembrie 1999, despre teoria complexitãþii ºi maºina
Turing universalã:

<BR><TT><A NAME="tex2html19"
  HREF="http://www.cs.cmu.edu/~mihaib/articles/complex/articles.html#complex">http://www.cs.cmu.edu/~mihaib/articles/complex/articles.html#complex</A></TT>.

<P>
</LI>
<LI>luna mai 2001, despre nanotehnologie:

<BR><TT><A NAME="tex2html20"
  HREF="http://www.cs.cmu.edu/~mihaib/articles/articles.html#nano">http://www.cs.cmu.edu/~mihaib/articles/articles.html#nano</A></TT>.

<P>
</LI>
<LI>iulie 1998, despre hardware reconfigurabil:

<BR><TT><A NAME="tex2html21"
  HREF="http://www.cs.cmu.edu/~mihaib/articles/articles.html#reconf">http://www.cs.cmu.edu/~mihaib/articles/articles.html#reconf</A></TT>.
</LI>
</UL>
</LI>
</UL>

<P>
<BR><HR><H4>Note</H4>
<DL>
<DT><A NAME="foot124">... analizat</A><A NAME="foot124"
 HREF="spatial-html.html#tex2html10"><SUP>1</SUP></A>
<DD>Am analizat o serie
de programe reprezentative scrise în limbajul C.

<DT><A NAME="foot126">... 10)</A><A NAME="foot126"
 HREF="spatial-html.html#tex2html11"><SUP>2</SUP></A>
<DD>Numãrul de
muchii într-un graf poate fi pãtratic în cel de noduri.

</DL>
<BR><HR>

</BODY>
</HTML>
