<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Execuþia speculativã</TITLE>
<META NAME="description" CONTENT="Execuþia speculativã">
<META NAME="keywords" CONTENT="speculativ-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Execuþia speculativã</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT><A NAME="tex2html2"
  HREF="http://www.cs.cmu.edu/~mihaib/">http://www.cs.cmu.edu/~mihaib/</A></TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>august 2001</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>diferite forme de execuþie speculativã în
procesoarele contemporane
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>cunoºtinþe despre arhitectura
microprocesoarelor
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>execuþie speculativã, thread, microprocesor
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Cuprins</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html31"
  HREF="speculativ-html.html">Performanþa procesoarelor</A>
<LI><A NAME="tex2html32"
  HREF="#SECTION00030000000000000000">Paralelismul din programe</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION00040000000000000000">Execuþia speculativã</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION00050000000000000000">Execuþia speculativã în software</A>
<LI><A NAME="tex2html35"
  HREF="#SECTION00060000000000000000">Execuþie speculativã în microprocesoare</A>
<UL>
<LI><A NAME="tex2html36"
  HREF="#SECTION00061000000000000000">Soluþia hardware</A>
<LI><A NAME="tex2html37"
  HREF="#SECTION00062000000000000000">Soluþia mixtã</A>
</UL>
<BR>
<LI><A NAME="tex2html38"
  HREF="#SECTION00070000000000000000">Execuþie speculativã la nivel de thread</A>
<LI><A NAME="tex2html39"
  HREF="#SECTION00080000000000000000">Rezumat</A>
<LI><A NAME="tex2html40"
  HREF="#SECTION00090000000000000000">Alte surse de informaþie</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>

<H1><A NAME="SECTION00020000000000000000">
Performanþa procesoarelor</A>
</H1>

<P>
Iatã un citat din ºtirile de astãzi (16 august 2001): ``Pe data de
27 august, la Intel Developer Forum, compania Intel va lansa noul
procesor Pentium 4 la 2 Ghz''.

<P>
Deja nu mai surprinde pe nimeni apariþia unei noi generaþii de
procesoare: timp de treizeci de ani noile generaþii s-au succedat
celor vechi, crescînd performanþa de fiecare datã cu un factor
constant.  Chiar dacã constanta în sine este micã, rezultatele
acumulate de-a lungul timpului sunt copleºitoare.  Pentru a mãsura
distanþa parcursã, este suficient sã ne uitãm la Intel 4004,
primul microprocesor, care avea o vitezã de ceas de 0,7 Mhz.
Creºterea înregistratã în exact 30 de ani este de 2 Ghz/0.7 Mhz =
2875 de ori!

<P>
Performanþa computaþionalã a calculatoarelor a crescut însã ºi
mai mult în aceastã perioadã.  Acest lucru este posibil pentru cã
performanþa unui microprocesor nu depinde doar de frecvenþa
ceasului, ci ºi de numãrul de instrucþiuni care pot fi executate
într-un ciclu de ceas.  Procesoarele au evoluat enorm ºi în
aceastã privinþã: Intel 4004 lucra la o singurã instrucþiune la
un moment dat, ºi îi trebuiau mai mulþi cicli de ceas pentru a o
executa complet, Pentium 4 poate avea simultan în execuþie pînã la
126 de instrucþiuni diferite, ºi poate termina execuþia mai multor
instrucþiuni în fiecare ciclu.

<P>
În acest articol voi discuta despre contribuþia la performanþã a
micro-arhitecturii ºi compilatoarelor ºi voi ignora contribuþia
ceasului.  Voi discuta atît procesoare contemporane, dar ºi unele
aflate încã pe ``planºetele'' designer-ilor, care încã nu au fãcut
saltul din laboratoarele de cercetare în fabrici.

<P>
Am mai scris articole în PC Report despre arhitectura procesoarelor
moderne (unele sunt menþionate în finalul acestui articol); în
articolul de faþã mã voi concentra asupra unei singure tehnologii,
ºi anume <EM>execuþia speculativã</EM> a codului.

<P>

<H1><A NAME="SECTION00030000000000000000">
Paralelismul din programe</A>
</H1>

<P>
Pentru a motiva folosirea execuþiei speculative, trebuie sã
subliniem încã odatã rolul paralelismului în performanþa
sistemelor de calcul.  Dacã fixãm frecvenþa ceasului, singura
metodã prin care putem creºte performanþa este sã executãm mai
multe instrucþiuni în aceeaºi perioadã de timp.  (Putem face ca
fiecare instrucþiune sã dureze mai puþini cicli de ceas, dar
beneficiile pe care le putem extrage cu aceastã metodã sunt
limitate.)  O sursã de performanþã este deci execuþia mai multor
instrucþiuni <EM>simultan</EM>.  Toate procesoarele moderne folosite în
calculatoare (nu neapãrat ºi cele din sisteme de control) sunt <EM>superscalare</EM>, putînd executa mai multe instrucþiuni în paralel.
De exemplu, Pentium 4 are 8 unitãþi funcþionale care pot opera în
paralel.

<P>
Aparent punem deci mai multe unitãþi computaþionale în paralel ºi
performanþa creºte.  În realitate lucrurile sunt mult mai
complicate, pentru cã nu oricare douã instrucþiuni dintr-un program
se pot executa simultan.  De exemplu, dacã o instrucþiune foloseºte
rezultatul alteia, atunci prima trebuie sã-ºi termine execuþia
înainte ca a douã sã înceapã.  Acest fenomen se numeºte <EM>dependenþã</EM> între cele douã instrucþiuni.

<P>
Existã douã feluri de dependenþe între instrucþiuni: dependenþe
de date ºi dependenþe de control.  Acestea sunt ilustrate în
figura&nbsp;<A HREF="speculativ-html.html#dependenta">1</A>.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="dependenta"></A><A NAME="206"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 1:</STRONG>
Dependenþe (a) <B>dependenþã de date:</B>
instrucþiunea a doua are nevoie de rezultatul primeia (b) <B>dependenþã de control:</B> instrucþiunea a doua trebuie sã aºtepte
evaluarea condiþiei pentru a ºti dacã trebuie sã fie executatã.</CAPTION>
<TR><TD><IMG
 WIDTH="361" HEIGHT="129" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=8cm\epsffile{dependenta.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Putem sã ne punem întrebarea: cîte instrucþiuni independente
existã într-un program?  Cît de multe instrucþiuni putem executa
potenþial în paralel, presupunînd cã avem un procesor ideal, cu o
infinitate de resurse?  Care tipuri de dependenþe impun mai multe
constrîngeri?

<P>
Pentru a rãspunde la astfel de întrebãri, la începutul anilor '90
mai mulþi cercetãtori au fãcut niºte studii ``limitã'', care
încercau sã estimeze paralelismul total disponibil într-un program
(cu alte cuvinte, care este limita superioarã pentru paralelismul
care poate fi exploatat de hardware).

<P>
Un astfel de studiu, a fost publicat de doi cercetãtori de la
universitatea Stanford în 1992; titlul sãu este ``Limite ale
dependenþelor de control asupra paralelismului''.  Voi rezuma aici
doar concluziile principale ale studiului, care sunt foarte
interesante.

<P>
Putem clasifica programele analizate în acest studiu în douã mari
categorii: programe ``numerice'', scrise în FORTRAN, care
manipuleazã matrici mari ºi au structuri de date foarte simple, ºi
programe ne-numerice, care sunt scrise în C, au structuri de date
complicate alocate dinamic ºi folosesc pointeri.  Aceastã
categorisire este relativ standard; suita de programe SPEC, cea mai
folositã pentru a evalua performanþa sistemelor de calcul, conþine
o mixturã de astfel de programe.

<P>
Natura paralelismului este diferitã pentru cele douã categorii:
programele în FORTRAN exhibã mai mult paralelism ºi mai multã
regularitate în calcul (de exemplu, instrucþiunile de salt sunt mai
predictibile).  Dacã socotim numai dependenþele de date,
paralelismul variazã între 45 ºi 3200 de instrucþiuni simultan
pentru programele ne-numerice ºi între 800 ºi 300000 (sic!) pentru
programele FORTRAN.

<P>
Dacã însã ne uitãm ºi la dependenþele de control, situaþia se
schimbã în mod dramatic: paralelismul disponibil coboarã la o
valoare sub 10 pentru programele ne-numerice, ºi la valori între 2
ºi 60000 pentru cele numerice.  Acest lucru se întîmplã pentru cã
instrucþiunile de salt sunt foarte frecvente în programe: în medie,
una din 7 instrucþiuni este un salt.  Dacã în plus presupunem cã
calculatorul nu poate executa douã salturi simultan, paralelismul
coboarã la o valoare sub 3 pentru programele ne-numerice ºi la un
maxim de 400 pentru cele numerice.

<P>
Din acest studiu putem extrage urmãtoarea concluzie:: <EM>dacã
executãm instrucþiunile programului în ordine, respectînd dependenþele
de control, nu putem creºte performanþa programului prea mult:</EM>
pur ºi simplu, nu existã suficient paralelism în program.  Acest lucru
este foarte pregnant pentru programele ne-numerice, care constituie
majoritatea covîrºitoare a programelor care se executã pe un desktop
contemporan.

<P>

<H1><A NAME="SECTION00040000000000000000">
Execuþia speculativã</A>
</H1>

<P>
Dacã vrem sã exploatãm mai mult paralelism, trebuie sã facem ceva
deosebit; nu putem executa instrucþiunile din programe în ordine.
Soluþia este sã executãm cod <EM>înainte</EM> de a fi siguri cã
trebuie executat; în felul acesta, dacã mai tîrziu aflãm cã am
anticipat corect, vom avea rezultatele pre-calculate.  Aceasta este
execuþia speculativã.

<P>
Existã douã feluri de execuþie speculativã:

<P>

<UL>
<LI>Care prezice instrucþiunile care se vor executa în viitor ºi
le executã mai devreme;
</LI>
<LI>Care executã instrucþiuni în toate direcþiile posibile
simultan ºi pãstreazã numai rezultatele corecte.
</LI>
</UL>

<P>
În general microprocesoarele executã programele dupã prima
strategie.  A doua strategie este însã adesea folositã în
circuitele hardware.  Figura&nbsp;<A HREF="speculativ-html.html#speculatie">2</A> ilustreazã beneficiile
execuþiei speculative.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="speculatie"></A><A NAME="214"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 2:</STRONG>
(a) Un fragment de program în C (b)
Execuþie a programului care respectã dependenþele de control:
întîi trebuie evaluatã condiþia C, ºi abia dupã aceea se poate
executa blocul A sau blocul B, depinzînd de rezultat.  (c) Execuþia
speculativã executã simultan A, B ºi C.  Apoi rezultatul evaluãrii
condiþiei este folosit pentru a alege rezultatele corecte.</CAPTION>
<TR><TD><IMG
 WIDTH="498" HEIGHT="295" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=11cm\epsffile{speculatie.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Lucrurile nu sunt însã chiar aºa de simple: ce se întîmplã cu
rezultatele speculaþiei dacã am executat ramura greºitã?  În
acest caz va trebui sã distrugem rezultatele parþiale calculate ºi
sã re-calculãm pe ramura corectã.  Execuþia speculativã eliminã
dependenþele de tip control din program, dar nu poate elimina
dependenþele de date.

<P>
Execuþia speculativã poate fi incorectã din douã motive:

<P>

<UL>
<LI>Bucata de cod pe care am ales-o nu trebuia executatã de loc: de
exemplu, alegem sã executãm A, dar trebuia sã executãm B;
</LI>
<LI>Bucata de cod pe care o executãm speculativ are nevoie de
informaþii care încã nu au fost calculate: de exemplu, o valoare
calculatã de C este necesarã în calculul lui A.
</LI>
</UL>

<P>
În concluzie, pentru a implementa execuþia speculativã avem nevoie
de urmãtoarele ingrediente:

<P>
<DL>
<DT><STRONG>alegere:</STRONG></DT>
<DD>Un mecanism care alege codul care va fi executat în
viitor;
</DD>
<DT><STRONG>detecþie:</STRONG></DT>
<DD>Un mecanism care depisteazã cînd execuþia
speculativã este eronatã, fie pentru cã am ales o ramurã
greºitã, fie pentru cã am ignorat o dependenþã de date;
</DD>
<DT><STRONG>reparaþie:</STRONG></DT>
<DD>Un mecanism care permite ca execuþia speculativã
greºitã sã fie des-fãcutã (rezultatele ei sã fie ``ºterse'');
</DD>
<DT><STRONG>reluare:</STRONG></DT>
<DD>Un mecanism care ne permite dupã o eroare sã reluãm
execuþia pe calea corectã.
</DD>
</DL>

<P>
În cele ce urmeazã voi discuta pe scurt în ce fel este
implementatã execuþia speculativã în procesoarele de astãzi, ºi
apoi cum aratã propunerile pentru procesoarele viitorului.
Procesoarele contemporane executã speculativ cod la nivel de
instrucþiune, pe cînd cele viitoare vor suporta probabil execuþia
speculativã la nivel de fir de execuþie (thread).

<P>
Execuþia speculativã poate fi implementatã în software, în
hardware, sau folosind o mixturã a ambelor tehnici.

<P>

<H1><A NAME="SECTION00050000000000000000">
Execuþia speculativã în software</A>
</H1>

<P>
Execuþia speculativã implementatã în software este folositã în
cazul procesoarelor paralele.  Avem atunci de a face cu programe pe
care vrem sã le executãm pe mai multe procesoare simultan, dar care
nu au fost scrise în mod paralel.  Cînd compilatorul nu poate
paraleliza automat codul, poate recurge la execuþia paralelã
speculativã.  Iatã un astfel de exemplu:

<P>
<PRE>
for (i=0; i &lt; N; i++) 
        a[b[i]] = f(i);
</PRE>

<P>
Sã presupunem cã <TT>N=2</TT>, ºi cã evaluarea funcþiei <TT>f</TT> nu
are ``efecte laterale''.

<P>

<UL>
<LI>Dacã matricea <TT>b</TT> conþine valorile <TT>[1,1]</TT>, atunci
cele douã atribuiri din buclã trebuie executate una dupã alta,
pentru cã amîndouã modificã variabila <TT>a[1]</TT>.

<P>
</LI>
<LI>Dacã matricea <TT>b</TT> însã conþine valorile <TT>[1,2]</TT>,
cele douã atribuiri se pot efectua în paralel, pentru cã folosesc
indici diferiþi în <TT>a</TT>.
</LI>
</UL>

<P>
Un compilator nu poate în general ºti care sunt valorile din
vectorul <TT>b</TT>, ºi ca atare nu va paraleliza acest cod.  Dacã
<TT>N</TT> este mare ºi ºtim cã în vectorul <TT>b</TT> nu existã douã
valori identice, atunci putem distribui toate aceste operaþii pe mai
multe procesoare, fiecare procesor efectuînd unele dintre ele.

<P>
Lawrence Rauchwerger a fost primul care a studiat în detaliu
execuþia speculativã complet în software; în schema pe care o
propune, compilatorul genereazã un program cu urmãtoarea structurã:

<P>

<UL>
<LI>Executã codul speculativ în paralel pe mai multe procesoare,
colectînd rezultatul într-un vector auxiliar <TT>aux</TT>;
</LI>
<LI>Monitorizeaza valorile din vectorul <TT>b</TT>;

<UL>
<LI>Dacã în final nu existã douã valori identice în <TT>b</TT>,
copiazã rezultatul din variabila <TT>aux</TT> în variabila <TT>a</TT>;
</LI>
<LI>Dacã se depisteazã douã valori identice în <TT>b</TT>,
executã versiunea originalã secvenþialã a codului ºi ignorã
variabila <TT>aux</TT>.
</LI>
</UL>
</LI>
</UL>

<P>
Frumuseþea acestei scheme este cã, atunci cînd speculaþia este
corectã, programul se executã mult mai repede, iar cînd speculaþia
este incorectã, nu se pierde foarte mult timp (se iroseºte doar
timpul pentru o execuþie paralelã, care e mai mic decît cel pentru
execuþia secvenþialã).  Preþul suplimentar pe care îl plãtim
este execuþia codului care verificã dacã valorile din vectorul
<TT>b</TT> se suprapun.

<P>
Observaþi toate ingredientele pe care le-am descris mai sus:

<P>
<DL>
<DT><STRONG>alegere:</STRONG></DT>
<DD>în cazul nostru, se vor executa viitoarele iteraþii
ale buclei&nbsp;<TT>for</TT>;
</DD>
<DT><STRONG>detecþie:</STRONG></DT>
<DD>cod suplimentar care monitorizeazã accesele la
variabila&nbsp;<TT>b</TT>; 
</DD>
<DT><STRONG>reparaþie:</STRONG></DT>
<DD>variabila auxiliarã <TT>aux</TT> stocheazã
rezultatele intermediare, fãrã a ``polua'' variabila realã&nbsp;<TT>a</TT>;
</DD>
<DT><STRONG>reluare:</STRONG></DT>
<DD>codul generat de compilator, care include atît
versiunea paralelã cît ºi pe cea secvenþialã.
</DD>
</DL>

<P>

<H1><A NAME="SECTION00060000000000000000">
Execuþie speculativã în microprocesoare</A>
</H1>

<P>

<H2><A NAME="SECTION00061000000000000000">
Soluþia hardware</A>
</H2>

<P>
O schemã de execuþie speculativã implementatã complet în hardware
este folositã la ora actualã de toate microprocesoarele moderne:
PowerPC 620, MIPS R10000, arhitectura P6 de la Intel, AMD K5 ºi
succesorii acestora.  Multe din ingredientele necesare le-am discutat
în alte articole din PC Report:

<P>
<DL>
<DT><STRONG>alegerea:</STRONG></DT>
<DD>este fãcutã circuitele de predicþia salturilor,
care ``ghicesc'' direcþiile salturilor condiþionale înainte ca
acestea sã fie executate;
</DD>
<DT><STRONG>detecþie:</STRONG></DT>
<DD>cînd rezultatul saltului este cunoscut, acesta este
comparat cu valoarea prezisã;
</DD>
<DT><STRONG>reparaþie:</STRONG></DT>
<DD>procesorul foloseºte o structurã numitã <EM>reorder buffer</EM>, în care face toate modificãrile (fãrã a modifica
regiºtrii adevãraþi);
</DD>
<DT><STRONG>reluare:</STRONG></DT>
<DD>în cazul unei erori, registrul PC, care indicã
instrucþiunea curentã, este pus sã indice spre instrucþiunea care
trebuia sã fie executatã dupã salt.
</DD>
</DL>

<P>
Deºi implementarea în hardware este foarte sofisticatã, ideea este
relativ simplã:

<P>

<UL>
<LI>Procesorul lanseazã în execuþie instrucþiuni înainte de a
ºti dacã salturile spre acele instrucþiuni vor fi sau nu executate;
</LI>
<LI>Aceste instrucþiuni se executã, dar rezultatele lor sunt
scrise fie în niºte regiºtri ``ascunºi'' (shadow registers), fie
într-un buffer (dacã instrucþiunile modificã memoria);
</LI>
<LI>Cînd instrucþiunea de salt este în fine evaluatã, se decide
dacã speculaþia a fost corectã:

<UL>
<LI>Dacã saltul a fost corect prezis, regiºtrii ascunºi sunt
copiaþi în cei corecþi, ºi informaþiile din buffer sunt trimise
spre memorie.
</LI>
<LI>Dacã saltul a fost incorect prezis, regiºtrii ascunºi sunt
ignoraþi, buffer-ul este golit ºi execuþia este repornitã de la
instrucþiunea corectã.
</LI>
</UL>
</LI>
</UL>

<P>

<H2><A NAME="SECTION00062000000000000000">
Soluþia mixtã</A>
</H2>

<P>
Arhitectura IA-64 de la Intel oferã o altã soluþie pentru execuþia
speculativã, în care compilatorul colaboreazã cu procesorul.
Fiecare instrucþiune este etichetatã cu o valoare de 1 bit, numitã
<EM>predicat</EM>.  Dacã predicatul unei instrucþiuni este 1, atunci
instrucþiunea se executã, altfel instrucþiunea este ignoratã.
Dacã notãm cu

<P>
<PRE>
p# a = b + c
</PRE>

<P>
faptul cã instrucþiunea <TT>a = b + c</TT> se executã numai
dacã <TT>p=1</TT>, atunci un programul:

<P>
<PRE>
if (a &lt; 0)
        b = b + 1;
else
        d = b * 2;
</PRE>

<P>
se va traduce în ceva de genul:

<P>
<PRE>
1# p = a &lt; 0   /* predicatul este 1: instructiunea se executa neconditionat */
1# q = not p
p# b = b + 1
q# d = b * 2
</PRE>

<P>
Dacã are destule resurse, microprocesorul va executa toate aceste
instrucþiuni simultan.

<P>

<H1><A NAME="SECTION00070000000000000000">
Execuþie speculativã la nivel de thread</A>
</H1>

<P>
Execuþia speculativã la nivel de fir de execuþie (thread) este un
subiect de cercetare foarte fierbinte; se publicã în continuare
foarte multe articole pe aceastã temã, dar nici un procesor încã
nu implementeazã astfel de scheme.  În aceastã secþiune voi
ilustra pe scurt una dintre propuneri; legãturi web spre alte
proiecte puteþi gãsi în finalul acestui text.

<P>
Motivaþia pentru acest gen de cercetare vine din faptul cã, în
viitorul foarte apropiat, din cauza miniaturizãrii, arhitecþii vor
avea atît de multe resurse încît vor putea implementa mai multe
procesoare pe aceeaºi pilulã de siliciu.  Desigur, aceste procesoare
pot executa fiecare alt program, dar cercetarea pe care o voi descrie
aici discutã despre cum mai multe procesoare pot colabora la
execuþia <EM>unui singur program secvenþial</EM>.

<P>
Cheia este, desigur, execuþia speculativã: programul este
împãrþit în mai multe fragmente de cod, în general de zeci pînã
la mii de instrucþiuni fiecare.  Fiecare fragment este un <EM>thread</EM>, care este executat în paralel pe un alt procesor.  Unul
dintre thread-uri este cel ``corect''; celelalte executã pãrþi din
``viitorul'' probabil al programului.

<P>
Sã ne uitãm la un simplu exemplu:

<P>
<PRE>
while (! gata) {
        ...
        x = hash[index1];
        ...
        hash[index2] = y;
}
</PRE>

<P>
Dacã valorile <TT>index1</TT> ºi <TT>index2</TT> sunt
diferite pentru toate iteraþiile, toate accesele fãcute de buclã
în tabela <TT>hash</TT> se pot efectua în paralel.  Dacã însã
valoarea lui <TT>index2</TT> dintr-o iteraþie este aceeaºi cu valoarea
lui <TT>index1</TT> dintr-o iteraþie ulterioarã, între valorile
corespunzãtoare din <TT>hash</TT> se stabileºte o dependenþã de date,
care împiedicã execuþia paralelã.  În figura&nbsp;<A HREF="speculativ-html.html#iteratii">3</A> (b)
ilustrãm o posibilã execuþie secvenþialã a acestui program; în
dreptunghiuri am ilustrat fiecare iteraþie.  În
figura&nbsp;<A HREF="speculativ-html.html#iteratii">3</A> (c) ilustrãm cum s-ar putea desfãºura
execuþia acestui program pe un multiprocesor cu 3 procesoare, cînd
fiecare iteraþie a buclei este un thread separat.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="iteratii"></A><A NAME="251"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figura 3:</STRONG>
Execuþia unui program (a) pe un uniprocesor
(b) sau pe un multiprocesor cu execuþie speculativã (c).  În (c)
procesorul al treilea descoperã cã a violat o dependenþã datoritã
execuþiei speculative, ºi ca atare rezultatele pe care le-a calculat
sunt distruse ºi execuþia iteraþiei sale este reluatã.</CAPTION>
<TR><TD><IMG
 WIDTH="676" HEIGHT="324" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=15cm\epsffile{iteratii.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Observaþi cã, spre deosebire de schema software-pur pe care am
descris-o mai devreme, în caz de speculaþie eronatã aici nu reluãm
întreg procesul de calcul, ci doar partea care a fost eronatã.

<P>
Ingredientele acestei scheme sunt urmãtoarele:

<P>
<DL>
<DT><STRONG>alegere:</STRONG></DT>
<DD>au fost propuse foarte multe scheme diferite de
separare a programului în thread-uri; cele mai multe soluþii
implicã compilatorul, care insereazã instrucþiuni suplimentare
pentru pornirea ºi oprirea thread-urilor.  Schemele cele mai populare
construiesc un thread din fiecare iteraþie a unei bucle (ca în
exemplul nostru), sau executã apelul unei proceduri în paralel cu
codul care urmeazã procedurii.
</DD>
<DT><STRONG>detecþie:</STRONG></DT>
<DD>una dintre cele mai elegante scheme foloseºte
cache-urile procesoarelor ºi protocolul de coerenþã al acestora
(mai multe detalii urmeazã mai jos);
</DD>
<DT><STRONG>reparaþie:</STRONG></DT>
<DD>cache-ul este folosit ºi pentru reparaþie dupã o
speculaþie greºitã: în figura&nbsp;<A HREF="speculativ-html.html#iteratii">3</A>, cache-ul
procesorului 3 este golit dupã detecþia dependenþei eronate;
</DD>
<DT><STRONG>reluare:</STRONG></DT>
<DD>reluarea este obþinutã re-setînd registrul PC la
începutul thread-ului.
</DD>
</DL>

<P>
Dintre toate thread-urile, unul singur este ``cel mai bãtrîn'':
acesta se executã ne-speculativ, ºi poate face orice modificãri.
Celelalte thread-uri sunt ordonate dupã vîrstã: în
figura&nbsp;<A HREF="speculativ-html.html#iteratii">3</A> thread-ul de pe procesorul 1 este cel mai vechi,
cel de pe procesorul 2 este urmãtorul ºi cel de pe procesorul 3 este
cel mai nou.  Thread-urile 2 ºi 3 se executã speculativ, pînã
cînd thread-ul 1 se terminã.  Apoi 2 devine cel mai bãtrîn, ºi
procesorul 1 poate porni un thread-ul 4 (care nu e ilustrat în
figurã).

<P>
Fiecare thread face toate citirile ºi scrierile din memorie folosind
cache-ul propriu.  Cînd un thread citeºte un cuvînt în cache, îl
marcheazã ca accesat (de exemplu, thread-ul 3 marcheazã cuvîntul de
la adresa <TT>hash[10]</TT>).  Cînd un thread modificã un cuvînt,
trimite aceastã informaþie tuturor celorlalte thread-uri mai tinere
decît el.  Cînd un thread tînãr a folosit o valoare care apoi este
modificatã de un thread mai bãtrîn (<TT>hash[10]</TT> în figurã este
citit de thread-ul tînãr 3 înainte de modificarea thread-ului
bãtrîn 1), mesajul de modificare care vine de la thread-ul 1
(indicat de sãgeata roºie din figurã) îi indicã thread-ului 3
faptul ca a speculat incorect.  Cînd un thread detecteazã o
speculaþie eronatã, se sinucide ºi reporneºte.

<P>
Thread-urile se pot termina numai în ordinea în care au fost create:
chiar dacã thread-ul 3 se terminã înainte de 1, trebuie sã
aºtepte pînã cînd 1 s-a isprãvit ºi a anunþat toate
modificãrile sale, ca sã vadã dacã nu cumva unele din valorile pe
care le-a folosit el însuºi au fost ilegale.

<P>

<H1><A NAME="SECTION00080000000000000000">
Rezumat</A>
</H1>

<P>
În acest articol am discutat despre paralelismul prezent în
programe, care poate fi exploatat pentru a executa programele mai
rapid.  Am vãzut cã existã douã feluri de dependenþe care fac ca
instrucþiunile sã <EM>nu</EM> fie paralele: dependenþe de date ºi
dependenþe de control.  Ambele tipuri de dependenþe limiteazã
paralelismul, dar dependenþele de control au impact foarte important,
limitînd paralelismul în programe ne-numerice la valori între 2 ºi
8.

<P>
Am vãzut cã execuþia speculativã încearcã sã elimine impactul
dependenþelor de control, executînd cod înainte de a fi certã
necesitatea lui.  Am vãzut de asemenea cã execuþia speculativã
poate fi implementatã în multe feluri: în software, în hardware,
sau cu suportul amîndurora; de asemenea, am vãzut cã putem specula
la nivel de instrucþiuni sau de thread.

<P>
Problema selecþiei thread-urilor ºi a suportului care trebuie sã
fie oferit de hardware este încã un subiect foarte activ de
cercetare; cu certitudine însã speculaþia la nivel de thread va fi
un ingredient al procesoarelor viitoarului.

<P>

<H1><A NAME="SECTION00090000000000000000">
Alte surse de informaþie</A>
</H1>

<P>

<UL>
<LI>Articolele mele anterioare despre arhitecturã din PC Report:

<P>

<UL>
<LI>Despre dependenþe ºi metoda redenumirii regiºtrilor, PC Report din
iulie 1999:
<BR><TT><A NAME="tex2html6"
  HREF="http://www.cs.cmu.edu/~mihaib/articles/articles.html#redenumire">http://www.cs.cmu.edu/~mihaib/articles/articles.html#redenumire</A></TT>.
</LI>
<LI>Despre predicþia salturilor pentru suportul execuþiei
speculative, PC Report din august 1999: 
<BR><TT><A NAME="tex2html7"
  HREF="http://www.cs.cmu.edu/~mihaib/articles/articles.html#predictie">http://www.cs.cmu.edu/~mihaib/articles/articles.html#predictie</A></TT>.
</LI>
<LI>Despre evoluþia arhitecturii microprocesoarelor ºi implementarea
de thread-uri direct în hardware, PC Report din martie 2000: <TT><A
NAME="tex2html8"
HREF="http://www.cs.cmu.edu/~mihaib/articles/articles.html#micro">http://www.cs.cmu.edu/~mihaib/articles/articles.html#micro</A></TT>.
</LI>
<LI>Despre coerenþa cache-urilor în multiprocesoare, PC Report din
noiembrie 1998: <BR><TT><A NAME="tex2html9"
HREF="http://www.cs.cmu.edu/~mihaib/articles/articles.html#smp">http://www.cs.cmu.edu/~mihaib/articles/articles.html#smp</A></TT>.
</LI>
</UL>

<P>
</LI>
<LI>Studiul menþionat în acest articol, despre limitele
paralelismului existent în programe ºi depãºirea lui prin
execuþia speculativã: ``Limits of Control Flow on Parallelism'', de
Monica Lam ºi Robert Wilson de la universitatea Stanford, publicat
în 1992 în conferinþa International Symposium on Computer
Architecture <TT><A NAME="tex2html10"
  HREF="http://suif.stanford.edu/papers/lam92.ps">http://suif.stanford.edu/papers/lam92.ps</A></TT>.

<P>
</LI>
<LI>Proiecte universitare de cercetare despre execuþia speculativã
la nivel de thread pentru multiprocesoare:

<P>

<UL>
<LI>Proiectul <EM>Stampede</EM> la universitatea Carnegie Mellon este
cel pe care l-am descris în acest articol: 
<BR><TT><A NAME="tex2html11"
  HREF="http://www.cs.cmu.edu/~stampede">http://www.cs.cmu.edu/~stampede</A></TT>
</LI>
<LI>Proiectul <EM>Multiscalar</EM> la universitatea Wisconsin-Maddison:

<BR><TT><A NAME="tex2html12"
  HREF="http://www.cs.wisc.edu/~mscalar">http://www.cs.wisc.edu/~mscalar</A></TT>
</LI>
<LI>Proiectul <EM>Hydra</EM> la universitatea Stanford: 
<BR><TT><A NAME="tex2html13"
  HREF="http://ogun.stanford.edu">http://ogun.stanford.edu</A></TT>
</LI>
<LI>Cercetare la universitatea Politehnicã din Catalunya: 
<BR><TT><A NAME="tex2html14"
  HREF="http://www.ac.upc.es/homes/antonio/specula.html">http://www.ac.upc.es/homes/antonio/specula.html</A></TT>
</LI>
<LI>Proiectul <EM>IACOMA</EM> la universitatea Illinois-Urbana: 
<BR><TT><A NAME="tex2html15"
  HREF="http://iacoma.cs.uiuc.edu/iacoma">http://iacoma.cs.uiuc.edu/iacoma</A></TT>
</LI>
<LI>Cercetarea lui Lawrence Rauchwerger la universitatea Texas A&amp;M:

<BR><TT><A NAME="tex2html16"
  HREF="http://www.cs.tamu.edu/faculty/rwerger">http://www.cs.tamu.edu/faculty/rwerger</A></TT>
</LI>
<LI>Proiectul <EM>M-Machine</EM> la universitatea Stanford (migrat de
la universitatea MIT):

<BR><TT><A NAME="tex2html17"
  HREF="http://cva.stanford.edu/m-machine/cva_m_machine.html">http://cva.stanford.edu/m-machine/cva_m_machine.html</A></TT>
</LI>
<LI>Proiectul <EM>TimeWarp</EM> la universitatea din Waiklao, Noua
Zeelandã: 
<BR><TT><A NAME="tex2html18"
  HREF="http://www.cs.waiklao.ac.nz/timewarp/wengine/index.html">http://www.cs.waiklao.ac.nz/timewarp/wengine/index.html</A></TT>
</LI>
<LI>Proiectul <EM>Multiplex</EM> la universitatea Purdue:

<BR><TT><A NAME="tex2html19"
  HREF="http://dynamo.ecn.purdue.edu/~mux">http://dynamo.ecn.purdue.edu/~mux</A></TT>
</LI>
</UL>
</LI>
</UL>

<P>
<BR><HR>

</BODY>
</HTML>
