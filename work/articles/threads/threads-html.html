<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Multithreading</TITLE>
<META NAME="description" CONTENT="Multithreading">
<META NAME="keywords" CONTENT="threads-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Multithreading</H1>
<P ALIGN="CENTER"><STRONG>Mihai BUDIU -- budiu@cs.cornell.edu</STRONG></P>
<P ALIGN="CENTER"><STRONG>decembrie 1996</STRONG></P>

<P>
<B>Subiect:</B> Implementarea thread-urilor fãrã ajutorul SO. 

<P>
<B>Cuvinte cheie:</B> thread, proces, stivã, cadru (stack frame),
context.

<P>
<B>Cunoºtinþe necesare:</B> limbajul C, funcþii recursive, elemente de
programare în limbaj de asamblare.

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html19"
  HREF="threads-html.html">Vedere de ansamblu</A>
<LI><A NAME="tex2html20"
  HREF="#SECTION00030000000000000000">Procese ºi ``thread''-uri</A>
<LI><A NAME="tex2html21"
  HREF="#SECTION00040000000000000000">Recursie ºi stive</A>
<LI><A NAME="tex2html22"
  HREF="#SECTION00050000000000000000">C exotic: <TT>longjmp</TT> ºi <TT>setjmp</TT></A>
<UL>
<LI><A NAME="tex2html23"
  HREF="#SECTION00051000000000000000"><TT>setjmp</TT></A>
<LI><A NAME="tex2html24"
  HREF="#SECTION00052000000000000000"><TT>longjmp</TT></A>
</UL>
<BR>
<LI><A NAME="tex2html25"
  HREF="#SECTION00060000000000000000">Un abuz</A>
<LI><A NAME="tex2html26"
  HREF="#SECTION00070000000000000000">Stive în stivã</A>
<LI><A NAME="tex2html27"
  HREF="#SECTION00080000000000000000">Funcþiile iniþiale</A>
<LI><A NAME="tex2html28"
  HREF="#SECTION00090000000000000000">Comutarea</A>
<LI><A NAME="tex2html29"
  HREF="#SECTION000100000000000000000">Întreruperi</A>
<LI><A NAME="tex2html30"
  HREF="#SECTION000110000000000000000">Rezumat</A>
</UL>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION00020000000000000000">
Vedere de ansamblu</A>
</H1>

<P>
Acest articol îºi propune sã explice unul dintre conceptele
esenþiale ale sistemelor de operare, ``thread-urile''.  (Din pãcate
nu ºtiu nici un termen românesc foarte convenabil care sã fie larg
acceptat pentru a traduce ``thread''; numele folosit este de obicei
``fir de execuþie'', dar îl gãsesc prea lung.  Vã rog sã
toleraþi acest barbarism, ºi probabil ºi alte cîteva.)
Bazîndu-se pe un minim de cunoºtinþe, constînd în programarea cu
funcþii recursive ºi elemente de bazã în C, articolul
construieºte toate conceptele necesare, ºi apoi ºi o implementare,
a unui pachet de funcþii care permite simularea execuþiei simultane
a mai multor programe, fãrã nici un fel de suport special din partea
sistemului de operare.

<P>
Din pãcate implementarea se bazeazã pe folosirea în mod
neconvenþional a unor instrucþiuni standard C (ANSI), ºi s-ar putea
sã nu poatã funcþiona întotdeauna.  Am testat programele pe trei
sisteme diferite ºi au mers, dar am avut într-un fel noroc: m-am 
bazat pe faptul cã (pentru cã este mai simplu pentru cei care scriu
compilatoare) anumite instrucþiuni fac mai mult decît spune manualul
cã trebuie sã facã.

<P>
Structura de ansamblu a textului este urmãtoarea: întîi
noþiunile de thread ºi proces sunt explicate, iar modul în care pot
fi implementate schiþat.  Apoi urmeazã o discuþie despre rolul
stivei în executarea programelor -- vedem faptul cã o parte
importantã despre starea unui program este þinutã pe stivã.

<P>
Explorãm apoi funcþionalitatea unor instrucþiuni C
standard, dar care se comportã extrem de ciudat; vedem cã ele
acþioneazã în mod dramatic asupra stivei.  Urmeazã un experiment
cu aceste instrucþiuni, a cãrui menire este sã verifice dacã nu
cumva ele îºi îndeplinesc misiunea într-un mod de care ne putem
folosi pentru a implementa thread-uri.

<P>
În fine, în caz cã experimentul s-a dovedit reuºit, trecem
la a pune la lucru aceste instrucþiuni pentru a scrie un set de
funcþii care simuleazã multi-procesarea.

<P>
Programele au fost testate cu succes pe urmãtoarele
platforme: Windows NT, folosind compilatorul MS Visual C++ 4.0, SunOS
4.x, ºi 5.x cu gcc, Linux 2.x cu gcc.  Se pare cã merg ºi pe HP-UX.

<P>
Extensiile cu ``întreruperi'' ale programelor au fost testate
numai pe sistemele Unix (Windows NT nu oferã funcþia <TT>alarm()</TT> pe
care ele se bazeazã).

<P>
Practic textul prezintã un mini-nucleu de sistem de operare
în esenþa lui; în orice sistem modern partea care se ocupã de
manipularea proceselor are o structurã asemãnãtoare.

<P>

<H1><A NAME="SECTION00030000000000000000">
Procese ºi ``thread''-uri</A>
</H1>

<P>
``Ce este un program'' probabil cã toatã lumea ºtie.  Ce
este un proces este un pic mai delicat, însã nu greu de înþeles.
Cea mai scurtã definiþie ar fi: ``un proces este un program în curs
de execuþie''.  E o micã diferenþã între cele douã noþiuni: în
timp ce un program este un concept ``static'', imuabil, un proces este
un obiect care se schimbã într-una.  De exemplu, atunci cînd un
program se executã, el modificã valorile variabilelor sale.  La
fiecare moment de timp procesul deci aratã altfel.  Distincþia este
aceeaºi ca cea dintre un drum trasat pe o hartã (programul) ºi o
excursie realã pe acel traseu (procesul).  Nici mãcar nu este
obligatoriu ca la rulãri diferite un acelaºi program sã parcurgã
aceleaºi faze: execuþia lui poate depinde de evenimente externe,
care sunt diferite (ca de exemplu interacþiunea cu utilizatorul).

<P>
Putem vorbi despre ``starea'' unui proces la un anumit moment
de timp.  Starea ar trebui sã ne spunã cam ``în ce fazã de
execuþie a programului am ajuns''.  Cum se poate descrie starea unui
proces?

<P>
Ei bine, starea trebuie sã cuprindã o indicaþie despre
urmãtoarea instrucþiune care se va executa.  La nivelul programelor
în limbaj-maºinã instrucþiunea urmãtoare este indicatã prin
valoarea unui registru special, numit PC de obicei (``Program
Counter'') (numai Intel se încãpãþîneazã sã-i zicã IP -
``Instruction Pointer''), care aratã adresa în memorie unde se aflã
urmãtoarea instrucþiune de executat.

<P>
PC-ul singur însã nu ajutã: dacã suntem în mijlocul unei
bucle, PC-ul nu ne poate spune de cîte ori s-a executat bucla.
Descrierea starea unui proces mai trebuie sã conþinã ºi descrierea
<EM>valorii</EM> tuturor variabilelor cu care opereazã programul.

<P>
Din pãcate nici atîta nu ajunge pentru a descrie starea unui
proces.  Ca sã va convingeþi iatã un exemplu:

<P>
<PRE>
int f(int a)
{  
  /* PC==&gt; */ printf("%d\n", a); 
}

int g(int a)
{  f(a); }

int main(void)
{  int x = 5;  f(x); g(x); return 0; }
</PRE>

<P>
Chiar dacã vã spun cã PC-ul puncteazã unde am pus
comentariul, în corpul funcþiei <TT>f()</TT>, ºi vã dau valorile
variabilelor, nu veþi putea spune ce se va întîmpla mai departe
dacã nu ºtiþi <EM>cine</EM> a chemat pe <TT>f()</TT>: <TT>main()</TT> sau
<TT>g()</TT>?

<P>
O descrierea a stãrii procesului trebuie sã includã deci
ºi <EM>istoricul</EM> apelurilor de funcþii: ce funcþii au început
sã se execute ºi nu s-au terminat încã.  Vom vedea cã aceastã
informaþie este de obicei menþinutã pe o <EM>stivã</EM> de cãtre
calculator.

<P>
Sã rezumãm: starea unui proces este descrisã de

<P>

<OL>
<LI>programul care este executat
</LI>
<LI>valoarea PC
</LI>
<LI>valorile variabilelor
</LI>
<LI>funcþiile care tocmai se executã ºi locurile în care ele s-au
întrerupt.
</LI>
</OL>

<P>
Calculatoarele moderne þin aceste informaþii în memorie (cu
excepþia PC), în zone diferite, astfel:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Informaþia</TD>
<TD ALIGN="LEFT">Unde</TD>
</TR>
<TR><TD ALIGN="LEFT">programul</TD>
<TD ALIGN="LEFT">``segmentul de cod''</TD>
</TR>
<TR><TD ALIGN="LEFT">variabile</TD>
<TD ALIGN="LEFT">``segmentul de date''</TD>
</TR>
<TR><TD ALIGN="LEFT">funcþiile în curs de execuþie</TD>
<TD ALIGN="LEFT">``segmentul de stivã''</TD>
</TR>
</TABLE>
</DIV>

<P>
Practic dacã vreau sã execut un program (sã-l transform
într-un proces), calculatorul trebuie sã aloce cîte o zonã de
memorie pentru fiecare din aceste pãrþi ºi sã punã în PC adresa
primei instrucþiuni.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="proces"></A><A NAME="363"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Un proces în memorie</CAPTION>
<TR><TD><IMG
 WIDTH="181" HEIGHT="250" BORDER="0"
 SRC="img1.png"
 ALT="\begin{figure}\centerline{\epsfxsize=4cm\epsffile{proces.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Partea interesantã este cã informaþia de mai sus este nu
numai necesarã ci ºi suficientã pentru a descrie starea unui
proces.  Mai exact, dacã ``salvãm'' cumva aceastã descriere,
stingem calculatorul, ºi dupã o sãptãmînã restaurãm starea aºa
cum era salvatã, procesul îºi va continua nestingherit execuþia
din locul în care a fost salvat, ca ºi cum nimic nu s-ar fi
întîmplat.

<P>
Tehnica asta este familiarã de cînd existã congelatoare: o
gãinã pusã la îngheþat nu îºi schimbã starea de loc pînã o
scoþi de acolo.  Toate variabilele care descriu starea ei (de
descompunere) sunt înþepenite la valoarea pe care o aveau în
momentul congelãrii.

<P>
Pe acest lucru se bazeazã ºi sistemele de operare moderne
cînd dau impresia executãrii simultane a mai multor procese:
(time-sharing) de fapt ele executã un proces o vreme (cîteva
milisecunde), apoi pun deoparte starea procesului, iau starea altui
proces, îl executã pe ãsta o vreme, dupã aceea se întorc din nou
la primul ºi tot aºa.

<P>
Dacã cele douã procese pe care le execuþi în ``paralel''
încap simultan în memorie treaba este ºi mai simplã: nu ai decît
de mutat PC de la unul la altul, ºi un indicator pentru care segment
de date ºi stiva se foloseºte în momentul curent!  Faptul cã un
proces foloseºte numai propriile lui zone de memorie asigurã faptul
cã nu îl ``deranjeazã'' pe celãlalt.

<P>
În dorinþa lor de perfecþiune, proiectanþii au observat
cã pot îmbunãtãþi schema în cazul în care cele douã procese
executã acelaºi program (nu este o presupunere complet absurdã, mai
ales dacã pe acelaºi calculator pot lucra mai multe persoane
simultan).  Îmbunãtãþirea se bazeazã pe faptul cã (practic
niciodatã) segmentul de cod nu se schimbã.  Din cauza asta dacã ai
douã procese care au acelaºi segment de cod, le poþi aranja sã
foloseascã împreunã acea parte de memorie.  Observaþi cã asta nu
înseamnã cã fac exact acelaºi lucru la un moment dat: PC-urile lor
pot avea valori complet diferite.

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="codcomun"></A><A NAME="369"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
Procese cu zona de cod comunã</CAPTION>
<TR><TD><IMG
 WIDTH="226" HEIGHT="245" BORDER="0"
 SRC="img2.png"
 ALT="\begin{figure}\centerline{\epsfxsize=5cm\epsffile{codcomun.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Odatã ideea asta nãscutã, a fost împinsã ºi mai departe:
datoritã faptului cã procesele nu au nici un fel de memorie
modificabilã în comun, este destul de greu pentru douã procese sã
schimbe informaþii (trebuie sã foloseascã fiºiere, ceea ce e
complicat ºi lent).  Ce-ar fi dacã am permite proceselor sã aibã
ºi ceva memorie în comun?  Ele vor trebui sã fie atente sã nu se
calce pe picioare (sã nu modifice fiecare starea altuia cînd nu
trebuie), dar ar putea cîºtiga mult prin eficienþa mare a
comunicãrii.

<P>
Aºa s-a nãscut noþiunea de ``thread'': douã thread-uri
sunt procese care au în comun ºi segmentul de date, pe lîngã cel
de cod.  Din cauzã cã thread-urile au în comun atît de mult,
cîteodatã conceptual sunt privite ca parte a aceluiaºi proces, dar
care de data asta poate avea mai multe ``fire de execuþie'' simultan
(traducerea termenului ``thread'' este fir).  Pentru utilizator e ca
ºi cum ai scrie un program care poate executa mai multe funcþii
simultan (de altfel asta vom obþine ºi noi în final).

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="thread"></A><A NAME="375"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
Folosirea memoriei de thread-uri</CAPTION>
<TR><TD><IMG
 WIDTH="226" HEIGHT="259" BORDER="0"
 SRC="img3.png"
 ALT="\begin{figure}\centerline{\epsfxsize=5cm\epsffile{thread.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Distincþia dintre un proces ºi un thread este doar de
naturã a folosirii în comun a memoriei: practic douã procese care
executã acelaºi program au memorii complet disjuncte, dar douã
thread-uri care executã acelaºi program folosesc segmentul de date
în comun.

<P>

<H1><A NAME="SECTION00040000000000000000">
Recursie ºi stive</A>
</H1>

<P>
În secþiunea de faþã o sã ne concentrãm privirea spre
una singurã din zonele de memorie de care are nevoie un proces (sau
thread): stiva.  Vom vedea de ce e nevoie de ea, ºi cum este ea
folositã.  Vom vedea cã unul dintre cele mai utile concepte ale
limbajelor de programare moderne, recursia, este implementatã
folosind mecanismul de stivã.

<P>
Sã considerãm un exemplu simplu, folosit de toatã lumea:

<P>
<PRE>
int factorial(int n)
{
    if (n == 1) 
        return 1;
    else 
        return 
               factorial(n-1)  /* &lt;= PC1 */
               * n;
}

int main(void)
{
        int l;
        l  = factorial(2);     /* &lt;= PC2 */
        printf("%d\n", l);
        l = factorial(4);
        printf("%d\n", l);
        return 0;
}
</PRE>

<P>
Cum merge?  Pãi execuþia se desfãºoarã aºa: începem cu
prima instrucþiune din <TT>main()</TT>, care este chiar un apel al funcþiei
<TT>factorial</TT>.  Pentru a executa <TT>factorial()</TT> programul pune bine la
pãstrare valoarea curentã a lui PC; cînd funcþia <TT>factorial()</TT> va
termina valoarea pãstratã va fi folositã pentru a continua
execuþia.  (Dacã nu am salva valoarea lui PC cînd chemãm
<TT>factorial()</TT>, nu am putea ºti atunci cînd se va termina dacã a
fost chemat prima oarã, cu argumentul 2, sau a doua oarã, cu 4.)

<P>
În continuare se procedeazã astfel: PC-ul este pus sã arate
la prima instrucþiune din corpul funcþiei <TT>factorial</TT>; am început s-o
executãm.  Valoarea argumentului <TT>n</TT> este luatã din valoarea cu
care a fost chemat factorial, 2.  Programul se executã de sus în
jos, <TT>n != 1</TT>, deci se executã <TT>return</TT>-ul dupã <TT>else</TT>.
Însã <TT>return</TT> are nevoie de valoarea calculatã de <TT>factorial(n-1)</TT> = <TT>factorial(1)</TT>!  Înainte de a termina prima
invocare a funcþiei factorial, trebuie sã începem o a doua.
Trebuie sã punem deoparte valoarea pe care o are <TT>n</TT> acum (2), ca
<TT>factorial(1)</TT> sã nu o strice.  Trebuie sã ne amintim ºi PC-ul
curent, ca dupã ce <TT>factorial(1)</TT> se terminã, sã putem face
înmulþirea ºi sã terminãm <TT>return</TT>-ul.

<P>
Deja figura se complicã: þinem minte locul de unde <TT>factorial</TT>
a fost chemat din <TT>main</TT>, dar ºi locul de unde s-a chemat singur, ºi
valorile variabilelor sale locale din acea clipã...Ne încurcãm.
Avem nevoie de o structurã care sã facã ordine.

<P>
Observaþi douã proprietãþi ale funcþiilor de care vom
profita:

<P>

<OL>
<LI>funcþiile se terminã întotdeauna în ordinea inversã decît cea
în care sunt invocate.  Dacã A cheamã pe B, B se va termina
înaintea lui A.

<P>
</LI>
<LI>de fiecare data cînd funcþia se executã se creazã o nouã copie
a variabilelor locale (putem include în aceastã categorie ºi
argumentele funcþiei, cum este <TT>n</TT> al lui <TT>factorial</TT>).
</LI>
</OL>

<P>
De fapt noi folosim acelaºi nume pentru o mulþime de
obiecte: la un moment dat pot exista multe <TT>n</TT>-uri.

<P>
Funcþiile recursive se implementeazã folosind <EM>cadre</EM>
(``(stack) frames'' în englezã).  Un cadru este o structurã de date
care þine în ea informaþiile necesare executãrii unei instanþe a
unei funcþii -- fiecare factorial care se va executa va avea propriul
lui cadru.

<P>
Un cadru de stivã aratã cam aºa:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">argument 1</TD>
</TR>
<TR><TD ALIGN="CENTER">argument 2</TD>
</TR>
<TR><TD ALIGN="CENTER">...</TD>
</TR>
<TR><TD ALIGN="CENTER">argument n</TD>
</TR>
<TR><TD ALIGN="CENTER">PC pentru întoarcere</TD>
</TR>
<TR><TD ALIGN="CENTER">variabile locale</TD>
</TR>
<TR><TD ALIGN="CENTER">spaþiu de lucru temporar</TD>
</TR>
</TABLE>
</DIV>

<P>
Cadrele sunt construite în douã etape: prima parte (cea de
deasupra liniei) este fãcutã de funcþia care o cheamã pe cea care
posedã cadrul; prin aceastã zonã chemãtorul ºi chematul
comunicã.

<P>
Partea a doua este construitã de funcþia care foloseºte
cadrul cînd începe sã se execute.  Acolo îºi pune ea
lucruºoarele pe care vrea sã le foloseascã singurã.

<P>
Ca o consecinþã a faptului cã funcþiile se terminã invers
de cum au început, putem pune cadrele lor pe o stivã (stiva,
þineþi minte=ultimul venit-primul ieºit).  În fiecare moment
funcþia care tocmai se executã foloseºte cadrul din vîrful stivei.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">acþiune</TD>
<TD ALIGN="LEFT">operaþie pe stiva</TD>
</TR>
<TR><TD ALIGN="LEFT">apel de funcþie</TD>
<TD ALIGN="LEFT">se creaza un nou cadru în vîrf</TD>
</TR>
<TR><TD ALIGN="LEFT">return</TD>
<TD ALIGN="LEFT">se distruge cadrul din vîrf</TD>
</TR>
<TR><TD ALIGN="LEFT">execuþia funcþiei</TD>
<TD ALIGN="LEFT">se foloseºte cadrul din vîrful stivei</TD>
</TR>
</TABLE>
</DIV>

<P>
Ca sã fie ºi mai clar, sã vedem cum aratã stiva în
momente succesive, în timpul execuþiei programului de mai sus:

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="cadre"></A><A NAME="381"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4:</STRONG>
Cadrele în timpul execuþiei</CAPTION>
<TR><TD><IMG
 WIDTH="724" HEIGHT="242" BORDER="0"
 SRC="img4.png"
 ALT="\begin{figure}\centerline{\epsfxsize=16cm\epsffile{cadre.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Figura&nbsp;<A HREF="threads-html.html#cadre">4</A> ne aratã stiva in 4 momente succesive: la început,
înainte ca <TT>main()</TT> sã cheme <TT>factorial(2)</TT>, dupã aceea cu cadrul
lui <TT>factorial(2)</TT> construit.  Observaþi cum cadrul lui
<TT>factorial(2)</TT> conþine adresa de întoarcere (PC2) în <TT>main()</TT>.
Funcþiile noastre nu au variabile temporare, iar singura variabilã
localã este <TT>l</TT>, în <TT>main</TT>.

<P>
Apoi <TT>factorial(2)</TT> cheamã <TT>factorial(1)</TT>: cadrul lui
<TT>factorial(2)</TT> continuã sã existe, cu <TT>n</TT>=2, ºi un nou cadru se
creazã, în care n=1.  Observaþi cã <TT>factorial(1)</TT> þine minte în
cadrul lui cã a fost chemat de <TT>factorial(2)</TT>, deci PC-ul dupã
terminare trebuie sã fie PC1.  Observaþi ºi cã pe stivã se aflã
douã valori ale lui n, una în cadrul lui <TT>factorial(1)</TT>, una în
cadrul lui <TT>factorial(2)</TT>.  Regulile limbajului C spun cã, dacã
funcþia curentã vrea sã ºtie cît este n, valoarea cu care va
lucra este cea din cadrul curent.

<P>
<TT>factorial(1)</TT> se terminã repede, returnînd valoarea 1.
Cadrul lui <TT>factorial(1)</TT> este distrus.  Cadrul curent devine cel
vechi, al lui <TT>factorial(2)</TT>, a cãrui execuþie se reia de dupã PC1.
Ce se întîmplã apoi: <TT>factorial(2)</TT> tocmai a aflat cît e
<TT>factorial(1)</TT> (=1), aºa cã va continua evaluarea expresiei <TT>n *
factorial(n-1)</TT>.  Valoarea folositã pentru n este 2, deci expresia
este 2*1 = 1.  Aceasta este ºi valoarea returnatã de <TT>factorial(2)</TT>,
care se întoarce la <TT>main()</TT>, la adresa salvatã în cadrul propriu,
PC2.

<P>
Dupã ce <TT>main()</TT> tipãreºte ``2'', se va efectua un ºir
asemãnãtor de operaþii, numai cã la momentul de vîrf se vor afla
pe stivã 4 cadre diferite pentru factorial.  Încercaþi sã
urmãriþi evoluþia.

<P>

<H1><A NAME="SECTION00050000000000000000">
C exotic: <TT>longjmp</TT> ºi <TT>setjmp</TT></A>
</H1>

<P>
Standardul ANSI pentru limbajul C conþine printre
instrucþiunile mai mult sau mai puþin ezoterice ºi cerinþa ca
orice compilator de C regulamentar sã implementeze douã foarte
ciudate ``funcþii'', numite <TT>setjmp</TT> ºi <TT>longjmp</TT>.  Prototipurile
acestor funcþii sunt în headerul <TT>&lt;setjmp.h&gt;</TT>.

<P>
Poate cel mai bine ar fi sã începem iarãºi printr-un
exemplu; rulaþi urmãtorul program:

<P>
<PRE>
#include &lt;setjmp.h&gt;
#include &lt;stdio.h&gt;

jmp_buf cadru;

void fun(void)
{  
   printf("fun se executa\n");
   longjmp(cadru, 1);
   printf("Nu ajung aici!\n");
}

int main(void)
{  
   if (setjmp(cadru) == 0) {    /* &lt;= PC salvat */
      printf("setjmp s-a intors prima oara\n");
      printf("Chem acum fun\n");
      fun();
      printf("Nu ajung aici!\n");
   }
   else {   /* setjmp != 0 */
      printf("setjmp s-a intors a doua oara!\n");
   }
   printf("Gata.\n");
   return 0;
}
</PRE>

<P>
Acum sã vedem cum funcþioneazã...Ca mai întotdeauna
în cazul limbajelor de programare, cel mai simplu mod pentru a
explica ce face un program este de a explica fiecare instrucþiune
componentã.

<P>

<H2><A NAME="SECTION00051000000000000000">
<TT>setjmp</TT></A>
</H2>

<P>
Instrucþiunea <TT>setjmp</TT> are ca argument un obiect de tip
<TT>jmp_buf</TT> (tip declarat în headerul <TT>setjmp.h</TT>).  (E mai
simplu sã ne gîndim la aceastã instrucþiune ca la un macro, nu ca
la o funcþie.)  Execuþia lui <TT>setjmp(x)</TT> pune în structura <TT>x</TT> urmãtoarele informaþii:

<P>

<OL>
<LI>o descriere a <EM>poziþiei</EM> pe stivã a cadrului funcþiei curente (cea
care conþine instrucþiunea <TT>setjmp()</TT>);
</LI>
<LI>valoarea curentã a PC (care puncteazã tocmai la instrucþiunea
<TT>setjmp()</TT>, nu?);
</LI>
<LI>În plus, <TT>setjmp()</TT> dã ca rezultat o valoare 0
</LI>
</OL>

<P>

<H2><A NAME="SECTION00052000000000000000">
<TT>longjmp</TT></A>
</H2>

<P>
Instrucþiunea <TT>longjmp()</TT> are douã argumente: unul de tip
<TT>jmp_buf</TT>, în care un <TT>setjmp()</TT> anterior a scris ceva, ºi o valoare
numericã.  Efectul executãrii lui <TT>longjmp(x, v)</TT> este:

<P>

<OL>
<LI>cadrul descris de <TT>x</TT> devine cel curent;
</LI>
<LI>valoarea salvatã a PC in <TT>x</TT> devine cea curentã;
</LI>
<LI>se continuã execuþia; asta înseamnã cã se re-executã <TT>setjmp()</TT>
(pentru cã acolo a fost salvat PC!).  De data asta însã rezultatul
``evaluãrii'' lui <TT>setjmp()</TT> este <TT>v</TT>!
</LI>
</OL>

<P>
Sã ne uitãm la programul de mai sus din nou.  El va tipãri:

<P>

<OL>
<LI><TT>setjmp s-a intors prima oara</TT>
</LI>
<LI><TT>Chem acum fun</TT>
</LI>
<LI><TT>fun se executa</TT>
</LI>
<LI><TT>setjmp s-a intors a doua oara!</TT>
</LI>
<LI><TT>Gata.</TT>
</LI>
</OL>

<P>
Execuþia începe cu <TT>setjmp(cadru)</TT>.  Asta salveazã în
variabila <TT>cadru</TT> descrierea cadrului funcþiei curente, <TT>main()</TT>, ºi valoarea PC, care puncteazã la linia cu comentariul.
<TT>setjmp()</TT> întoarce 0, aºa cã <TT>if</TT>-ul este ``adevãrat''.
Prima linie se tipãreºte acum, ca ºi a doua.

<P>
Se cheamã <TT>fun()</TT>, care scrie linia a treia.

<P>
Partea interesantã începe: se executã <TT>longjmp(cadru,
1)</TT>.  Aplicînd definiþia de mai sus, asta înseamnã:

<P>

<OL>
<LI>cadrul curent devine cel salvat, al funcþiei <TT>main()</TT>.
Practic cadrul lui <TT>fun()</TT> este ``ºters'' de pe stivã.
</LI>
<LI>PC capãtã valoarea din momentul lui <TT>setjmp</TT>: puncteazã
la linia cu comentariul din nou; practic <TT>setjmp</TT> se executã din
nou!
</LI>
<LI>valoarea execuþiei lui <TT>setjmp</TT> este 1, cum a indicat <TT>longjmp</TT>-ul.
</LI>
</OL>

<P>
Deci <TT>if</TT>-ul se executã din nou ºi el, pe ramura
<TT>else</TT> de data asta.  Asta cauzeazã apariþia liniei&nbsp;4.

<P>
Linia 5 apare apoi natural.

<P>
Interesant, nu?

<P>
Practic <TT>longjmp</TT> face o ``întoarcere în timp'', la
situaþia pe care o avea execuþia unui program în momentul cînd a
executat <TT>setjmp</TT>.

<P>
Care e folosul unor asemenea instrucþiuni?

<P>
<TT>setjmp</TT> ºi <TT>longjmp</TT> au fost create pentru a uºura
tratarea erorilor: dacã ceva se întîmplã undeva în adîncurile
misterioase ale unor funcþii recursive, poþi imediat ``ieºi la
suprafaþã'' cu un <TT>longjmp</TT>, fãrã sã trebuiascã sã scrii fiecare
funcþie de pe drum în aºa fel încît sã verifice dacã nu cumva
funcþiile pe care le cheamã au produs vreo eroare.

<P>
(Modul acesta de a trata erorile poate fi îmbunãtãþit
folosind limbaje care permit definirea ºi tratarea excepþiilor, care
funcþioneazã într-un mod asemãnãtor, dar mai elegant.  De altfel
compilatorul de C de la Microsoft pentru Windows NT chiar extinde
limbajul C pentru a încorpora excepþii; însuºi sistemul de operare
Windows NT ajutã la asta).

<P>
Sã mai observãm cã în momentul executãrii instrucþiunii
<TT>longjmp</TT> <EM>cadrul de stivã</EM> indicat de <TT>jmp_buf</TT>-ul dat
ca argument lui <TT>longjmp</TT> <EM>trebuie</EM> sa existe!  (Dacã nu,
dezastre se vor întîmpla.)  Din aceastã cauzã standardul ANSI
spune despre <TT>longjmp</TT>: ``<TT>longjmp</TT> poate fi executatã numai
într-o funcþie care este un descendent direct din funcþia care a
executat <TT>setjmp</TT>''.  Datoritã modului în care se creazã ºi
distrug cadre de stivã, aceastã cerinþã îndeplinitã va garanta
existenþa cadrului la care se sare.

<P>
[Cu alte cuvinte nu se poate face aºa:

<P>
<PRE>
jmp_buf x;

int g()
{  setjmp(x); }

int h()
{  longjmp(x); }

int main()
{  g(); h(); }
</PRE>

<P>
pentru cã atunci cînd <TT>h()</TT> face <TT>longjmp</TT>, cadrul
salvat în <TT>x</TT>, al funcþiei <TT>g()</TT> nu mai este pe stivã,
pentru cã funcþia <TT>g()</TT> ºi-a terminat execuþia -- <TT>h()</TT> nu
este un descendent direct al lui <TT>g()</TT>.]

<P>

<H1><A NAME="SECTION00060000000000000000">
Un abuz</A>
</H1>

<P>
Am spus mai sus ca <TT>longjmp</TT> ``ºterge'' de pe stiva toate
cadrele pîna la cel salvat.  De fapt acest lucru este foarte
costisitor, ºi este mult mai simplu pentru <TT>longjmp</TT> doar sã
``mute'' vîrful stivei la cadrul indicat.  Este o ºansã destul de
mare ca stiva între cadrul la care se sare ºi cel de la care se sare
sã rãmînã neatinsã.

<P>
Mai trebuie sã vedem ºi dacã <TT>longjmp</TT> poate fi
``prostitã'' sã sarã în alte direcþii decît scrie la carte; sã
încercãm urmãtorul program:

<P>
<PRE>
#include &lt;setjmp.h&gt;
#include &lt;stdio.h&gt;

jmp_buf b[2];
int setup = 0;

void fun1(void);

void delay(void) { for (long i=0; i &lt; 5000000; i++); }

void fun0(void)
{        
        if (setjmp(b[0]) == 0)
                fun1();
        else {
                printf("Fun 0\n");
                delay();
                longjmp(b[1], 1);
        }
}

void fun1(void)
{
        if (!setup) setjmp(b[1]);
        setup=1;
        printf("Fun 1\n");
        delay();
        longjmp(b[0], 1);
}

int main(void)
{       
        fun0();
        return 0;
}
</PRE>

<P>
Funcþiile <TT>fun0()</TT> ºi <TT>fun1()</TT> nu au variabile locale ºi
nici argumente; practic cadrele lor nu conþin nici un fel de
informaþii interesante.

<P>
Evoluþia programului nu este prea greu de urmãrit, cel
puþin pînã la executarea lui <TT>fun1()</TT>.  Practic <TT>main()</TT> cheamã
<TT>fun0()</TT>, acesta îºi salveazã cadrul în <TT>b[0]</TT>, <TT>fun0()</TT> cheamã
apoi <TT>fun1()</TT>, care salveazã cadrul lui personal in <TT>b[1]</TT>, ºi scrie
ceva pe ecran.

<P>
Partea interesantã începe: <TT>fun1()</TT> face un <TT>longjmp</TT> la
<TT>b[0]</TT>; dacã avem noroc, aceasta mutã PC la loc în <TT>fun0()</TT>, care
se re-executã.  Vom obþine pe ecran:

<P>
<PRE>
Fun1
Fun0
Fun1
...
</PRE>

<P>
Dacã programul compilat de dumneavoastrã nu se comportã
astfel, înseamnã cã <TT>longjmp</TT> nu vrea sã sarã cînd cadrul
descris de <TT>jmp_buf</TT> nu este anterior celui curent pe stivã.  Puteþi
continua sã citiþi textul mai departe, dar programele pe care le
prezentãm nu vor funcþiona nici ele; desigur, se pot scrie altfel,
fãrã a folosi <TT>setjmp</TT> ºi <TT>longjmp</TT>, în limbaj de asamblare.
Însã detaliile ar deveni mai proeminente decît tabloul însuºi.

<P>

<H1><A NAME="SECTION00070000000000000000">
Stive în stivã</A>
</H1>

<P>
Presupunînd cã 

<P>

<OL>
<LI><TT>longjmp</TT> poate sãri în orice direcþie;
</LI>
<LI><TT>longjmp</TT> nu stricã stiva atunci cînd se executã;
</LI>
</OL>

<P>
vom implementa acum pas cu pas un set de funcþii care
simuleazã multithreading.  Ideea centralã este urmãtoarea: pe
stivã creãm mai multe cadre, a cãror descriere o salvãm într-un
vector de <TT>jmp_buf</TT>.  Dupã aceea, sã executãm thread-ul 10
înseamnã sã facem cadrul din cãsuþa 10 a vectorului cadrul curent
(cu un <TT>longjmp</TT>).  Sã întrerupem thread-ul 5 din execuþie
înseamnã sã punem în cãsuþa 5 a vectorului descrierea cadrului
curent (cu un <TT>setjmp</TT>).

<P>
Avem o singurã problemã realã: cum facem ca un thread sã
nu dea cu stiva peste cadrele care se aflã pe stivã ``sub'' el?
(Stiva este una: va trebui sã înghesuim pe ea mai multe cadre
potenþial active simultan.)

<P>
Soluþia este extrem de ingenioasã ºi simplã: pentru a crea
douã cadre la distanþã mare pe stivã, între ele trebuie sã se
afle un cadru (sau mai multe) foarte mari.

<P>
Dacã ne uitãm puþin mai sus, vom vedea cã un cadru
conþine <EM>toate</EM> variabilele locale ale unei funcþii; deci o funcþie
de genul:

<P>
<PRE>
void f(void) { char c[100000]; }
</PRE>

<P>
va avea un cadru de 100000 de octeþi cel puþin!

<P>
Avem deci la îndemînã urmãtoarele operaþii pe stivã:

<P>

<OL>
<LI>apelul de funcþie, care creazã un cadru;
</LI>
<LI>terminarea unei funcþii, care distruge cadrul curent;
</LI>
<LI><TT>longjmp</TT>, care face un cadru indicat de pe stivã curent;
</LI>
<LI><TT>setjmp</TT> care salveazã descrierea unui cadru.
</LI>
</OL>

<P>
Le putem combina pentru a obþine o serie de cadre, pe care sã le
salvãm, plasate la mari distanþe unele de altele.  Codul aratã cam
aºa:

<P>
<PRE>
#include &lt;setjmp.h&gt;

#define NR_THREADS 2
#define SPATIU_STIVA 1024

jmp_buf contexte[NR_THREADS];
jmp_buf main_context;

void salveaza(int);   /* declaratie forward */

void aloca_stiva(int thread_no)
    /* aloca spatiu pe stiva pentru thread-urile thread_no -&gt; NR_THREADS */
{
    char space[SPATIU_STIVA];     /* alocare esentiala a stivei */
    
    if (thread_no &gt;= NR_THREADS) /* am terminat? */ 
        longjmp(main_context, 1);       
    salveaza(thread_no);
}

void salveaza(int thread_no)
    /* salveaza contexte pentru thread_no -&gt; NR_THREADS */
{
    if (setjmp(contexte[thread_no])) {
        /* vom adauga cod aici */
    }   
    else
        aloca_stiva(thread_no+1);
}

int main(void)
{
    if (!setjmp(main_context)) 
        aloca_stiva(0);
    return 0;
}
</PRE>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="frames"></A><A NAME="387"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5:</STRONG>
Cadre de stivã succesive</CAPTION>
<TR><TD><IMG
 WIDTH="749" HEIGHT="413" BORDER="0"
 SRC="img5.png"
 ALT="\begin{figure}\centerline{\epsfxsize=16.5cm\epsffile{frames.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV><P></P>

<P>
Desenele 1-5 din figura&nbsp;<A HREF="threads-html.html#frames">5</A> aratã evoluþia stivei
pe mãsurã ce <TT>aloca_stiva()</TT> ºi <TT>salveaza()</TT> se executã.
Desenul 5 aratã starea dupã execuþia lui <TT>longjmp(main_context, 1)</TT>, din funcþia <TT>aloca_stiva</TT>.  (Ne vom
referi la desenele 6-8 mai tîrziu puþin.)

<P>
O descriere sumarã a situaþiei: avem 3 cadre ale funcþiei
<TT>salveaza</TT> descrise de vectorul <TT>contexte</TT>, ºi cadrul curent
este cel al funcþiei <TT>main()</TT>.  Dacã am fost norocoºi, faptul
cã am fãcut un <TT>longjmp</TT> la <TT>main_context</TT> nu a stricat cu
nimic cadrele pe care le-am pus la pãstrare pe stivã.  (Norocoºi
în sensul cã implementarea lui <TT>longjmp</TT> funcþioneazã
ne-distructiv, deºi standardul de C nu o obligã!)

<P>
Vom vedea cã funcþia <TT>aloca_stiva</TT> construieºte niºte
``cadre de sacrificiu'', pe care le vom folosi pentru a chema alte
funcþii (spaþiul ocupat de cadrele lui <TT>aloca_stiva</TT> va fi
re-folosit).

<P>

<H1><A NAME="SECTION00080000000000000000">
Funcþiile iniþiale</A>
</H1>

<P>
Mai avem de fãcut puþini paºi pentru a obþine mai multe
thread-uri: trebuie ca fiecare din cadrele (salvate în vectorul <TT>contexte</TT>) ale lui <TT>salveaza</TT> sã poatã invoca o altã funcþie
atunci cînd va fi pornit.  Avem mai multe soluþii, dar cea mai
simplã pare sã construim un vector de pointeri spre funcþii: cîte
unul pentru fiecare cadru salvat.  Cînd vom face acel cadru curent,
el va invoca funcþia respectivã:

<P>
<PRE>
/* modificari ale codului precedent */
typedef void (*functie_initiala)(void);

functie_initiala functie_start[NR_THREADS];

void salveaza(int thread_no)
    /* salveaza contexte pentru thread_no -&gt; NR_THREADS */
{
    if (setjmp(contexte[thread_no])) {
        (functie_start[thread_no])();   /* invoca functia */
    }   
    else
        aloca_stiva(thread_no+1);
}

int main(void)
{
    extern functie_initiala f, g;    /* functiile care vor fi
                                        executate de threaduri;
                                        undeva in alt fisier */
    if (!setjmp(main_context)) 
        aloca_stiva(0);
    functie_start[0] = f;
    functie_start[1] = g;
    longjmp(contexte[0], 1);         /* porneste threadul 0 */
    return 0;
}
</PRE>

<P>
Am vãzut cã starea stivei dupã executarea apelului lui <TT>aloca_stiva</TT> din <TT>main()</TT> este cea din figura&nbsp;<A HREF="threads-html.html#frames">5</A>, poza
5.  Dupã <TT>longjmp</TT>-ul din main situaþia devine cea din poza 6:
cadrul curent este cel care a fost creat de <TT>salveaza(0)</TT> ºi
salvat în <TT>contexte[0]</TT>.  Acum <TT>salveaza()</TT> va chema funcþia
din cãsuþa 0 a vectorului <TT>functie_start</TT>; asta va transforma
starea stivei ca în poza 7.

<P>
Primul thread a pornit!  Funcþia <TT>f</TT>, care este de fapt cea
invocatã, poate face acum orice.

<P>
Mai trebuie sã concepem un mecanism prin care un thread se
întrerupe ºi dã drumul altuia.  Asta e deja o sarcinã relativ
simplã: va implica douã acþiuni:

<P>

<UL>
<LI>salvarea stãrii thread-ului curent (pentru a putea fi continuat mai
tîrziu) se face cu <TT>setjmp</TT>;
</LI>
<LI>transformarea stãrii celuilalt în starea curentã folosind
<TT>longjmp</TT>.
</LI>
</UL>

<P>

<H1><A NAME="SECTION00090000000000000000">
Comutarea</A>
</H1>

<P>
Pentru a fi civilizaþi vom împacheta operaþia de
``comutare'' a thread-ului într-o funcþie.  Vom introduce ºi o
variabilã globalã care ºtie cine este thread-ul curent; se va
dovedi foarte utilã:

<P>
<PRE>
/* modificari la codul anterior */

int thread_curent;

void sari_la(int th)
{
    if (!setjmp(contexte[thread_curent])) {
        thread_curent = th;
        longjmp(contexte[thread_curent], 1);
    }
}
</PRE>

<P>
Deja puteþi testa pachetul de thread-uri scriind ceva de
genul pentru funcþiile iniþiale:

<P>
<PRE>
void f(void)
{
   int x=0;

   while (1) {
        x++;
        printf("Functia f, thread %d, x=%d\n", thread_curent, x);
        sari_la(1-thread_curent);
   }
}

void g(void)
{
   int x=0;

   while (1) {
        x++;
        printf("Functia g, thread %d, x=%d\n", thread_curent, x);
        sari_la(1-thread_curent);
   }
}

int thread_curent = 0;  /* incepem cu thread-ul 0 */
</PRE>

<P>
Faptul cã în acest program nu se cheamã pur ºi simplu <TT>f()</TT> ºi <TT>g()</TT> alternativ, ci se <EM>continuã</EM> execuþia lor se
vede din faptul cã valorile pe care le folosesc pentru <TT>x</TT> cresc.

<P>
Într-un scenariu mai complicat, cu mai multe funcþii
iniþiale mai sofisticate, situaþia stivei la un moment dat ar putea
arãta ca în figura&nbsp;<A HREF="threads-html.html#frames">5</A>, poza 8: practic funcþiile
iniþiale au chemat alte funcþii la rîndul lor (cum <TT>f()</TT>
cheamã <TT>printf()</TT>), care la un moment dat ºi-au întrerupt
execuþia.  Cadrele lor sunt salvate (în figurã asta este valabil
pentru thread-urile 0 ºi 2).  Unul dintre thread-uri tocmai se
executã (în figurã thread-ul nr.&nbsp;1), ºi cadrul lui este cel
curent.

<P>
De aici încolo nu mai avem mare lucru de fãcut; ar fi
elegant sã concepem un set de funcþii care construieºte thread-uri
noi în mod dinamic (sã nu trebuiascã sã punem cu mîna pointerii
la început), funcþii care sã omoare thread-uri, ºi poate o
funcþie care sã aleagã cine sã se execute.

<P>
Pentru a þine mai uºor socoteala despre starea fiecãrui
thread ar fi bine sã strîngem toate informaþiile care þin de el
într-o singurã structurã (care va include cadrul ºi funcþia
iniþialã); asta va necesita o ``periere'' a codului anterior, dar mai
bine s-o facem acum, cît încã nu e prea mare.  Iatã declaraþiile
funcþiilor pe care ni le propunem:

<P>
<PRE>
/* threads.h */
#ifndef THREADSH
#define THREADSH

#include &lt;setjmp.h&gt;

#define PUBLIC
#define PRIVAT static    
/* cuvintul cheie `static' este folosit in doua sensuri in C
 * a) pentru a indica variabile locale ale unei functii care 
 *    nu se aloca pe stiva ci in segmentul de date
 * b) pentru a indica faptul ca o definitie dintr-un fisier
 *    nu este vizibila in exterior
 * Definim macro-ul PRIVAT pentru aceasta a doua semnificatie:
 * va face programul mai usor de citit
 */

#define MAX_THREADS 10          /* numarul maxim */
#define SPATIU_STIVA (32 * 1024)/* in octeti */

typedef void (*functie_initiala)(void);

struct thread {
    jmp_buf context;
    jmp_buf context_original;   /* contextul din salveaza() */
    int stare;
#define THREAD_GOL       0
#define THREAD_GATA      1      /* gata de executie */
#define THREAD_MORT      2
#define THREAD_ASTEAPTA  3      /* nefolosit, deocamdata */
    functie_initiala functie_start;
};

void initializeaza(void);

int creaza_thread(functie_initiala);
/* creaza un thread; intoarce un numar (-1 = eroare) */

void omoara_thread(int);

void porneste(int th);
/* porneste executia incepind cu acest thread */

void sari_la(int th);

void alege(void);
/* alege un thread pentru executie si sari la el */

#endif   /* THREADSH */
</PRE>

<P>
Funcþia <TT>alege()</TT> este ceea ce în englezã se cheamã
<TT>scheduler()</TT>: partea care decide cine cînd se executã.  Vom folosi
cea mai simplã implementare pentru ea, care în terminologia
sistemelor de operare se cheamã ``round-robin'': o coadã circularã.

<P>
O implementare ar putea arãta cam aºa (am mai modificat ºi
funcþiile vechi pe ici-pe colo):

<P>
<PRE>
/* threads.c */

#include "threads.h"
#include &lt;stdio.h&gt;     /* pentru printf */
#include &lt;assert.h&gt;    /* pentru erori */

#define pt_orice_thread(t) \
  for ((t) = tabela_thread; (t) &lt; tabela_thread + MAX_THREADS; (t)++)
#define NU_E_THREAD (tabela_thread + MAX_THREADS)

PRIVAT struct thread tabela_thread[MAX_THREADS]; 
PRIVAT int thread_curent;
PRIVAT jmp_buf context_main;            /* folosit la initializare */

PRIVAT void
panica(char * s, int d)
    /* eroare fatala */
{
    fprintf(stderr, "** panica: ");
    fprintf(stderr, s, d);
    fflush(stderr);
    exit(1);
}

PRIVAT void 
aloca_stiva(int thread_no, int maxthreads)
    /* creaza spatiu pe stiva pentru thread_no pina la maxthreads */
{
    char space[SPATIU_STIVA];           /* spatiul de pe stiva */
    void salveaza(int, int);
    
    if (thread_no &gt;= maxthreads) 
        longjmp(context_main, 1);       /* le-am facut pe toate */
    salveaza(thread_no, maxthreads);
}

PRIVAT void 
salveaza(int thread_no, int max)
{
    char c;

    if (setjmp(tabela_thread[thread_no].context)) {
        tabela_thread[thread_no].functie_start();
        
        /* daca se ajunge aici functia s-a terminat; omoara-l */
        omoara_thread(thread_no);
    }   
    else
        aloca_stiva(thread_no+1, max); /*  nu se mai intoarce.. */
}

PRIVAT void
copiaza_context(jmp_buf s, jmp_buf d)
   /* muta date dintr-un jmp_buf intr-altul
      (se bazeaza pe faptul ca sunt vectori:
       a se vedea definitia din setjmp.h) */
{
    int i;
    char *sb, *db;

    sb = (char *) s;
    db = (char *) d;
    for (i = 0; i &lt; sizeof(jmp_buf); i++)
        *db++ = *sb++;
}

PUBLIC void 
initializeaza(void)
{
    struct thread* t;

    if (!setjmp(context_main)) 
        aloca_stiva(0, MAX_THREADS);

    /* pastram o copie a cadrelor initiale de acum, ca sa le punem
       la loc cind moare un thread */
    pt_orice_thread(t)
        copiaza_context(t-&gt;context, t-&gt;context_original);
}    

PUBLIC int
creaza_thread(functie_initiala start)
   /* facem un thread; intoarcem tid */
{
    struct thread *t;

    /* cautam un loc gol in tabela */
    pt_orice_thread(t)
        if (t-&gt;stare == THREAD_GOL ||
            t-&gt;stare == THREAD_MORT) break;
    if (t == NU_E_THREAD) return -1;        /* n-am gasit */
    t-&gt;functie_start = start;
    t-&gt;stare = THREAD_GATA;
    return t - tabela_thread;
}

#define thread_corect(x) ((x) &gt;= 0 &amp;&amp; (x) &lt; MAX_THREADS)
/* verifica daca un thread are un numar corect */
    
PUBLIC void
omoara_thread(int th)
{
    struct thread *t;

    if (!thread_corect(th)) {
        return;
    }
    t = tabela_thread + th;
    t-&gt;stare = THREAD_MORT;
    copiaza_context(t-&gt;context_original, t-&gt;context);
    /* contextul acestui thread devine cel original, al functiei
       salveaza(th); in acest fel putem construi un nou thread
       folosind stiva acestuia */
    alege();
}

PUBLIC void
sari_la(int th)
{
    struct thread *t, *c;

    if (! thread_corect(th)) return;
    t = tabela_thread + th;
    if (t-&gt;stare != THREAD_GATA) return;
    assert(thread_corect(thread_curent));
    c = tabela_thread + thread_curent;
    
    /* salvam starea curenta */
    if (!setjmp(c-&gt;context)) {
        thread_curent = th;
        longjmp(t-&gt;context, 1);
    }
    else {
        /* continuam chematorul (asta poate lipsi) */
        thread_curent = c - tabela_thread;
    }
}

PUBLIC void
alege(void)
{
    struct thread *t;
    static int ultimul = 0;
    int i;

    for (i=0; i &lt; MAX_THREADS; i++) {
        t = tabela_thread + ultimul;
        ultimul = (ultimul+1) % MAX_THREADS;
        if (t-&gt;stare == THREAD_GATA) break;
    }
    if (i == MAX_THREADS) 
        panica("Nu mai e nimeni gata\n", 0);
    else sari_la(t - tabela_thread);

    /* ne intoarcem la chemator */
}

PUBLIC void 
porneste(int th)
{
    struct thread *t;

    if (! thread_corect(th)) return;
    t = tabela_thread + th;
    if (t-&gt;stare != THREAD_GATA) return;
    thread_curent = th;
    longjmp(t-&gt;context, 1);
}
</PRE>

<P>

<H1><A NAME="SECTION000100000000000000000">
Întreruperi</A>
</H1>

<P>
Deja avem un pachet de funcþii prin care putem simula
execuþia independentã ``paralelã'' a mai multor programe.  Singura
neplãcere constã din faptul cã programele trebuie sã-ºi paseze
reciproc controlul, chemînd <TT>sari_la()</TT> sau <TT>alege()</TT>.

<P>
Am dori ca un mecanism extern sã se ocupe de asta fãrã sã
trebuiascã sã ne batem capul prea tare.  Vom schiþa în continuare
o soluþie, dar trebuie sã atragem atenþia asupra faptului cã este
practic inutilã.

<P>
Cea mai simplã metodã este sã avem un ``ceas'' care sã
întrerupã din timp în timp execuþia programului curent ºi sã
zicã: ``destul: este rîndul altcuiva''.  La nivel hardware asta se
întîmplã pe orice calculator modern, prin <EM>întreruperi</EM>.

<P>
Pentru sistemul de operare Unix avem la dispoziþie toate
mecanismele de care avem nevoie: semnale generate de nucleu.  Problema
cea mare cu folosirea semnalelor este cã dacã survin în timp ce
procesul executã un apel de sistem (cum ar fi scrierea într-un
fiºier), ele opresc apelul din execuþie.  Din cauza asta codul care
urmeazã este util numai pentru a ilustra cum se fac lucrurile în
realitate în interiorul nucleului, ºi nu ºi pentru a scrie programe
reale cu thread-uri care se comutã singure.  Pentru cã programul nu
este lipsit de posibile învãþãminte, iatã cam cum ar arãta:

<P>
Fiecare proces are în Unix pentru fiecare semnal asociatã o
funcþie care ``trateazã semnalul'' (signal handler).  Apariþia unui
semnal se soldeazã cu executarea funcþiei.  Mai precis, cînd
nucleul sistemului are de trimis un semnal pentru un proces,
construieºte pe stivã cadrul funcþiei de tratament, pe care dupã
aceea o executã.  Funcþia asta se poate executa practic în orice
moment, fãrã a fi chematã de program.

<P>
Cu funcþia de bibliotecã <TT>signal()</TT> se declarã
``handler''-e.

<P>
Unix ne mai pune la dispoziþie funcþia de bibliotecã <TT>alarm(timp)</TT>, care la <TT>timp</TT> secunde de la invocare va genera un
semnal de tip <TT>SIGALRM</TT>.

<P>
O primã schiþã a tratamentului semnalelor ar fi: (indicãm
adãugãrile faþã de funcþiile existente deja în codul precedent
cu <TT>/**/</TT>)

<P>
<PRE>
#include &lt;unistd.h&gt;     /* pentru alarm() */
#include &lt;signal.h&gt;     /* pentru signal() */

#define CUANTA 1        /* timp in sec. intre doua intreruperi */
/* #definitia trebuie pusa in threads.h */

PRIVAT int tratam_intrerupere;

PRIVAT void 
intrerupere(int ignor)
{
   if (tratam_intrerupere) 
        panica("intrerupere in tratament de intrerupere", 0);
   tratam_intrerupere++;
   alarm(CUANTA);
   signal(SIGALRM, intrerupere);
   tratam_intrerupere--;
   alege();
}

PUBLIC void 
porneste(int th)
{
    struct thread *t;

    if (! thread_corect(th)) return;
    t = tabela_thread + th;
    if (t-&gt;stare != THREAD_GATA) return;
    thread_curent = th;
/**/signal(SIGALRM, intrerupere);
/**/alarm(CUANTA);              /* intrerupere */
    longjmp(t-&gt;context, 1);
}
</PRE>

<P>
Aceste funcþii vor face ca periodic sã fie invocat
<TT>alege()</TT>.  Din pãcate soluþia nu este suficient de grijulie, pentru
cã existã riscul ca întreruperea sã vinã atunci cînd facem ceva
important (de exemplu lucrãm în funcþia <TT>creaza_thread()</TT> ºi am
fãcut jumãtate din schimbãri în a pune la punct starea procesului
cel nou).  În general întreruperile nu trebuie sã lase structurile
de date ne-consistente.

<P>
Existã o soluþie foarte elegantã pentru asta: funcþia
<TT>intrerupere()</TT> va evita sã cheme <TT>alege()</TT> dacã s-a ivit tocmai în
mijlocul unei funcþii importante, ºi va ruga chiar funcþia
importantã sã cheme <TT>alege()</TT> cînd se terminã.

<P>
Ca sã simplificãm povestea, vom face funcþiile <TT>sari_la()</TT>
ºi <TT>alege()</TT> private; oricum utilizatorul nu mai are nevoie de ele,
pentru cã sunt chemate automat.

<P>
<PRE>
/* threads.h -- adaugiri sau modificari */

#define CUANTA 2   /* sec */

#if 0
   /* functiile astea nu mai sunt publice */
void sari_la(int th);
void alege(void); /* alege un thread pentru executie si sari la el */
#endif
</PRE>

<P>
Modificãrile din <TT>threads.c</TT> sunt indicate cu /**/ (celelalte
funcþii rãmîn neschimbate):

<P>
<PRE>
/* threads.c -- adaugiri sau modificari */

#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

PRIVAT int tratam_intrerupere;  /* cind tratam intreruperi != 0 */
PRIVAT int mod_nucleu ;         /* in functii importante != 0 */
PRIVAT int realege;             /* intrerupere intirziata */

PRIVAT int
creaza_thread(functie_initiala start)
   /* facem un thread; intoarcem tid */
{
    struct thread *t;

    /* cautam un loc gol in tabela */
/**/mod_nucleu++;
    pt_orice_thread(t)
        if (t-&gt;stare == THREAD_GOL ||
            t-&gt;stare == THREAD_MORT) break;
    if (t == NU_E_THREAD) {
/**/    mod_nucleu--;
        return -1;          /* n-am gasit */
    }
    t-&gt;functie_start = start;
    t-&gt;stare = THREAD_GATA;
/**/if (realege) alege();
/**/mod_nucleu--;
    return t - tabela_thread;
}

PUBLIC void
omoara_thread(int th)
{
    struct thread *t;

/**/mod_nucleu++;
    if (!thread_corect(th)) {
/**/    mod_nucleu--;
        return;
    }
    t = tabela_thread + th;
    t-&gt;stare = THREAD_MORT;
    copiaza_context(t-&gt;context_original, t-&gt;context);
    alege();
/**/mod_nucleu--;
}

/* PRIVAT void sari_la(int th)... in loc de PUBLIC */

PRIVAT void
alege(void)
{
    struct thread *t;
    static int ultimul = 0;
    int i;

/**/realege=0;
    for (i=0; i &lt; MAX_THREADS; i++) {
        t = tabela_thread + ultimul;
        ultimul = (ultimul+1) % MAX_THREADS;
        if (t-&gt;stare == THREAD_GATA) break;
    }
    if (i == MAX_THREADS) 
        panica("Nu e nimeni gata!\n", 0);
    else sari_la(t - tabela_thread);

    /* ne intoarcem la chemator */
}

PRIVAT void 
salveaza(int thread_no, int max)
{
    char c;

    if (setjmp(tabela_thread[thread_no].context)) {
/**/    mod_nucleu=0;
        tabela_thread[thread_no].functie_start();
        omoara_thread(thread_no);
    }   
    else
        aloca_stiva(thread_no+1, max); /*  nu se mai intoarce.. */
}


PRIVAT void
intrerupere(int ignor)
{
    tratam_intrerupere++;
    alarm(CUANTA);
    signal(SIGALRM, intrerupere);
    if (tratam_intrerupere &gt; 1) {
        tratam_intrerupere--;
        return;
    }           
/**/if (mod_nucleu) {         /* aminam alegerea */
/**/    tratam_intrerupere--;
/**/    realege++;
/**/    return;
/**/}
/**/else {
/**/    tratam_intrerupere--;
/**/    mod_nucleu++;
        alege();
/**/    mod_nucleu--;
/**/}
}
</PRE>

<P>
Variabila <TT>mod_nucleu</TT> indicã execuþia curentã a unei
proceduri ne-intreruptibile.  O întrerupere venitã în acest caz nu
va face <TT>alege()</TT>, dar îºi va indica prezenþa prin <TT>realege++</TT>.
Funcþiile importante care pot fi chemate de utilizator
<TT>creaza_thread()</TT> ºi <TT>omoara_thread()</TT> vor verifica înainte de a
termina dacã nu a venit o întrerupere între timp, ºi eventual vor
chema ele <TT>alege()</TT>.

<P>

<H1><A NAME="SECTION000110000000000000000">
Rezumat</A>
</H1>

<P>
Am vãzut cã programele se executã în niºte universuri
închise, pe care dacã le pãstrãm neschimbate, putem întrerupe 
rularea programelor fãrã nici un fel de consecinþe.  Am vãzut cum
putem folosi acest lucru pentru a executa mai multe programe pe o
singurã maºinã.

<P>
Stiva este un mecanism extrem de simplu, de care ne folosim
pentru a implementa funcþii recursive.  Un cadru de stivã este
micro-universul în care se executã o funcþie.

<P>
Limbajul C ne oferã instrucþiuni prin care putem comuta
între cadre diferite de pe o aceeaºi stivã: astfel obþinem mai
multe thread-uri.

<P>
Prezenþa unui ceas extern ne ajutã sã comutãm automat
între mai multe procese.

<P>
<BR><HR>

</BODY>
</HTML>
