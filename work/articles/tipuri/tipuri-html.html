<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Tipuri de date</TITLE>
<META NAME="description" CONTENT="Tipuri de date">
<META NAME="keywords" CONTENT="tipuri-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<H1 ALIGN="CENTER">Tipuri de date</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu</STRONG></P>
<P ALIGN="CENTER"><STRONG>mai 1995</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Tipurile de date în  în Pascal
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>tip de date, operatori, funcþii, puternic
			tipizat, polimorfism, supraîncãrcare
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>Pascal, teoria elementarã a mulþimilor
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html30"
  HREF="tipuri-html.html">Introducere</A>
<LI><A NAME="tex2html31"
  HREF="#SECTION00030000000000000000">Ce este un tip de date</A>
<LI><A NAME="tex2html32"
  HREF="#SECTION00040000000000000000">Tipuri enumerate</A>
<LI><A NAME="tex2html33"
  HREF="#SECTION00050000000000000000">Tipuri fundamentale</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION00060000000000000000">Derivarea tipurilor</A>
<UL>
<LI><A NAME="tex2html35"
  HREF="#SECTION00061000000000000000">Subdomeniu</A>
<LI><A NAME="tex2html36"
  HREF="#SECTION00062000000000000000">Articol (record)</A>
<LI><A NAME="tex2html37"
  HREF="#SECTION00063000000000000000">Vector (matrice)</A>
<LI><A NAME="tex2html38"
  HREF="#SECTION00064000000000000000">Mulþime</A>
<LI><A NAME="tex2html39"
  HREF="#SECTION00065000000000000000">Fiºier</A>
<LI><A NAME="tex2html40"
  HREF="#SECTION00066000000000000000">Record cu case</A>
<LI><A NAME="tex2html41"
  HREF="#SECTION00067000000000000000">Pointer</A>
</UL>
<BR>
<LI><A NAME="tex2html42"
  HREF="#SECTION00070000000000000000">Numele tipurilor</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION00080000000000000000">Operatori</A>
<UL>
<LI><A NAME="tex2html44"
  HREF="#SECTION00081000000000000000"><TT>boolean</TT></A>
<LI><A NAME="tex2html45"
  HREF="#SECTION00082000000000000000"><TT>integer</TT></A>
<LI><A NAME="tex2html46"
  HREF="#SECTION00083000000000000000"><TT>char</TT></A>
<LI><A NAME="tex2html47"
  HREF="#SECTION00084000000000000000"><TT>real</TT></A>
<LI><A NAME="tex2html48"
  HREF="#SECTION00085000000000000000">pentru orice tip enumerare T</A>
<LI><A NAME="tex2html49"
  HREF="#SECTION00086000000000000000">pentru orice tip subrange T</A>
<LI><A NAME="tex2html50"
  HREF="#SECTION00087000000000000000">pentru orice tip <TT>T = array[S] of B</TT></A>
<LI><A NAME="tex2html51"
  HREF="#SECTION00088000000000000000">pentru orice tip mulþime <TT>T = set of S</TT></A>
<LI><A NAME="tex2html52"
  HREF="#SECTION00089000000000000000">pentru orice tip <TT>record R = record e1:T1; ... en:Tn; end</TT></A>
<LI><A NAME="tex2html53"
  HREF="#SECTION000810000000000000000">pentru orice tip pointer PA = <IMG
 WIDTH="15" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$\uparrow$">A</A>
<LI><A NAME="tex2html54"
  HREF="#SECTION000811000000000000000">pentru tipul fiºier <TT>F = file of T</TT></A>
</UL>
<BR>
<LI><A NAME="tex2html55"
  HREF="#SECTION00090000000000000000">Polimorfism ºi supraîncãrcare</A>
<LI><A NAME="tex2html56"
  HREF="#SECTION000100000000000000000">Glosar cu traduceri în englezã</A>
</UL>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION00020000000000000000">
Introducere</A>
</H1>

<P>
Avantajele folosirii unui limbaj <EM>puternic tipizat</EM> sunt
apreciate de orice programator experimentat.  Printre ele sunt:

<P>

<UL>
<LI>uºureazã înþelegerea programului de cãtre om;
</LI>
<LI>încurajeazã o gîndire ºi formulare disciplinatã a problemei;
</LI>
<LI>uºureazã munca de optimizare a compilatorului;
</LI>
<LI>permit depistarea erorilor într-o fazã timpurie.
</LI>
</UL>

<P>
Un limbaj se numeºte ``puternic tipizat'' dacã în faza de
execuþie a unui program nu pot apãrea erori cauzate de tipuri incorecte
ale expresiilor.  Acest articol îºi propune sã explice într-un
cadru cît se poate de riguros o colecþie foarte simplã de
fapte care descrie semnificaþia noþiunii de ``tip de date''.

<P>

<H1><A NAME="SECTION00030000000000000000">
Ce este un tip de date</A>
</H1>

<P>
Existã mai multe definiþii posibile pentru tipurile de date,
din mai multe perspective.  O privire globalã defineºte simultan
atît tipurile de date cît ºi operaþiile care se pot face cu ele,
pentru cã acestea sunt de fapt cele douã faþete ale unei aceleiaºi
monezi: nu pot exista una fãrã cealaltã.  Noi vom trata cele douã 
subiecte pe rînd ºi în mod inegal,
acordînd o oarecare prioritate tipurilor de date.

<P>
Astfel, în cea mai simplã accepþiune posibilã,
un tip de date nu este altceva decît <EM>o mulþime de valori</EM>.

<P>
Ce este o valoare?  Nu are nici o importanþã!  Este un
nume special dat elementelor care aparþin unui tip.  Termenul
``aparþin'' este justificat, pentru cã, reþineþi, tipul este
<EM>o mulþime</EM>, în cel mai precis sens matematic.

<P>
Exemple?  în Pascal tipul <TT>boolean</TT> este o mulþime cu
douã elemente.  Aceste douã elemente se noteazã în Pascal cu <TT>false</TT> ºi <TT>true</TT>. <TT>False</TT> ºi <TT>true</TT> se numesc de aceea
<EM>valori booleene</EM>.  Tipul <TT>integer</TT> este tot o mulþime care
include, printre altele, niºte elemente (valori) care în Pascal se
noteazã cu <TT>-2, -1, 0, 1, 2, 3</TT> etc.  Tipul <TT>integer</TT> este
un tip interesant, pentru cã îºi propune sã mimeze mulþimea
matematica <B>Z</B> a numerelor întregi, dar nu reuºeºte prea bine,
pentru cã mulþimea <TT>integer</TT> este finitã, iar <B>Z</B> nu!  Care
sunt limitele mulþimii <TT>integer</TT> nu se specificã.  În dialectul
Turbo Pascal (cel mai rãspîndit pe PC-uri) <TT>integer</TT> are 65536
de elemente, de la cel notat <TT>-32768</TT> la cel notat <TT>32767</TT>.
Elementele tipului <TT>integer</TT> sunt numite valori întregi (sau mai
precis <EM>integer values</EM>).

<P>
Dacã aþi citit textul de mai sus cu atenþie aþi
observat cã ne-am ferit sã spunem ca <TT>false</TT> este un element
(valoare) boolean.  Am spus <TT>false</TT> este o notaþie (o
reprezentare) a unui element boolean!  De aici încolo nu vom mai
fi atît de scrupuloºi; dealtfel cele douã noþiuni
(element ºi reprezentare) se pot adesea interschimba fãrã
ambiguitate.

<P>
Vom zice de aceea: <BR><P></P>
<DIV ALIGN="CENTER">
boolean = { false, true }
</DIV>
<BR CLEAR="ALL">
<P></P>
unde
acoladele sunt notaþia uzualã pentru mulþime. 

<P>

<H1><A NAME="SECTION00040000000000000000">
Tipuri enumerate</A>
</H1>

<P>
Pascal pune la dispoziþie programatorului mai multe mecanisme
prin care el sã-ºi construiascã noi tipuri.  Cel mai simplu dintre
acestea este <EM>enumerarea</EM>.  Enumerarea construieºte un nou tip cu un
numãr finit de elemente descriind între paranteze reprezentarea
canonicã a fiecãrui element.

<P>
Exemplu (tipic) :

<P>
<PRE>
 (rosu, verde, albastru, galben, mov, negru, alb)
</PRE>

<P>
este descrierea unui nou tip care are 7 elemente cu
reprezentãrile <TT>rosu</TT>, <TT>verde</TT>, etc.  Putem da acestui tip
un nume folosind directiva <TT>type</TT> din Pascal.

<P>
<PRE>
 type culoare = (rosu, verde, albastru, galben, mov, negru, alb);
</PRE>

<P>
Din punct de vedere matematic am putea scrie
<BR><P></P>
<DIV ALIGN="CENTER">
culoare = { rosu, verde, albastru, galben, mov, negru, alb }
</DIV>
<BR CLEAR="ALL">
<P></P>
Tipul boolean din Pascal ar putea fi definit el însuºi
astfel:

<P>
<PRE>
 type boolean = (false, true);
</PRE>

<P>
De ce ne este oferit însã de-a gata vom afla din urmãtoarea
secþiune ºi din cele consacrate operatorilor.

<P>

<H1><A NAME="SECTION00050000000000000000">
Tipuri fundamentale</A>
</H1>

<P>
Limbajul Pascal (standard) conþine patru tipuri gata
construite.  Pe acestea le numim <EM>tipuri fundamentale</EM>.  Ele sunt:

<P>
<PRE>
real, integer, char, boolean
</PRE>

<P>
Pentru <TT>boolean</TT> am vãzut <BR><P></P>
boolean = { false, true }
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
Pentru <TT>integer</TT> am putea scrie ceva de genul <BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
integer =
\{ n \epsilon {\bf Z} \; | \; limita_{jos} \leq n < limita_{sus} \}
\end{displaymath}
 -->

<IMG
 WIDTH="335" HEIGHT="35" BORDER="0"
 SRC="img3.png"
 ALT="\begin{displaymath}integer =
\{ n \epsilon {\bf Z} \; \vert \; limita_{jos} \leq n &lt; limita_{sus} \} \end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
limita<sub>jos</sub> ºi limita<sub>sus</sub> depind de dialectul de Pascal
folosit.  Pentru Turbo ele sunt (dupã cum am zis) <TT>-32768</TT>,
respectiv <TT>32768</TT>.

<P>
Pentru <TT>char</TT> lucrurile sunt grele pentru cã existã
unele caractere care <EM>nu</EM> au o reprezentare evidentã!
Tot ce putem spune este cã aceastã mulþime include mulþimea

<P>
<TT>{'a', 'b', ...'A', 'B', ..., '0', ..., '!', ...} </TT>

<P>
a caracterelor care pot fi tipãrite.

<P>
Iar pentru <TT>real</TT> lucrurile sunt ºi mai încîlcite, pentru cã,
deºi <TT>real</TT> se doreºte o imagine a mulþimii
<B>R</B> a numerelor reale, în realitate <TT>real</TT> este finitã
ºi are elementele distribuite într-un mod foarte ciudat pe axa
realã (nici mãcar douã elemente ale ei nu sunt echidistante)!
Aceasta mulþime este subiectul <EM>analizei
numerice</EM>, care studiazã cum putem face calcule cînd putem
manipula numai aproximãri ale valorilor.

<P>

<H1><A NAME="SECTION00060000000000000000">
Derivarea tipurilor</A>
</H1>

<P>
Pascal (ºi nu numai el) pune la dispoziþie niºte puternice
mecanisme prin care putem construi noi tipuri plecînd de la cele
existente.  (Prin enumerare putem construi tipuri plecînd de la
nimic.)  Derivarea dã naºtere unei noi mulþimi de elemente
combinînd elementele unor tipuri deja existente.

<P>
Existã o interesantã clasã de tipuri numite <EM>tipuri scalare</EM>.  
Tipurile <TT>boolean, char, integer</TT> ºi toate tipurile construite prin
enumerare sunt scalare.  Aceste tipuri au întotdeauna un numãr finit
de elemente ºi dupã cum vom vedea mai tîrziu, existã (datoritã
operatorilor de comparaþie) o relaþie de ordine totalã pe ele
(adicã dintre douã elemente unul e mai mare ºi celãlalt mai mic)<A NAME="tex2html1"
  HREF="#foot360"><SUP>1</SUP></A>.

<P>

<H2><A NAME="SECTION00061000000000000000">
Subdomeniu</A>
</H2>

<P>
Existã o operaþie prin care dintr-un tip <EM>scalar</EM>
putem extrage o submulþime formatã din elemente
consecutive.  Ea devine un nou tip care se va numi un <EM>subdomeniu</EM>
(``subrange'' în englezã) al celui iniþial.  Pentru cã pe
tipurile scalare existã o ordine, submulþimea se indicã prin
capetele ei.  Exemplu:

<P>
<PRE>
 1 .. 100
</PRE>

<P>
este un tip subdomeniu al <TT>integer</TT>, avînd 100 de elemente.

<P>
Iatã un tip subdomeniu al tipului culoare definit mai sus,
cãruia îi dãm ºi un nume:

<P>
<PRE>
 type CulPrimara = rosu .. albastru;
</PRE>

<P>
Tipul numit CulPrimara are 3 elemente: <BR><P></P>
<DIV ALIGN="CENTER">
CulPrimara = {rosu, verde, albastru }.
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
Tipurile subdomeniu sunt toate scalare.

<P>

<H2><A NAME="SECTION00062000000000000000">
Articol (record)</A>
</H2>

<P>
Dacã avem la dispoziþie tipurile T<sub>1</sub>, T<sub>2</sub>, ... T<sub>n</sub>
putem forma un nou tip cu construcþia:

<P>
<PRE>
record 
  c1 : T1;
  c2 : T2;
  ....
  cn : Tn;
end
</PRE>

<P>
Ce mulþime reprezintã noul tip?  O valoare de tip record
subsumeazã n valori, fiecare din tipul T<sub>i</sub> respectiv.  Cu
alte cuvinte putem asimila un record cu un tuplu (o mulþime ordonatã)
cu n elemente (v<sub>1</sub>, v<sub>2</sub>,... , v<sub>n</sub>), unde <!-- MATH
 $v_i \epsilon T_i\,|\, i \epsilon
\{1 \ldots n\}.$
 -->
<IMG
 WIDTH="134" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img10.png"
 ALT="$ v_i \epsilon T_i\,\vert\, i \epsilon
\{1 \ldots n\}.$">

<P>
Sã dãm un nume tipului de mai sus:

<P>
<PRE>
type R = record 
   c1 : T1; 
   c2 : T2; 
   ... 
   cn : Tn
end;
</PRE>

<P>
atunci
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
R = \{ (v_1, v_2, \ldots, v_n) \; | \; v_i \epsilon T_i, \; i = 1\ldots n \}.
\end{displaymath}
 -->

<IMG
 WIDTH="305" HEIGHT="34" BORDER="0"
 SRC="img11.png"
 ALT="\begin{displaymath}R = \{ (v_1, v_2, \ldots, v_n) \; \vert \; v_i \epsilon T_i, \; i = 1\ldots n \}.\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
sau altfel scris
<BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
R = T_1 \times T_2 \times \dots  \times T_n = \prod_{i=1}^n T_i
\end{displaymath}
 -->

<IMG
 WIDTH="237" HEIGHT="58" BORDER="0"
 SRC="img12.png"
 ALT="\begin{displaymath}R = T_1 \times T_2 \times \dots \times T_n = \prod_{i=1}^n T_i \end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
unde <IMG
 WIDTH="19" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img13.png"
 ALT="$ \times $"> denotã operaþia de produs cartezian.

<P>
Un tip construit cu <TT>record</TT> nu este scalar.

<P>
<B>Notã</B>: pentru deplina rigoare ar trebui sã includem în
mulþimea R ºi numele cîmpurilor c<sub>1</sub>, c<sub>2</sub>, ...,
c<sub>n</sub>.  O definiþie completã ar fi: produsul cartezian al
tipurilor componente, avînd fiecare componentã etichetatã cu numele 
corespunzãtor.  Etichetarea se poate defini ºi ea perfect
riguros, dar o lãsãm pe seama cititorului.

<P>

<H2><A NAME="SECTION00063000000000000000">
Vector (matrice)</A>
</H2>

<P>
Dacã avem un tip oarecare B ºi un tip scalar S (cu
excepþia lui <TT>integer</TT>) putem forma din ele un nou tip cu
operaþia (dînd ºi nume tipului):

<P>
<PRE>
 type A = array [S] of B;
</PRE>

<P>
Nu este prea complicat de vãzut cã asta înseamnã <BR><P></P>
A = B x B x ... x B = B<sup>|S|</sup>
</DIV>
<BR CLEAR="ALL">
<P></P>
unde produsul este luat
de cardinal din S (numãrul de elemente al lui S) ori.  Aceasta
pentru cã un <TT>array[S] of B</TT> este o colecþie de atîtea
valori de tipul B cîte valori conþine tipul S.

<P>
Un tip construit cu <TT>array</TT> nu este scalar.

<P>
Notã: Ca mai sus, fiecare componentã a unui element din
produsul B<sup>n</sup> este etichetatã cu o valoare corespunzãtoare
din S.

<P>

<H2><A NAME="SECTION00064000000000000000">
Mulþime</A>
</H2>

<P>
Dacã avem un tip scalar S putem forma tipul (dacã S nu are
prea multe elemente):

<P>
<PRE>
set of S
</PRE>

<P>
Ce valori are acest nou tip?  Un element al tipului <TT>set
of S</TT> este o mulþime formatã cu elemente din S.  Deci dacã
avem declaraþia:

<P>
<PRE>
type R = set of S;
</PRE>

<P>
atunci <BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
R = \{ M \; | \; M \subset S \} = {\cal P} (S)
\end{displaymath}
 -->

<IMG
 WIDTH="201" HEIGHT="34" BORDER="0"
 SRC="img19.png"
 ALT="\begin{displaymath}R = \{ M \; \vert \; M \subset S \} = {\cal P} (S) \end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
adicã mulþimea pãrþilor lui S.

<P>
Un tip construit cu <TT>set</TT> nu este scalar.

<P>

<H2><A NAME="SECTION00065000000000000000">
Fiºier</A>
</H2>

<P>
Fiºierul este un tip interesant.  Este prima metodã de a
construi un tip care -- teoretic vorbind -- este infinit!  (Toate
tipurile de pînã acum sunt finite pentru cã sunt construite prin
combinaþii finite ale unor mulþimi finite).  Bine-nþeles cã
practic ºi acest tip este finit, dar cu o dimensiune maximã
neprecizatã.

<P>
Fiind dat un tip T (care nu e fiºier la rîndul sãu) ce face
operaþia:

<P>
<PRE>
file of T
</PRE>

<P>
?

<P>
Un fiºier este asemãnator unui <TT>array</TT>, dar are o lungime
neprecizatã.  El conþine la un moment dat 0 sau 1 sau 2, ...
valori de tipul T.  Deci dacã F e definit

<P>
<PRE>
type F = file of T;
</PRE>

<P>
atunci ca mulþime <BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
F = \bigcup_n \{ T^n \; | \; n
\epsilon {\bf N} \} = T^*
\end{displaymath}
 -->

<IMG
 WIDTH="183" HEIGHT="49" BORDER="0"
 SRC="img22.png"
 ALT="\begin{displaymath}F = \bigcup_n \{ T^n \; \vert \; n
\epsilon {\bf N} \} = T^* \end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
unde <B>N</B> este mulþimea numerelor
naturale.

<P>
(O astfel de operaþie aplicatã lui T (reuniunea tuturor
puterilor) se numeºte operaþia lui Kleene, ºi se noteazã
cu T<sup>*</sup>).

<P>

<H2><A NAME="SECTION00066000000000000000">
Record cu case</A>
</H2>

<P>
Ajungem la o operaþie mai puþin omogenã de combinare a
tipurilor.  Sã considerãm directiva Pascal:

<P>
<PRE>
type RC = record
   c1 : T1;
   case c2 : T2 of
     v1 : ( c3 : T3 );
     v2 : ( c4 : T4 );
end
</PRE>

<P>
Un model aproximativ este dat de <BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
RC \subset T1 \times T2
\times (T3 \cup T4)
\end{displaymath}
 -->

<IMG
 WIDTH="209" HEIGHT="34" BORDER="0"
 SRC="img24.png"
 ALT="\begin{displaymath}RC \subset T1 \times T2
\times (T3 \cup T4) \end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
pentru cã o valoare de tip RC are primele
douã cîmpuri de tipurile T1, respectiv T2, ºi un alt cîmp
dintr-unul din tipurile T3 sau T4.

<P>
In realitate RC nu este atît de vastã, pentru cã nu orice
combinaþie din mulþimea indicatã este în RC.  Cînd cîmpul al
doilea are valoarea v1, cîmpul al treilea nu poate fi de tipul T4!
Deci corect este: <BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
RC = T1 \times ( \{v1\} \times T3 \cup \{v2\}
\times T4)
\end{displaymath}
 -->

<IMG
 WIDTH="279" HEIGHT="34" BORDER="0"
 SRC="img25.png"
 ALT="\begin{displaymath}RC = T1 \times ( \{v1\} \times T3 \cup \{v2\}
\times T4) \end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P> {v1} este mulþimea formatã din elementul v1
aparþinînd lui T2.

<P>
Un astfel de tip nu este scalar.

<P>

<H2><A NAME="SECTION00067000000000000000">
Pointer</A>
</H2>

<P>
Ultimul mod de derivare a tipurilor în Pascal este prin
luarea referinþei la ele.  Un tip

<P>
<PRE>
type PT = ^T;
</PRE>

<P>
are printre valorile sale o valoare specialã <TT>nil</TT>, ºi apoi
valori care <EM>aratã</EM> spre valori din tipul T.  Tipul PT este
deci izomorf (corespondent unu la unu) cu tipul T la care se adaugã
un nou element: <BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
PT = T \cup \{ {\bf nil} \}.
\end{displaymath}
 -->

<IMG
 WIDTH="124" HEIGHT="34" BORDER="0"
 SRC="img26.png"
 ALT="\begin{displaymath}PT = T \cup \{ {\bf nil} \}.\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
Tipul pointer din Pascal este singurul tip care poate sã
includã în definiþia sa pe sine însuºi, ca în:

<P>
<PRE>
type 
  PA = ^A;
  A = record
    i : I;
    n : PA;
  end;
</PRE>

<P>
Asta dã o interesantã ``ecuaþie'' pentru mulþimea
PA: <BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
PA = \{ nil \} \cup A = \{ nil \} \cup ( I \times PA ).
\end{displaymath}
 -->

<IMG
 WIDTH="277" HEIGHT="34" BORDER="0"
 SRC="img27.png"
 ALT="\begin{displaymath}PA = \{ nil \} \cup A = \{ nil \} \cup ( I \times PA ).\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
Nu este nimic contradictoriu în aceastã formulã!
Cele douã mulþimi sunt într-adevãr egale, în sensul
cã fiecare element care se aflã în PA este fie <B>nil</B> fie se
poate scrie sub forma (i, pa) unde <IMG
 WIDTH="28" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.png"
 ALT="$i \epsilon I$"> ºi <!-- MATH
 $pa \epsilon
PA$
 -->
<IMG
 WIDTH="58" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$pa \epsilon
PA$">.

<P>
De fapt aceasta este definiþia (recursivã) a unei liste
(aþi recunoscut probabil tipul PA ca fiind tipul celulei de bazã
care compune o listã simplu înlãnþuitã):

<P>
O listã (de tipul I) este sau

<UL>
<LI>lista vidã, sau

<P>
</LI>
<LI>o valoare de tipul I împreunã cu o listã ``mai micã'' de
acelaºi tip.

<P>
</LI>
</UL>

<P>

<H1><A NAME="SECTION00070000000000000000">
Numele tipurilor</A>
</H1>

<P>
Am folosit adesea în exemplele anterioare nume asociate
tipurilor cu ajutorul directivei <TT>type</TT>.  în construcþia:

<P>
<PRE>
 type 
  t = record
    a : array[1..10] of integer;
    c : char;
  end;
</PRE>

<P>
avem douã parþi:

<P>

<OL>
<LI>una care construieºte un nou tip

<P>
<PRE>
 record
   a: array[1..10] of integer;
   c: char;
 end
</PRE>

<P>
</LI>
<LI>una care îi dã un nume acestei construcþii:

<P>
<PRE>
 type t = constructie;
</PRE>
</LI>
</OL>

<P>
Acestea sunt douã operaþii distincte.  Mai mult, în Pascal tipurile
<TT>t</TT> ºi <TT>record a:array[1..10] of integer; c:char; end</TT> sunt
în realitate distincte deºi au aceeaºi structurã (sunt formate
prin produsele aceloraºi mulþimi: integer<sup>10</sup> x char
<P>
Asta putem vedea dacã scriem:

<P>
<PRE>
 var x, z: t;
     y: record array[1..10] of integer; c: char; end;
</PRE>

<P>
Acum <TT>x</TT> ºi <TT>y</TT> au tipuri diferite.  O operaþie
de felul <TT>x := y</TT> nu este permisã!  Putem face însã
<TT>x := z</TT>.

<P>
Deci: douã tipuri nu sunt <EM>compatibile</EM> chiar dacã
au aceeaºi structurã.  Ele trebuie sã aibã acelaºi <EM>nume</EM>, ºi atunci de fapt sunt o aceeaºi mulþime.

<P>

<H1><A NAME="SECTION00080000000000000000">
Operatori</A>
</H1>

<P>
În realitate orice definiþie a unui tip ca mulþime trebuie
sã includã ºi o mulþime de
operaþii pe valorile sale, care iau naºtere automat odatã cu
crearea sa.  Ce este o operaþie?  Aparent banalã întrebarea nu are
un rãspuns evident.  <TT>div</TT> este o operaþie între doi întregi.
Ce înseamnã asta?  Ea combinã cele douã valori întregi cãrora li
se aplicã pentru a genera una nouã.  Este deci o <EM>funcþie</EM>
definitã astfel: <BR><P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{displaymath}
div : integer \times integer \rightarrow integer
\end{displaymath}
 -->

<IMG
 WIDTH="255" HEIGHT="33" BORDER="0"
 SRC="img34.png"
 ALT="\begin{displaymath}div : integer \times integer \rightarrow integer
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>

<P>
Ea asociazã perechii (a,b) de numere întregi numãrul
``cîtul împãrþirii lui a la b''.

<P>
<TT>div</TT> este o funcþie care nu se poate calcula pentru
toate perechile de întregi.  Dacã al doilea este 0 atunci
operaþia nu are sens.  Deci funcþia este <EM>parþialã</EM>,
adicã nu este definitã pentru toate valorile posibile ale
argumentelor.

<P>
De fapt asta sunt toþi operatorii -- funcþii din tipuri
(sau produse carteziene de tipuri) în tipuri.

<P>
De ce sunt tipurile atît de legate de operatori?  Pentru
cã crearea unui nou tip prin oricare din operaþiile de mai sus
dã naºtere în mod automat unor operatori care lucreazã
cu valori din acel tip.  De exemplu definirea unui tip enumerare ca
cel <TT>culoare</TT> de mai sus dã naºtere urmãtorilor
operatori:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><code>&lt; &gt; &lt;= &gt;= &lt;&gt; =</code></TD>
<TD ALIGN="LEFT">culoare x culoare</TD>
<TD ALIGN="LEFT"><code>boolean</code></TD>
</TR>
<TR><TD ALIGN="CENTER"><code>succ pred</code></TD>
<TD ALIGN="LEFT">culoare</TD>
<TD ALIGN="LEFT">culoare</TD>
</TR>
<TR><TD ALIGN="CENTER"><code>ord</code></TD>
<TD ALIGN="LEFT">culoare</TD>
<TD ALIGN="LEFT"><code>integer</code></TD>
</TR>
</TABLE>
</DIV>

<P>
Iatã mai jos pentru fiecare tip ce operatori are (dacã
este fundamental) ºi cãror operatori le dã naºtere:

<P>

<H2><A NAME="SECTION00081000000000000000">
<TT>boolean</TT></A>
</H2>

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>= &lt;&gt; &lt; &gt; &lt;= &gt;=</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT> x <TT>boolean</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>and or</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT> x <TT>boolean</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>not</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>succ pred</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>ord</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION00082000000000000000">
<TT>integer</TT></A>
</H2>

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>= &lt;&gt; &lt; &gt; &lt;= &gt;=</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT> x <TT>integer</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>succ pred</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>ord</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>+ - * div mod</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT> x <TT>integer</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>odd</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION00083000000000000000">
<TT>char</TT></A>
</H2>

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>= &lt;&gt; &lt; &gt; &lt;= &gt;=</TT></TD>
<TD ALIGN="LEFT"><TT>char</TT> x <TT>char</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>succ pred</TT></TD>
<TD ALIGN="LEFT"><TT>char</TT></TD>
<TD ALIGN="LEFT"><TT>char</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>ord</TT></TD>
<TD ALIGN="LEFT"><TT>char</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>chr</TT></TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT"><TT>char</TT></TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION00084000000000000000">
<TT>real</TT></A>
</H2>

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>+ - / *</TT></TD>
<TD ALIGN="LEFT"><TT>real</TT> x <TT>real</TT></TD>
<TD ALIGN="LEFT"><TT>real</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>= &lt;&gt; &lt; &gt; &lt;= &gt;=</TT></TD>
<TD ALIGN="LEFT"><TT>real</TT> x <TT>real</TT></TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION00085000000000000000">
pentru orice tip enumerare T</A>
</H2>

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>pred succ</TT></TD>
<TD ALIGN="LEFT">T</TD>
<TD ALIGN="LEFT">T</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>= &lt;&gt; &lt; &gt; &lt;= &gt;=</TT></TD>
<TD ALIGN="LEFT">T x T</TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>ord</TT></TD>
<TD ALIGN="LEFT">T</TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION00086000000000000000">
pentru orice tip subrange T</A>
</H2>
moºteneºte toate operaþiile tipului din care este derivat

<P>

<H2><A NAME="SECTION00087000000000000000">
pentru orice tip <TT>T = array[S] of B</TT></A>
</H2>

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>[]</TT></TD>
<TD ALIGN="LEFT">T x S</TD>
<TD ALIGN="LEFT">B</TD>
</TR>
</TABLE>
</DIV>

<P>
(operaþia de indexare aplicatã astfel <TT>t[s]</TT> unde <IMG
 WIDTH="46" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$t \in
T$"> ºi <IMG
 WIDTH="47" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.png"
 ALT="$s \in S$">).

<P>

<H2><A NAME="SECTION00088000000000000000">
pentru orice tip mulþime <TT>T = set of S</TT></A>
</H2>

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>= &lt;&gt; &lt;= &gt;=</TT></TD>
<TD ALIGN="LEFT">T x T</TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>in</TT></TD>
<TD ALIGN="LEFT">S x T</TD>
<TD ALIGN="LEFT"><TT>boolean</TT></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>+ - *</TT></TD>
<TD ALIGN="LEFT">T x T</TD>
<TD ALIGN="LEFT">T</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>[]</TT> (discutabil)</TD>
<TD ALIGN="LEFT">S</TD>
<TD ALIGN="LEFT">T</TD>
</TR>
</TABLE>
</DIV>

<P>
(ultimul este constructorul de mulþime aplicat astfel: 
<TT>[s, s1, s2..s3]</TT> unde <!-- MATH
 $s1, s2, s3, s4 \in S$
 -->
<IMG
 WIDTH="130" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="$s1, s2, s3, s4 \in S$">).

<P>

<H2><A NAME="SECTION00089000000000000000">
pentru orice tip <TT>record R = record e1:T1; ... en:Tn; end</TT></A>
</H2>

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>.</TT></TD>
<TD ALIGN="LEFT">R x mulþimea etichetelor</TD>
<TD ALIGN="LEFT"><IMG
 WIDTH="43" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$ \bigcup_i T_i $"></TD>
</TR>
</TABLE>
</DIV>

<P>
(ultima este operaþia de selecþie, care se aplicã astfel 
<TT>r.e</TT> unde <IMG
 WIDTH="49" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$r \in R$"> ºi e este una din etichete.)

<P>

<H2><A NAME="SECTION000810000000000000000">
pentru orice tip pointer PA = <IMG
 WIDTH="15" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$\uparrow$">A</A>
</H2>

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><IMG
 WIDTH="15" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$\uparrow$"></TD>
<TD ALIGN="LEFT">PA</TD>
<TD ALIGN="LEFT">A</TD>
</TR>
</TABLE>
</DIV>

<P>
(Operaþia de dereferenþiere, aplicatã astfel: pa <IMG
 WIDTH="15" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$\uparrow$">
unde <IMG
 WIDTH="72" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.png"
 ALT="$pa \in PA$">.)

<P>

<H2><A NAME="SECTION000811000000000000000">
pentru tipul fiºier <TT>F = file of T</TT></A>
</H2>

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">operatori</TD>
<TD ALIGN="LEFT">domeniu de definiþie</TD>
<TD ALIGN="LEFT">domeniu de valori</TD>
</TR>
<TR><TD ALIGN="CENTER"><IMG
 WIDTH="15" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$\uparrow$"></TD>
<TD ALIGN="LEFT">F</TD>
<TD ALIGN="LEFT">I</TD>
</TR>
</TABLE>
</DIV>

<P>
(Operaþia de scriere/citire din buffer aplicatã astfel:
f<IMG
 WIDTH="15" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$\uparrow$"> unde <IMG
 WIDTH="51" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.png"
 ALT="$f \in F$">.)

<P>
În plus pe lîngã operaþiile descrise anterior o valoare
din orice tip poate fi atribuitã (<TT>:=</TT>) unei variabile de acelaºi tip (cu
excepþia fiºierelor).

<P>

<H1><A NAME="SECTION00090000000000000000">
Polimorfism ºi supraîncãrcare</A>
</H1>

<P>
Dupã cum vedeþi anumiþi operatori sunt definiþi
pentru mai multe tipuri.  De exemplu <TT>succ</TT> merge pe orice tip
scalar, dînd un rezultat de acelaºi tip.  în realitate <!-- MATH
 $succ : integer \rightarrow integer$
 -->
<IMG
 WIDTH="193" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.png"
 ALT="$
succ : integer \rightarrow integer $"> ºi <!-- MATH
 $succ : char \rightarrow
char$
 -->
<IMG
 WIDTH="151" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$ succ : char \rightarrow
char $"> sunt doi operatori diferiþi dar care au acelaºi nume.  Un
astfel de operator, care funcþioneazã pe mai multe tipuri de
date simultan ºi a cãrui comportare depinde de tipul la care se
aplicã se numeºte <EM>supraîncãrcat</EM>.
	Adesea astfel de operatori sunt bineveniþi, adesea însã pot sã dea naºtere la probleme.  De exemplu teoretic existã patru
operatori + astfel:

<P>
<P></P>
<DIV ALIGN="CENTER">
+ : integer x integer --&gt; integer <br>
+ : real x real --&gt; real <br>
+ : integer x real --&gt; real <br>
+ : real x integer --&gt; real 
<BR CLEAR="ALL"></DIV><P></P>
<BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>

<P>
Toþi aceºtia sunt supraîncãrcãri ale lui +. (Ca sã nu
vorbim de folosirea lui + ca reuniune de mulþimi).  Putem sã
aplicãm unul ºi sã ne gîndim la altul, cum ar fi în urmãtorul
exemplu:

<P>
<PRE>
 var
  i,j : integer;
  r : real;

  i := j + r;
</PRE>

<P>
Ori asta nu se poate, pentru cã aici + este presupus a fi
<BR><P></P>
<DIV ALIGN="CENTER">
+ : integer x real --&gt; integer
</DIV>
<BR CLEAR="ALL">
<P></P>
care nu existã!

<P>
Existã un gen special de operatori care seamãnã cu cei
supraîncãrcaþi dar care nu sunt supraîncãrcaþi ci <EM>polimorfici</EM>.  Distincþia între ei nu este cîteodatã foarte
precisã.  În Pascal la acest titlu aspirã de pildã operatorii
``<TT>.</TT>'' (pentru selecþie), ``<TT>[]</TT>'' (pentru indexare), etc.

<P>
De ce?  Pentru cã operatorul <TT>[]</TT> este definit pentru
orice tipuri <TT>R, S, B</TT>:

<P>
<PRE>
R = array [S] of B 
[] : R x S -&gt; B
</PRE>

<P>
ºi opereazã la fel independent de natura tipurilor <TT>S</TT>
(scalar) ºi <TT>B</TT>, extrãgînd din valoarea de tipul <TT>R</TT> (un
array) pe cea etichetatã cu valoarea datã de tipul <TT>S</TT>.  Putem
spune cã <TT>[]</TT> este un <EM>singur</EM> operator, oricare ar fi tipul
<TT>R</TT> format ca mai sus.  <TT>[]</TT> este atunci un operator
polimorfic -- pentru cã lucreazã cu mai multe tipuri dar în exact
acelaºi mod.

<P>
(Sã observãm cã mai existã un operator notat tot cu <TT>[]</TT> 
pentru construit mulþimi, care este tot polimorfic!  Cei doi operatori 
sunt distinºi dupã modul în care se scriu în expresie.  Acesta este tot o
supraîncãrcare!)

<P>

<H1><A NAME="SECTION000100000000000000000">
Glosar cu traduceri în englezã</A>
</H1>

<P>
<DL>
<DT><STRONG>Tip de date (data type)</STRONG></DT>
<DD>o mulþime de valori cãreia adesea i
se adaugã un set de operatori ºi un set de reguli de folosire a
operatorilor.

<P>
</DD>
<DT><STRONG>Puternic tipizat (strongly typed) (despre un limbaj)</STRONG></DT>
<DD>care nu
poate genera erori cauzate de tipuri eronate în timpul execuþiei.

<P>
</DD>
<DT><STRONG>Operator (operator)</STRONG></DT>
<DD>o operaþie între mai multe valori dînd
ca rezultat o altã valoare; strict vorbind o funcþie (parþialã)
definitã pe un produs cartezian de tipuri cu valori într-un tip.

<P>
</DD>
<DT><STRONG>Polimorfic (polymorphic)</STRONG></DT>
<DD>un operator care opereazã la fel
asupra mai multor tipuri de date structurate asemãnator.

<P>
</DD>
<DT><STRONG>Supraîncãrcat (overloaded)</STRONG></DT>
<DD>(despre un operator) în realitate
mai mulþi operatori cu acelaºi nume, dar care sunt distinºi dupã
contextul în care se aplicã (tipurile argumentelor ºi al
rezultatului).

<P>
</DD>
<DT><STRONG>Tip scalar (scalar type)</STRONG></DT>
<DD>un tip cu un numãr finit de elemente
asupra cãrora este fixatã o relaþie de ordine totalã (cu ajutorul
unor operatori).

<P>
</DD>
</DL>

<P>
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot360">... mic)</A><A NAME="foot360"
 HREF="tipuri-html.html#tex2html1"><SUP>1</SUP></A>
<DD>
Raportul Pascal marcheazã ºi tipul <TT>real</TT> ca fiind scalar, dar din 
motive de omogenitate noi nu îl vom considera astfel, pentru cã el nu 
se comportã în nici o privinþa ca un tip scalar

</DL>
<BR><HR>

</BODY>
</HTML>
