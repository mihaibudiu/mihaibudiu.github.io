<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Tranzacþii</TITLE>
<META NAME="description" CONTENT="Tranzacþii">
<META NAME="keywords" CONTENT="tranzactii-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">Tranzacþii</H1>
<P ALIGN="CENTER"><STRONG>Mihai Budiu -- <TT>mihaib+@cs.cmu.edu</TT> 
<BR><TT>http://www.cs.cmu.edu/~mihaib/</TT></STRONG></P>
<P ALIGN="CENTER"><STRONG>9 Martie 1998</STRONG></P>

<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Tranzacþiile atomice: proprietãþi, implementãri,
utilizare 
</DD>
<DT><STRONG>Cunoºtinþe necesare:</STRONG></DT>
<DD>programare, concurenþã
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>atomicitate, durabilitate, independenþã,
consistenþã, <I>log</I> (înregistrare), <I>lock</I> (încuietoare),
<I>timestamp</I>
</DD>
</DL>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html33"
  HREF="tranzactii-html.html">Unelte</A>
<LI><A NAME="tex2html34"
  HREF="#SECTION00030000000000000000">Ce sunt tranzacþiile</A>
<LI><A NAME="tex2html35"
  HREF="#SECTION00040000000000000000">Proprietãþi ale tranzacþiilor</A>
<UL>
<LI><A NAME="tex2html36"
  HREF="#SECTION00041000000000000000">Atomicitate</A>
<LI><A NAME="tex2html37"
  HREF="#SECTION00042000000000000000">Independenþa</A>
<LI><A NAME="tex2html38"
  HREF="#SECTION00043000000000000000">Consistenþa; programarea cu invarianþi</A>
<LI><A NAME="tex2html39"
  HREF="#SECTION00044000000000000000">Durabilitatea</A>
</UL>
<BR>
<LI><A NAME="tex2html40"
  HREF="#SECTION00050000000000000000">Operaþiile tranzacþiilor</A>
<UL>
<LI><A NAME="tex2html41"
  HREF="#SECTION00051000000000000000">Sinucidere ºi crimã</A>
</UL>
<BR>
<LI><A NAME="tex2html42"
  HREF="#SECTION00060000000000000000">La ce sunt utile tranzacþiile?</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION00070000000000000000">Serializabilitate</A>
<UL>
<LI><A NAME="tex2html44"
  HREF="#SECTION00071000000000000000"><I>Schedule</I></A>
<LI><A NAME="tex2html45"
  HREF="#SECTION00072000000000000000">Graful dependenþelor</A>
<LI><A NAME="tex2html46"
  HREF="#SECTION00073000000000000000">Controlul accesului concurent</A>
<LI><A NAME="tex2html47"
  HREF="#SECTION00074000000000000000">Izolare: recapitulare</A>
</UL>
<BR>
<LI><A NAME="tex2html48"
  HREF="#SECTION00080000000000000000">Implementarea lui <TT>Abort</TT> ºi <I>Commit</I></A>
<UL>
<LI><A NAME="tex2html49"
  HREF="#SECTION00081000000000000000"><I>Log</I>-ul</A>
</UL>
<BR>
<LI><A NAME="tex2html50"
  HREF="#SECTION00090000000000000000">Catastrofe (crash)</A>
<UL>
<LI><A NAME="tex2html51"
  HREF="#SECTION00091000000000000000">``Write-ahead log''</A>
<LI><A NAME="tex2html52"
  HREF="#SECTION00092000000000000000">Protocolul de refacere (recovery)</A>
</UL>
<BR>
<LI><A NAME="tex2html53"
  HREF="#SECTION000100000000000000000">Încheiere</A>
</UL>
<!--End of Table of Contents-->
<P>
<BR>
<BR>
<BR>

<P>

<H1><A NAME="SECTION00020000000000000000">
Unelte</A>
</H1>

<P>
La o adicã un calculator nu este altceva decît o unealtã.  O
unealtã care este folositã cu foarte mult succes în rezolvarea a
fel de fel de probleme.  Hai sã luãm totuºi calculatorul ca pe un
scop în sine, ºi sã aruncãm o scurtã privire asupra naturii
muncii din domeniu, fie ea scriere de software sau proiectare de
hardware (permiteþi-mi sã contrag totul la aceste douã categorii).
Aº vrea sã observ cã poate mai pregnant decît în alte domenii
tehnice, munca din calculatoare constã tot din creaþia unor unelte.

<P>
Ce sunt sistemele de operare?  Niºte unelte care mãresc
productivitatea utilizãrii unui calculator.  Ce sunt limbajele de
programare?  Unelte care înlesnesc exprimarea unor operaþii
complexe.  Ce sunt reþelele de calculatoare?  Unelte care mijlocesc
schimbul de informaþii.  Procedurile sunt unelte care rezolvã
subprobleme, etc.  ªi tot aºa, la scarã macro sau micro,
peste tot numai unelte.  Un bun specialist în proiectarea aplicaþiilor sau
sistemelor are la dispoziþie o paletã amplã de unelte din care le
alege pe cele mai potrivite scopurilor sale.

<P>
Unele probleme sunt de nerezolvat fãrã unelte potrivite; e ca ºi
cum ai încerca sã înþelegi teoria relativitãþii cunoscînd numai
aritmetica de clasa a doua.  Uneltele nu numai cã dau chei pentru
soluþionarea dificultãþilor, ci creazã ºi un cadru ordonat în
care sã ne exprimãm gîndurile.  Este de neconceput scrierea de
software la ora actualã fãrã suportul conceptului de ``proces'': un
program care se executã în izolare.  Ori procesul nu este altceva
decît o altã unealtã construitã de cãtre sistemul de operare; o
abstracþie, dar una extrem de utilã.

<P>
În acest articol voi prezenta tot o unealtã.  Una mai puþin
cunoscutã, ºi care a fost aplicatã în relativ puþine contexte,
deºi este extrem de expresivã ºi utilã.  Dar lucrurile se vor
schimba cu siguranþã în ceea ce o priveºte, pentru cã domeniul ei
de aplicaþii se lãrgeºte permanent, de la bazele de date, în care
a fost (ºi este) folositã iniþial pînã la sistemele de operare sau
aplicaþiile distribuite.  Este vorba de <I>tranzacþii</I>, numite
ºi ``tranzacþii atomice''.

<P>

<H1><A NAME="SECTION00030000000000000000">
Ce sunt tranzacþiile</A>
</H1>

<P>
Dintru început trebuie spus cã subiectul este extrem de generos.
Existã cãrþi întregi scrise despre tranzacþii, existã
varietãþi extrem de exotice de tranzacþii, dar evident, în
spaþiul unui astfel de articol nu putem sã ne aventurãm prea
departe.  Vom fi deci relativ ``tradiþionali'', discutînd despre
unul dintre cele mai simple modele de tranzacþii, cam aºa cum este
el întîlnit în majoritatea cãrþilor de baze de date.

<P>
Ce e o tranzacþie?  O tranzacþie este o unealtã pusã la îndemînã
unui programator prin care acesta poate exprima anumite proprietãþi
ale pãrþilor unor programe.  Principala proprietate pe care
tranzacþiile o pun la dispoziþie este <I>atomicitatea</I>.
Cuvîntul atom, spuneau manualele de fizicã de liceu pe vremea mea,
însemna în greaca veche ``indivizibil'', ``care nu poate fi spart
în bucãþi''.  O tranzacþie îi permite unui programator sã
grupeze mai multe operaþii elementare într-un tot indivizibil, sã
construiascã deci noi operaþii, dar într-un fel care sã nu ne
permitã sã discernem structura lor interioarã (adicã faptul cã
sunt compuse din mai multe bucãþele).  Vom vedea imediat cã acest
lucru poate fi interpretat în mai multe feluri, depinzînd de
contextul la care ne gîndim.

<P>

<H1><A NAME="SECTION00040000000000000000">
Proprietãþi ale tranzacþiilor</A>
</H1>

<P>
Înainte de a vedea cum aratã sau cum se implementeazã tranzacþiile
o sã le trecem în vedere proprietãþile.  În literaturã sunt
evidenþiate patru proprietãþi esenþiale, ale cãror iniþiale sunt
ACID.  

<P>
Sã reþinem însã cã anumite implementãri ale tranzacþiilor nu
oferã toate aceste proprietãþi, probabil pentru cã domeniul de
utilizare al nu are neapãratã nevoie de unele din proprietãþi.
Vom vedea de asemenea cã proprietãþile acestea nu sunt complet
independente, ºi cã anume mecanisme de implementare pot oferi
simultan mai multe proprietãþi; o oarecare independenþã
existã între proprietãþi.

<P>

<H2><A NAME="SECTION00041000000000000000">
Atomicitate</A>
</H2>

<P>
O tranzacþie grupeazã mai multe instrucþiuni laolaltã într-o
``macro-instrucþiune'' care se comportã ca o unitate indivizibilã.
Putem vedea aceastã proprietate în douã feluri, care se numesc
respectiv atomicitate ºi independenþã.  Primul punct de vedere
este discutat în aceastã secþiune, iar al doilea ceva mai tîrziu.

<P>
Un grup de instrucþiuni dintr-o tranzacþie se comportã ca o
singurã entitate atunci cînd se întîmplã o catastrofã.  Chiar
dacã am grupat 10 instrucþiuni ºi curentul cade dupã ce am executat
numai primele 5, sistemul de tranzacþii trebuie sã ne asigure cã
dupã reluarea execuþiei efectul celor cinci instrucþiuni nu este
vizibil.  O întrerupere catastrofalã trebuie sã lase sistemul
într-o stare corectã, care ar fi putut surveni în urma unei
execuþii normale.  Cu alte cuvinte dacã am grupat niºte
instrucþiuni într-o tranzacþie atunci se executã ori toate ori
niciuna: ``totul sau nimic''.

<P>
Sã luãm un exemplu ipotetic: un program de contabilitate care
calculeazã plãþile fãcute angajaþilor.  Programul trebuie ca
pentru fiecare angajat sã marcheze salariul de plãtit ºi sã scadã
aceeaºi sumã din budgetul întreprinderii (îmi cer scuze dacã o
dau în barã cu terminologia contabilã; ideea conteazã). 
Programul ar putea arãta aºa:

<P>
<PRE>
platit := 0;
for i:=1 to angajati do begin 
        dePlata[i] := dePlata[i] + salariu[i];
        platit := platit + salariu[i]
end;
budget := budget - platit;
</PRE>

<P>
Dacã presupunem cã valorile modificate sunt înregistrãri pe disc,
într-o bazã de date, atunci dacã curentul cade undeva la mijlocul
buclei anumite salarii vor fi fost plãtite, dar suma nu a fost
scãzutã din budget.  Programul nu poate fi reluat de la început,
pentru cã anumite salarii au fost plãtite, dar altele nu.

<P>
Soluþia este sã executãm toate aceste instrucþiuni într-o
singurã tranzacþie, care atunci cînd este întreruptã inainte de
terminare va face ca modificãrile fãcute sã disparã.  Cum, vom 
vedea mai tîrziu.

<P>

<H2><A NAME="SECTION00042000000000000000">
Independenþa</A>
</H2>

<P>
Independenþa se referã la un context în care mai multe programe
acþioneazã simultan asupra aceluiaºi set de date (activitate
concurentã).  Un program nu trebuie sã vadã rezultatele parþiale
ale altui program, pentru cã acestea nu ar fi corecte.

<P>
Ca exemplu sã considerãm un program care implementeazã o mãrire de
salariu (ura!), ceva de genul:

<P>
<PRE>
for i:=1 to angajati do
        salariu[i] := salariu[i] * 110/100; { marire 10 la suta :( }
</PRE>

<P>
Ce se poate întîmpla dacã acest program se executã ``simultan'' cu
cel anterior?  O posibilitate este ca acest program sã porneascã
în execuþie dupã cel precedent, sã ajungã la acelaºi indice undeva 
ºi apoi sã o ia înainte.  În acest fel unora dintre angajaþi le vor fi 
plãtite salarii indexate (celor din urmã), iar altora nu.  Total necinstit,
ºi nu numai necinstit, ci arbitrar, pentru cã rezultatul depinde de
momentul la care se executã programele ºi de viteza lor relativã.

<P>
Dacã fiecare din aceste fragmente de program ar fi fost o tranzacþie
aºa ceva nu s-ar fi putut întîmpla: toate mãririle ar fi fost
executate ori înainte ori dupã toate plãþile.

<P>

<H2><A NAME="SECTION00043000000000000000">
Consistenþa; programarea cu invarianþi</A>
</H2>

<P>
Sã aruncãm o privire la totalitatea variabilelor unui program.  La
un anumit moment de timp ele vor avea fiecare o valoare.  Dar nu orice
combinaþie de valori este posibilã.  De exemplu, pentru un program
care sorteazã un vector de numere, în vector se vor afla tot timpul
aceleaºi numere, poate în altã ordine.  Aceastã regulã (mai
precis acest predicat) se numeºte un <I>invariant</I>, pentru cã
trebuie sã fie tot timpul adevãratã, indiferent de faza de
execuþie a programului.  Pentru primul program de mai sus un
invariant este cã (*) ``suma de plãtit ºi budgetul curent trebuie
sã aibã aceeaºi sumã'' (balanþa de plãþi este zero).

<P>
Tehnica invarianþilor este extrem de importantã pentru ingineria
programãrii.  Un tip de date abstract nu este altceva decît o serie
de proceduri care menþin niºte invarianþi foarte preciºi despre
anumite structuri de date.  

<P>
Dacã atunci cînd scriem un program scriem procedurile în aºa fel 
încît atunci cînd datele de
intrare respectã un invariant sã avem garanþia cã ºi datele de
ieºire respectã acelaºi invariant, atunci putem obþine
demonstraþii de corectitudine pentru programe.  Prin inducþie
matematicã.  (Schiþã de demonstraþie: sã presupunem cã datele de
intrare respectã un invariant.  Dacã toate procedurile chemate
pãstreazã acest invariant, atunci prin inducþie dupã numãrul de
proceduri chemate demonstrãm imediat cã invariantul este
întotdeauna adevãrat.  Deci este adevãrat ºi atunci cînd
programul se terminã.)  De altfel tehnica invarianþilor este cheia
demonstraþiilor de corectitudine din metoda post-condiþiilor a lui
Hoare.  Dar asta este o cu totul altã mîncare de peºte; am vrut
doar sã arãt cã paradigma este extrem de puternicã.

<P>
Ei bine, tranzacþiile sunt una din metodele pentru a programa uºor
cu invarianþi.  Luînd din nou programul din primul exemplu, care
plãtea salariile, este evident cã invariantul (*) nu este adevãrat
în interiorul buclei, unde variabilã <TT>dePlatit</TT> are o valoare
nenulã, dar budgetul a rãmas încã neschimbat.  Invariantul (*)
este adevãrat înainte ºi dupã textul prezentat.  De aceea dacã
``îmbrãcãm'' programul într-o tranzacþie obþinem invariantul
adevãrat întotdeauna, pentru cã pentru universul exterior nu mai
existã de fapt o buclã <TT>for</TT> cu mii de instrucþiuni, ci o
singurã operaþie atomicã.

<P>

<H2><A NAME="SECTION00044000000000000000">
Durabilitatea</A>
</H2>

<P>
Ultima proprietate a tranzacþiilor este legatã de programarea cu
structuri de date persistente (lucru adevãrat ºi pentru atomicitate, 
descrisã mai sus).  Un program Pascal simplu se executã de fiecare datã 
la fel, plecînd de la aceleaºi valori iniþiale.  Dar un program care
opereazã cu un fiºier, sau o bazã de date, are structuri de date
care se aflã pe disc ºi care supravieþuiesc ``morþii''
programului.  Operaþia de creºtere a salariului va avea, dacã este
executatã de douã ori, rezultate diferite, pentru cã a doua
creºtere se aplicã peste prima, pentru cã rezultatele
primeia au fost salvate pe disc.  Noþiunea de persistenþã este
prezentã explicit în puþine limbaje de programare, dar este
crucialã în baze de date, unde în mod implicit orice operaþie se
efectueazã asupra unor date ``permanente''.

<P>
Durabilitatea tocmai la asta se referã: atunci cînd o tranzacþie se
terminã rezultatele ei trebuie sã fie permanente, chiar în cazul
unor catastrofe (ex. cãderea curentului).  Atunci cînd cumpãraþi
un bilet de avion, se executã o tranzacþie care se terminã cu
tipãrirea biletului.  Cum ar fi dacã biletul ar fi tipãrit, dar
datele despre vînzare nu ar fi încã pe disc ºi curentul ar cãdea?
La reluarea execuþiei pentru baza de date biletul ar fi ca
ne-vîndut, deci s-ar putea sã vã treziþi doi pe un loc.  Aºa ceva
este intolerabil (iar într-un sistem cu mii de terminale ºi o reþea
globalã, cum au companiile de aviaþie, malfuncþiile hardware sunt
statistic frecvente ºi normale), aºa cã tranzacþiile trebuie sã
ofere ºi durabilitate.

<P>
Pe scurt iatã proprietãþile tranzacþiilor:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Nume</TD>
<TD ALIGN="LEFT">Proprietate</TD>
</TR>
<TR><TD ALIGN="LEFT">Atomicitate</TD>
<TD ALIGN="LEFT">Catastrofele nu pot întrerupe o tranzacþie ``la mijloc''</TD>
</TR>
<TR><TD ALIGN="LEFT">Consistenþã</TD>
<TD ALIGN="LEFT">Tranzacþiile pãstreazã structurile de date corecte</TD>
</TR>
<TR><TD ALIGN="LEFT">Independenþã</TD>
<TD ALIGN="LEFT">Programe executate în paralel nu interferã</TD>
</TR>
<TR><TD ALIGN="LEFT">Durabilitate</TD>
<TD ALIGN="LEFT">Rezultatul unei tranzacþii este permanent</TD>
</TR>
</TABLE>
</DIV>

<P>

<H1><A NAME="SECTION00050000000000000000">
Operaþiile tranzacþiilor</A>
</H1>

<P>
Sã vedem cum se manifestã tranzacþiile pentru un programator.
Operaþiile esenþiale elementare (atomice) pe care programatorul le
are la dispoziþie atunci cînd opereazã asupra unei baze de date
sunt citirile ºi scrierile unei valori din baza de date, precum ºi
felurite operaþii aritmetice.  Tranzacþiile se manifestã prin 3 noi
instrucþiuni la dispoziþia programatorului:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Operaþie</TD>
<TD ALIGN="LEFT">Semnificaþie</TD>
</TR>
<TR><TD ALIGN="LEFT">Begin</TD>
<TD ALIGN="LEFT">Indicã începutul unei tranzacþii</TD>
</TR>
<TR><TD ALIGN="LEFT">End</TD>
<TD ALIGN="LEFT">Indicã sfîrºitul tranzacþiei</TD>
</TR>
<TR><TD ALIGN="LEFT">Abort</TD>
<TD ALIGN="LEFT">Sfîrºit nereuºit de tranzacþie; modificãrile dispar</TD>
</TR>
<TR><TD ALIGN="LEFT">Read</TD>
<TD ALIGN="LEFT">Citeºte valoarea unei variabile persistente</TD>
</TR>
<TR><TD ALIGN="LEFT">Write</TD>
<TD ALIGN="LEFT">Scrie valoarea unei variabile persistente</TD>
</TR>
</TABLE>
</DIV>

<P>
Vom folosi în mod explicit <TT>Write</TT> ºi <TT>Read</TT> pentru
a indica operaþiile asupra valorilor persistente; pe lîngã valori
persistente (din baza de date) mai avem de-a face în exemple ºi cu valori 
locale fiecãrui proces (ca variabilele locale unei funcþii din limbajele de
programare).

<P>
Unul din exemplele de mai sus va fi scris deci astfel într-un sistem care
oferã tranzacþii:

<P>
<PRE>
Begin Transaction
for i:=1 to angajati do begin
        x := Read(salariu[i]); { x e o variabila locala, nepersistenta }
        x := x * 110/100; { marire 10 la suta }
        Write(x, salariu[i]);
End Transaction
</PRE>

<P>
Tot ceea ce se aflã între <TT>Begin Transaction</TT> ºi <TT>End
Transaction</TT> se va comporta ca o singurã instrucþiune (lungã).
Modificãrile tuturor salariilor vor deveni în mod normal (dacã nu
se produce vreo eroare) vizibile instantaneu la
execuþia comenzii <TT>End Transaction</TT>.  Sfîrºitul cu succes al
unei tranzacþii se numeºte <I>Commit</I>.

<P>
Instrucþiunea <TT>Abort</TT> este utilã atunci cînd ceva neplãcut
s-a întîmplat ºi tranzacþia nu se poate termina cu succes.  Toate
modificãrile fãcute asupra datelor persistente, de la execuþia lui
<TT>Begin</TT> sunt pierdute pentru eternitate atunci cînd se executã
<TT>Abort</TT>.  Tranzacþia se considerã terminatã.

<P>
Iatã un exemplu de utilizare a tranzacþiilor în cadrul sistemelor
de operare în care instrucþiunea <TT>Abort</TT> este utilizatã: codul
ipotetic al operaþiei <TT>move</TT>, care mutã un fiºier dintr-un director
într-altul ºi eventual îi schimbã numele:

<P>
<PRE>
procedure move(numeVechi, numeNou)
begin
        Begin Transaction;
        directorNou := extrageDirector(numeNou);
        fisierNou := extrageNumeFisier(numeNou);
        este := cauta(directorNou, fisierNou);
        if (este) then Abort;  { fisierul nou exista deja }

        directorVechi := extrageDirector(numeVechi);
        fisierVechi := extrageNumeFisier(numeVechi);
        este := cauta(directorVechi, fisierVechi);
        if (not este) then Abort; { fisierul vechi nu exista }

        continutFisier := fisier(numeVechi);
        eroare := sterge(directorVechi, fisierVechi);
        if (eroare) then Abort;
        
        eroare := creaza(directorNou, fisierNou);
        if (eroare) then Abort;
        fisier(numeNou) := continutFisier;
        End Transaction;
end;
</PRE>

<P>
(Funcþiile <TT>cauta</TT>, <TT>sterge</TT>, etc. opereazã
tot cu structuri persistente, deci sunt asemãnãtoare cu
<TT>Read</TT> ºi <TT>Write</TT> de mai sus, numai cã sunt puþin mai
complicate; ele pot fi sintetizate din mai multe operaþii de acest
fel.)

<P>
Ideea este cã pe disc operaþiile atomice sunt foarte simple:
ºtergerea unui nume dintr-un director, crearea unui nume într-un alt
director, asocierea unui nume cu un conþinut.  Ca procedura
<TT>move</TT> sã aibã succes toate operaþiile componente trebuie sã se
efectueze cu succes; dacã nu <I>nici una</I> nu trebuie sã se
efectueze: cum ar fi ca fiºierul sã fie ºters din directorul vechi
dar sã nu aparã în cel nou pentru cã utilizatorul, de pildã, nu
are drept de scriere în directorul cel nou?

<P>
Este însã foarte greu sã ne asigurãm cã toate condiþiile sunt
adevãrate simultan, mai ales în prezenþa activitãþii concurente.
Dacã mai multe procese încearcã simultan sã facã <TT>move</TT> la
un acelaºi rezultat, atunci degeaba unul din ele verificã înainte de
mutare dacã rezultatul existã, pentru cã rezultatul ar putea sã
aparã în timp ce el ºterge numele vechi.

<P>
Cu tranzacþiile problema se rezolvã automat: dacã toate condiþiile
au fost îndeplinite <TT>End</TT> face modificãrile dintr-odatã;
altfel nici o modificare nu este vizibilã, ºi <TT>Abort</TT> este
executat.  Este o diferenþã între <TT>End Transaction</TT> ºi
<I>Commit</I>: instrucþiunea <TT>End</TT> anunþã sfîrºitul
tranzacþiei ºi <I>încercarea</I> de a face modificãrile permanente.
Faptul cã rezultatele operaþiilor devin permanente se numeºte
<I>Commit</I>.  Un <TT>End</TT> însã poate sã nu reuºeascã sã
facã <TT>Commit</TT>, ºi atunci se va transforma în <TT>Abort</TT>.

<P>
Deci <TT>End</TT> nu înseamnã ``succes'', ci ``aº vrea sã termin
cu succes''.  Dacã este posibil <TT>End</TT> rezultã în
<I>Commit</I> (care înseamnã într-adevãr ``succes''), altfel
<TT>End</TT> devine un <TT>Abort</TT>.

<P>

<H2><A NAME="SECTION00051000000000000000">
Sinucidere ºi crimã</A>
</H2>

<P>
Trebuie spus cã existã douã feluri în care o tranzacþie se poate
termina cu eºec:

<P>

<UL>
<LI>Cînd programul executã instrucþiunea <TT>Abort</TT>
tranzacþia se ``sinucide'';
</LI>
<LI>Cînd sistemul care implementeazã tranzacþii observã cã nu
poate oferi garanþiile promise, el poate ucide o tranzacþie spontan.
Aceasta este o crimã.
</LI>
</UL>

<P>
Vom vedea mai jos exemple de contexte în care sistemul ar avea nevoie
sã ``ucidã'' tranzacþii.  Ideea este cã promisiunile fãcute sunt
mai importante decît execuþia codului; codul poate fi eventual
re-executat, dar promisiunile nu pot fi în nici un caz încãlcate.
În general atunci cînd o tranzacþie este ucisã programul care a
invocat-o (sau utilizatorul) este informat de acest lucru ºi poate
decide dacã sã încerce din nou execuþia sau nu, în funcþie de
motive.

<P>

<H1><A NAME="SECTION00060000000000000000">
La ce sunt utile tranzacþiile?</A>
</H1>

<P>
Deja ne-am fãcut o idee despre utilitatea tranzacþiilor.  Sã
recapitulãm: 

<P>

<UL>
<LI>Programare uºoarã în prezentã concurenþei: dacã vrem sã
respectãm invarianþi în prezenþa unor procese concurente, atunci
închidem porþiunile de cod care ``stricã'' invarianþii în
tranzacþii ºi alte programe vor vedea numai stãri consistente;
</LI>
<LI>Tratament al malfuncþiilor hardware/software (crashes): nu mai
trebuie sã ne facem griji ce se întîmplã dacã picã un
calculator; chiar dacã se vor pierde date, calculatorul va putea
funcþiona corect, pentru cã datele rãmase sunt consistente.  De
asemenea, dacã ni s-a promis cã ceva s-a executat, rezultatul a
devenit permanent în pofida catastrofelor;
</LI>
<LI>Tratament simplificat al erorilor: dacã survine o condiþie de eroare
programatorul poate executa un simplu <TT>Abort</TT> pentru a
reveni la starea iniþialã corectã, fãrã a trebui sã refacã
``manual'' toate valorile modificate.
</LI>
</UL>

<P>

<H1><A NAME="SECTION00070000000000000000">
Serializabilitate</A>
</H1>

<P>
Chiar dacã intuitiv noþiunea de independenþã poate pãrea clarã,
trebuie sã înþelegem foarte bine ce înseamnã.  Aceastã secþiune
este consacratã numai acestui scop.  Pentru cã independenþa nu are
sens în absenþa paralelismului, discutãm despre un sistem în care
se pot executa simultan mai multe procese cu tranzacþii.

<P>
Vom defini o proprietate mai tare decît cea de independenþã,
numitã <I>serializabilitate</I> (serializability).
Serializabilitatea este o proprietate e <I>executãrii</I>
tranzacþiilor care implicã independenþã.  Vom vedea deci cã
dacã sistemul run-time care implementeazã tranzacþiile garanteazã
cã orice execuþie a unui set de tranzacþii este serializabilã,
atunci tranzacþiile sunt independente.

<P>

<H2><A NAME="SECTION00071000000000000000">
<I>Schedule</I></A>
</H2>

<P>
Cum am vãzut, fiecare tranzacþie este în realitate compusã din mai
multe instrucþiuni, pe care le putem considera atomice.  Atunci cînd
douã tranzacþii se executã ``simultan'', de fapt avem de-a face cu
o execuþie <I>întreþesutã</I> a instrucþiunilor care le compun.
O ordine de execuþie a instrucþiunilor din mai multe tranzacþii se
numeºte <I>schedule</I> (nu am nici o traducere rezonabilã pentru
acest termen; numele românesc cel mai apropiat ar fi
``planificare'').

<P>
Sã vedem un exemplu foarte simplu; sã notãm tranzacþiile cu T1,
T2, etc.  Iatã douã posibile tranzacþii care citesc variabila
persistentã <TT>salariu</TT> într-o variabilã localã, o modificã ºi
apoi o pun la loc:

<P>
<PRE>
Begin T1;
1)  x := Read(salariu);
2)  x := x * 110/100;
3)  Write(salariu, x);
End T1;

Begin T2;
1)  y := Read(salariu);
2)  y := y + 200;
3)  Write(salariu, y);
End T2;
</PRE>

<P>
Aceste tranzacþii conþin fiecare cîte 3 instrucþiuni; existã
foarte multe ``schedules'' posibile pentru executarea lor.  Iatã unul
dintre ele:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><TT>Begin T1; </TT></TD>
<TD ALIGN="LEFT">tt&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>1) x := Read(salariu); </TT></TD>
<TD ALIGN="LEFT">tt&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">ttBegin T2;</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">tt1) y := Read(salariu);</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>2) x := x * 110/100; </TT></TD>
<TD ALIGN="LEFT">tt&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>3) Write(salariu, x); </TT></TD>
<TD ALIGN="LEFT">tt&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">tt2) y := y + 200;</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">tt3) Write(salariu, y);</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>End T1; </TT></TD>
<TD ALIGN="LEFT">tt&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">ttEnd T2;</TD>
</TR>
</TABLE>
</DIV>

<P>
Existã douã ``schedules'' speciale: cel în care toate operaþiile
lui T1 se executã înainte de începutul lui T2, ºi cel în care
toate se executã dupã sfîrºitul lui T2.  Aceste douã
``schedules'' se numesc <I>seriale</I>, pentru cã sunt
formate din executarea ``în serie'' a unei tranzacþii ºi apoi a
celeilalte.

<P>
Toate celelalte ``schedules'' constau din amestecãri ale
instrucþiunilor lui T1 cu T2, ca în exemplul de mai sus.  Un
``schedule'' se numeºte <I>serializabil</I> dacã produce <I>exact
aceleaºi rezultate finale</I> ca unul dintre ``schedule''-le seriale.
Citiþi cu atenþie definiþia asta.  Rezultat final înseamnã exact
aceleaºi valori ale variabilelor persistente.

<P>
Ce putem spune despre ``schedule''-ul din exemplul de mai sus?  Este
sau nu serializabil?  Nu este!  Sã vedem un exemplu de date pentru
care asta e evident: dacã iniþial <TT>salariu</TT> avea valoarea
100, atunci schedule-ul de mai sus va da valoarea finalã 300
(verificaþi).  Pe de altã parte execuþia T1 urmat de T2 dã
valoarea 310, iar T2 urmat de T1 dã valoarea 330.

<P>
<BLOCKQUOTE>
Sistemul care implementeazã tranzacþii trebuie sã excludã
posibilitatea executãrii instrucþiunilor unor tranzacþii într-o
ordine (schedule) care nu este serializabilã.

</BLOCKQUOTE>

<P>

<H2><A NAME="SECTION00072000000000000000">
Graful dependenþelor</A>
</H2>

<P>
Sã încercãm sã ne dãm seama pentru care motive ``schedule''-ul de
mai sus nu este serializabil.  Putem sã ne gîndim la
serializabilitate ºi în urmãtorul fel: pentru anumite operaþii
ordinea de executare nu conteazã.  De exemplu dacã citim o valoare
în douã tranzacþii nu conteazã în ce ordine citim, pentru cã
vom obþine acelaºi rezultat.  Pe de altã dacã scriem douã valori
într-o singurã variabilã persistentã (cum se întîmplã mai sus,
cu tranzacþiile T1 ºi T2), atunci ordinea scrierilor este extrem de
importantã pentru rezultatul final, pentru cã ultima scriere dã
valoarea rezultatului.

<P>
Operaþiile care se pot schimba între ele fãrã a afecta valoarea
rezultatului se spune cã <I>comutã</I>.  Toate citirile comutã
între ele, aºa cum comutã operaþii de orice fel asupra
variabilelor locale ºi operaþii care se efectueazã asupra unor
variabile persistente <I>diferite</I>.  Cu alte cuvinte dacã eu scriu
în variabila <I>a</I> iar tu citeºti <I>b</I> nu conteazã prea tare
în ce ordine facem asta, pentru cã rezultatul va fi acelaºi.

<P>
Un criteriu de serializabilitate este urmãtorul: dacã putem schimba
într-un ``schedule'' între ele instrucþiuni care comutã ºi
obþinem un ``schedule'' serial, atunci avem de-a face cu un
``schedule'' serializabil.  Altfel nu.

<P>
Hai sã vedem care instrucþiuni din T1 ºi T2 nu comutã în
schedule-ul dat ca exemplu.  ``T1 3)'' nu comutã cu ``T2 1)'', pentru
cã ``T1 3)'' scrie în <TT>salariu</TT> iar ``T2 1)'' citeºte din 
<TT>salariu</TT>.  De asemenea, ``T1 3)'' nu comutã cu ``T2 3)'', pentru cã 
amîndouã scriu în aceeaºi valoare.  Pãi atunci e clar de ce acest schedule
nu e serializabil: instrucþiunea ``T1 3)'' nu poate fi nici
``împinsã'' înainte de T2 nici dupã, din cauza acestor
dependenþe.

<P>
Formal putem exprima acest lucru printr-un <I>graf de dependenþe</I>
care caracterizeazã un <I>schedule</I>.  În graful (orientat) al
dependenþelor nodurile sunt tranzacþii.  Între douã tranzacþii
avem un arc dacã prima executã o operaþie care nu
comutã cu o operaþie executatã ulterior de a doua.  Testul de
serializabilitate atunci devine foarte simplu:

<P>
<BLOCKQUOTE>
Un ``schedule'' este serializabil dacã în graful dependenþelor
asociat lui nu existã cicluri.

</BLOCKQUOTE>

<P>
Verificarea prezenþei ciclurilor într-un graf se poate face în timp
linear în numãrul de noduri.  Mai mult, o sortare topologicã a
grafului ne indicã ordinea serialã echivalentã cu cea datã.

<P>
Graful dependenþelor pentru ``schedule''-ul de mai sus este
urmãtorul:

<P>
<PRE>
        T2 scrie salariu dupa ce T1 scrie
     /----&gt;---\
     |        |
     |        V
     T1       T2
     ^        |
     |        |
     \---&lt;----/
        T1 scrie salariu dupa ce T2 citeste
</PRE>

<P>
Avem deci un algoritm posibil pentru a implementa tranzacþii izolate:
le lãsãm sã se execute pînã cînd una vrea sã se termine; atunci
verificãm dacã graful asociat execuþiei are cicluri, ºi dacã are
atunci executãm <TT>Abort</TT> pentru (cel puþin) una din
tranzacþii. 

<P>
În secþiunea urmãtoare intrãm în zona <I>implementãrii</I>
tranzacþiilor.  Vom vedea cum se implementeazã partea care oferã
proprietatea de ``Independenþã''.  Cum se implementeazã celelalte
proprietãþi (durabilitate, etc.) mai tîrziu.

<P>

<H2><A NAME="SECTION00073000000000000000">
Controlul accesului concurent</A>
</H2>

<P>
Existã douã tipuri mari de implementãri de sisteme tranzacþionale
din punct de vedere al serializabilitãþii:

<P>

<UL>
<LI>Sisteme cu control ``optimist'' asupra concurenþei: acestea
afirmã cã avem rar conflicte, deci e mai ieftin sã executãm
tranzacþiile ºi la sfîrºit sã facem <TT>Abort</TT> dacã execuþia
nu a fost serialã; atunci fiecare operaþie se face rapid;

<P>
</LI>
<LI>Sisteme cu control ``pesimist'', care îºi iau toate
precauþiile de la început, în aºa fel încît pur ºi simplu
execuþii ne-serializabile sunt imposibile.
</LI>
</UL>

<P>
Secþiunile urmãtoare dau exemple din fiecare tip.

<P>

<H3><A NAME="SECTION00073100000000000000">
Încuietori</A>
</H3>

<P>
Încuietorile (<I>locks</I>) sunt o metodã pentru controlul pesimist
al accesului.  Ideea este cã atunci cînd faci operaþii asupra unei
valori interzici accesele altor tranzacþii la acea valoare; ºtim
cã accesele la valori diferite sunt serializabile.

<P>

<H4><A NAME="SECTION00073110000000000000">
Tipuri de încuietori</A>
</H4>

<P>
Pentru a nu limita excesiv activitatea concurentã în sistem de
obicei se folosesc mai multe tipuri de încuietori.  Existã variante
extrem de sofisticate, dar noi vom discuta doar una, în care existã
încuietori separate pentru citire ºi scriere.  O încuietoare pentru
scriere este mai ``exclusivã'' decît una pentru citire, pentru cã
putem executa mai multe citiri simultan, dar o scriere nu poate fi
simultanã cu o altã operaþie din altã tranzacþie.

<P>
Manipularea încuietorilor se poate face fie explicit de cãtre
programator (cînd e nevoie de control fin) fie în ascuns de cãtre
sistemul tranzacþional.  În orice caz, încuietorile sunt asociate
valorilor persistente ºi se manipuleazã cu urmãtoarele operaþii
(primele douã sunt fundamentale, iar urmãtoarele auxiliare):

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Operaþie</TD>
<TD ALIGN="LEFT">Semnificaþie</TD>
</TR>
<TR><TD ALIGN="LEFT">lock(date, operaþie)</TD>
<TD ALIGN="LEFT">``încuie'' aceste date pentru ``operaþie''</TD>
</TR>
<TR><TD ALIGN="LEFT">unlock(date)</TD>
<TD ALIGN="LEFT">elibereazã restricþiile asupra acestor date</TD>
</TR>
<TR><TD ALIGN="LEFT">upgrade(date)</TD>
<TD ALIGN="LEFT">întãreºte o încuietoare</TD>
</TR>
<TR><TD ALIGN="LEFT">degrade(date)</TD>
<TD ALIGN="LEFT">slãbeºte o încuietoare</TD>
</TR>
</TABLE>
</DIV>

<P>
Cum funcþioneazã încuietorile?  De obicei existã o entitate (proces) 
specialã numit ``lock manager'' care þine minte care din date
sunt încuiate, de cine ºi în ce fel.  Atunci cînd o tranzacþie
vrea sã încuie o valoare se petrec urmãtoarele lucruri:

<P>

<UL>
<LI>Dacã datele nu sunt încuiate atunci încuietoarea este pusã
ºi execuþia continuã în mod normal;
</LI>
<LI>Dacã pe date existã deja o încuietoare:

<UL>
<LI>Cînd încuietoarea precedentã era pentru citire iar cea
cerutã este tot pentru citire o a doua încuietoare este pusã, dupã
care execuþia continuã iar accesul la date este permis;
</LI>
<LI>Cînd încuietoarea precedentã indicã un conflict cu cea
curentã atunci cererea de încuiere este refuzatã.
</LI>
</UL>
</LI>
</UL>

<P>
Existã douã acþiuni posibile cînd încuierea este refuzatã;
alegerea uneia dintre ele poate fi o politicã a celui care a
implementat baza de date, sau poate fi la alegerea utilizatorului:

<P>

<UL>
<LI>Cel care cere o încuiere imposibilã este pur ºi simplu blocat
din execuþie pînã cînd valoarea se ``descuie'', iar atunci execuþia
este automat continuatã;

<P>
</LI>
<LI>Cel care cere o încuiere imposibilã primeºte un cod de eroare
ºi decide ce trebuie sã facã (de pildã sã <TT>Abort</TT>-eze
tranzacþia curentã).
</LI>
</UL>

<P>
Terminarea unei tranzacþii (cu <I>Commit</I> sau <TT>Abort</TT>)
elibereazã întotdeauna toate încuietorile.

<P>
O tranzacþie este <I>obligatã</I> sã încuie datele înainte de a
le accesa.  Un exemplu ar fi:

<P>
<PRE>
Begin T2;
    lock(salariu, readLock);  { incuie pentru citire }
    y := Read(salariu);
    y := y + 200;
    upgrade(salariu);         { transforma incuietoarea pentru scriere }
    Write(salariu, y);
    unlock(salariu);
End T2;
</PRE>

<P>

<H4><A NAME="SECTION00073120000000000000">
Protocolul în douã faze</A>
</H4>

<P>
E interesant cã doar punînd încuietori în jurul acceselor la date
nu e suficient.  Ca sã ne convingem, consideraþi tranzacþiile T1 ºi
T2 în forma în care exact fiecare acces este protejat, ca în
exemplul urmãtor pentru T2:

<P>
<PRE>
Begin T2;
    lock(salariu, readLock);
    y := Read(salariu);
    unlock(salariu);
    y := y + 200;
    lock(salariu, writeLock);
    Write(salariu, y);
    unlock(salariu);
End T2;
</PRE>

<P>
E uºor de observat cã o astfel de încuiere permite execuþii
neserializabile (chiar execuþia indicatã mai sus este posibilã).
Nu ajunge deci sã încuiem, trebuie sã respectãm un <I>protocol</I>
de încuiere.  Adicã un set de reguli pentru toatã lumea.

<P>
Cel mai simplu ºi mai des folosit protocol este cel în douã faze
(two-phase locking; 2PL).  Acest protocol se poate enunþa astfel:

<P>
<BLOCKQUOTE>
În prima fazã se pot numai obþine încuietori (adicã se
executã instrucþiuni <TT>lock</TT> ºi <TT>upgrade</TT>).
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>În a doua fazã se pot numai dealoca încuietori
(<TT>unlock</TT> sau <TT>degrade</TT>).

</BLOCKQUOTE>

<P>
Dacã facem un grafic al numãrului de încuietori posedate de o
tranzacþie, el trebuie sã arate cam ca în figura urmãtoare: sã
aibã o fazã de creºtere (growing phase) ºi una de descreºtere
(shrinking phase).

<P>
<PRE>
                  growing  shrinking
                ^       ____
                |      /    \
numar de        |     /      \____
incuietori      |  __/            |
                | /                \
                0-----------------------&gt;
                                timp
</PRE>

<P>
Acest protocol <I>garanteazã</I> serializabilitatea.  Este un
exerciþiu interesant sã demonstrãm acest lucru.  Iatã o schiþã a
demonstraþiei.

<P>
Sã presupunem (prin absurd) cã o serie de tranzacþii T1, T2, ...
Tn, care respectã protocolul 2PL, au avut o execuþie
ne-serializabilã.  Asta înseamnã cã în graful lor de dependenþe
existã un ciclu, T1 <IMG
 WIDTH="23" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> T2 <IMG
 WIDTH="23" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$">
...Tn <IMG
 WIDTH="23" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> T1.  Ce înseamnã cã avem un arc de la T1 la
T2?  Înseamnã cã T1 a operat asupra unei valori înainte de T2, cu o
operaþie care nu comutã cu cea a lui T2.  Dar noi ºtim cã T1 nu
are voie sã opereze asupra unei valori ne-încuiate.  Asta înseamnã
cã T2 a încuiat acea valoare <I>dupã</I> ce T1 a descuiat-o.  Arcul
T2 <IMG
 WIDTH="23" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\rightarrow$"> T3 indicã un lucru asemãnãtor, ºi anume cã T3 a
încuiat o valoare (nu necesar aceeaºi) <I>dupã</I> ce T2 a
descuiat-o.  Din aproape în aproape obþinem cã, în fine, T1 a
încuiat o valoare dupã ce T1 a descuiat o altã valoare, ceea ce
este absurd.  Concluzia iniþialã era deci greºitã.  În concluzie
2PL garanteazã serializabilitate.

<P>
Sã observãm ca 2PL <I>nu</I> este acelaºi lucru cu
serializabilitatea, ci cã 2PL doar o <I>implicã</I>.

<P>

<H4><A NAME="SECTION00073130000000000000">
2PL strict</A>
</H4>

<P>
Existã un dezavantaj al lui 2PL ºi o implementare care îl evitã.
Sã considerãm urmãtorul scenariu: o tranzacþie T1 încuie o
valoare <IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$x$">, o modificã ºi apoi o descuie.  T2 vine la rînd,
încuie ºi citeºte <IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$x$">.  Dacã acum T1 vrea sã execute
<TT>Abort</TT>, valoarea lui <IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$x$"> trebuie pusã cum era înainte ca T1
sã o fi modificat.  Dar T2 a citit-o deja!  Asta înseamnã nimic
altceva decît cã dacã T1 executã <TT>Abort</TT>, T2 trebuie sã
fie ``ucisã'' de sistem, pentru a respecta proprietatea de izolare!
E clar cã lanþul poate fi mai lung: T3 poate a citit la rîndul ei
<IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$x$">, ºi atunci trebuie ucisã ºi ea.

<P>
O astfel de situaþie foarte neplãcutã (pentru cã o mulþime de
operaþii trebuie ``ºterse'') se numeºte <I>cascaded abort</I>
(abort în cascadã).  (O altã consecinþã neplãcutã este cã T2
nu se poate termina înainte de T1, pentru cã dacã T2 face
<I>Commit</I> iar T1 <TT>Abort</TT> am încurcat-o, cãci T2 a promis
cã valoarea lui <IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$x$"> este permanentã, dar nu avea voie s-o citeascã!
Deci T2 trebuie sã aºtepte ca T1 sã se termine.)

<P>
Soluþia este simplã: restrîngi concurenþa, dar nu laºi pe nimeni
sã vadã ce-ai modificat.  Nu descui nimic pînã la sfîrºit, cînd
descui totul dintr-o miºcare (de exemplu folosind <TT>End Transaction</TT>,
care elibereazã încuietorile).  Graficul ar arãta atunci cam aºa:

<P>
<PRE>
                  growing       shrinking
                ^       _________
                |      /         |
numar de        |     /          |
incuietori      |  __/           |
                | /              |terminare
                0-----------------------&gt;
                                timp
</PRE>

<P>

<H4><A NAME="SECTION00073140000000000000">
Blocarea (<I>deadlock</I>)</A>
</H4>

<P>
Încuietorile sunt foarte bune ºi frumoase pentru a obþine
serializabilitate, dar au un foarte, foarte mare dezavantaj....  Pot
duce la situaþii de blocare totalã, din care nu existã ieºire.
Aceasta se cheamã <I>deadlock</I>.  Iatã un exemplu foarte simplu de
``schedule'' în care douã tranzacþii încuie niºte valori, dupã
care nici una nu mai poate progresa nicicum, pentru cã vrea valoarea
încuiatã de cealaltã:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><TT>T1                  </TT></TD>
<TD ALIGN="LEFT"><TT>T2 </TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>lock(x, writeLock)  </TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>lock(y, writeLock) </TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>lock(y, writeLock)  </TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>refuz: blocat       </TT></TD>
<TD ALIGN="LEFT"><TT>lock(x, writeLock) </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>refuz: blocat </TT></TD>
</TR>
</TABLE>
</DIV>

<P>
Problema deadlock-ului este foarte interesantã ºi complicatã; prea
complicatã pentru articolul ãsta.  Sã menþionãm cã existã
tehnici standard pentru a o trata:

<P>

<UL>
<LI>Prevenirea deadlock-ului, folosind protocoale speciale pentru a
pune încuietori (ex: protocoale ierarhice);

<P>
</LI>
<LI>Evitarea deadlock-ului, alocînd resurse în mod special sau
folosind tehnici bazate pe timp (vom vedea exemple mai jos);

<P>
</LI>
<LI>Detectarea ºi repararea deadlock-ului: algoritmi care
analizeazã cine pe cine aºteaptã pot detecta deadlock-ul ºi pot
ucide una dintre tranzacþiile implicate.  Mecanismul de
<TT>Abort</TT> se va ocupa de restul.
</LI>
</UL>

<P>
Algoritmii pentru detectarea deadlock-ului sunt extrem de sofisticaþi
în sisteme distribuite, ºi de aceea de obicei evitarea este tehnica
folositã.

<P>
O metodã nu prea precisã constã în a omorîorice tranzacþie care
a aºteptat mai mult de un anumit timp eliberarea unei încuietori; e
clar atunci cã nu se pot petrece deadlock-uri, dar s-ar putea ca
nevinovaþi sã piarã, doar pentru cã stãteau la o coadã prea
lungã.

<P>

<H4><A NAME="SECTION00073150000000000000">
Granularitatea încuietorilor</A>
</H4>

<P>
O problemã foarte importantã, pe care am eludat-o (ºi o vom eluda
ºi mai departe) este <I>granularitatea</I> unei încuietori: cît de
mare este o ``valoare'' pe care o încui?  Încuietori mai mari
restrîng paralelismul posibil, dar reduc costul: o tranzacþie ca cea
din primul exemplu, care proceseazã toate salariile ar prefera sã
punã o singurã încuietoare mare decît un milion mici.  Astfel
putem încuia:

<P>

<UL>
<LI>O singurã valoare;
</LI>
<LI>O înregistrare (într-o bazã de date relaþionalã) (un
<TT>record</TT>);
</LI>
<LI>O întreagã relaþie (un fiºier);
</LI>
<LI>O parte din baza de date;
</LI>
<LI>Întreaga bazã de date.
</LI>
</UL>

<P>
Încuietori de mãrimi diferite ridicã ºi alte probleme: de exemplu
trebuie sã fim grijulii sã nu avem o tranzacþie care încuie o
valoare pentru scriere ºi o alta care încuie tot fiºierul care conþine 
valoarea, pentru cã atunci avem un conflict.

<P>

<H3><A NAME="SECTION00073200000000000000">
<I>Timestamps</I></A>
</H3>

<P>
O altã metodã de control al activitãþii concurente este de a
impune tranzacþiilor de la început o anumitã ordine de acces la date.
De pildã tranzacþiile sunt etichetate cu ora la
care au fost lansate, ºi o tranzacþie mai ``bãtrînã'' nu este
lãsatã cu nici un chip sã facã o operaþie asupra unei valori
atinse de o tranzacþie mai ``tînãrã''.  Cu alte cuvinte se alege
de la început unul dintre ``schedule''-urile seriale cu care va fi
echivalent cel al execuþiei curente.

<P>
Metoda foloseºte cîte douã ``etichete temporale'' (timestamps)
pentru <I>fiecare</I> valoare persistentã.  O etichetã (RT: read
time) indicã ultima tranzacþie care a citit valoarea, iar o alta
(WT: write time) indicã ultima tranzacþie care a scris valoarea.
Notînd eticheta unei tranzacþii T1 cu T(T1), protocoalele de acces
la date ale unei tranzacþii vor fi:

<P>
<PRE>
procedure read(date, tranzactie)
begin
   if T(tranzactie) &gt;= RT(date) then begin
        RT(date) := T(tranzactie);
        return date;
   else
        Abort;
end;


procedure write(date, valoare, tranzactie)
begin
   if (T(tranzactie) &gt;= max(RT(date), WT(date))) then begin
        date := valoare;
        WT(date) := T(tranzactie)
   end 
   else if RT(date) &gt; T(tranzactie) then Abort
   else if RT(date) &lt;= T(tranzactie) and
           T(tranzactie) &lt; WT(date) then
   ;     { nu face absolut nimic; ignora scrierea } 
end;
</PRE>

<P>
Aceste proceduri vor lãsa o tranzacþie mai veche sã facã
operaþii asupra unei valori numai dacã tranzacþii mai noi nu au
fãcut operaþii care nu comutã.  Cazul scrierii este
interesant: dacã o tranzacþie veche scrie peste o valoare pe care a
scris între timp o tranzacþie mai nouã (dar între cele douã
timpuri nimeni nu a citit valoarea), atunci valoarea scrisã de
tranzacþia veche este pur ºi simplu ignoratã.  Asta pentru cã
dacã tranzacþia veche ar fi scris înainte valoarea, nimeni nu ar fi
apucat sã o citeascã pînã cînd cea nouã ar fi supra-scris-o.

<P>

<H4><A NAME="SECTION00073210000000000000">
``Timestamps'' ºi ``locks''</A>
</H4>

<P>
Putem combina laolaltã încuietorile cu ``timestamps'' pentru a evita
deadlock-ul.  Existã douã mari soluþii care folosesc ``timestamps''
pentru a arbitra accesul la un lock:

<P>
<DL>
<DT><STRONG>wait-die:</STRONG></DT>
<DD> 
<BR>
<UL>
<LI>Cînd o tranzacþie vrea o încuietoare þinutã de o
tranzacþie mai ``tînãrã'' atunci trebuie sã aºtepte;
</LI>
<LI>Cînd o tranzacþie vrea o încuietoare a unei
``bãtrîne'', tînãra este ucisã.
</LI>
</UL>

<P>
</DD>
<DT><STRONG>wound-wait:</STRONG></DT>
<DD> 
<BR>
<UL>
<LI>Cînd o tranzacþie vine ºi vrea o încuietoare þinutã de o
tranzacþie mai tînãrã, tînãra este ucisã;
</LI>
<LI>Tranzacþiile tinere aºteaptã încuietorile þinute de
vîrstnice.
</LI>
</UL>
</DD>
</DL>

<P>
Amîndouã schemele dau prioritate tranzacþiilor care au trãit mai
mult, în ideea cã au fãcut mai multã treabã ºi e pãcat sã le
omorîm.  Wait-die poate produce livelock, sau ``starvation'' (cînd
tranzacþii tinere sunt mereu repornite ºi nu apucã niciodatã un
lock).  Nu se pot produce deadlock-uri, pentru cã în orice ciclu
tranzacþia cea mai tînãrã trebuie sã moarã.

<P>

<H4><A NAME="SECTION00073220000000000000">
O metodã optimistã: algoritmul validãrii</A>
</H4>

<P>
O metodã care nu restrînge deloc accesul concurent este urmãtoarea:
cine are de fãcut modificãri strînge toate valorile de modificat
în variabile locale, iar cînd a terminat verificã dacã poate sã
salveze modificãrile.  Asta se poate dacã nimeni nu s-a atins între
timp de valorile iniþiale.  Dacã aceastã fazã (de <I>validare</I>)
se terminã cu succes toate valorile sunt salvate (printr-o operaþie
atomicã) în baza de date.  Altfel tranzacþia face <TT>Abort</TT>.

<P>
Ca sã verifice dacã nimeni nu s-a atins de valori între timp,
fiecare valoare este etichetatã cu un numãr de <I>versiune</I>, care
este incrementat la fiecare scriere.  Dacã observi atunci cînd
vrei sã-þi salvezi rezultatele cã versiunea s-a schimbat faþã de
atunci cînd ai citit datele, renunþi sã le mai scrii.

<P>
Un astfel de protocol este folosit de sistemul de fiºiere NFS
(network file system): fiecare fiºier pe server are o versiune.  Cînd
cineva ºterge un fiºier ºi creazã altul folosind aceleaºi
porþiuni de pe disc (mai precis acelaºi inod -- pentru detalii
citiþi articolele mele mai vechi despre sistemul de fiºiere din
Unix, disponibile ºi din pagina mea de web), versiunea se
incrementeazã.  Dacã un alt client vrea sã facã operaþii pe un
fiºier care nu mai existã, server-ul se prinde, pentru cã clientul
oferã versiunea veche a inod-ului.  Astfel accese ilegale sunt
interzise.

<P>

<H2><A NAME="SECTION00074000000000000000">
Izolare: recapitulare</A>
</H2>

<P>
Am vãzut multe tehnici alternative pentru a implementa proprietatea
de izolare a tranzacþiilor.  Un anume sistem va implementa probabil
una singurã dintre ele.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>Protocol</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=312><B>Calitãþi</B></TD>
</TR>
<TR><TD ALIGN="LEFT">2PL</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=312>deadlock ºi cascaded-abort posibile</TD>
</TR>
<TR><TD ALIGN="LEFT">2PL strict</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=312>deadlock posibil; concurenþã redusã faþã de 2PL</TD>
</TR>
<TR><TD ALIGN="LEFT">Timestamp</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=312>restrînge ``schedule''-le posibile; necesitã spaþiu
            suplimentar pentru etichete; concurenþã mare</TD>
</TR>
<TR><TD ALIGN="LEFT">Validare</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=312>poate cauza abort-uri tardive; cere spaþiu suplimentar</TD>
</TR>
<TR><TD ALIGN="LEFT">Timestamp + lock</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=312>pot cauza ``starvation''; nu au deadlock</TD>
</TR>
</TABLE>
</DIV>

<P>

<H1><A NAME="SECTION00080000000000000000">
Implementarea lui <TT>Abort</TT> ºi <I>Commit</I></A>
</H1>

<P>
Dom'le, am tot vorbit de cum se implementeazã sincronizarea, ºi am
folosit mereu operaþiile <TT>Abort</TT> ºi <I>Commit</I>, dar nu
avem încã nici cea mai micã idee despre cum se pot
implementa.  Le-a venit timpul.

<P>
Existã douã metode mari pentru a <I>modifica</I> valorile
persistente (baza de date):

<P>

<OL>
<LI>Toate modificãrile se fac pe <I>copii</I> ale valorilor din
baza de date (acestea se numesc ``date umbrã'' (shadow-data)).
Tranzacþia citeºte toate valorile interesante din baza de date
(poate folosi fie încuietori, fie validare), dupã care modificã
toate valorile local.  Cînd a terminat cu succes, (<I>Commit</I>) trimite 
toate valorile la server-ul care þine baza de date, unde ele trebuie
efectuate <I>în mod atomic</I>, toate deodatã (<I>redo</I>).  Dacã
tranzacþia decide sã facã <TT>Abort</TT> nu trimite nici o valoare,
ci doar elibereazã încuietorile.

<P>
</LI>
<LI>Tranzacþia poate alege sã modifice valorile direct în baza de
date.  În cazul ãsta <I>Commit</I> e foarte simplã: eliberezi
încuietorile.  <TT>Abort</TT> însã are nevoie de un mecanism
special, prin care variabilele trebuie readuse la valorile iniþiale
(<I>undo</I>).
</LI>
</OL>

<P>
În fiecare caz una dintre operaþiile de terminare este mai grea
decît cealaltã.  Amuzant este cã ambele probleme pot fi rezolvate
folosind <I>aceeaºi</I> unealtã, în moduri uºor diferite.
Aceastã unealtã este setul de înregistrãri, mai precis numit
<I>log</I>, sau <I>audit</I>.

<P>

<H2><A NAME="SECTION00081000000000000000">
<I>Log</I>-ul</A>
</H2>

<P>
Un ``log'' este o secvenþã linearã, teoretic nesfîrºitã, de
înregistrãri care descriu operaþii.  Existã douã feluri de
``log'':

<P>

<OL>
<LI>``log''-ul de <I>intenþii</I>, sau ``redo-log'': atunci cînd
modificãrile se fac pe o copie personalã a datelor, toate noile
valori ale datelor sunt marcate în log.  Pentru <I>Commit</I>, log-ul
tranzacþiei este trimis la baza de date care re-executã (de aici
numele de ``redo'') toate operaþiile descrise în log, de data asta direct 
în baza de date, într-o manierã atomicã.

<P>
</LI>
<LI>``log''-ul ``undo'' þine minte în schimb toate valorile
<I>iniþiale</I> ale datelor, înainte de modificare.  Dacã faci
modificãri marchezi în log cum erau valorile, iar dacã-þi vine
pofta sã faci <TT>Abort</TT> atunci o iei de-a-ndoaselea în log ºi
refaci valorile cum erau iniþial.  Aceastã tehnicã de parcurgere
inversã cu des-facerea modificãrilor se numeºte <I>Rollback</I>.
</LI>
</OL>

<P>
Vom vedea cã, în mod surprinzãtor, log-ul se poate folosi nu numai
pentru a implementa operaþiile de <TT>Abort</TT> ºi <I>Commit</I>, ci
ºi pentru a obþine proprietãþile de atomicitate ºi durabilitate
în faþa catastrofelor!

<P>
Desigur cã putem avea un log combinat, care þine ambele feluri de
valori, ºi care permite atît ``undo'' cît ºi ``redo''.  Iatã un
exemplu posibil de înregistrare dintr-un astfel de log:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Tranzacþie</TD>
<TD ALIGN="CENTER">T232</TD>
</TR>
<TR><TD ALIGN="LEFT">Ora</TD>
<TD ALIGN="CENTER">12:01:22 EST</TD>
</TR>
<TR><TD ALIGN="LEFT">Valoare modificatã</TD>
<TD ALIGN="CENTER">salariu</TD>
</TR>
<TR><TD ALIGN="LEFT">Valoare iniþialã</TD>
<TD ALIGN="CENTER">100</TD>
</TR>
<TR><TD ALIGN="LEFT">Valoare finalã</TD>
<TD ALIGN="CENTER">200</TD>
</TR>
</TABLE>
</DIV>

<P>
În log trebuie marcate nu numai operaþiile asupra valorilor
persistente, ci ºi fiecare acþiune de început ºi terminare de
tranzacþie.

<P>

<H3><A NAME="SECTION00081100000000000000">
Puncte de control (<I>checkpoints</I>)</A>
</H3>

<P>
Problema principalã cu log-ul este cã acesta creºte permanent
cu noi înregistrãri.  Niciodatã nu se elibereazã spaþiu.
E clar, asta nu poate merge la infinit.  O metodã care recupereazã
spaþiul inutil din log (de exemplu înregistrãrile tranzacþiilor
care au fãcut <I>Commit</I>) se bazeazã pe ceea ce se numeºte
``puncte de control'' (checkpoints).  Aceasta este o formã specialã
de ``garbage collecting''.

<P>
Sã facem urmãtoarea observaþie: dacã ºtim starea iniþialã a
unui sistem ºi toate modificãrile fãcute asupra lui (în ordine)
atunci putem deduce starea curentã.  Exact asta este ºi un log:
lista tuturor modificãrilor fãcute asupra unui sistem.  Dar de la un
anumit rang încolo, descrierea modificãrilor poate fi mai mare decît
descrierea stãrii întregului sistem.  Putem atunci ``compacta''
lista modificãrilor þinînd minte starea curentã a sistemului ºi
uitînd toate modificãrile fãcute pînã atunci.  Aceastã ``stare
îngheþatã'' a sistemului se numeºte ``checkpoint''.

<P>
Problema este mai grea decît pare: de fapt sistemul nu este
niciodatã într-o stare stabilã; tot timpul sunt în execuþie
tranzacþii despre care nu ºtim încã dacã se vor termina cu succes
sau nu, deci nu putem vorbi de ``o stare''.  Soluþia (cu variante din
ce în ce mai sofisticate ºi performante) este grosso-modo
urmãtoarea: se opreºte toatã activitatea din sistem, dupã care
log-ul este parcurs în ordine inversã.  Toate informaþiile despre
tranzacþii care au fost terminate pot fi ºterse din ``log'', pentru
cã efectele acestora sunt deja în baza de date (proprietatea de
durabilitate garanteazã acest lucru).  În log se mai pãstreazã
doar informaþii despre tranzacþiile curente neterminate.  De obicei
toate aceste lucruri se fac tot folosind log-ul: se scrie o
înregistrare specialã ``checkpoint'', dupã care log-ul este scanat
ºi sunt copiate toate înregistrãrile încã ``vii''.  Tot spaþiul
aflã înainte de checkpoint poate fi apoi reutilizat.

<P>
Tehnica aceasta este folositã ºi în sisteme de operare, unde
proceselor care ruleazã pentru foarte mult timp li se fac periodic
astfel de puncte de control, pentru ca în cazul unei catastrofe sã
se reia calculele numai de la ultimul punct.

<P>

<H1><A NAME="SECTION00090000000000000000">
Catastrofe (crash)</A>
</H1>

<P>
Am vãzut pînã acum cum se pot obþine proprietãþile de izolare
(prin controlul accesului concurent) ºi consistenþã (printr-un stil
de programare care menþine invarianþii adevãraþi înafara
tranzacþiilor).

<P>
În aceastã secþiune vom introduce ultimul element suplimentar care
complicã viaþa celor ce implementeazã tranzacþii: catastrofele
ºi vom vedea cum tranzacþiile reuºesc sã ofere proprietãþile de
atomicitate ºi durabilitate în faþa unor condiþii atît de
adverse.

<P>
Scula esenþialã este din nou ``log''-ul (undo-redo).

<P>
Vrem sã asigurãm deci douã proprietãþi:

<P>
<DL>
<DT><STRONG>Durabilitate:</STRONG></DT>
<DD>o tranzacþie care a fãcut <I>Commit</I> trebuie
sã aibã efectele permanente orice s-ar întîmpla.
</DD>
<DT><STRONG>Atomicitate:</STRONG></DT>
<DD>dupã un ``crash'' baza de date va executa un
protocol special de refacere (recovery protocol) care-i va permite sã
reia operaþiunile într-un mod corect (adicã tranzacþiile
neterminate la ora crash-ului vor fi <TT>Abort</TT>-ate).  Mai mult,
un crash în timpul acþiunii de refacere trebuie sã nu cauzeze daune
de nici un fel!
</DD>
</DL>

<P>
Prima regulã pe care trebuie s-o respectãm este urmãtoarea:

<P>
<BLOCKQUOTE>
Raportãm succesul unei tranzacþii <I>numai dupã ce</I> toate
valorile modificate de ea au ajuns pe un mediu stabil (stable medium),
care supravieþuieºte catastrofelor.

</BLOCKQUOTE>

<P>
(În funcþie de importanþa sistemului, mediul stabil se poate defini
ca memorie RAM, memorie NVRAM, disc, disc cu redundanþã, disc dublu
(mirrored disk), bandã magneticã, bunker anti-atomic, etc.  Depinde
de ce fel de catastrofe vrem sã ne ferim.)

<P>
Aceastã regulã este adevãratã pentru cã nu existã nici un
<I>undo</I> pentru ceea ce i-am spus utilizatorului.  Dacã am tipãrit un
bilet de avion atunci nu mai putem sã-l luãm înapoi (cel puþin
pînã învãþãm sã dezvoltãm roboþi suficient de
puternici...).  

<P>
Astfel garantãm durabilitatea.

<P>

<H2><A NAME="SECTION00091000000000000000">
``Write-ahead log''</A>
</H2>

<P>
Pentru a garanta atomicitatea trebuie sã avem o metodã de a
identifica toate tranzacþiile care erau neterminate la momentul
crash-ului ºi de a face <TT>Abort</TT> cu ele.  Pentru cã un crash
distruge absolut toate valorile variabilelor ne-persistente, toatã
informaþia necesarã pentru identificare ºi <TT>Abort</TT>
<I>trebuie sã fie pe un mediu stabil</I>.  Regula de aur este:

<P>
<BLOCKQUOTE>
O operaþie poate fi efectuatã în baza da date numai dacã
înregistrarea din log care o descrie a ajuns pe un mediu stabil.

</BLOCKQUOTE>

<P>
E uºor de înþeles de ce: dacã facem o modificare în baza de date
ºi aparatul crapã înainte sã apucãm sã scriem în log, nu avem
nici o metodã dupã repornire sã ne dãm seama cã am scris
într-adevãr ceva în baza de date sau nu.

<P>

<H2><A NAME="SECTION00092000000000000000">
Protocolul de refacere (recovery)</A>
</H2>

<P>
Dacã respectãm regula de aur atunci avem destulã informaþie ca sã
refacem baza de date dupã o catastrofã.  Algoritmul are trei paºi
mari:

<P>

<OL>
<LI>Scanãm log-ul ºi identificãm toate tranzacþiile care
corespund clientului care a rãposat (dacã a decedat chiar serverul
considerãm toate tranzacþiile).

<P>
</LI>
<LI>Pentru toate tranzacþiile care au o înregistrare <I>Commit</I>
în log re-executãm acþiunile din log în ordinea în care au fost
fãcute.

<P>
</LI>
<LI>Pentru toate tranzacþiile neterminate din log executãm
acþiunile în ordine inversã, ºtergînd modificãrile lor.
</LI>
</OL>

<P>
Ca treaba sã meargã cum trebuie, este necesar ca înregistrãrile din
log sã satisfacã o proprietate suplimentarã: acþiunile lor trebuie
sã fie <I>idempotente</I>.  Asta înseamnã cã executarea unei
acþiuni din log de mai multe ori trebuie sã dea exact acelaºi rezultat ca
executarea o singurã datã.  În acest fel nu ne doare dacã cumva
re-executãm acþiuni care au mai fost fãcute.  De asemenea, nu avem
probleme dacã picã din nou curentul în timpul acþiunii de
refacere: o a doua refacere va da aceleaºi rezultate.

<P>
O înregistrare de log de genul ``A este incrementat cu 2'' nu este
idempotentã, pentru cã fiecare nouã execuþie schimbã valoarea lui
A.  Exemplul de mai sus însã este.

<P>
Sã observãm cã ``regula de aur'' ne oferã ºi cheia creºterii
performanþei în implementarea tranzacþiilor: nu trebuie sã scriem
în log de fiecare datã cînd facem ceva: trebuie sã scriem în log
numai înainte de a modifica baza de date.  Putem astfel strînge
serii întregi de modificãri în log, pe care le scriem dintr-un
singur foc.  Se ºtie cã pentru accesul la disc mai mult costã sã
începi decît sã faci treaba, deci costul este practic acelaºi
pentru una sau mai multe înregistrãri.  Singurul moment cînd
trebuie neapãrat sã salvãm pe disc este exact înainte de
terminarea tranzacþiei; toate celelalte modificãri pot fi amînate.

<P>

<H1><A NAME="SECTION000100000000000000000">
Încheiere</A>
</H1>

<P>
Ar mai fi foarte multe lucruri de spus despre tranzacþii; foarte
interesant este protocolul pentru tranzacþii în medii distribuite,
numit ``Two-phase commit protocol'', 2PC.  Tranzacþiile ierarhice
(nested) sunt o altã paradigmã aplicatã cu succes.  Sisteme de
fiºiere bazate pe log-uri sunt folosite cu succes în sisteme Unix
pentru refaceri extrem de rapide dupã cãderi.

<P>
Tranzacþiile sunt o sculã foarte utilã pentru programator, care cu
preþul unei oarecare scãderi în performanþã oferã o serie de
proprietãþi foarte utile ale datelor.  Este de aºteptat sã devinã
o paradigmã din ce în ce mai întîlnitã în arsenalul sculelor
programatorilor.

<P>
<BR><HR>

</BODY>
</HTML>
