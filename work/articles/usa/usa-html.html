<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//RO">

<!--Converted with LaTeX2HTML 2K.1beta (1.47)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>``Uºa din spate''</TITLE>
<META NAME="description" CONTENT="``Uºa din spate''">
<META NAME="keywords" CONTENT="usa-html">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-2">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../articles.css">

</HEAD>

<BODY >

<P>

<P>
<H1 ALIGN="CENTER">``Uºa din spate''</H1>
<P ALIGN="CENTER"><STRONG>Mihai BUDIU - budiu@cs.cornell.edu 
<BR>
http://www.cs.cornell.edu/Info/People/budiu/budiu.html</STRONG></P>
<P ALIGN="CENTER"><STRONG>18 martie 1997</STRONG></P>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html7"
  HREF="usa-html.html">Personajele</A>
<LI><A NAME="tex2html8"
  HREF="#SECTION00030000000000000000">Programul <TT>login</TT></A>
<LI><A NAME="tex2html9"
  HREF="#SECTION00040000000000000000">Ticãloºia</A>
<LI><A NAME="tex2html10"
  HREF="#SECTION00050000000000000000">Compilatorul</A>
<LI><A NAME="tex2html11"
  HREF="#SECTION00060000000000000000">Concluzii</A>
</UL>
<!--End of Table of Contents-->
<P>
<DL>
<DT><STRONG>Subiect:</STRONG></DT>
<DD>Putem avea încredere în programe?
</DD>
<DT><STRONG>Cuvinte cheie:</STRONG></DT>
<DD>back-door
</DD>
<DT><STRONG>Cunoºtinþe necesare: </STRONG></DT>
<DD>elemente despre funcþionarea
calculatoarelor, compilare, elemente de C
</DD>
</DL>

<P>

<H1><A NAME="SECTION00020000000000000000">
Personajele</A>
</H1>

<P>
Ken Thomson este unul dintre numele cele mai mari din istoria
calculatoarelor.  Sau, dacã asta poate fi contestat, este cu
siguranþã unul dintre numele cele mai faimoase.  Ken Thomson
lucreazã la laboratoarele Bell, care au aparþinut firmei AT&amp;T.
(Laboratoarele Bell au fost sediul cercetãrii gigantului
telecomunicaþiilor; multe dintre descoperirile revoluþionare ale
secolului au fost fãcute aici.  O lista ne-exhaustivã trebuie sã
cuprindã: sateliþii de telecomunicaþii, bateriile solare,
tranzistorul, laser-ul, sistemul de operare Unix ºi limbajul C++.  La
ora actualã AT&amp;T a fost spartã în bucãþi de legea americanã
anti-trust, aºa cã o parte însemnatã a laboratoarelor Bell a
devenit o firmã independentã numitã Lucent Technologies).

<P>
Ken Thomson este practic inventatorul Unix-ului.  (Am scris un articol
ceva mai detaliat in BYTE din August 1996 despre istoria acestui
faimos sistem de operare).  Acest sistem a revoluþionat în multe
privinþe sistemele de calcul, iar influenþele sale se dovedesc
fructuoase ºi în ziua de azi.  Pentru aceastã realizare lui Thomson
i-a fost decernat în 1984 premiul Turing al ACM (Association for
Computing Machinery), care pentru lumea calculatoarelor este
echivalent cu un Nobel.

<P>
În cuvîntarea þinutã cu prilejul decernãrii premiului, Thomson a
dezvãluit cea mai mare fraudã informaticã, al cãrei autor este el
însuºi.  Textul comunicãrii este ``Reflections on Trusting Trust'',
adicã ``Reflecþii asupra încrederii în încredere''.  Problema
centralã care pe care Thomson o pune este dacã putem avea încredere
în programele pe care le folosim, ºi cum putem dobîndi încredere
în ele.  Expunerea lui aratã cã posibilitatea de a citi programele
nu este o garanþie suficientã pentru a ne asigura de corectitudinea
lor!

<P>
O mulþime de bani se investesc în ziua de azi în cercetãri legate
de aceastã întrebare.  Fericiþi sunt cei care nu au avut niciodatã
de suferit de pe urma viruºilor.  În ziua de azi programele devin
din ce în ce mai mobile (de exemplu applet-urile sunt programe
transferate prin reþea în momentul cînd clientul de web acceseazã
un document) ºi Internetul este calul de bãtaie al marilor firme,
care au înþeles cã o mulþime de bani se pot obþine prin servicii
oferite prin reþea.  Întrebãrile lui Thomson sunt cu atît mai
acute din aceastã cauzã, iar rãspunsuri pe deplin satisfãcãtoare
sunt departe de a fi date.

<P>
Thomson sesiza însã gravitatea acestor probleme acum 20 de ani,
cînd calculatoarele erau departe de a fi atît de rãspîndite.
Iatã povestea lui:

<P>

<H1><A NAME="SECTION00030000000000000000">
Programul <TT>login</TT></A>
</H1>

<P>
Thomson este, dupã cum am spus, autorul sistemului de operare Unix.
Sistemul Unix este conceput pentru calculatoare care sunt folosite de
mai mulþi utilizatori simultan, ºi din cauza aceasta adreseazã de
la bun început destul de serios problema securitãþii.  Unix-ul
încearcã sã izoleze procesele care se executã pe o aceeaºi
maºinã între ele, ca sã nu se poatã incomoda.  (Un proces este un
program care a fost pornit in execuþie, deci un obiect activ).  În
Unix programele care sunt executate de un acelaºi utilizator au
oarecari posibilitãþi lãrgite de a se influenþa reciproc; de
exemplu un proces al meu poate omorîpe un altul care-mi aparþine,
dar nu poate omorînici unul din procesele care nu a fost create de
mine.  (Mai precis, poate trimite semnale, care uneori pot cauza
moartea; <EM>moartea</EM> unui proces este încetarea execuþiei sale).

<P>
Pentru a putea decide ce drepturi au procesele, ele trebuie sã fie
asociate cumva utilizatorilor.  Asocierea aceasta este realizatã în
Unix de programul <TT>/bin/login</TT>.

<P>
(În cele ce urmeazã vom simplifica discuþia pentru a pune în
valoare doar detaliile care ne intereseazã; în realitate lucrurile
sunt puþin mai complicate.  Poate vom consacra cîndva un articol
special securitãþii în sistemele Unix.)

<P>
Programul <TT>login</TT> face legãtura dintre un utilizator ºi
procesele sale; acest program <EM>autentificã</EM> un utilizator
testînd cunoaºterea unui secret.  Aceastã verificare se face cînd
utilizatorul se aºeazã prima oarã în faþa calculatorului (face
``login''), o singurã datã, ºi efectele ei sunt vizibile pînã
cînd utilizatorul pãrãseºte terminalul în mod explicit (face
``logout'').  Toate comenzile lansate de la acest terminal între cele
douã evenimente sunt implicit ale utilizatorului care a fost
autentificat.  (Dacã utilizatorul pãrãseºte terminalul pentru o
pauzã de cafea ºi altcineva îl foloseºte în rãstimp,
calculatorul nu are nici o metodã de a verifica acest lucru, ºi ia
comenzile ca fiind executate de persoana care a fost ultima
autentificatã.  Calculatorul nu are la ora actualã nici o metodã de
a ``simþi'' lumea exterioarã, pentru a observa cã utilizatorul este
altul.)

<P>
Lucrurile funcþioneazã cam aºa:

<P>

<OL>
<LI>Dacã un utilizator (eu) vrea sã foloseascã o maºina Unix,
în primul rînd trebuie sã vorbeascã cu administratorul de sistem.
Administratorul de sistem îi acordã un nume de utilizator (<TT>budiu</TT>) ºi un numãr asociat întotdeauna (uid = ``user
identifier''); pentru mine din întîmplare uid=831.  Pentru cã în
general corespondenþa nume-numãr este unu-la-unu, vom folosi numele
de ``uid'' pentru ambele.  Comanda <TT>id</TT> în Unix afiºeazã numele
ºi numãrul, precum ºi alte informaþii legate de identificare:

<P>
<PRE>
uid=813(budiu) gid=5(users)
</PRE>

<P>
</LI>
<LI>Noul utilizator îi comunicã administratorului un secret: o
<EM>parolã</EM>.  Parola este criptatã ºi pusã pe disc ca fiind
asociatã utilizatorului respectiv.

<P>
</LI>
<LI>Toate parolele (criptate) ºi numele de utilizatori sunt þinute
în Unix-urile tradiþionale într-un fiºier numit <TT>/etc/passwd</TT>.
Iatã o posibila linie:

<P>
<PRE>
budiu:PGffJFh3BfCAw:831:5:Mihai Budiu:/home/budiu:/bin/bash
</PRE>

<P>
Cîmpurile sunt separate cu semnul ``:''.  Primul este numele meu de
utilizator asociat, al doilea este parola mea criptatã, al treilea
este numãrul (uid) asociat mie; celelalte nu ne intereseazã prea tare
în acest articol, dar pentru curioºi sunt: numãrul grupului din
care fac parte, numele meu real, directorul meu casã ºi programul cu
care conversez eu în mod normal (``shell''-ul meu).

<P>
</LI>
<LI>În acest moment fiecare utilizator are un nume ºi o parolã,
pe care nu trebuie sã le comunice nimãnui (ori altcineva se va putea
substitui lui în folosirea calculatorului).  Utilizatorul poate
sã-ºi schimbe mai tîrziu parola dacã vrea, dar uid-ul este în
principiu fixat.

<P>
</LI>
<LI>Calculatorul la pornire executã pentru fiecare terminal legat
la calculator cîte o copie a programului <TT>/bin/login</TT>.

<P>
</LI>
<LI>Programul <TT>login</TT> scrie pe fiecare terminal textul <TT>login:</TT> ºi aºteaptã sã vinã un utilizator.

<P>
</LI>
<LI>Utilizatorul se aºeazã la terminal ºi îºi tasteazã numele
asignat (eu de pildã scriu <TT>login: budiu</TT>).

<P>
</LI>
<LI>Programul <TT>login</TT> cere parola scriind: <TT>Password:</TT>.

<P>
</LI>
<LI>Utilizatorul tasteazã parola (nu spun).  <TT>/bin/login</TT>
cripteazã parola, ºi comparã rezultatul cu ºirul din fiºierul
<TT>/etc/passwd</TT>.  Dacã rezultatele coincid (în cazul meu se
obþine <TT>PGffJFh3BfCAw</TT>), atunci utilizatorul este considerat
autentificat, ºi este primit de sistem.

<P>
</LI>
<LI>Dacã utilizatorul nu este primit, <TT>/bin/login</TT> se executã
din nou de la pasul 6.

<P>
</LI>
<LI>Dacã utilizatorul a fost primit, pe acel terminal se executã
un program care acceptã comenzi de la utilizator ºi le executã
(shell).  Acest program are pusã în frunte o ºtampilã care spune:
``acest program aparþine lui cutare uid'' (831 pentru mine).

<P>
</LI>
<LI>În continuare, shell-ul ascultã comenzile mele, le executã
una cîte una, ºi reia conversaþia cu mine, pîna tastez <TT>logout</TT>.

<P>
</LI>
<LI>Toate comenzile care sunt ``pui'' ai shell-ului moºtenesc
genetic de la el uid-ul meu, 831.
</LI>
</OL>

<P>
Discuþia se poate dovedi pe alocuri confuzã pentru cã acelaºi
cuvînt se foloseºte simultan pentru a desemna mai multe lucruri; de
pildã ``login'' înseamnã:

<P>

<UL>
<LI>Acþiunea de a te prezenta calculatorului;
</LI>
<LI>Un program care se executã pentru a face prezentãrile;
</LI>
<LI>Textul scris de acel program pe ecran;
</LI>
</UL>

<P>
Din schema asta complexã trebuie reþinut un lucru destul de simplu:
toate procesele mele moºtenesc de la <TT>/bin/login</TT> uid-ul meu;
<TT>/bin/login</TT> este singurul program care mã identificã.

<P>

<H1><A NAME="SECTION00040000000000000000">
Ticãloºia</A>
</H1>

<P>
De acest lucru s-a folosit Thomson pentru a crea o intrare universalã
(o ``uºa din spate neºtiutã de nimeni'': a ``back door''): Thomson
a scris programul <TT>/bin/login</TT> în aºa fel încît dacã cineva
tasteazã numele lui ºi o parolã fixatã sã fie acceptat în sistem
chiar dacã nu are dreptul (adicã chiar dacã în <TT>/etc/passwd</TT>
nu existã nici o linie pentru Thomson!).  În felul acesta Thomson
poate avea acces neîngrãdit la orice sistem Unix din lume.

<P>
Lumea ºi-a exprimat dintotdeauna temerile cu privire la programe
cumpãrate pe de-a gata: ele sunt întotdeauna susceptibile sã
conþinã asemenea portiþe care îi dau fabricantului tot felul de
privilegii din momentul în care programele ajung sã se execute.  Nu
ne vom lansa în consideraþii etice aici, mai bine sã urmãrim mai
departe subterfugiile lui Thomson, care nu se opresc aici!

<P>
Thomson este gata sã punã la dispoziþia celor sperioºi sursele C
ale programului <TT>/bin/login</TT>, pe care aceºtia sã le poatã
inspecta.  Programul în principiu trebuie sã fie destul de simplu
ceva de genul (scris în pseudo-C):

<P>
<PRE>
while (1) {
  scrie("login: ");
  nume = citeste();
  scrie("Password: ");
  parola = citeste();

  criptata = cripteaza(parola);
  parola_corecta = cauta_parola("/etc/passwd", nume);
  if (egale(criptata, parola_corecta)) {
     uid = cauta_uid("/etc/passwd", nume);
     shell = cauta_shell("/etc/passwd", nume);
     executa(shell);
  }
}
</PRE>

<P>
Dar dacã sursele sunt vizibile, oricine poate depista porþiunea în
care în funcþie de o comparaþie cu numele lui Thomson se ia o
decizie specialã.

<P>
Probabil testul aratã cam aºa:

<P>
<PRE>
usa_din_spate()
{
  if (egale(nume, "Thomson") &amp;&amp;
      egale(parola, "secret")) 
    executa("/bin/sh");
}
</PRE>

<P>
Testul poate fi invocat inserînd o linie care cheamã funcþia <TT>usa_din_spate()</TT> în locul unde am lãsat o linie albã în sursele
lui <TT>login</TT>.

<P>

<H1><A NAME="SECTION00050000000000000000">
Compilatorul</A>
</H1>

<P>
Thomson a scos acest test din sursele programului <TT>/bin/login</TT>,
dar a modificat compilatorul de C!  (În definitiv tot el a scris ºi
compilatorul, nu?).  Compilatorul de C se uitã atunci cînd
compileazã un program dacã nu cumva programul este chiar sursa de la
<TT>/bin/login</TT>; dacã este chiar sursa, atunci înainte de a compila
programul, compilatorul de C insereazã el însuºi funcþia <TT>usa_din_spate()</TT> ºi apelul ei în sursã!

<P>
În felul acesta sursele programului sunt absolut inofensive pentru
orice cititor, pentru cã ele sunt transformate abia la compilare, iar
rezultatul compilãrii nu mai este atît de simplu de citit.

<P>
De data asta cel care aratã ciudat este compilatorul însuºi: codul
lui este probabil cam aºa (ºirurile de caractere sunt foarte lungi,
aºa cã înlocuim cu ``...'' conþinutul lor în exemplul de mai
jos):

<P>
<PRE>
char * cod_login = "while (1) {\n\tscrie(\"login: \");\n....";
char * cod_usa_din_spate = "usa_din_spate(){if(egale(nume, ....";
char * apel_usa_din_spate = "usa_din_spate();";

modifica_login(program)
{
   /* text care modifica programul login */
   insereaza(program, cod_usa_din_spate);
   insereaza(program, apel_usa_din_spate);
}

analizeaza(program)
{
   if (seamana(program, cod_login)) {
       modifica_login(program);
   }
   compilare_obisnuita();
}
</PRE>

<P>
Dacã cineva se uitã la sursele compilatorului de C va observa
probabil acest tratament neobiºnuit al programului care tocmai se
compileazã.

<P>
Din cauza asta Thomson a mers ºi mai departe, acþionînd în
acelaºi fel: a modificat compilatorul de C în aºa fel încît sã
depisteze ºi cînd codul compilat este chiar compilatorul de C.
Sursele compilatorului de C distribuite utilizatorilor sunt ``curate''
(nu conþin codul de mai sus), dar compilatorul deja instalat pe
fiecare maºinã este deja ``infectat'', pentru cã procedeazã
astfel:

<P>
Cînd observã cã tocmai compilez din nou compilatorul din surse (de
exemplu cînd compilez funcþia <TT>analizeaza()</TT>, atunci insereazã
la începutul ei codul care modificã programul login.

<P>
Cu alte cuvinte compilatorul instalat aratã cam aºa:

<P>
<PRE>
modifica_login(program)
{
    ....
    insereaza(program, cod_usa_din_spate);
}    

modifica_compilator(program)
{
    ....
    insereaza(program, cod_modifica_login);
    insereaza(program, cod_modifica_compilator);
}

analizeaza(program)
{
   ...
   if (seamana(program, cod_login)) {
      modifica_login(program);
   }
   if (seamana(program, cod_analizeaza)) {
      modifica_compilator(program)
   }
   compilare_obisnuita();
}
</PRE>

<P>
Nimeni nu poate descoperi aceastã stratagemã cu uºurinþã.  Un
individ mai suspicios va analiza cu atenþie codul compilatorului, va
observa cã totul este în regulã, îl va compila folosind
compilatorul existent.  Dar deja în acest moment compilatorul sigur a
devenit infectat.  Pe de altã parte este foarte greu sã compilezi
ceva fãrã a folosi compilatorul de C (în Unix C este limbajul
favorit).  Din aceastã cauzã este extrem de dificil de îndepãrtat
uºa din spate.

<P>

<H1><A NAME="SECTION00060000000000000000">
Concluzii</A>
</H1>

<P>
Voi încheia acest articol traducînd literal încheierea lui Thomson
însuºi; cei la curent cu atacurile informatice petrecute în ultima
vreme în România vor vedea aceste cuvinte ca fiind de o remarcabilã
actualitate (vã reamintesc cã textul este din 1984):

<P>
<BLOCKQUOTE>
Morala este evidentã: nu poþi avea încredere în cod pe care nu
l-ai creat <EM>în totalitate</EM> tu însuþi (mai ales cod de la
companii care angajeazã oameni ca mine).  Nici o cantitate de
verificare a codului la nivelul surselor sau analizã nu te va proteja
în cazul în care foloseºti cod nesigur.  Demonstrînd posibilitatea
acestui fel de atac am ales compilatorul de C.  Aº fi putut alege
orice alt program care mînuieºte programe, cum ar fi un asamblor, un
încãrcãtor (loader) sau chiar microcod hardware.  Pe mãsurã ce
nivelul programelor scade, aceste ``bug''-uri devin din ce in ce mai
greu de detectat.  Un bug bine-instalat in microcod va fi aproape
imposibil de detectat.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Dupã ce am încercat sa vã conving cã nu pot fi crezut, vreau sã
moralizez un pic.  Aº vrea sã critic presa în felul în care
trateazã ``hackerii'' [...]  Actele fãcute de aceºti copii sunt
vandalism în cel mai bun caz, ºi probabil încãlcarea proprietãþii
private ºi furt în cel mai rãu.  Numai inadecvarea legilor penale
îi salveazã pe aceºti hackeri de la urmãriri penale serioase.
Companiile care sunt vulnerabile activitãþii lor (ºi majoritatea
companiilor mari sunt vulnerabile) fac mari presiuni pentru a adapta
legile.  [În Statele Unite în ziua de azi lucrurile stau deja mult
mai bine din acest punct de vedere.]
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Este o situaþie explozivã: pe de o parte presa, televiziunea ºi
filmele fac eroi din vandali numindu-i ``copii minune''.  Pe de altã
parte actele acestor copii vor fi în curînd pedepsibile cu ani grei
de închisoare.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Am privit aceºti copii depunînd mãrturie în faþa Congresului.
Este evident cã nu-ºi dau de loc seama de seriozitatea actelor lor.
Este evident o prãpastie culturalã.  Actul de a pãtrunde într-un
sistem de calcul ar trebui sã fie însoþit de acelaºi stigmat
social cu acela de a intra în casa vecinului.  Nu trebuie sã conteze
cã uºa vecinului nu este încuiatã.  Presa trebuie sã înveþe cã
folosirea ``strîmbã'' a unui calculator nu este cu nimic mai
uimitoare decît condusul în stare de ebrietate.

</BLOCKQUOTE>

<P>
<BR><HR>

</BODY>
</HTML>
